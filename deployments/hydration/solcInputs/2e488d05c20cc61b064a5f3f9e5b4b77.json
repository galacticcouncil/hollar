{
  "language": "Solidity",
  "sources": {
    "@aave/core-v3/contracts/dependencies/gnosis/contracts/GPv2SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport {IERC20} from '../../openzeppelin/contracts/IERC20.sol';\n\n/// @title Gnosis Protocol v2 Safe ERC20 Transfer Library\n/// @author Gnosis Developers\n/// @dev Gas-efficient version of Openzeppelin's SafeERC20 contract.\nlibrary GPv2SafeERC20 {\n  /// @dev Wrapper around a call to the ERC20 function `transfer` that reverts\n  /// also when the token returns `false`.\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    bytes4 selector_ = token.transfer.selector;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let freeMemoryPointer := mload(0x40)\n      mstore(freeMemoryPointer, selector_)\n      mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n      mstore(add(freeMemoryPointer, 36), value)\n\n      if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n\n    require(getLastTransferResult(token), 'GPv2: failed transfer');\n  }\n\n  /// @dev Wrapper around a call to the ERC20 function `transferFrom` that\n  /// reverts also when the token returns `false`.\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    bytes4 selector_ = token.transferFrom.selector;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let freeMemoryPointer := mload(0x40)\n      mstore(freeMemoryPointer, selector_)\n      mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n      mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n      mstore(add(freeMemoryPointer, 68), value)\n\n      if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n\n    require(getLastTransferResult(token), 'GPv2: failed transferFrom');\n  }\n\n  /// @dev Verifies that the last return was a successful `transfer*` call.\n  /// This is done by checking that the return data is either empty, or\n  /// is a valid ABI encoded boolean.\n  function getLastTransferResult(IERC20 token) private view returns (bool success) {\n    // NOTE: Inspecting previous return data requires assembly. Note that\n    // we write the return data to memory 0 in the case where the return\n    // data size is 32, this is OK since the first 64 bytes of memory are\n    // reserved by Solidy as a scratch space that can be used within\n    // assembly blocks.\n    // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html>\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      /// @dev Revert with an ABI encoded Solidity error with a message\n      /// that fits into 32-bytes.\n      ///\n      /// An ABI encoded Solidity error has the following memory layout:\n      ///\n      /// ------------+----------------------------------\n      ///  byte range | value\n      /// ------------+----------------------------------\n      ///  0x00..0x04 |        selector(\"Error(string)\")\n      ///  0x04..0x24 |      string offset (always 0x20)\n      ///  0x24..0x44 |                    string length\n      ///  0x44..0x64 | string value, padded to 32-bytes\n      function revertWithMessage(length, message) {\n        mstore(0x00, '\\x08\\xc3\\x79\\xa0')\n        mstore(0x04, 0x20)\n        mstore(0x24, length)\n        mstore(0x44, message)\n        revert(0x00, 0x64)\n      }\n\n      switch returndatasize()\n      // Non-standard ERC20 transfer without return.\n      case 0 {\n        // NOTE: When the return data size is 0, verify that there\n        // is code at the address. This is done in order to maintain\n        // compatibility with Solidity calling conventions.\n        // <https://docs.soliditylang.org/en/v0.7.6/control-structures.html#external-function-calls>\n        if iszero(extcodesize(token)) {\n          revertWithMessage(20, 'GPv2: not a contract')\n        }\n\n        success := 1\n      }\n      // Standard ERC20 transfer returning boolean success value.\n      case 32 {\n        returndatacopy(0, 0, returndatasize())\n\n        // NOTE: For ABI encoding v1, any non-zero value is accepted\n        // as `true` for a boolean. In order to stay compatible with\n        // OpenZeppelin's `SafeERC20` library which is known to work\n        // with the existing ERC20 implementation we care about,\n        // make sure we return success for any non-zero return value\n        // from the `transfer*` call.\n        success := iszero(iszero(mload(0)))\n      }\n      default {\n        revertWithMessage(31, 'GPv2: malformed transfer result')\n      }\n    }\n  }\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/Address.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n    // for accounts without code, i.e. `keccak256('')`\n    bytes32 codehash;\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      codehash := extcodehash(account)\n    }\n    return (codehash != accountHash && codehash != 0x0);\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, 'Address: insufficient balance');\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{value: amount}('');\n    require(success, 'Address: unable to send value, recipient may have reverted');\n  }\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address payable) {\n    return payable(msg.sender);\n  }\n\n  function _msgData() internal view virtual returns (bytes memory) {\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    return msg.data;\n  }\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport './Context.sol';\nimport './IERC20.sol';\nimport './SafeMath.sol';\nimport './Address.sol';\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n   * a default value of 18.\n   *\n   * To select a different value for {decimals}, use {_setupDecimals}.\n   *\n   * All three of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory name, string memory symbol) {\n    _name = name;\n    _symbol = symbol;\n    _decimals = 18;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n   * called.\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account) public view override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20};\n   *\n   * Requirements:\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``sender``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance')\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].sub(\n        subtractedValue,\n        'ERC20: decreased allowance below zero'\n      )\n    );\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), 'ERC20: transfer from the zero address');\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(amount, 'ERC20: transfer amount exceeds balance');\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: mint to the zero address');\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: burn from the zero address');\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(amount, 'ERC20: burn amount exceeds balance');\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n   *\n   * This is internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), 'ERC20: approve from the zero address');\n    require(spender != address(0), 'ERC20: approve to the zero address');\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Sets {decimals} to a value other than the default one of 18.\n   *\n   * WARNING: This function should only be called from the constructor. Most\n   * applications that interact with token contracts will not expect\n   * {decimals} to ever change, and may work incorrectly if it does.\n   */\n  function _setupDecimals(uint8 decimals_) internal {\n    _decimals = decimals_;\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be to transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {IERC20} from './IERC20.sol';\n\ninterface IERC20Detailed is IERC20 {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport './Context.sol';\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\npragma solidity 0.8.10;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n  /**\n   * @dev Returns the downcasted uint224 from uint256, reverting on\n   * overflow (when the input is greater than largest uint224).\n   *\n   * Counterpart to Solidity's `uint224` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 224 bits\n   */\n  function toUint224(uint256 value) internal pure returns (uint224) {\n    require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n    return uint224(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint128 from uint256, reverting on\n   * overflow (when the input is greater than largest uint128).\n   *\n   * Counterpart to Solidity's `uint128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   */\n  function toUint128(uint256 value) internal pure returns (uint128) {\n    require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n    return uint128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint96 from uint256, reverting on\n   * overflow (when the input is greater than largest uint96).\n   *\n   * Counterpart to Solidity's `uint96` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 96 bits\n   */\n  function toUint96(uint256 value) internal pure returns (uint96) {\n    require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n    return uint96(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint64 from uint256, reverting on\n   * overflow (when the input is greater than largest uint64).\n   *\n   * Counterpart to Solidity's `uint64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   */\n  function toUint64(uint256 value) internal pure returns (uint64) {\n    require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n    return uint64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint32 from uint256, reverting on\n   * overflow (when the input is greater than largest uint32).\n   *\n   * Counterpart to Solidity's `uint32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   */\n  function toUint32(uint256 value) internal pure returns (uint32) {\n    require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n    return uint32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint16 from uint256, reverting on\n   * overflow (when the input is greater than largest uint16).\n   *\n   * Counterpart to Solidity's `uint16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   */\n  function toUint16(uint256 value) internal pure returns (uint16) {\n    require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n    return uint16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted uint8 from uint256, reverting on\n   * overflow (when the input is greater than largest uint8).\n   *\n   * Counterpart to Solidity's `uint8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits.\n   */\n  function toUint8(uint256 value) internal pure returns (uint8) {\n    require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n    return uint8(value);\n  }\n\n  /**\n   * @dev Converts a signed int256 into an unsigned uint256.\n   *\n   * Requirements:\n   *\n   * - input must be greater than or equal to 0.\n   */\n  function toUint256(int256 value) internal pure returns (uint256) {\n    require(value >= 0, 'SafeCast: value must be positive');\n    return uint256(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int128 from int256, reverting on\n   * overflow (when the input is less than smallest int128 or\n   * greater than largest int128).\n   *\n   * Counterpart to Solidity's `int128` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 128 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt128(int256 value) internal pure returns (int128) {\n    require(\n      value >= type(int128).min && value <= type(int128).max,\n      \"SafeCast: value doesn't fit in 128 bits\"\n    );\n    return int128(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int64 from int256, reverting on\n   * overflow (when the input is less than smallest int64 or\n   * greater than largest int64).\n   *\n   * Counterpart to Solidity's `int64` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 64 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt64(int256 value) internal pure returns (int64) {\n    require(\n      value >= type(int64).min && value <= type(int64).max,\n      \"SafeCast: value doesn't fit in 64 bits\"\n    );\n    return int64(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int32 from int256, reverting on\n   * overflow (when the input is less than smallest int32 or\n   * greater than largest int32).\n   *\n   * Counterpart to Solidity's `int32` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 32 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt32(int256 value) internal pure returns (int32) {\n    require(\n      value >= type(int32).min && value <= type(int32).max,\n      \"SafeCast: value doesn't fit in 32 bits\"\n    );\n    return int32(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int16 from int256, reverting on\n   * overflow (when the input is less than smallest int16 or\n   * greater than largest int16).\n   *\n   * Counterpart to Solidity's `int16` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 16 bits\n   *\n   * _Available since v3.1._\n   */\n  function toInt16(int256 value) internal pure returns (int16) {\n    require(\n      value >= type(int16).min && value <= type(int16).max,\n      \"SafeCast: value doesn't fit in 16 bits\"\n    );\n    return int16(value);\n  }\n\n  /**\n   * @dev Returns the downcasted int8 from int256, reverting on\n   * overflow (when the input is less than smallest int8 or\n   * greater than largest int8).\n   *\n   * Counterpart to Solidity's `int8` operator.\n   *\n   * Requirements:\n   *\n   * - input must fit into 8 bits.\n   *\n   * _Available since v3.1._\n   */\n  function toInt8(int256 value) internal pure returns (int8) {\n    require(\n      value >= type(int8).min && value <= type(int8).max,\n      \"SafeCast: value doesn't fit in 8 bits\"\n    );\n    return int8(value);\n  }\n\n  /**\n   * @dev Converts an unsigned uint256 into a signed int256.\n   *\n   * Requirements:\n   *\n   * - input must be less than or equal to maxInt256.\n   */\n  function toInt256(uint256 value) internal pure returns (int256) {\n    // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n    require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n    return int256(value);\n  }\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary SafeMath {\n  /// @notice Returns x + y, reverts if sum overflows uint256\n  /// @param x The augend\n  /// @param y The addend\n  /// @return z The sum of x and y\n  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    unchecked {\n      require((z = x + y) >= x);\n    }\n  }\n\n  /// @notice Returns x - y, reverts if underflows\n  /// @param x The minuend\n  /// @param y The subtrahend\n  /// @return z The difference of x and y\n  function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    unchecked {\n      require((z = x - y) <= x);\n    }\n  }\n\n  /// @notice Returns x - y, reverts if underflows\n  /// @param x The minuend\n  /// @param y The subtrahend\n  /// @param message The error msg\n  /// @return z The difference of x and y\n  function sub(\n    uint256 x,\n    uint256 y,\n    string memory message\n  ) internal pure returns (uint256 z) {\n    unchecked {\n      require((z = x - y) <= x, message);\n    }\n  }\n\n  /// @notice Returns x * y, reverts if overflows\n  /// @param x The multiplicand\n  /// @param y The multiplier\n  /// @return z The product of x and y\n  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    unchecked {\n      require(x == 0 || (z = x * y) / x == y);\n    }\n  }\n\n  /// @notice Returns x / y, reverts if overflows - no specific check, solidity reverts on division by 0\n  /// @param x The numerator\n  /// @param y The denominator\n  /// @return z The product of x and y\n  function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    return x / y;\n  }\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/upgradeability/AdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport './BaseAdminUpgradeabilityProxy.sol';\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for\n * initializing the implementation, admin, and init data.\n */\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n  /**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param _admin Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(\n    address _logic,\n    address _admin,\n    bytes memory _data\n  ) payable UpgradeabilityProxy(_logic, _data) {\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\n    BaseAdminUpgradeabilityProxy._willFallback();\n  }\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/upgradeability/BaseAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport './UpgradeabilityProxy.sol';\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant ADMIN_SLOT =\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @return The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address) {\n    return _admin();\n  }\n\n  /**\n   * @return The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), 'Cannot change the admin of a proxy to the zero address');\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\n    external\n    payable\n    ifAdmin\n  {\n    _upgradeTo(newImplementation);\n    (bool success, ) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @return adm The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    //solium-disable-next-line\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n    //solium-disable-next-line\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal virtual override {\n    require(msg.sender != _admin(), 'Cannot call fallback function from the proxy admin');\n    super._willFallback();\n  }\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport './Proxy.sol';\nimport '../contracts/Address.sol';\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT =\n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Returns the current implementation.\n   * @return impl Address of the current implementation\n   */\n  function _implementation() internal view override returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    //solium-disable-next-line\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n    require(\n      Address.isContract(newImplementation),\n      'Cannot set a proxy implementation to a non-contract address'\n    );\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    //solium-disable-next-line\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport './BaseUpgradeabilityProxy.sol';\n\n/**\n * @title InitializableUpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\n * implementation and init data.\n */\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Contract initializer.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  function initialize(address _logic, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if (_data.length > 0) {\n      (bool success, ) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/upgradeability/Proxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\nabstract contract Proxy {\n  /**\n   * @dev Fallback function.\n   * Will run if no other function in the contract matches the call data.\n   * Implemented entirely in `_fallback`.\n   */\n  fallback() external payable {\n    _fallback();\n  }\n\n  /**\n   * @return The Address of the implementation.\n   */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function _delegate(address implementation) internal {\n    //solium-disable-next-line\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n  function _willFallback() internal virtual {}\n\n  /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/openzeppelin/upgradeability/UpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport './BaseUpgradeabilityProxy.sol';\n\n/**\n * @title UpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n * implementation and init data.\n */\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Contract constructor.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, bytes memory _data) payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if (_data.length > 0) {\n      (bool success, ) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }\n}\n"
    },
    "@aave/core-v3/contracts/dependencies/weth/WETH9.sol": {
      "content": "// Copyright (C) 2015, 2016, 2017 Dapphub\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.8.10;\n\ncontract WETH9 {\n  string public name = 'Wrapped Ether';\n  string public symbol = 'WETH';\n  uint8 public decimals = 18;\n\n  event Approval(address indexed src, address indexed guy, uint256 wad);\n  event Transfer(address indexed src, address indexed dst, uint256 wad);\n  event Deposit(address indexed dst, uint256 wad);\n  event Withdrawal(address indexed src, uint256 wad);\n\n  mapping(address => uint256) public balanceOf;\n  mapping(address => mapping(address => uint256)) public allowance;\n\n  receive() external payable {\n    deposit();\n  }\n\n  function deposit() public payable {\n    balanceOf[msg.sender] += msg.value;\n    emit Deposit(msg.sender, msg.value);\n  }\n\n  function withdraw(uint256 wad) public {\n    require(balanceOf[msg.sender] >= wad);\n    balanceOf[msg.sender] -= wad;\n    payable(msg.sender).transfer(wad);\n    emit Withdrawal(msg.sender, wad);\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return address(this).balance;\n  }\n\n  function approve(address guy, uint256 wad) public returns (bool) {\n    allowance[msg.sender][guy] = wad;\n    emit Approval(msg.sender, guy, wad);\n    return true;\n  }\n\n  function transfer(address dst, uint256 wad) public returns (bool) {\n    return transferFrom(msg.sender, dst, wad);\n  }\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 wad\n  ) public returns (bool) {\n    require(balanceOf[src] >= wad);\n\n    if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n      require(allowance[src][msg.sender] >= wad);\n      allowance[src][msg.sender] -= wad;\n    }\n\n    balanceOf[src] -= wad;\n    balanceOf[dst] += wad;\n\n    emit Transfer(src, dst, wad);\n\n    return true;\n  }\n}\n\n/*\n                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n\n*/\n"
    },
    "@aave/core-v3/contracts/flashloan/interfaces/IFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from '../../interfaces/IPoolAddressesProvider.sol';\nimport {IPool} from '../../interfaces/IPool.sol';\n\n/**\n * @title IFlashLoanReceiver\n * @author Aave\n * @notice Defines the basic interface of a flashloan-receiver contract.\n * @dev Implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n */\ninterface IFlashLoanReceiver {\n  /**\n   * @notice Executes an operation after receiving the flash-borrowed assets\n   * @dev Ensure that the contract can return the debt + premium, e.g., has\n   *      enough funds to repay and has approved the Pool to pull the total amount\n   * @param assets The addresses of the flash-borrowed assets\n   * @param amounts The amounts of the flash-borrowed assets\n   * @param premiums The fee of each flash-borrowed asset\n   * @param initiator The address of the flashloan initiator\n   * @param params The byte-encoded params passed when initiating the flashloan\n   * @return True if the execution of the operation succeeds, false otherwise\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external returns (bool);\n\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  function POOL() external view returns (IPool);\n}\n"
    },
    "@aave/core-v3/contracts/flashloan/interfaces/IFlashLoanSimpleReceiver.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from '../../interfaces/IPoolAddressesProvider.sol';\nimport {IPool} from '../../interfaces/IPool.sol';\n\n/**\n * @title IFlashLoanSimpleReceiver\n * @author Aave\n * @notice Defines the basic interface of a flashloan-receiver contract.\n * @dev Implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n */\ninterface IFlashLoanSimpleReceiver {\n  /**\n   * @notice Executes an operation after receiving the flash-borrowed asset\n   * @dev Ensure that the contract can return the debt + premium, e.g., has\n   *      enough funds to repay and has approved the Pool to pull the total amount\n   * @param asset The address of the flash-borrowed asset\n   * @param amount The amount of the flash-borrowed asset\n   * @param premium The fee of the flash-borrowed asset\n   * @param initiator The address of the flashloan initiator\n   * @param params The byte-encoded params passed when initiating the flashloan\n   * @return True if the execution of the operation succeeds, false otherwise\n   */\n  function executeOperation(\n    address asset,\n    uint256 amount,\n    uint256 premium,\n    address initiator,\n    bytes calldata params\n  ) external returns (bool);\n\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  function POOL() external view returns (IPool);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IAaveIncentivesController\n * @author Aave\n * @notice Defines the basic interface for an Aave Incentives Controller.\n * @dev It only contains one single function, needed as a hook on aToken and debtToken transfers.\n */\ninterface IAaveIncentivesController {\n  /**\n   * @dev Called by the corresponding asset on transfer hook in order to update the rewards distribution.\n   * @dev The units of `totalSupply` and `userBalance` should be the same.\n   * @param user The address of the user whose asset balance has changed\n   * @param totalSupply The total supply of the asset prior to user balance change\n   * @param userBalance The previous user balance prior to balance change\n   */\n  function handleAction(\n    address user,\n    uint256 totalSupply,\n    uint256 userBalance\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IACLManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IACLManager\n * @author Aave\n * @notice Defines the basic interface for the ACL Manager\n */\ninterface IACLManager {\n  /**\n   * @notice Returns the contract address of the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the identifier of the PoolAdmin role\n   * @return The id of the PoolAdmin role\n   */\n  function POOL_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the EmergencyAdmin role\n   * @return The id of the EmergencyAdmin role\n   */\n  function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the RiskAdmin role\n   * @return The id of the RiskAdmin role\n   */\n  function RISK_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the FlashBorrower role\n   * @return The id of the FlashBorrower role\n   */\n  function FLASH_BORROWER_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the Bridge role\n   * @return The id of the Bridge role\n   */\n  function BRIDGE_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the AssetListingAdmin role\n   * @return The id of the AssetListingAdmin role\n   */\n  function ASSET_LISTING_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Set the role as admin of a specific role.\n   * @dev By default the admin role for all roles is `DEFAULT_ADMIN_ROLE`.\n   * @param role The role to be managed by the admin role\n   * @param adminRole The admin role\n   */\n  function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\n\n  /**\n   * @notice Adds a new admin as PoolAdmin\n   * @param admin The address of the new admin\n   */\n  function addPoolAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as PoolAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removePoolAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is PoolAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is PoolAdmin, false otherwise\n   */\n  function isPoolAdmin(address admin) external view returns (bool);\n\n  /**\n   * @notice Adds a new admin as EmergencyAdmin\n   * @param admin The address of the new admin\n   */\n  function addEmergencyAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as EmergencyAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removeEmergencyAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is EmergencyAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is EmergencyAdmin, false otherwise\n   */\n  function isEmergencyAdmin(address admin) external view returns (bool);\n\n  /**\n   * @notice Adds a new admin as RiskAdmin\n   * @param admin The address of the new admin\n   */\n  function addRiskAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as RiskAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removeRiskAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is RiskAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is RiskAdmin, false otherwise\n   */\n  function isRiskAdmin(address admin) external view returns (bool);\n\n  /**\n   * @notice Adds a new address as FlashBorrower\n   * @param borrower The address of the new FlashBorrower\n   */\n  function addFlashBorrower(address borrower) external;\n\n  /**\n   * @notice Removes an address as FlashBorrower\n   * @param borrower The address of the FlashBorrower to remove\n   */\n  function removeFlashBorrower(address borrower) external;\n\n  /**\n   * @notice Returns true if the address is FlashBorrower, false otherwise\n   * @param borrower The address to check\n   * @return True if the given address is FlashBorrower, false otherwise\n   */\n  function isFlashBorrower(address borrower) external view returns (bool);\n\n  /**\n   * @notice Adds a new address as Bridge\n   * @param bridge The address of the new Bridge\n   */\n  function addBridge(address bridge) external;\n\n  /**\n   * @notice Removes an address as Bridge\n   * @param bridge The address of the bridge to remove\n   */\n  function removeBridge(address bridge) external;\n\n  /**\n   * @notice Returns true if the address is Bridge, false otherwise\n   * @param bridge The address to check\n   * @return True if the given address is Bridge, false otherwise\n   */\n  function isBridge(address bridge) external view returns (bool);\n\n  /**\n   * @notice Adds a new admin as AssetListingAdmin\n   * @param admin The address of the new admin\n   */\n  function addAssetListingAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as AssetListingAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removeAssetListingAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is AssetListingAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is AssetListingAdmin, false otherwise\n   */\n  function isAssetListingAdmin(address admin) external view returns (bool);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\nimport {IInitializableAToken} from './IInitializableAToken.sol';\n\n/**\n * @title IAToken\n * @author Aave\n * @notice Defines the basic interface for an AToken.\n */\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\n  /**\n   * @dev Emitted during the transfer action\n   * @param from The user whose tokens are being transferred\n   * @param to The recipient\n   * @param value The scaled amount being transferred\n   * @param index The next liquidity index of the reserve\n   */\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n  /**\n   * @notice Mints `amount` aTokens to `user`\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted aTokens\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool);\n\n  /**\n   * @notice Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * @dev In some instances, the mint event could be emitted from a burn transaction\n   * if the amount to burn is less than the interest that the user accrued\n   * @param from The address from which the aTokens will be burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The next liquidity index of the reserve\n   */\n  function burn(\n    address from,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external;\n\n  /**\n   * @notice Mints aTokens to the reserve treasury\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external;\n\n  /**\n   * @notice Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n   * @param from The address getting liquidated, current owner of the aTokens\n   * @param to The recipient\n   * @param value The amount of tokens getting transferred\n   */\n  function transferOnLiquidation(\n    address from,\n    address to,\n    uint256 value\n  ) external;\n\n  /**\n   * @notice Transfers the underlying asset to `target`.\n   * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()\n   * @param target The recipient of the underlying\n   * @param amount The amount getting transferred\n   */\n  function transferUnderlyingTo(address target, uint256 amount) external;\n\n  /**\n   * @notice Handles the underlying received by the aToken after the transfer has been completed.\n   * @dev The default implementation is empty as with standard ERC20 tokens, nothing needs to be done after the\n   * transfer is concluded. However in the future there may be aTokens that allow for example to stake the underlying\n   * to receive LM rewards. In that case, `handleRepayment()` would perform the staking of the underlying asset.\n   * @param user The user executing the repayment\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed\n   * @param amount The amount getting repaid\n   */\n  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Allow passing a signed message to approve spending\n   * @dev implements the permit function as for\n   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n   * @param owner The owner of the funds\n   * @param spender The spender\n   * @param value The amount\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param v Signature param\n   * @param s Signature param\n   * @param r Signature param\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @notice Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @return The address of the underlying asset\n   */\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n\n  /**\n   * @notice Returns the address of the Aave treasury, receiving the fees on this aToken.\n   * @return Address of the Aave treasury\n   */\n  function RESERVE_TREASURY_ADDRESS() external view returns (address);\n\n  /**\n   * @notice Get the domain separator for the token\n   * @dev Return cached value if chainId matches cache, otherwise recomputes separator\n   * @return The domain separator of the token at current chain\n   */\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /**\n   * @notice Returns the nonce for owner.\n   * @param owner The address of the owner\n   * @return The nonce of the owner\n   */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/ICreditDelegationToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title ICreditDelegationToken\n * @author Aave\n * @notice Defines the basic interface for a token supporting credit delegation.\n */\ninterface ICreditDelegationToken {\n  /**\n   * @dev Emitted on `approveDelegation` and `borrowAllowance\n   * @param fromUser The address of the delegator\n   * @param toUser The address of the delegatee\n   * @param asset The address of the delegated asset\n   * @param amount The amount being delegated\n   */\n  event BorrowAllowanceDelegated(\n    address indexed fromUser,\n    address indexed toUser,\n    address indexed asset,\n    uint256 amount\n  );\n\n  /**\n   * @notice Delegates borrowing power to a user on the specific debt token.\n   * Delegation will still respect the liquidation constraints (even if delegated, a\n   * delegatee cannot force a delegator HF to go below 1)\n   * @param delegatee The address receiving the delegated borrowing power\n   * @param amount The maximum amount being delegated.\n   */\n  function approveDelegation(address delegatee, uint256 amount) external;\n\n  /**\n   * @notice Returns the borrow allowance of the user\n   * @param fromUser The user to giving allowance\n   * @param toUser The user to give allowance to\n   * @return The current allowance of `toUser`\n   */\n  function borrowAllowance(address fromUser, address toUser) external view returns (uint256);\n\n  /**\n   * @notice Delegates borrowing power to a user on the specific debt token via ERC712 signature\n   * @param delegator The delegator of the credit\n   * @param delegatee The delegatee that can use the credit\n   * @param value The amount to be delegated\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param v The V signature param\n   * @param s The S signature param\n   * @param r The R signature param\n   */\n  function delegationWithSig(\n    address delegator,\n    address delegatee,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IDefaultInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IReserveInterestRateStrategy} from './IReserveInterestRateStrategy.sol';\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IDefaultInterestRateStrategy\n * @author Aave\n * @notice Defines the basic interface of the DefaultReserveInterestRateStrategy\n */\ninterface IDefaultInterestRateStrategy is IReserveInterestRateStrategy {\n  /**\n   * @notice Returns the usage ratio at which the pool aims to obtain most competitive borrow rates.\n   * @return The optimal usage ratio, expressed in ray.\n   */\n  function OPTIMAL_USAGE_RATIO() external view returns (uint256);\n\n  /**\n   * @notice Returns the optimal stable to total debt ratio of the reserve.\n   * @return The optimal stable to total debt ratio, expressed in ray.\n   */\n  function OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO() external view returns (uint256);\n\n  /**\n   * @notice Returns the excess usage ratio above the optimal.\n   * @dev It's always equal to 1-optimal usage ratio (added as constant for gas optimizations)\n   * @return The max excess usage ratio, expressed in ray.\n   */\n  function MAX_EXCESS_USAGE_RATIO() external view returns (uint256);\n\n  /**\n   * @notice Returns the excess stable debt ratio above the optimal.\n   * @dev It's always equal to 1-optimal stable to total debt ratio (added as constant for gas optimizations)\n   * @return The max excess stable to total debt ratio, expressed in ray.\n   */\n  function MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the variable rate slope below optimal usage ratio\n   * @dev It's the variable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\n   * @return The variable rate slope, expressed in ray\n   */\n  function getVariableRateSlope1() external view returns (uint256);\n\n  /**\n   * @notice Returns the variable rate slope above optimal usage ratio\n   * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\n   * @return The variable rate slope, expressed in ray\n   */\n  function getVariableRateSlope2() external view returns (uint256);\n\n  /**\n   * @notice Returns the stable rate slope below optimal usage ratio\n   * @dev It's the stable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\n   * @return The stable rate slope, expressed in ray\n   */\n  function getStableRateSlope1() external view returns (uint256);\n\n  /**\n   * @notice Returns the stable rate slope above optimal usage ratio\n   * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\n   * @return The stable rate slope, expressed in ray\n   */\n  function getStableRateSlope2() external view returns (uint256);\n\n  /**\n   * @notice Returns the stable rate excess offset\n   * @dev It's an additional premium applied to the stable when stable debt > OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO\n   * @return The stable rate excess offset, expressed in ray\n   */\n  function getStableRateExcessOffset() external view returns (uint256);\n\n  /**\n   * @notice Returns the base stable borrow rate\n   * @return The base stable borrow rate, expressed in ray\n   */\n  function getBaseStableBorrowRate() external view returns (uint256);\n\n  /**\n   * @notice Returns the base variable borrow rate\n   * @return The base variable borrow rate, expressed in ray\n   */\n  function getBaseVariableBorrowRate() external view returns (uint256);\n\n  /**\n   * @notice Returns the maximum variable borrow rate\n   * @return The maximum variable borrow rate, expressed in ray\n   */\n  function getMaxVariableBorrowRate() external view returns (uint256);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IERC20WithPermit.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\n\n/**\n * @title IERC20WithPermit\n * @author Aave\n * @notice Interface for the permit function (EIP-2612)\n */\ninterface IERC20WithPermit is IERC20 {\n  /**\n   * @notice Allow passing a signed message to approve spending\n   * @dev implements the permit function as for\n   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n   * @param owner The owner of the funds\n   * @param spender The spender\n   * @param value The amount\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param v Signature param\n   * @param s Signature param\n   * @param r Signature param\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IInitializableAToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\nimport {IPool} from './IPool.sol';\n\n/**\n * @title IInitializableAToken\n * @author Aave\n * @notice Interface for the initialize function on AToken\n */\ninterface IInitializableAToken {\n  /**\n   * @dev Emitted when an aToken is initialized\n   * @param underlyingAsset The address of the underlying asset\n   * @param pool The address of the associated pool\n   * @param treasury The address of the treasury\n   * @param incentivesController The address of the incentives controller for this aToken\n   * @param aTokenDecimals The decimals of the underlying\n   * @param aTokenName The name of the aToken\n   * @param aTokenSymbol The symbol of the aToken\n   * @param params A set of encoded parameters for additional initialization\n   */\n  event Initialized(\n    address indexed underlyingAsset,\n    address indexed pool,\n    address treasury,\n    address incentivesController,\n    uint8 aTokenDecimals,\n    string aTokenName,\n    string aTokenSymbol,\n    bytes params\n  );\n\n  /**\n   * @notice Initializes the aToken\n   * @param pool The pool contract that is initializing this contract\n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @param incentivesController The smart contract managing potential incentives distribution\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n   * @param aTokenName The name of the aToken\n   * @param aTokenSymbol The symbol of the aToken\n   * @param params A set of encoded parameters for additional initialization\n   */\n  function initialize(\n    IPool pool,\n    address treasury,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 aTokenDecimals,\n    string calldata aTokenName,\n    string calldata aTokenSymbol,\n    bytes calldata params\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IInitializableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\nimport {IPool} from './IPool.sol';\n\n/**\n * @title IInitializableDebtToken\n * @author Aave\n * @notice Interface for the initialize function common between debt tokens\n */\ninterface IInitializableDebtToken {\n  /**\n   * @dev Emitted when a debt token is initialized\n   * @param underlyingAsset The address of the underlying asset\n   * @param pool The address of the associated pool\n   * @param incentivesController The address of the incentives controller for this aToken\n   * @param debtTokenDecimals The decimals of the debt token\n   * @param debtTokenName The name of the debt token\n   * @param debtTokenSymbol The symbol of the debt token\n   * @param params A set of encoded parameters for additional initialization\n   */\n  event Initialized(\n    address indexed underlyingAsset,\n    address indexed pool,\n    address incentivesController,\n    uint8 debtTokenDecimals,\n    string debtTokenName,\n    string debtTokenSymbol,\n    bytes params\n  );\n\n  /**\n   * @notice Initializes the debt token.\n   * @param pool The pool contract that is initializing this contract\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @param incentivesController The smart contract managing potential incentives distribution\n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\n   * @param debtTokenName The name of the token\n   * @param debtTokenSymbol The symbol of the token\n   * @param params A set of encoded parameters for additional initialization\n   */\n  function initialize(\n    IPool pool,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 debtTokenDecimals,\n    string memory debtTokenName,\n    string memory debtTokenSymbol,\n    bytes calldata params\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(\n    address asset,\n    uint256 amount,\n    uint256 fee\n  ) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\n    external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration)\n    external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPoolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IPoolDataProvider\n * @author Aave\n * @notice Defines the basic interface of a PoolDataProvider\n */\ninterface IPoolDataProvider {\n  struct TokenData {\n    string symbol;\n    address tokenAddress;\n  }\n\n  /**\n   * @notice Returns the address for the PoolAddressesProvider contract.\n   * @return The address for the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the list of the existing reserves in the pool.\n   * @dev Handling MKR and ETH in a different way since they do not have standard `symbol` functions.\n   * @return The list of reserves, pairs of symbols and addresses\n   */\n  function getAllReservesTokens() external view returns (TokenData[] memory);\n\n  /**\n   * @notice Returns the list of the existing ATokens in the pool.\n   * @return The list of ATokens, pairs of symbols and addresses\n   */\n  function getAllATokens() external view returns (TokenData[] memory);\n\n  /**\n   * @notice Returns the configuration data of the reserve\n   * @dev Not returning borrow and supply caps for compatibility, nor pause flag\n   * @param asset The address of the underlying asset of the reserve\n   * @return decimals The number of decimals of the reserve\n   * @return ltv The ltv of the reserve\n   * @return liquidationThreshold The liquidationThreshold of the reserve\n   * @return liquidationBonus The liquidationBonus of the reserve\n   * @return reserveFactor The reserveFactor of the reserve\n   * @return usageAsCollateralEnabled True if the usage as collateral is enabled, false otherwise\n   * @return borrowingEnabled True if borrowing is enabled, false otherwise\n   * @return stableBorrowRateEnabled True if stable rate borrowing is enabled, false otherwise\n   * @return isActive True if it is active, false otherwise\n   * @return isFrozen True if it is frozen, false otherwise\n   */\n  function getReserveConfigurationData(address asset)\n    external\n    view\n    returns (\n      uint256 decimals,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus,\n      uint256 reserveFactor,\n      bool usageAsCollateralEnabled,\n      bool borrowingEnabled,\n      bool stableBorrowRateEnabled,\n      bool isActive,\n      bool isFrozen\n    );\n\n  /**\n   * @notice Returns the efficiency mode category of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The eMode id of the reserve\n   */\n  function getReserveEModeCategory(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the caps parameters of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return borrowCap The borrow cap of the reserve\n   * @return supplyCap The supply cap of the reserve\n   */\n  function getReserveCaps(address asset)\n    external\n    view\n    returns (uint256 borrowCap, uint256 supplyCap);\n\n  /**\n   * @notice Returns if the pool is paused\n   * @param asset The address of the underlying asset of the reserve\n   * @return isPaused True if the pool is paused, false otherwise\n   */\n  function getPaused(address asset) external view returns (bool isPaused);\n\n  /**\n   * @notice Returns the siloed borrowing flag\n   * @param asset The address of the underlying asset of the reserve\n   * @return True if the asset is siloed for borrowing\n   */\n  function getSiloedBorrowing(address asset) external view returns (bool);\n\n  /**\n   * @notice Returns the protocol fee on the liquidation bonus\n   * @param asset The address of the underlying asset of the reserve\n   * @return The protocol fee on liquidation\n   */\n  function getLiquidationProtocolFee(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the unbacked mint cap of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The unbacked mint cap of the reserve\n   */\n  function getUnbackedMintCap(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the debt ceiling of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The debt ceiling of the reserve\n   */\n  function getDebtCeiling(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the debt ceiling decimals\n   * @return The debt ceiling decimals\n   */\n  function getDebtCeilingDecimals() external pure returns (uint256);\n\n  /**\n   * @notice Returns the reserve data\n   * @param asset The address of the underlying asset of the reserve\n   * @return unbacked The amount of unbacked tokens\n   * @return accruedToTreasuryScaled The scaled amount of tokens accrued to treasury that is to be minted\n   * @return totalAToken The total supply of the aToken\n   * @return totalStableDebt The total stable debt of the reserve\n   * @return totalVariableDebt The total variable debt of the reserve\n   * @return liquidityRate The liquidity rate of the reserve\n   * @return variableBorrowRate The variable borrow rate of the reserve\n   * @return stableBorrowRate The stable borrow rate of the reserve\n   * @return averageStableBorrowRate The average stable borrow rate of the reserve\n   * @return liquidityIndex The liquidity index of the reserve\n   * @return variableBorrowIndex The variable borrow index of the reserve\n   * @return lastUpdateTimestamp The timestamp of the last update of the reserve\n   */\n  function getReserveData(address asset)\n    external\n    view\n    returns (\n      uint256 unbacked,\n      uint256 accruedToTreasuryScaled,\n      uint256 totalAToken,\n      uint256 totalStableDebt,\n      uint256 totalVariableDebt,\n      uint256 liquidityRate,\n      uint256 variableBorrowRate,\n      uint256 stableBorrowRate,\n      uint256 averageStableBorrowRate,\n      uint256 liquidityIndex,\n      uint256 variableBorrowIndex,\n      uint40 lastUpdateTimestamp\n    );\n\n  /**\n   * @notice Returns the total supply of aTokens for a given asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The total supply of the aToken\n   */\n  function getATokenTotalSupply(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the total debt for a given asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The total debt for asset\n   */\n  function getTotalDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the user data in a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param user The address of the user\n   * @return currentATokenBalance The current AToken balance of the user\n   * @return currentStableDebt The current stable debt of the user\n   * @return currentVariableDebt The current variable debt of the user\n   * @return principalStableDebt The principal stable debt of the user\n   * @return scaledVariableDebt The scaled variable debt of the user\n   * @return stableBorrowRate The stable borrow rate of the user\n   * @return liquidityRate The liquidity rate of the reserve\n   * @return stableRateLastUpdated The timestamp of the last update of the user stable rate\n   * @return usageAsCollateralEnabled True if the user is using the asset as collateral, false\n   *         otherwise\n   */\n  function getUserReserveData(address asset, address user)\n    external\n    view\n    returns (\n      uint256 currentATokenBalance,\n      uint256 currentStableDebt,\n      uint256 currentVariableDebt,\n      uint256 principalStableDebt,\n      uint256 scaledVariableDebt,\n      uint256 stableBorrowRate,\n      uint256 liquidityRate,\n      uint40 stableRateLastUpdated,\n      bool usageAsCollateralEnabled\n    );\n\n  /**\n   * @notice Returns the token addresses of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return aTokenAddress The AToken address of the reserve\n   * @return stableDebtTokenAddress The StableDebtToken address of the reserve\n   * @return variableDebtTokenAddress The VariableDebtToken address of the reserve\n   */\n  function getReserveTokensAddresses(address asset)\n    external\n    view\n    returns (\n      address aTokenAddress,\n      address stableDebtTokenAddress,\n      address variableDebtTokenAddress\n    );\n\n  /**\n   * @notice Returns the address of the Interest Rate strategy\n   * @param asset The address of the underlying asset of the reserve\n   * @return irStrategyAddress The address of the Interest Rate strategy\n   */\n  function getInterestRateStrategyAddress(address asset)\n    external\n    view\n    returns (address irStrategyAddress);\n\n  /**\n   * @notice Returns whether the reserve has FlashLoans enabled or disabled\n   * @param asset The address of the underlying asset of the reserve\n   * @return True if FlashLoans are enabled, false otherwise\n   */\n  function getFlashLoanEnabled(address asset) external view returns (bool);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPriceOracle\n * @author Aave\n * @notice Defines the basic interface for a Price oracle.\n */\ninterface IPriceOracle {\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   */\n  function getAssetPrice(address asset) external view returns (uint256);\n\n  /**\n   * @notice Set the price of the asset\n   * @param asset The address of the asset\n   * @param price The price of the asset\n   */\n  function setAssetPrice(address asset, uint256 price) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   */\n  function BASE_CURRENCY() external view returns (address);\n\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   */\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   */\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPriceOracleSentinel.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IPriceOracleSentinel\n * @author Aave\n * @notice Defines the basic interface for the PriceOracleSentinel\n */\ninterface IPriceOracleSentinel {\n  /**\n   * @dev Emitted after the sequencer oracle is updated\n   * @param newSequencerOracle The new sequencer oracle\n   */\n  event SequencerOracleUpdated(address newSequencerOracle);\n\n  /**\n   * @dev Emitted after the grace period is updated\n   * @param newGracePeriod The new grace period value\n   */\n  event GracePeriodUpdated(uint256 newGracePeriod);\n\n  /**\n   * @notice Returns the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns true if the `borrow` operation is allowed.\n   * @dev Operation not allowed when PriceOracle is down or grace period not passed.\n   * @return True if the `borrow` operation is allowed, false otherwise.\n   */\n  function isBorrowAllowed() external view returns (bool);\n\n  /**\n   * @notice Returns true if the `liquidation` operation is allowed.\n   * @dev Operation not allowed when PriceOracle is down or grace period not passed.\n   * @return True if the `liquidation` operation is allowed, false otherwise.\n   */\n  function isLiquidationAllowed() external view returns (bool);\n\n  /**\n   * @notice Updates the address of the sequencer oracle\n   * @param newSequencerOracle The address of the new Sequencer Oracle to use\n   */\n  function setSequencerOracle(address newSequencerOracle) external;\n\n  /**\n   * @notice Updates the duration of the grace period\n   * @param newGracePeriod The value of the new grace period duration\n   */\n  function setGracePeriod(uint256 newGracePeriod) external;\n\n  /**\n   * @notice Returns the SequencerOracle\n   * @return The address of the sequencer oracle contract\n   */\n  function getSequencerOracle() external view returns (address);\n\n  /**\n   * @notice Returns the grace period\n   * @return The duration of the grace period\n   */\n  function getGracePeriod() external view returns (uint256);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IReserveInterestRateStrategy\n * @author Aave\n * @notice Interface for the calculation of the interest rates\n */\ninterface IReserveInterestRateStrategy {\n  /**\n   * @notice Calculates the interest rates depending on the reserve's state and configurations\n   * @param params The parameters needed to calculate interest rates\n   * @return liquidityRate The liquidity rate expressed in rays\n   * @return stableBorrowRate The stable borrow rate expressed in rays\n   * @return variableBorrowRate The variable borrow rate expressed in rays\n   */\n  function calculateInterestRates(DataTypes.CalculateInterestRatesParams memory params)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IScaledBalanceToken\n * @author Aave\n * @notice Defines the basic interface for a scaled-balance token.\n */\ninterface IScaledBalanceToken {\n  /**\n   * @dev Emitted after the mint action\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted tokens\n   * @param value The scaled-up amount being minted (based on user entered amount and balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'onBehalfOf'\n   * @param index The next liquidity index of the reserve\n   */\n  event Mint(\n    address indexed caller,\n    address indexed onBehalfOf,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @dev Emitted after the burn action\n   * @dev If the burn function does not involve a transfer of the underlying asset, the target defaults to zero address\n   * @param from The address from which the tokens will be burned\n   * @param target The address that will receive the underlying, if any\n   * @param value The scaled-up amount being burned (user entered amount - balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'from'\n   * @param index The next liquidity index of the reserve\n   */\n  event Burn(\n    address indexed from,\n    address indexed target,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @notice Returns the scaled balance of the user.\n   * @dev The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index\n   * at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   */\n  function scaledBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @notice Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled total supply\n   */\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n  /**\n   * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)\n   * @return The scaled total supply\n   */\n  function scaledTotalSupply() external view returns (uint256);\n\n  /**\n   * @notice Returns last index interest was accrued to the user's balance\n   * @param user The address of the user\n   * @return The last index interest was accrued to the user's balance, expressed in ray\n   */\n  function getPreviousIndex(address user) external view returns (uint256);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IStableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IInitializableDebtToken} from './IInitializableDebtToken.sol';\n\n/**\n * @title IStableDebtToken\n * @author Aave\n * @notice Defines the interface for the stable debt token\n * @dev It does not inherit from IERC20 to save in code size\n */\ninterface IStableDebtToken is IInitializableDebtToken {\n  /**\n   * @dev Emitted when new stable debt is minted\n   * @param user The address of the user who triggered the minting\n   * @param onBehalfOf The recipient of stable debt tokens\n   * @param amount The amount minted (user entered amount + balance increase from interest)\n   * @param currentBalance The balance of the user based on the previous balance and balance increase from interest\n   * @param balanceIncrease The increase in balance since the last action of the user 'onBehalfOf'\n   * @param newRate The rate of the debt after the minting\n   * @param avgStableRate The next average stable rate after the minting\n   * @param newTotalSupply The next total supply of the stable debt token after the action\n   */\n  event Mint(\n    address indexed user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint256 currentBalance,\n    uint256 balanceIncrease,\n    uint256 newRate,\n    uint256 avgStableRate,\n    uint256 newTotalSupply\n  );\n\n  /**\n   * @dev Emitted when new stable debt is burned\n   * @param from The address from which the debt will be burned\n   * @param amount The amount being burned (user entered amount - balance increase from interest)\n   * @param currentBalance The balance of the user based on the previous balance and balance increase from interest\n   * @param balanceIncrease The increase in balance since the last action of 'from'\n   * @param avgStableRate The next average stable rate after the burning\n   * @param newTotalSupply The next total supply of the stable debt token after the action\n   */\n  event Burn(\n    address indexed from,\n    uint256 amount,\n    uint256 currentBalance,\n    uint256 balanceIncrease,\n    uint256 avgStableRate,\n    uint256 newTotalSupply\n  );\n\n  /**\n   * @notice Mints debt token to the `onBehalfOf` address.\n   * @dev The resulting rate is the weighted average between the rate of the new debt\n   * and the rate of the previous debt\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\n   * of credit delegate, or same as `onBehalfOf` otherwise\n   * @param onBehalfOf The address receiving the debt tokens\n   * @param amount The amount of debt tokens to mint\n   * @param rate The rate of the debt being minted\n   * @return True if it is the first borrow, false otherwise\n   * @return The total stable debt\n   * @return The average stable borrow rate\n   */\n  function mint(\n    address user,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 rate\n  )\n    external\n    returns (\n      bool,\n      uint256,\n      uint256\n    );\n\n  /**\n   * @notice Burns debt of `user`\n   * @dev The resulting rate is the weighted average between the rate of the new debt\n   * and the rate of the previous debt\n   * @dev In some instances, a burn transaction will emit a mint event\n   * if the amount to burn is less than the interest the user earned\n   * @param from The address from which the debt will be burned\n   * @param amount The amount of debt tokens getting burned\n   * @return The total stable debt\n   * @return The average stable borrow rate\n   */\n  function burn(address from, uint256 amount) external returns (uint256, uint256);\n\n  /**\n   * @notice Returns the average rate of all the stable rate loans.\n   * @return The average stable rate\n   */\n  function getAverageStableRate() external view returns (uint256);\n\n  /**\n   * @notice Returns the stable rate of the user debt\n   * @param user The address of the user\n   * @return The stable rate of the user\n   */\n  function getUserStableRate(address user) external view returns (uint256);\n\n  /**\n   * @notice Returns the timestamp of the last update of the user\n   * @param user The address of the user\n   * @return The timestamp\n   */\n  function getUserLastUpdated(address user) external view returns (uint40);\n\n  /**\n   * @notice Returns the principal, the total supply, the average stable rate and the timestamp for the last update\n   * @return The principal\n   * @return The total supply\n   * @return The average stable rate\n   * @return The timestamp of the last update\n   */\n  function getSupplyData()\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint40\n    );\n\n  /**\n   * @notice Returns the timestamp of the last update of the total supply\n   * @return The timestamp\n   */\n  function getTotalSupplyLastUpdated() external view returns (uint40);\n\n  /**\n   * @notice Returns the total supply and the average stable rate\n   * @return The total supply\n   * @return The average rate\n   */\n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\n\n  /**\n   * @notice Returns the principal debt balance of the user\n   * @return The debt balance of the user since the last burn/mint action\n   */\n  function principalBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the underlying asset of this stableDebtToken (E.g. WETH for stableDebtWETH)\n   * @return The address of the underlying asset\n   */\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IVariableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\nimport {IInitializableDebtToken} from './IInitializableDebtToken.sol';\n\n/**\n * @title IVariableDebtToken\n * @author Aave\n * @notice Defines the basic interface for a variable debt token.\n */\ninterface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken {\n  /**\n   * @notice Mints debt token to the `onBehalfOf` address\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\n   * of credit delegate, or same as `onBehalfOf` otherwise\n   * @param onBehalfOf The address receiving the debt tokens\n   * @param amount The amount of debt being minted\n   * @param index The variable debt index of the reserve\n   * @return True if the previous balance of the user is 0, false otherwise\n   * @return The scaled total debt of the reserve\n   */\n  function mint(\n    address user,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool, uint256);\n\n  /**\n   * @notice Burns user variable debt\n   * @dev In some instances, a burn transaction will emit a mint event\n   * if the amount to burn is less than the interest that the user accrued\n   * @param from The address from which the debt will be burned\n   * @param amount The amount getting burned\n   * @param index The variable debt index of the reserve\n   * @return The scaled total debt of the reserve\n   */\n  function burn(\n    address from,\n    uint256 amount,\n    uint256 index\n  ) external returns (uint256);\n\n  /**\n   * @notice Returns the address of the underlying asset of this debtToken (E.g. WETH for variableDebtWETH)\n   * @return The address of the underlying asset\n   */\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "@aave/core-v3/contracts/mocks/oracle/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol';\n\ncontract PriceOracle is IPriceOracle {\n  // Map of asset prices (asset => price)\n  mapping(address => uint256) internal prices;\n\n  uint256 internal ethPriceUsd;\n\n  event AssetPriceUpdated(address asset, uint256 price, uint256 timestamp);\n  event EthPriceUpdated(uint256 price, uint256 timestamp);\n\n  function getAssetPrice(address asset) external view override returns (uint256) {\n    return prices[asset];\n  }\n\n  function setAssetPrice(address asset, uint256 price) external override {\n    prices[asset] = price;\n    emit AssetPriceUpdated(asset, price, block.timestamp);\n  }\n\n  function getEthUsdPrice() external view returns (uint256) {\n    return ethPriceUsd;\n  }\n\n  function setEthUsdPrice(uint256 price) external {\n    ethPriceUsd = price;\n    emit EthPriceUpdated(price, block.timestamp);\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {BaseUpgradeabilityProxy} from '../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol';\n\n/**\n * @title BaseImmutableAdminUpgradeabilityProxy\n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern\n * @notice This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * @dev The admin role is stored in an immutable, which helps saving transactions costs\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  address internal immutable _admin;\n\n  /**\n   * @dev Constructor.\n   * @param admin The address of the admin\n   */\n  constructor(address admin) {\n    _admin = admin;\n  }\n\n  modifier ifAdmin() {\n    if (msg.sender == _admin) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @notice Return the admin address\n   * @return The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address) {\n    return _admin;\n  }\n\n  /**\n   * @notice Return the implementation address\n   * @return The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address) {\n    return _implementation();\n  }\n\n  /**\n   * @notice Upgrade the backing implementation of the proxy.\n   * @dev Only the admin can call this function.\n   * @param newImplementation The address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @notice Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * @dev This is useful to initialize the proxied contract.\n   * @param newImplementation The address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\n    external\n    payable\n    ifAdmin\n  {\n    _upgradeTo(newImplementation);\n    (bool success, ) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @notice Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal virtual override {\n    require(msg.sender != _admin, 'Cannot call fallback function from the proxy admin');\n    super._willFallback();\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {InitializableUpgradeabilityProxy} from '../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol';\nimport {Proxy} from '../../../dependencies/openzeppelin/upgradeability/Proxy.sol';\nimport {BaseImmutableAdminUpgradeabilityProxy} from './BaseImmutableAdminUpgradeabilityProxy.sol';\n\n/**\n * @title InitializableAdminUpgradeabilityProxy\n * @author Aave\n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function\n */\ncontract InitializableImmutableAdminUpgradeabilityProxy is\n  BaseImmutableAdminUpgradeabilityProxy,\n  InitializableUpgradeabilityProxy\n{\n  /**\n   * @dev Constructor.\n   * @param admin The address of the admin\n   */\n  constructor(address admin) BaseImmutableAdminUpgradeabilityProxy(admin) {\n    // Intentionally left blank\n  }\n\n  /// @inheritdoc BaseImmutableAdminUpgradeabilityProxy\n  function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {\n    BaseImmutableAdminUpgradeabilityProxy._willFallback();\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\n/**\n * @title VersionedInitializable\n * @author Aave, inspired by the OpenZeppelin Initializable contract\n * @notice Helper contract to implement initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * @dev WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\nabstract contract VersionedInitializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  uint256 private lastInitializedRevision = 0;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    uint256 revision = getRevision();\n    require(\n      initializing || isConstructor() || revision > lastInitializedRevision,\n      'Contract instance has already been initialized'\n    );\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      lastInitializedRevision = revision;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /**\n   * @notice Returns the revision number of the contract\n   * @dev Needs to be defined in the inherited class as a constant.\n   * @return The revision number\n   */\n  function getRevision() internal pure virtual returns (uint256);\n\n  /**\n   * @notice Returns true if and only if the function is running in the constructor\n   * @return True if the function is running in the constructor\n   */\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    //solium-disable-next-line\n    assembly {\n      cs := extcodesize(address())\n    }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/configuration/ReserveConfiguration.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Errors} from '../helpers/Errors.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n  uint256 internal constant LTV_MASK =                       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n  uint256 internal constant LIQUIDATION_THRESHOLD_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n  uint256 internal constant LIQUIDATION_BONUS_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n  uint256 internal constant DECIMALS_MASK =                  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant ACTIVE_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant FROZEN_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROWING_MASK =                 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant STABLE_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant PAUSED_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant SILOED_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant FLASHLOAN_ENABLED_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant RESERVE_FACTOR_MASK =            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROW_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant SUPPLY_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant LIQUIDATION_PROTOCOL_FEE_MASK =  0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant EMODE_CATEGORY_MASK =            0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant UNBACKED_MINT_CAP_MASK =         0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant DEBT_CEILING_MASK =              0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n  uint256 internal constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n  uint256 internal constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n  uint256 internal constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n  uint256 internal constant IS_ACTIVE_START_BIT_POSITION = 56;\n  uint256 internal constant IS_FROZEN_START_BIT_POSITION = 57;\n  uint256 internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n  uint256 internal constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n  uint256 internal constant IS_PAUSED_START_BIT_POSITION = 60;\n  uint256 internal constant BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61;\n  uint256 internal constant SILOED_BORROWING_START_BIT_POSITION = 62;\n  uint256 internal constant FLASHLOAN_ENABLED_START_BIT_POSITION = 63;\n  uint256 internal constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n  uint256 internal constant BORROW_CAP_START_BIT_POSITION = 80;\n  uint256 internal constant SUPPLY_CAP_START_BIT_POSITION = 116;\n  uint256 internal constant LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152;\n  uint256 internal constant EMODE_CATEGORY_START_BIT_POSITION = 168;\n  uint256 internal constant UNBACKED_MINT_CAP_START_BIT_POSITION = 176;\n  uint256 internal constant DEBT_CEILING_START_BIT_POSITION = 212;\n\n  uint256 internal constant MAX_VALID_LTV = 65535;\n  uint256 internal constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\n  uint256 internal constant MAX_VALID_LIQUIDATION_BONUS = 65535;\n  uint256 internal constant MAX_VALID_DECIMALS = 255;\n  uint256 internal constant MAX_VALID_RESERVE_FACTOR = 65535;\n  uint256 internal constant MAX_VALID_BORROW_CAP = 68719476735;\n  uint256 internal constant MAX_VALID_SUPPLY_CAP = 68719476735;\n  uint256 internal constant MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535;\n  uint256 internal constant MAX_VALID_EMODE_CATEGORY = 255;\n  uint256 internal constant MAX_VALID_UNBACKED_MINT_CAP = 68719476735;\n  uint256 internal constant MAX_VALID_DEBT_CEILING = 1099511627775;\n\n  uint256 public constant DEBT_CEILING_DECIMALS = 2;\n  uint16 public constant MAX_RESERVES_COUNT = 128;\n\n  /**\n   * @notice Sets the Loan to Value of the reserve\n   * @param self The reserve configuration\n   * @param ltv The new ltv\n   */\n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\n    require(ltv <= MAX_VALID_LTV, Errors.INVALID_LTV);\n\n    self.data = (self.data & LTV_MASK) | ltv;\n  }\n\n  /**\n   * @notice Gets the Loan to Value of the reserve\n   * @param self The reserve configuration\n   * @return The loan to value\n   */\n  function getLtv(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n    return self.data & ~LTV_MASK;\n  }\n\n  /**\n   * @notice Sets the liquidation threshold of the reserve\n   * @param self The reserve configuration\n   * @param threshold The new liquidation threshold\n   */\n  function setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold)\n    internal\n    pure\n  {\n    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.INVALID_LIQ_THRESHOLD);\n\n    self.data =\n      (self.data & LIQUIDATION_THRESHOLD_MASK) |\n      (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the liquidation threshold of the reserve\n   * @param self The reserve configuration\n   * @return The liquidation threshold\n   */\n  function getLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the liquidation bonus of the reserve\n   * @param self The reserve configuration\n   * @param bonus The new liquidation bonus\n   */\n  function setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus)\n    internal\n    pure\n  {\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.INVALID_LIQ_BONUS);\n\n    self.data =\n      (self.data & LIQUIDATION_BONUS_MASK) |\n      (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the liquidation bonus of the reserve\n   * @param self The reserve configuration\n   * @return The liquidation bonus\n   */\n  function getLiquidationBonus(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the decimals of the underlying asset of the reserve\n   * @param self The reserve configuration\n   * @param decimals The decimals\n   */\n  function setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals)\n    internal\n    pure\n  {\n    require(decimals <= MAX_VALID_DECIMALS, Errors.INVALID_DECIMALS);\n\n    self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the decimals of the underlying asset of the reserve\n   * @param self The reserve configuration\n   * @return The decimals of the asset\n   */\n  function getDecimals(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the active state of the reserve\n   * @param self The reserve configuration\n   * @param active The active state\n   */\n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\n    self.data =\n      (self.data & ACTIVE_MASK) |\n      (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the active state of the reserve\n   * @param self The reserve configuration\n   * @return The active state\n   */\n  function getActive(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n    return (self.data & ~ACTIVE_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the frozen state of the reserve\n   * @param self The reserve configuration\n   * @param frozen The frozen state\n   */\n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\n    self.data =\n      (self.data & FROZEN_MASK) |\n      (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the frozen state of the reserve\n   * @param self The reserve configuration\n   * @return The frozen state\n   */\n  function getFrozen(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n    return (self.data & ~FROZEN_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the paused state of the reserve\n   * @param self The reserve configuration\n   * @param paused The paused state\n   */\n  function setPaused(DataTypes.ReserveConfigurationMap memory self, bool paused) internal pure {\n    self.data =\n      (self.data & PAUSED_MASK) |\n      (uint256(paused ? 1 : 0) << IS_PAUSED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the paused state of the reserve\n   * @param self The reserve configuration\n   * @return The paused state\n   */\n  function getPaused(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n    return (self.data & ~PAUSED_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the borrowable in isolation flag for the reserve.\n   * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the borrowed\n   * amount will be accumulated in the isolated collateral's total debt exposure.\n   * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n   * consistency in the debt ceiling calculations.\n   * @param self The reserve configuration\n   * @param borrowable True if the asset is borrowable\n   */\n  function setBorrowableInIsolation(DataTypes.ReserveConfigurationMap memory self, bool borrowable)\n    internal\n    pure\n  {\n    self.data =\n      (self.data & BORROWABLE_IN_ISOLATION_MASK) |\n      (uint256(borrowable ? 1 : 0) << BORROWABLE_IN_ISOLATION_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrowable in isolation flag for the reserve.\n   * @dev If the returned flag is true, the asset is borrowable against isolated collateral. Assets borrowed with\n   * isolated collateral is accounted for in the isolated collateral's total debt exposure.\n   * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n   * consistency in the debt ceiling calculations.\n   * @param self The reserve configuration\n   * @return The borrowable in isolation flag\n   */\n  function getBorrowableInIsolation(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~BORROWABLE_IN_ISOLATION_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the siloed borrowing flag for the reserve.\n   * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n   * @param self The reserve configuration\n   * @param siloed True if the asset is siloed\n   */\n  function setSiloedBorrowing(DataTypes.ReserveConfigurationMap memory self, bool siloed)\n    internal\n    pure\n  {\n    self.data =\n      (self.data & SILOED_BORROWING_MASK) |\n      (uint256(siloed ? 1 : 0) << SILOED_BORROWING_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the siloed borrowing flag for the reserve.\n   * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n   * @param self The reserve configuration\n   * @return The siloed borrowing flag\n   */\n  function getSiloedBorrowing(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~SILOED_BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Enables or disables borrowing on the reserve\n   * @param self The reserve configuration\n   * @param enabled True if the borrowing needs to be enabled, false otherwise\n   */\n  function setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled)\n    internal\n    pure\n  {\n    self.data =\n      (self.data & BORROWING_MASK) |\n      (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrowing state of the reserve\n   * @param self The reserve configuration\n   * @return The borrowing state\n   */\n  function getBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Enables or disables stable rate borrowing on the reserve\n   * @param self The reserve configuration\n   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\n   */\n  function setStableRateBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool enabled\n  ) internal pure {\n    self.data =\n      (self.data & STABLE_BORROWING_MASK) |\n      (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the stable rate borrowing state of the reserve\n   * @param self The reserve configuration\n   * @return The stable rate borrowing state\n   */\n  function getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~STABLE_BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the reserve factor of the reserve\n   * @param self The reserve configuration\n   * @param reserveFactor The reserve factor\n   */\n  function setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor)\n    internal\n    pure\n  {\n    require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.INVALID_RESERVE_FACTOR);\n\n    self.data =\n      (self.data & RESERVE_FACTOR_MASK) |\n      (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the reserve factor of the reserve\n   * @param self The reserve configuration\n   * @return The reserve factor\n   */\n  function getReserveFactor(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the borrow cap of the reserve\n   * @param self The reserve configuration\n   * @param borrowCap The borrow cap\n   */\n  function setBorrowCap(DataTypes.ReserveConfigurationMap memory self, uint256 borrowCap)\n    internal\n    pure\n  {\n    require(borrowCap <= MAX_VALID_BORROW_CAP, Errors.INVALID_BORROW_CAP);\n\n    self.data = (self.data & BORROW_CAP_MASK) | (borrowCap << BORROW_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrow cap of the reserve\n   * @param self The reserve configuration\n   * @return The borrow cap\n   */\n  function getBorrowCap(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return (self.data & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the supply cap of the reserve\n   * @param self The reserve configuration\n   * @param supplyCap The supply cap\n   */\n  function setSupplyCap(DataTypes.ReserveConfigurationMap memory self, uint256 supplyCap)\n    internal\n    pure\n  {\n    require(supplyCap <= MAX_VALID_SUPPLY_CAP, Errors.INVALID_SUPPLY_CAP);\n\n    self.data = (self.data & SUPPLY_CAP_MASK) | (supplyCap << SUPPLY_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the supply cap of the reserve\n   * @param self The reserve configuration\n   * @return The supply cap\n   */\n  function getSupplyCap(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return (self.data & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the debt ceiling in isolation mode for the asset\n   * @param self The reserve configuration\n   * @param ceiling The maximum debt ceiling for the asset\n   */\n  function setDebtCeiling(DataTypes.ReserveConfigurationMap memory self, uint256 ceiling)\n    internal\n    pure\n  {\n    require(ceiling <= MAX_VALID_DEBT_CEILING, Errors.INVALID_DEBT_CEILING);\n\n    self.data = (self.data & DEBT_CEILING_MASK) | (ceiling << DEBT_CEILING_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the debt ceiling for the asset if the asset is in isolation mode\n   * @param self The reserve configuration\n   * @return The debt ceiling (0 = isolation mode disabled)\n   */\n  function getDebtCeiling(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return (self.data & ~DEBT_CEILING_MASK) >> DEBT_CEILING_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the liquidation protocol fee of the reserve\n   * @param self The reserve configuration\n   * @param liquidationProtocolFee The liquidation protocol fee\n   */\n  function setLiquidationProtocolFee(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 liquidationProtocolFee\n  ) internal pure {\n    require(\n      liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE,\n      Errors.INVALID_LIQUIDATION_PROTOCOL_FEE\n    );\n\n    self.data =\n      (self.data & LIQUIDATION_PROTOCOL_FEE_MASK) |\n      (liquidationProtocolFee << LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the liquidation protocol fee\n   * @param self The reserve configuration\n   * @return The liquidation protocol fee\n   */\n  function getLiquidationProtocolFee(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return\n      (self.data & ~LIQUIDATION_PROTOCOL_FEE_MASK) >> LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the unbacked mint cap of the reserve\n   * @param self The reserve configuration\n   * @param unbackedMintCap The unbacked mint cap\n   */\n  function setUnbackedMintCap(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 unbackedMintCap\n  ) internal pure {\n    require(unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP, Errors.INVALID_UNBACKED_MINT_CAP);\n\n    self.data =\n      (self.data & UNBACKED_MINT_CAP_MASK) |\n      (unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the unbacked mint cap of the reserve\n   * @param self The reserve configuration\n   * @return The unbacked mint cap\n   */\n  function getUnbackedMintCap(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return (self.data & ~UNBACKED_MINT_CAP_MASK) >> UNBACKED_MINT_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the eMode asset category\n   * @param self The reserve configuration\n   * @param category The asset category when the user selects the eMode\n   */\n  function setEModeCategory(DataTypes.ReserveConfigurationMap memory self, uint256 category)\n    internal\n    pure\n  {\n    require(category <= MAX_VALID_EMODE_CATEGORY, Errors.INVALID_EMODE_CATEGORY);\n\n    self.data = (self.data & EMODE_CATEGORY_MASK) | (category << EMODE_CATEGORY_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the eMode asset category\n   * @param self The reserve configuration\n   * @return The eMode category for the asset\n   */\n  function getEModeCategory(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return (self.data & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the flashloanable flag for the reserve\n   * @param self The reserve configuration\n   * @param flashLoanEnabled True if the asset is flashloanable, false otherwise\n   */\n  function setFlashLoanEnabled(DataTypes.ReserveConfigurationMap memory self, bool flashLoanEnabled)\n    internal\n    pure\n  {\n    self.data =\n      (self.data & FLASHLOAN_ENABLED_MASK) |\n      (uint256(flashLoanEnabled ? 1 : 0) << FLASHLOAN_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the flashloanable flag for the reserve\n   * @param self The reserve configuration\n   * @return The flashloanable flag\n   */\n  function getFlashLoanEnabled(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~FLASHLOAN_ENABLED_MASK) != 0;\n  }\n\n  /**\n   * @notice Gets the configuration flags of the reserve\n   * @param self The reserve configuration\n   * @return The state flag representing active\n   * @return The state flag representing frozen\n   * @return The state flag representing borrowing enabled\n   * @return The state flag representing stableRateBorrowing enabled\n   * @return The state flag representing paused\n   */\n  function getFlags(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (\n      bool,\n      bool,\n      bool,\n      bool,\n      bool\n    )\n  {\n    uint256 dataLocal = self.data;\n\n    return (\n      (dataLocal & ~ACTIVE_MASK) != 0,\n      (dataLocal & ~FROZEN_MASK) != 0,\n      (dataLocal & ~BORROWING_MASK) != 0,\n      (dataLocal & ~STABLE_BORROWING_MASK) != 0,\n      (dataLocal & ~PAUSED_MASK) != 0\n    );\n  }\n\n  /**\n   * @notice Gets the configuration parameters of the reserve from storage\n   * @param self The reserve configuration\n   * @return The state param representing ltv\n   * @return The state param representing liquidation threshold\n   * @return The state param representing liquidation bonus\n   * @return The state param representing reserve decimals\n   * @return The state param representing reserve factor\n   * @return The state param representing eMode category\n   */\n  function getParams(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 dataLocal = self.data;\n\n    return (\n      dataLocal & ~LTV_MASK,\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION,\n      (dataLocal & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION\n    );\n  }\n\n  /**\n   * @notice Gets the caps parameters of the reserve from storage\n   * @param self The reserve configuration\n   * @return The state param representing borrow cap\n   * @return The state param representing supply cap.\n   */\n  function getCaps(DataTypes.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint256, uint256)\n  {\n    uint256 dataLocal = self.data;\n\n    return (\n      (dataLocal & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION,\n      (dataLocal & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION\n    );\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/configuration/UserConfiguration.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Errors} from '../helpers/Errors.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {ReserveConfiguration} from './ReserveConfiguration.sol';\n\n/**\n * @title UserConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the user configuration\n */\nlibrary UserConfiguration {\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  uint256 internal constant BORROWING_MASK =\n    0x5555555555555555555555555555555555555555555555555555555555555555;\n  uint256 internal constant COLLATERAL_MASK =\n    0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;\n\n  /**\n   * @notice Sets if the user is borrowing the reserve identified by reserveIndex\n   * @param self The configuration object\n   * @param reserveIndex The index of the reserve in the bitmap\n   * @param borrowing True if the user is borrowing the reserve, false otherwise\n   */\n  function setBorrowing(\n    DataTypes.UserConfigurationMap storage self,\n    uint256 reserveIndex,\n    bool borrowing\n  ) internal {\n    unchecked {\n      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);\n      uint256 bit = 1 << (reserveIndex << 1);\n      if (borrowing) {\n        self.data |= bit;\n      } else {\n        self.data &= ~bit;\n      }\n    }\n  }\n\n  /**\n   * @notice Sets if the user is using as collateral the reserve identified by reserveIndex\n   * @param self The configuration object\n   * @param reserveIndex The index of the reserve in the bitmap\n   * @param usingAsCollateral True if the user is using the reserve as collateral, false otherwise\n   */\n  function setUsingAsCollateral(\n    DataTypes.UserConfigurationMap storage self,\n    uint256 reserveIndex,\n    bool usingAsCollateral\n  ) internal {\n    unchecked {\n      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);\n      uint256 bit = 1 << ((reserveIndex << 1) + 1);\n      if (usingAsCollateral) {\n        self.data |= bit;\n      } else {\n        self.data &= ~bit;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns if a user has been using the reserve for borrowing or as collateral\n   * @param self The configuration object\n   * @param reserveIndex The index of the reserve in the bitmap\n   * @return True if the user has been using a reserve for borrowing or as collateral, false otherwise\n   */\n  function isUsingAsCollateralOrBorrowing(\n    DataTypes.UserConfigurationMap memory self,\n    uint256 reserveIndex\n  ) internal pure returns (bool) {\n    unchecked {\n      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);\n      return (self.data >> (reserveIndex << 1)) & 3 != 0;\n    }\n  }\n\n  /**\n   * @notice Validate a user has been using the reserve for borrowing\n   * @param self The configuration object\n   * @param reserveIndex The index of the reserve in the bitmap\n   * @return True if the user has been using a reserve for borrowing, false otherwise\n   */\n  function isBorrowing(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex)\n    internal\n    pure\n    returns (bool)\n  {\n    unchecked {\n      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);\n      return (self.data >> (reserveIndex << 1)) & 1 != 0;\n    }\n  }\n\n  /**\n   * @notice Validate a user has been using the reserve as collateral\n   * @param self The configuration object\n   * @param reserveIndex The index of the reserve in the bitmap\n   * @return True if the user has been using a reserve as collateral, false otherwise\n   */\n  function isUsingAsCollateral(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex)\n    internal\n    pure\n    returns (bool)\n  {\n    unchecked {\n      require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);\n      return (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0;\n    }\n  }\n\n  /**\n   * @notice Checks if a user has been supplying only one reserve as collateral\n   * @dev this uses a simple trick - if a number is a power of two (only one bit set) then n & (n - 1) == 0\n   * @param self The configuration object\n   * @return True if the user has been supplying as collateral one reserve, false otherwise\n   */\n  function isUsingAsCollateralOne(DataTypes.UserConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    uint256 collateralData = self.data & COLLATERAL_MASK;\n    return collateralData != 0 && (collateralData & (collateralData - 1) == 0);\n  }\n\n  /**\n   * @notice Checks if a user has been supplying any reserve as collateral\n   * @param self The configuration object\n   * @return True if the user has been supplying as collateral any reserve, false otherwise\n   */\n  function isUsingAsCollateralAny(DataTypes.UserConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return self.data & COLLATERAL_MASK != 0;\n  }\n\n  /**\n   * @notice Checks if a user has been borrowing only one asset\n   * @dev this uses a simple trick - if a number is a power of two (only one bit set) then n & (n - 1) == 0\n   * @param self The configuration object\n   * @return True if the user has been supplying as collateral one reserve, false otherwise\n   */\n  function isBorrowingOne(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\n    uint256 borrowingData = self.data & BORROWING_MASK;\n    return borrowingData != 0 && (borrowingData & (borrowingData - 1) == 0);\n  }\n\n  /**\n   * @notice Checks if a user has been borrowing from any reserve\n   * @param self The configuration object\n   * @return True if the user has been borrowing any reserve, false otherwise\n   */\n  function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\n    return self.data & BORROWING_MASK != 0;\n  }\n\n  /**\n   * @notice Checks if a user has not been using any reserve for borrowing or supply\n   * @param self The configuration object\n   * @return True if the user has not been borrowing or supplying any reserve, false otherwise\n   */\n  function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\n    return self.data == 0;\n  }\n\n  /**\n   * @notice Returns the Isolation Mode state of the user\n   * @param self The configuration object\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @return True if the user is in isolation mode, false otherwise\n   * @return The address of the only asset used as collateral\n   * @return The debt ceiling of the reserve\n   */\n  function getIsolationModeState(\n    DataTypes.UserConfigurationMap memory self,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList\n  )\n    internal\n    view\n    returns (\n      bool,\n      address,\n      uint256\n    )\n  {\n    if (isUsingAsCollateralOne(self)) {\n      uint256 assetId = _getFirstAssetIdByMask(self, COLLATERAL_MASK);\n\n      address assetAddress = reservesList[assetId];\n      uint256 ceiling = reservesData[assetAddress].configuration.getDebtCeiling();\n      if (ceiling != 0) {\n        return (true, assetAddress, ceiling);\n      }\n    }\n    return (false, address(0), 0);\n  }\n\n  /**\n   * @notice Returns the siloed borrowing state for the user\n   * @param self The configuration object\n   * @param reservesData The data of all the reserves\n   * @param reservesList The reserve list\n   * @return True if the user has borrowed a siloed asset, false otherwise\n   * @return The address of the only borrowed asset\n   */\n  function getSiloedBorrowingState(\n    DataTypes.UserConfigurationMap memory self,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList\n  ) internal view returns (bool, address) {\n    if (isBorrowingOne(self)) {\n      uint256 assetId = _getFirstAssetIdByMask(self, BORROWING_MASK);\n      address assetAddress = reservesList[assetId];\n      if (reservesData[assetAddress].configuration.getSiloedBorrowing()) {\n        return (true, assetAddress);\n      }\n    }\n\n    return (false, address(0));\n  }\n\n  /**\n   * @notice Returns the address of the first asset flagged in the bitmap given the corresponding bitmask\n   * @param self The configuration object\n   * @return The index of the first asset flagged in the bitmap once the corresponding mask is applied\n   */\n  function _getFirstAssetIdByMask(DataTypes.UserConfigurationMap memory self, uint256 mask)\n    internal\n    pure\n    returns (uint256)\n  {\n    unchecked {\n      uint256 bitmapData = self.data & mask;\n      uint256 firstAssetPosition = bitmapData & ~(bitmapData - 1);\n      uint256 id;\n\n      while ((firstAssetPosition >>= 2) != 0) {\n        id += 1;\n      }\n      return id;\n    }\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Errors library\n * @author Aave\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n */\nlibrary Errors {\n  string public constant CALLER_NOT_POOL_ADMIN = '1'; // 'The caller of the function is not a pool admin'\n  string public constant CALLER_NOT_EMERGENCY_ADMIN = '2'; // 'The caller of the function is not an emergency admin'\n  string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = '3'; // 'The caller of the function is not a pool or emergency admin'\n  string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = '4'; // 'The caller of the function is not a risk or pool admin'\n  string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = '5'; // 'The caller of the function is not an asset listing or pool admin'\n  string public constant CALLER_NOT_BRIDGE = '6'; // 'The caller of the function is not a bridge'\n  string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = '7'; // 'Pool addresses provider is not registered'\n  string public constant INVALID_ADDRESSES_PROVIDER_ID = '8'; // 'Invalid id for the pool addresses provider'\n  string public constant NOT_CONTRACT = '9'; // 'Address is not a contract'\n  string public constant CALLER_NOT_POOL_CONFIGURATOR = '10'; // 'The caller of the function is not the pool configurator'\n  string public constant CALLER_NOT_ATOKEN = '11'; // 'The caller of the function is not an AToken'\n  string public constant INVALID_ADDRESSES_PROVIDER = '12'; // 'The address of the pool addresses provider is invalid'\n  string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = '13'; // 'Invalid return value of the flashloan executor function'\n  string public constant RESERVE_ALREADY_ADDED = '14'; // 'Reserve has already been added to reserve list'\n  string public constant NO_MORE_RESERVES_ALLOWED = '15'; // 'Maximum amount of reserves in the pool reached'\n  string public constant EMODE_CATEGORY_RESERVED = '16'; // 'Zero eMode category is reserved for volatile heterogeneous assets'\n  string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = '17'; // 'Invalid eMode category assignment to asset'\n  string public constant RESERVE_LIQUIDITY_NOT_ZERO = '18'; // 'The liquidity of the reserve needs to be 0'\n  string public constant FLASHLOAN_PREMIUM_INVALID = '19'; // 'Invalid flashloan premium'\n  string public constant INVALID_RESERVE_PARAMS = '20'; // 'Invalid risk parameters for the reserve'\n  string public constant INVALID_EMODE_CATEGORY_PARAMS = '21'; // 'Invalid risk parameters for the eMode category'\n  string public constant BRIDGE_PROTOCOL_FEE_INVALID = '22'; // 'Invalid bridge protocol fee'\n  string public constant CALLER_MUST_BE_POOL = '23'; // 'The caller of this function must be a pool'\n  string public constant INVALID_MINT_AMOUNT = '24'; // 'Invalid amount to mint'\n  string public constant INVALID_BURN_AMOUNT = '25'; // 'Invalid amount to burn'\n  string public constant INVALID_AMOUNT = '26'; // 'Amount must be greater than 0'\n  string public constant RESERVE_INACTIVE = '27'; // 'Action requires an active reserve'\n  string public constant RESERVE_FROZEN = '28'; // 'Action cannot be performed because the reserve is frozen'\n  string public constant RESERVE_PAUSED = '29'; // 'Action cannot be performed because the reserve is paused'\n  string public constant BORROWING_NOT_ENABLED = '30'; // 'Borrowing is not enabled'\n  string public constant STABLE_BORROWING_NOT_ENABLED = '31'; // 'Stable borrowing is not enabled'\n  string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = '32'; // 'User cannot withdraw more than the available balance'\n  string public constant INVALID_INTEREST_RATE_MODE_SELECTED = '33'; // 'Invalid interest rate mode selected'\n  string public constant COLLATERAL_BALANCE_IS_ZERO = '34'; // 'The collateral balance is 0'\n  string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '35'; // 'Health factor is lesser than the liquidation threshold'\n  string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = '36'; // 'There is not enough collateral to cover a new borrow'\n  string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = '37'; // 'Collateral is (mostly) the same currency that is being borrowed'\n  string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '38'; // 'The requested amount is greater than the max loan size in stable rate mode'\n  string public constant NO_DEBT_OF_SELECTED_TYPE = '39'; // 'For repayment of a specific type of debt, the user needs to have debt that type'\n  string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '40'; // 'To repay on behalf of a user an explicit amount to repay is needed'\n  string public constant NO_OUTSTANDING_STABLE_DEBT = '41'; // 'User does not have outstanding stable rate debt on this reserve'\n  string public constant NO_OUTSTANDING_VARIABLE_DEBT = '42'; // 'User does not have outstanding variable rate debt on this reserve'\n  string public constant UNDERLYING_BALANCE_ZERO = '43'; // 'The underlying balance needs to be greater than 0'\n  string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '44'; // 'Interest rate rebalance conditions were not met'\n  string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '45'; // 'Health factor is not below the threshold'\n  string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = '46'; // 'The collateral chosen cannot be liquidated'\n  string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '47'; // 'User did not borrow the specified currency'\n  string public constant INCONSISTENT_FLASHLOAN_PARAMS = '49'; // 'Inconsistent flashloan parameters'\n  string public constant BORROW_CAP_EXCEEDED = '50'; // 'Borrow cap is exceeded'\n  string public constant SUPPLY_CAP_EXCEEDED = '51'; // 'Supply cap is exceeded'\n  string public constant UNBACKED_MINT_CAP_EXCEEDED = '52'; // 'Unbacked mint cap is exceeded'\n  string public constant DEBT_CEILING_EXCEEDED = '53'; // 'Debt ceiling is exceeded'\n  string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = '54'; // 'Claimable rights over underlying not zero (aToken supply or accruedToTreasury)'\n  string public constant STABLE_DEBT_NOT_ZERO = '55'; // 'Stable debt supply is not zero'\n  string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = '56'; // 'Variable debt supply is not zero'\n  string public constant LTV_VALIDATION_FAILED = '57'; // 'Ltv validation failed'\n  string public constant INCONSISTENT_EMODE_CATEGORY = '58'; // 'Inconsistent eMode category'\n  string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = '59'; // 'Price oracle sentinel validation failed'\n  string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = '60'; // 'Asset is not borrowable in isolation mode'\n  string public constant RESERVE_ALREADY_INITIALIZED = '61'; // 'Reserve has already been initialized'\n  string public constant USER_IN_ISOLATION_MODE = '62'; // 'User is in isolation mode'\n  string public constant INVALID_LTV = '63'; // 'Invalid ltv parameter for the reserve'\n  string public constant INVALID_LIQ_THRESHOLD = '64'; // 'Invalid liquidity threshold parameter for the reserve'\n  string public constant INVALID_LIQ_BONUS = '65'; // 'Invalid liquidity bonus parameter for the reserve'\n  string public constant INVALID_DECIMALS = '66'; // 'Invalid decimals parameter of the underlying asset of the reserve'\n  string public constant INVALID_RESERVE_FACTOR = '67'; // 'Invalid reserve factor parameter for the reserve'\n  string public constant INVALID_BORROW_CAP = '68'; // 'Invalid borrow cap for the reserve'\n  string public constant INVALID_SUPPLY_CAP = '69'; // 'Invalid supply cap for the reserve'\n  string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = '70'; // 'Invalid liquidation protocol fee for the reserve'\n  string public constant INVALID_EMODE_CATEGORY = '71'; // 'Invalid eMode category for the reserve'\n  string public constant INVALID_UNBACKED_MINT_CAP = '72'; // 'Invalid unbacked mint cap for the reserve'\n  string public constant INVALID_DEBT_CEILING = '73'; // 'Invalid debt ceiling for the reserve\n  string public constant INVALID_RESERVE_INDEX = '74'; // 'Invalid reserve index'\n  string public constant ACL_ADMIN_CANNOT_BE_ZERO = '75'; // 'ACL admin cannot be set to the zero address'\n  string public constant INCONSISTENT_PARAMS_LENGTH = '76'; // 'Array parameters that should be equal length are not'\n  string public constant ZERO_ADDRESS_NOT_VALID = '77'; // 'Zero address not valid'\n  string public constant INVALID_EXPIRATION = '78'; // 'Invalid expiration'\n  string public constant INVALID_SIGNATURE = '79'; // 'Invalid signature'\n  string public constant OPERATION_NOT_SUPPORTED = '80'; // 'Operation not supported'\n  string public constant DEBT_CEILING_NOT_ZERO = '81'; // 'Debt ceiling is not zero'\n  string public constant ASSET_NOT_LISTED = '82'; // 'Asset is not listed'\n  string public constant INVALID_OPTIMAL_USAGE_RATIO = '83'; // 'Invalid optimal usage ratio'\n  string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = '84'; // 'Invalid optimal stable to total debt ratio'\n  string public constant UNDERLYING_CANNOT_BE_RESCUED = '85'; // 'The underlying asset cannot be rescued'\n  string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = '86'; // 'Reserve has already been added to reserve list'\n  string public constant POOL_ADDRESSES_DO_NOT_MATCH = '87'; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'\n  string public constant STABLE_BORROWING_ENABLED = '88'; // 'Stable borrowing is enabled'\n  string public constant SILOED_BORROWING_VIOLATION = '89'; // 'User is trying to borrow multiple assets including a siloed one'\n  string public constant RESERVE_DEBT_NOT_ZERO = '90'; // the total debt of the reserve needs to be 0\n  string public constant FLASHLOAN_DISABLED = '91'; // FlashLoaning for this asset is disabled\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/helpers/Helpers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\n\n/**\n * @title Helpers library\n * @author Aave\n */\nlibrary Helpers {\n  /**\n   * @notice Fetches the user current stable and variable debt balances\n   * @param user The user address\n   * @param reserveCache The reserve cache data object\n   * @return The stable debt balance\n   * @return The variable debt balance\n   */\n  function getUserCurrentDebt(address user, DataTypes.ReserveCache memory reserveCache)\n    internal\n    view\n    returns (uint256, uint256)\n  {\n    return (\n      IERC20(reserveCache.stableDebtTokenAddress).balanceOf(user),\n      IERC20(reserveCache.variableDebtTokenAddress).balanceOf(user)\n    );\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/logic/BorrowLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {GPv2SafeERC20} from '../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {SafeCast} from '../../../dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IStableDebtToken} from '../../../interfaces/IStableDebtToken.sol';\nimport {IVariableDebtToken} from '../../../interfaces/IVariableDebtToken.sol';\nimport {IAToken} from '../../../interfaces/IAToken.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {Helpers} from '../helpers/Helpers.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {ValidationLogic} from './ValidationLogic.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {IsolationModeLogic} from './IsolationModeLogic.sol';\n\n/**\n * @title BorrowLogic library\n * @author Aave\n * @notice Implements the base logic for all the actions related to borrowing\n */\nlibrary BorrowLogic {\n  using ReserveLogic for DataTypes.ReserveCache;\n  using ReserveLogic for DataTypes.ReserveData;\n  using GPv2SafeERC20 for IERC20;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using SafeCast for uint256;\n\n  // See `IPool` for descriptions\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @notice Implements the borrow feature. Borrowing allows users that provided collateral to draw liquidity from the\n   * Aave protocol proportionally to their collateralization power. For isolated positions, it also increases the\n   * isolated debt.\n   * @dev  Emits the `Borrow()` event\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n   * @param params The additional parameters needed to execute the borrow function\n   */\n  function executeBorrow(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.ExecuteBorrowParams memory params\n  ) public {\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n    reserve.updateState(reserveCache);\n\n    (\n      bool isolationModeActive,\n      address isolationModeCollateralAddress,\n      uint256 isolationModeDebtCeiling\n    ) = userConfig.getIsolationModeState(reservesData, reservesList);\n\n    ValidationLogic.validateBorrow(\n      reservesData,\n      reservesList,\n      eModeCategories,\n      DataTypes.ValidateBorrowParams({\n        reserveCache: reserveCache,\n        userConfig: userConfig,\n        asset: params.asset,\n        userAddress: params.onBehalfOf,\n        amount: params.amount,\n        interestRateMode: params.interestRateMode,\n        maxStableLoanPercent: params.maxStableRateBorrowSizePercent,\n        reservesCount: params.reservesCount,\n        oracle: params.oracle,\n        userEModeCategory: params.userEModeCategory,\n        priceOracleSentinel: params.priceOracleSentinel,\n        isolationModeActive: isolationModeActive,\n        isolationModeCollateralAddress: isolationModeCollateralAddress,\n        isolationModeDebtCeiling: isolationModeDebtCeiling\n      })\n    );\n\n    uint256 currentStableRate = 0;\n    bool isFirstBorrowing = false;\n\n    if (params.interestRateMode == DataTypes.InterestRateMode.STABLE) {\n      currentStableRate = reserve.currentStableBorrowRate;\n\n      (\n        isFirstBorrowing,\n        reserveCache.nextTotalStableDebt,\n        reserveCache.nextAvgStableBorrowRate\n      ) = IStableDebtToken(reserveCache.stableDebtTokenAddress).mint(\n        params.user,\n        params.onBehalfOf,\n        params.amount,\n        currentStableRate\n      );\n    } else {\n      (isFirstBorrowing, reserveCache.nextScaledVariableDebt) = IVariableDebtToken(\n        reserveCache.variableDebtTokenAddress\n      ).mint(params.user, params.onBehalfOf, params.amount, reserveCache.nextVariableBorrowIndex);\n    }\n\n    if (isFirstBorrowing) {\n      userConfig.setBorrowing(reserve.id, true);\n    }\n\n    if (isolationModeActive) {\n      uint256 nextIsolationModeTotalDebt = reservesData[isolationModeCollateralAddress]\n        .isolationModeTotalDebt += (params.amount /\n        10 **\n          (reserveCache.reserveConfiguration.getDecimals() -\n            ReserveConfiguration.DEBT_CEILING_DECIMALS)).toUint128();\n      emit IsolationModeTotalDebtUpdated(\n        isolationModeCollateralAddress,\n        nextIsolationModeTotalDebt\n      );\n    }\n\n    reserve.updateInterestRates(\n      reserveCache,\n      params.asset,\n      0,\n      params.releaseUnderlying ? params.amount : 0\n    );\n\n    if (params.releaseUnderlying) {\n      IAToken(reserveCache.aTokenAddress).transferUnderlyingTo(params.user, params.amount);\n    }\n\n    emit Borrow(\n      params.asset,\n      params.user,\n      params.onBehalfOf,\n      params.amount,\n      params.interestRateMode,\n      params.interestRateMode == DataTypes.InterestRateMode.STABLE\n        ? currentStableRate\n        : reserve.currentVariableBorrowRate,\n      params.referralCode\n    );\n  }\n\n  /**\n   * @notice Implements the repay feature. Repaying transfers the underlying back to the aToken and clears the\n   * equivalent amount of debt for the user by burning the corresponding debt token. For isolated positions, it also\n   * reduces the isolated debt.\n   * @dev  Emits the `Repay()` event\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n   * @param params The additional parameters needed to execute the repay function\n   * @return The actual amount being repaid\n   */\n  function executeRepay(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) external returns (uint256) {\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    DataTypes.ReserveCache memory reserveCache = reserve.cache();\n    reserve.updateState(reserveCache);\n\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(\n      params.onBehalfOf,\n      reserveCache\n    );\n\n    ValidationLogic.validateRepay(\n      reserveCache,\n      params.amount,\n      params.interestRateMode,\n      params.onBehalfOf,\n      stableDebt,\n      variableDebt\n    );\n\n    uint256 paybackAmount = params.interestRateMode == DataTypes.InterestRateMode.STABLE\n      ? stableDebt\n      : variableDebt;\n\n    // Allows a user to repay with aTokens without leaving dust from interest.\n    if (params.useATokens && params.amount == type(uint256).max) {\n      params.amount = IAToken(reserveCache.aTokenAddress).balanceOf(msg.sender);\n    }\n\n    if (params.amount < paybackAmount) {\n      paybackAmount = params.amount;\n    }\n\n    if (params.interestRateMode == DataTypes.InterestRateMode.STABLE) {\n      (reserveCache.nextTotalStableDebt, reserveCache.nextAvgStableBorrowRate) = IStableDebtToken(\n        reserveCache.stableDebtTokenAddress\n      ).burn(params.onBehalfOf, paybackAmount);\n    } else {\n      reserveCache.nextScaledVariableDebt = IVariableDebtToken(\n        reserveCache.variableDebtTokenAddress\n      ).burn(params.onBehalfOf, paybackAmount, reserveCache.nextVariableBorrowIndex);\n    }\n\n    reserve.updateInterestRates(\n      reserveCache,\n      params.asset,\n      params.useATokens ? 0 : paybackAmount,\n      0\n    );\n\n    if (stableDebt + variableDebt - paybackAmount == 0) {\n      userConfig.setBorrowing(reserve.id, false);\n    }\n\n    IsolationModeLogic.updateIsolatedDebtIfIsolated(\n      reservesData,\n      reservesList,\n      userConfig,\n      reserveCache,\n      paybackAmount\n    );\n\n    if (params.useATokens) {\n      IAToken(reserveCache.aTokenAddress).burn(\n        msg.sender,\n        reserveCache.aTokenAddress,\n        paybackAmount,\n        reserveCache.nextLiquidityIndex\n      );\n    } else {\n      IERC20(params.asset).safeTransferFrom(msg.sender, reserveCache.aTokenAddress, paybackAmount);\n      IAToken(reserveCache.aTokenAddress).handleRepayment(\n        msg.sender,\n        params.onBehalfOf,\n        paybackAmount\n      );\n    }\n\n    emit Repay(params.asset, params.onBehalfOf, msg.sender, paybackAmount, params.useATokens);\n\n    return paybackAmount;\n  }\n\n  /**\n   * @notice Implements the rebalance stable borrow rate feature. In case of liquidity crunches on the protocol, stable\n   * rate borrows might need to be rebalanced to bring back equilibrium between the borrow and supply APYs.\n   * @dev The rules that define if a position can be rebalanced are implemented in `ValidationLogic.validateRebalanceStableBorrowRate()`\n   * @dev Emits the `RebalanceStableBorrowRate()` event\n   * @param reserve The state of the reserve of the asset being repaid\n   * @param asset The asset of the position being rebalanced\n   * @param user The user being rebalanced\n   */\n  function executeRebalanceStableBorrowRate(\n    DataTypes.ReserveData storage reserve,\n    address asset,\n    address user\n  ) external {\n    DataTypes.ReserveCache memory reserveCache = reserve.cache();\n    reserve.updateState(reserveCache);\n\n    ValidationLogic.validateRebalanceStableBorrowRate(reserve, reserveCache, asset);\n\n    IStableDebtToken stableDebtToken = IStableDebtToken(reserveCache.stableDebtTokenAddress);\n    uint256 stableDebt = IERC20(address(stableDebtToken)).balanceOf(user);\n\n    stableDebtToken.burn(user, stableDebt);\n\n    (, reserveCache.nextTotalStableDebt, reserveCache.nextAvgStableBorrowRate) = stableDebtToken\n      .mint(user, user, stableDebt, reserve.currentStableBorrowRate);\n\n    reserve.updateInterestRates(reserveCache, asset, 0, 0);\n\n    emit RebalanceStableBorrowRate(asset, user);\n  }\n\n  /**\n   * @notice Implements the swap borrow rate feature. Borrowers can swap from variable to stable positions at any time.\n   * @dev Emits the `Swap()` event\n   * @param reserve The of the reserve of the asset being repaid\n   * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n   * @param asset The asset of the position being swapped\n   * @param interestRateMode The current interest rate mode of the position being swapped\n   */\n  function executeSwapBorrowRateMode(\n    DataTypes.ReserveData storage reserve,\n    DataTypes.UserConfigurationMap storage userConfig,\n    address asset,\n    DataTypes.InterestRateMode interestRateMode\n  ) external {\n    DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n    reserve.updateState(reserveCache);\n\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(\n      msg.sender,\n      reserveCache\n    );\n\n    ValidationLogic.validateSwapRateMode(\n      reserve,\n      reserveCache,\n      userConfig,\n      stableDebt,\n      variableDebt,\n      interestRateMode\n    );\n\n    if (interestRateMode == DataTypes.InterestRateMode.STABLE) {\n      (reserveCache.nextTotalStableDebt, reserveCache.nextAvgStableBorrowRate) = IStableDebtToken(\n        reserveCache.stableDebtTokenAddress\n      ).burn(msg.sender, stableDebt);\n\n      (, reserveCache.nextScaledVariableDebt) = IVariableDebtToken(\n        reserveCache.variableDebtTokenAddress\n      ).mint(msg.sender, msg.sender, stableDebt, reserveCache.nextVariableBorrowIndex);\n    } else {\n      reserveCache.nextScaledVariableDebt = IVariableDebtToken(\n        reserveCache.variableDebtTokenAddress\n      ).burn(msg.sender, variableDebt, reserveCache.nextVariableBorrowIndex);\n\n      (, reserveCache.nextTotalStableDebt, reserveCache.nextAvgStableBorrowRate) = IStableDebtToken(\n        reserveCache.stableDebtTokenAddress\n      ).mint(msg.sender, msg.sender, variableDebt, reserve.currentStableBorrowRate);\n    }\n\n    reserve.updateInterestRates(reserveCache, asset, 0, 0);\n\n    emit SwapBorrowRateMode(asset, msg.sender, interestRateMode);\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/logic/BridgeLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {GPv2SafeERC20} from '../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {SafeCast} from '../../../dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {IAToken} from '../../../interfaces/IAToken.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {ValidationLogic} from './ValidationLogic.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\n\nlibrary BridgeLogic {\n  using ReserveLogic for DataTypes.ReserveCache;\n  using ReserveLogic for DataTypes.ReserveData;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeCast for uint256;\n  using GPv2SafeERC20 for IERC20;\n\n  // See `IPool` for descriptions\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @notice Mint unbacked aTokens to a user and updates the unbacked for the reserve.\n   * @dev Essentially a supply without transferring the underlying.\n   * @dev Emits the `MintUnbacked` event\n   * @dev Emits the `ReserveUsedAsCollateralEnabled` if asset is set as collateral\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n   * @param asset The address of the underlying asset to mint aTokens of\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function executeMintUnbacked(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    DataTypes.UserConfigurationMap storage userConfig,\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external {\n    DataTypes.ReserveData storage reserve = reservesData[asset];\n    DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n    reserve.updateState(reserveCache);\n\n    ValidationLogic.validateSupply(reserveCache, reserve, amount);\n\n    uint256 unbackedMintCap = reserveCache.reserveConfiguration.getUnbackedMintCap();\n    uint256 reserveDecimals = reserveCache.reserveConfiguration.getDecimals();\n\n    uint256 unbacked = reserve.unbacked += amount.toUint128();\n\n    require(unbacked <= unbackedMintCap * (10**reserveDecimals), Errors.UNBACKED_MINT_CAP_EXCEEDED);\n\n    reserve.updateInterestRates(reserveCache, asset, 0, 0);\n\n    bool isFirstSupply = IAToken(reserveCache.aTokenAddress).mint(\n      msg.sender,\n      onBehalfOf,\n      amount,\n      reserveCache.nextLiquidityIndex\n    );\n\n    if (isFirstSupply) {\n      if (\n        ValidationLogic.validateUseAsCollateral(\n          reservesData,\n          reservesList,\n          userConfig,\n          reserveCache.reserveConfiguration\n        )\n      ) {\n        userConfig.setUsingAsCollateral(reserve.id, true);\n        emit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\n      }\n    }\n\n    emit MintUnbacked(asset, msg.sender, onBehalfOf, amount, referralCode);\n  }\n\n  /**\n   * @notice Back the current unbacked with `amount` and pay `fee`.\n   * @dev It is not possible to back more than the existing unbacked amount of the reserve\n   * @dev Emits the `BackUnbacked` event\n   * @param reserve The reserve to back unbacked for\n   * @param asset The address of the underlying asset to repay\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @param protocolFeeBps The fraction of fees in basis points paid to the protocol\n   * @return The backed amount\n   */\n  function executeBackUnbacked(\n    DataTypes.ReserveData storage reserve,\n    address asset,\n    uint256 amount,\n    uint256 fee,\n    uint256 protocolFeeBps\n  ) external returns (uint256) {\n    DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n    reserve.updateState(reserveCache);\n\n    uint256 backingAmount = (amount < reserve.unbacked) ? amount : reserve.unbacked;\n\n    uint256 feeToProtocol = fee.percentMul(protocolFeeBps);\n    uint256 feeToLP = fee - feeToProtocol;\n    uint256 added = backingAmount + fee;\n\n    reserveCache.nextLiquidityIndex = reserve.cumulateToLiquidityIndex(\n      IERC20(reserveCache.aTokenAddress).totalSupply() +\n        uint256(reserve.accruedToTreasury).rayMul(reserveCache.nextLiquidityIndex),\n      feeToLP\n    );\n\n    reserve.accruedToTreasury += feeToProtocol.rayDiv(reserveCache.nextLiquidityIndex).toUint128();\n\n    reserve.unbacked -= backingAmount.toUint128();\n    reserve.updateInterestRates(reserveCache, asset, added, 0);\n\n    IERC20(asset).safeTransferFrom(msg.sender, reserveCache.aTokenAddress, added);\n\n    emit BackUnbacked(asset, msg.sender, backingAmount, fee);\n\n    return backingAmount;\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/logic/EModeLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {GPv2SafeERC20} from '../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IPriceOracleGetter} from '../../../interfaces/IPriceOracleGetter.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {ValidationLogic} from './ValidationLogic.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\n\n/**\n * @title EModeLogic library\n * @author Aave\n * @notice Implements the base logic for all the actions related to the eMode\n */\nlibrary EModeLogic {\n  using ReserveLogic for DataTypes.ReserveCache;\n  using ReserveLogic for DataTypes.ReserveData;\n  using GPv2SafeERC20 for IERC20;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n\n  // See `IPool` for descriptions\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @notice Updates the user efficiency mode category\n   * @dev Will revert if user is borrowing non-compatible asset or change will drop HF < HEALTH_FACTOR_LIQUIDATION_THRESHOLD\n   * @dev Emits the `UserEModeSet` event\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param usersEModeCategory The state of all users efficiency mode category\n   * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n   * @param params The additional parameters needed to execute the setUserEMode function\n   */\n  function executeSetUserEMode(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    mapping(address => uint8) storage usersEModeCategory,\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.ExecuteSetUserEModeParams memory params\n  ) external {\n    ValidationLogic.validateSetUserEMode(\n      reservesData,\n      reservesList,\n      eModeCategories,\n      userConfig,\n      params.reservesCount,\n      params.categoryId\n    );\n\n    uint8 prevCategoryId = usersEModeCategory[msg.sender];\n    usersEModeCategory[msg.sender] = params.categoryId;\n\n    if (prevCategoryId != 0) {\n      ValidationLogic.validateHealthFactor(\n        reservesData,\n        reservesList,\n        eModeCategories,\n        userConfig,\n        msg.sender,\n        params.categoryId,\n        params.reservesCount,\n        params.oracle\n      );\n    }\n    emit UserEModeSet(msg.sender, params.categoryId);\n  }\n\n  /**\n   * @notice Gets the eMode configuration and calculates the eMode asset price if a custom oracle is configured\n   * @dev The eMode asset price returned is 0 if no oracle is specified\n   * @param category The user eMode category\n   * @param oracle The price oracle\n   * @return The eMode ltv\n   * @return The eMode liquidation threshold\n   * @return The eMode asset price\n   */\n  function getEModeConfiguration(\n    DataTypes.EModeCategory storage category,\n    IPriceOracleGetter oracle\n  )\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 eModeAssetPrice = 0;\n    address eModePriceSource = category.priceSource;\n\n    if (eModePriceSource != address(0)) {\n      eModeAssetPrice = oracle.getAssetPrice(eModePriceSource);\n    }\n\n    return (category.ltv, category.liquidationThreshold, eModeAssetPrice);\n  }\n\n  /**\n   * @notice Checks if eMode is active for a user and if yes, if the asset belongs to the eMode category chosen\n   * @param eModeUserCategory The user eMode category\n   * @param eModeAssetCategory The asset eMode category\n   * @return True if eMode is active and the asset belongs to the eMode category chosen by the user, false otherwise\n   */\n  function isInEModeCategory(uint256 eModeUserCategory, uint256 eModeAssetCategory)\n    internal\n    pure\n    returns (bool)\n  {\n    return (eModeUserCategory != 0 && eModeAssetCategory == eModeUserCategory);\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/logic/FlashLoanLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {GPv2SafeERC20} from '../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {SafeCast} from '../../../dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IAToken} from '../../../interfaces/IAToken.sol';\nimport {IFlashLoanReceiver} from '../../../flashloan/interfaces/IFlashLoanReceiver.sol';\nimport {IFlashLoanSimpleReceiver} from '../../../flashloan/interfaces/IFlashLoanSimpleReceiver.sol';\nimport {IPoolAddressesProvider} from '../../../interfaces/IPoolAddressesProvider.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {ValidationLogic} from './ValidationLogic.sol';\nimport {BorrowLogic} from './BorrowLogic.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\n\n/**\n * @title FlashLoanLogic library\n * @author Aave\n * @notice Implements the logic for the flash loans\n */\nlibrary FlashLoanLogic {\n  using ReserveLogic for DataTypes.ReserveCache;\n  using ReserveLogic for DataTypes.ReserveData;\n  using GPv2SafeERC20 for IERC20;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeCast for uint256;\n\n  // See `IPool` for descriptions\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  // Helper struct for internal variables used in the `executeFlashLoan` function\n  struct FlashLoanLocalVars {\n    IFlashLoanReceiver receiver;\n    uint256 i;\n    address currentAsset;\n    uint256 currentAmount;\n    uint256[] totalPremiums;\n    uint256 flashloanPremiumTotal;\n    uint256 flashloanPremiumToProtocol;\n  }\n\n  /**\n   * @notice Implements the flashloan feature that allow users to access liquidity of the pool for one transaction\n   * as long as the amount taken plus fee is returned or debt is opened.\n   * @dev For authorized flashborrowers the fee is waived\n   * @dev At the end of the transaction the pool will pull amount borrowed + fee from the receiver,\n   * if the receiver have not approved the pool the transaction will revert.\n   * @dev Emits the `FlashLoan()` event\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n   * @param params The additional parameters needed to execute the flashloan function\n   */\n  function executeFlashLoan(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.FlashloanParams memory params\n  ) external {\n    // The usual action flow (cache -> updateState -> validation -> changeState -> updateRates)\n    // is altered to (validation -> user payload -> cache -> updateState -> changeState -> updateRates) for flashloans.\n    // This is done to protect against reentrance and rate manipulation within the user specified payload.\n\n    ValidationLogic.validateFlashloan(reservesData, params.assets, params.amounts);\n\n    FlashLoanLocalVars memory vars;\n\n    vars.totalPremiums = new uint256[](params.assets.length);\n\n    vars.receiver = IFlashLoanReceiver(params.receiverAddress);\n    (vars.flashloanPremiumTotal, vars.flashloanPremiumToProtocol) = params.isAuthorizedFlashBorrower\n      ? (0, 0)\n      : (params.flashLoanPremiumTotal, params.flashLoanPremiumToProtocol);\n\n    for (vars.i = 0; vars.i < params.assets.length; vars.i++) {\n      vars.currentAmount = params.amounts[vars.i];\n      vars.totalPremiums[vars.i] = vars.currentAmount.percentMul(vars.flashloanPremiumTotal);\n      IAToken(reservesData[params.assets[vars.i]].aTokenAddress).transferUnderlyingTo(\n        params.receiverAddress,\n        vars.currentAmount\n      );\n    }\n\n    require(\n      vars.receiver.executeOperation(\n        params.assets,\n        params.amounts,\n        vars.totalPremiums,\n        msg.sender,\n        params.params\n      ),\n      Errors.INVALID_FLASHLOAN_EXECUTOR_RETURN\n    );\n\n    for (vars.i = 0; vars.i < params.assets.length; vars.i++) {\n      vars.currentAsset = params.assets[vars.i];\n      vars.currentAmount = params.amounts[vars.i];\n\n      if (\n        DataTypes.InterestRateMode(params.interestRateModes[vars.i]) ==\n        DataTypes.InterestRateMode.NONE\n      ) {\n        _handleFlashLoanRepayment(\n          reservesData[vars.currentAsset],\n          DataTypes.FlashLoanRepaymentParams({\n            asset: vars.currentAsset,\n            receiverAddress: params.receiverAddress,\n            amount: vars.currentAmount,\n            totalPremium: vars.totalPremiums[vars.i],\n            flashLoanPremiumToProtocol: vars.flashloanPremiumToProtocol,\n            referralCode: params.referralCode\n          })\n        );\n      } else {\n        // If the user chose to not return the funds, the system checks if there is enough collateral and\n        // eventually opens a debt position\n        BorrowLogic.executeBorrow(\n          reservesData,\n          reservesList,\n          eModeCategories,\n          userConfig,\n          DataTypes.ExecuteBorrowParams({\n            asset: vars.currentAsset,\n            user: msg.sender,\n            onBehalfOf: params.onBehalfOf,\n            amount: vars.currentAmount,\n            interestRateMode: DataTypes.InterestRateMode(params.interestRateModes[vars.i]),\n            referralCode: params.referralCode,\n            releaseUnderlying: false,\n            maxStableRateBorrowSizePercent: params.maxStableRateBorrowSizePercent,\n            reservesCount: params.reservesCount,\n            oracle: IPoolAddressesProvider(params.addressesProvider).getPriceOracle(),\n            userEModeCategory: params.userEModeCategory,\n            priceOracleSentinel: IPoolAddressesProvider(params.addressesProvider)\n              .getPriceOracleSentinel()\n          })\n        );\n        // no premium is paid when taking on the flashloan as debt\n        emit FlashLoan(\n          params.receiverAddress,\n          msg.sender,\n          vars.currentAsset,\n          vars.currentAmount,\n          DataTypes.InterestRateMode(params.interestRateModes[vars.i]),\n          0,\n          params.referralCode\n        );\n      }\n    }\n  }\n\n  /**\n   * @notice Implements the simple flashloan feature that allow users to access liquidity of ONE reserve for one\n   * transaction as long as the amount taken plus fee is returned.\n   * @dev Does not waive fee for approved flashborrowers nor allow taking on debt instead of repaying to save gas\n   * @dev At the end of the transaction the pool will pull amount borrowed + fee from the receiver,\n   * if the receiver have not approved the pool the transaction will revert.\n   * @dev Emits the `FlashLoan()` event\n   * @param reserve The state of the flashloaned reserve\n   * @param params The additional parameters needed to execute the simple flashloan function\n   */\n  function executeFlashLoanSimple(\n    DataTypes.ReserveData storage reserve,\n    DataTypes.FlashloanSimpleParams memory params\n  ) external {\n    // The usual action flow (cache -> updateState -> validation -> changeState -> updateRates)\n    // is altered to (validation -> user payload -> cache -> updateState -> changeState -> updateRates) for flashloans.\n    // This is done to protect against reentrance and rate manipulation within the user specified payload.\n\n    ValidationLogic.validateFlashloanSimple(reserve);\n\n    IFlashLoanSimpleReceiver receiver = IFlashLoanSimpleReceiver(params.receiverAddress);\n    uint256 totalPremium = params.amount.percentMul(params.flashLoanPremiumTotal);\n    IAToken(reserve.aTokenAddress).transferUnderlyingTo(params.receiverAddress, params.amount);\n\n    require(\n      receiver.executeOperation(\n        params.asset,\n        params.amount,\n        totalPremium,\n        msg.sender,\n        params.params\n      ),\n      Errors.INVALID_FLASHLOAN_EXECUTOR_RETURN\n    );\n\n    _handleFlashLoanRepayment(\n      reserve,\n      DataTypes.FlashLoanRepaymentParams({\n        asset: params.asset,\n        receiverAddress: params.receiverAddress,\n        amount: params.amount,\n        totalPremium: totalPremium,\n        flashLoanPremiumToProtocol: params.flashLoanPremiumToProtocol,\n        referralCode: params.referralCode\n      })\n    );\n  }\n\n  /**\n   * @notice Handles repayment of flashloaned assets + premium\n   * @dev Will pull the amount + premium from the receiver, so must have approved pool\n   * @param reserve The state of the flashloaned reserve\n   * @param params The additional parameters needed to execute the repayment function\n   */\n  function _handleFlashLoanRepayment(\n    DataTypes.ReserveData storage reserve,\n    DataTypes.FlashLoanRepaymentParams memory params\n  ) internal {\n    uint256 premiumToProtocol = params.totalPremium.percentMul(params.flashLoanPremiumToProtocol);\n    uint256 premiumToLP = params.totalPremium - premiumToProtocol;\n    uint256 amountPlusPremium = params.amount + params.totalPremium;\n\n    DataTypes.ReserveCache memory reserveCache = reserve.cache();\n    reserve.updateState(reserveCache);\n    reserveCache.nextLiquidityIndex = reserve.cumulateToLiquidityIndex(\n      IERC20(reserveCache.aTokenAddress).totalSupply() +\n        uint256(reserve.accruedToTreasury).rayMul(reserveCache.nextLiquidityIndex),\n      premiumToLP\n    );\n\n    reserve.accruedToTreasury += premiumToProtocol\n      .rayDiv(reserveCache.nextLiquidityIndex)\n      .toUint128();\n\n    reserve.updateInterestRates(reserveCache, params.asset, amountPlusPremium, 0);\n\n    IERC20(params.asset).safeTransferFrom(\n      params.receiverAddress,\n      reserveCache.aTokenAddress,\n      amountPlusPremium\n    );\n\n    IAToken(reserveCache.aTokenAddress).handleRepayment(\n      params.receiverAddress,\n      params.receiverAddress,\n      amountPlusPremium\n    );\n\n    emit FlashLoan(\n      params.receiverAddress,\n      msg.sender,\n      params.asset,\n      params.amount,\n      DataTypes.InterestRateMode(0),\n      params.totalPremium,\n      params.referralCode\n    );\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/logic/GenericLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IScaledBalanceToken} from '../../../interfaces/IScaledBalanceToken.sol';\nimport {IPriceOracleGetter} from '../../../interfaces/IPriceOracleGetter.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {EModeLogic} from './EModeLogic.sol';\n\n/**\n * @title GenericLogic library\n * @author Aave\n * @notice Implements protocol-level logic to calculate and validate the state of a user\n */\nlibrary GenericLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n\n  struct CalculateUserAccountDataVars {\n    uint256 assetPrice;\n    uint256 assetUnit;\n    uint256 userBalanceInBaseCurrency;\n    uint256 decimals;\n    uint256 ltv;\n    uint256 liquidationThreshold;\n    uint256 i;\n    uint256 healthFactor;\n    uint256 totalCollateralInBaseCurrency;\n    uint256 totalDebtInBaseCurrency;\n    uint256 avgLtv;\n    uint256 avgLiquidationThreshold;\n    uint256 eModeAssetPrice;\n    uint256 eModeLtv;\n    uint256 eModeLiqThreshold;\n    uint256 eModeAssetCategory;\n    address currentReserveAddress;\n    bool hasZeroLtvCollateral;\n    bool isInEModeCategory;\n  }\n\n  /**\n   * @notice Calculates the user data across the reserves.\n   * @dev It includes the total liquidity/collateral/borrow balances in the base currency used by the price feed,\n   * the average Loan To Value, the average Liquidation Ratio, and the Health factor.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param params Additional parameters needed for the calculation\n   * @return The total collateral of the user in the base currency used by the price feed\n   * @return The total debt of the user in the base currency used by the price feed\n   * @return The average ltv of the user\n   * @return The average liquidation threshold of the user\n   * @return The health factor of the user\n   * @return True if the ltv is zero, false otherwise\n   */\n  function calculateUserAccountData(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.CalculateUserAccountDataParams memory params\n  )\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256,\n      uint256,\n      bool\n    )\n  {\n    if (params.userConfig.isEmpty()) {\n      return (0, 0, 0, 0, type(uint256).max, false);\n    }\n\n    CalculateUserAccountDataVars memory vars;\n\n    if (params.userEModeCategory != 0) {\n      (vars.eModeLtv, vars.eModeLiqThreshold, vars.eModeAssetPrice) = EModeLogic\n        .getEModeConfiguration(\n          eModeCategories[params.userEModeCategory],\n          IPriceOracleGetter(params.oracle)\n        );\n    }\n\n    while (vars.i < params.reservesCount) {\n      if (!params.userConfig.isUsingAsCollateralOrBorrowing(vars.i)) {\n        unchecked {\n          ++vars.i;\n        }\n        continue;\n      }\n\n      vars.currentReserveAddress = reservesList[vars.i];\n\n      if (vars.currentReserveAddress == address(0)) {\n        unchecked {\n          ++vars.i;\n        }\n        continue;\n      }\n\n      DataTypes.ReserveData storage currentReserve = reservesData[vars.currentReserveAddress];\n\n      (\n        vars.ltv,\n        vars.liquidationThreshold,\n        ,\n        vars.decimals,\n        ,\n        vars.eModeAssetCategory\n      ) = currentReserve.configuration.getParams();\n\n      unchecked {\n        vars.assetUnit = 10**vars.decimals;\n      }\n\n      vars.assetPrice = vars.eModeAssetPrice != 0 &&\n        params.userEModeCategory == vars.eModeAssetCategory\n        ? vars.eModeAssetPrice\n        : IPriceOracleGetter(params.oracle).getAssetPrice(vars.currentReserveAddress);\n\n      if (vars.liquidationThreshold != 0 && params.userConfig.isUsingAsCollateral(vars.i)) {\n        vars.userBalanceInBaseCurrency = _getUserBalanceInBaseCurrency(\n          params.user,\n          currentReserve,\n          vars.assetPrice,\n          vars.assetUnit\n        );\n\n        vars.totalCollateralInBaseCurrency += vars.userBalanceInBaseCurrency;\n\n        vars.isInEModeCategory = EModeLogic.isInEModeCategory(\n          params.userEModeCategory,\n          vars.eModeAssetCategory\n        );\n\n        if (vars.ltv != 0) {\n          vars.avgLtv +=\n            vars.userBalanceInBaseCurrency *\n            (vars.isInEModeCategory ? vars.eModeLtv : vars.ltv);\n        } else {\n          vars.hasZeroLtvCollateral = true;\n        }\n\n        vars.avgLiquidationThreshold +=\n          vars.userBalanceInBaseCurrency *\n          (vars.isInEModeCategory ? vars.eModeLiqThreshold : vars.liquidationThreshold);\n      }\n\n      if (params.userConfig.isBorrowing(vars.i)) {\n        vars.totalDebtInBaseCurrency += _getUserDebtInBaseCurrency(\n          params.user,\n          currentReserve,\n          vars.assetPrice,\n          vars.assetUnit\n        );\n      }\n\n      unchecked {\n        ++vars.i;\n      }\n    }\n\n    unchecked {\n      vars.avgLtv = vars.totalCollateralInBaseCurrency != 0\n        ? vars.avgLtv / vars.totalCollateralInBaseCurrency\n        : 0;\n      vars.avgLiquidationThreshold = vars.totalCollateralInBaseCurrency != 0\n        ? vars.avgLiquidationThreshold / vars.totalCollateralInBaseCurrency\n        : 0;\n    }\n\n    vars.healthFactor = (vars.totalDebtInBaseCurrency == 0)\n      ? type(uint256).max\n      : (vars.totalCollateralInBaseCurrency.percentMul(vars.avgLiquidationThreshold)).wadDiv(\n        vars.totalDebtInBaseCurrency\n      );\n    return (\n      vars.totalCollateralInBaseCurrency,\n      vars.totalDebtInBaseCurrency,\n      vars.avgLtv,\n      vars.avgLiquidationThreshold,\n      vars.healthFactor,\n      vars.hasZeroLtvCollateral\n    );\n  }\n\n  /**\n   * @notice Calculates the maximum amount that can be borrowed depending on the available collateral, the total debt\n   * and the average Loan To Value\n   * @param totalCollateralInBaseCurrency The total collateral in the base currency used by the price feed\n   * @param totalDebtInBaseCurrency The total borrow balance in the base currency used by the price feed\n   * @param ltv The average loan to value\n   * @return The amount available to borrow in the base currency of the used by the price feed\n   */\n  function calculateAvailableBorrows(\n    uint256 totalCollateralInBaseCurrency,\n    uint256 totalDebtInBaseCurrency,\n    uint256 ltv\n  ) internal pure returns (uint256) {\n    uint256 availableBorrowsInBaseCurrency = totalCollateralInBaseCurrency.percentMul(ltv);\n\n    if (availableBorrowsInBaseCurrency < totalDebtInBaseCurrency) {\n      return 0;\n    }\n\n    availableBorrowsInBaseCurrency = availableBorrowsInBaseCurrency - totalDebtInBaseCurrency;\n    return availableBorrowsInBaseCurrency;\n  }\n\n  /**\n   * @notice Calculates total debt of the user in the based currency used to normalize the values of the assets\n   * @dev This fetches the `balanceOf` of the stable and variable debt tokens for the user. For gas reasons, the\n   * variable debt balance is calculated by fetching `scaledBalancesOf` normalized debt, which is cheaper than\n   * fetching `balanceOf`\n   * @param user The address of the user\n   * @param reserve The data of the reserve for which the total debt of the user is being calculated\n   * @param assetPrice The price of the asset for which the total debt of the user is being calculated\n   * @param assetUnit The value representing one full unit of the asset (10^decimals)\n   * @return The total debt of the user normalized to the base currency\n   */\n  function _getUserDebtInBaseCurrency(\n    address user,\n    DataTypes.ReserveData storage reserve,\n    uint256 assetPrice,\n    uint256 assetUnit\n  ) private view returns (uint256) {\n    // fetching variable debt\n    uint256 userTotalDebt = IScaledBalanceToken(reserve.variableDebtTokenAddress).scaledBalanceOf(\n      user\n    );\n    if (userTotalDebt != 0) {\n      userTotalDebt = userTotalDebt.rayMul(reserve.getNormalizedDebt());\n    }\n\n    userTotalDebt = userTotalDebt + IERC20(reserve.stableDebtTokenAddress).balanceOf(user);\n\n    userTotalDebt = assetPrice * userTotalDebt;\n\n    unchecked {\n      return userTotalDebt / assetUnit;\n    }\n  }\n\n  /**\n   * @notice Calculates total aToken balance of the user in the based currency used by the price oracle\n   * @dev For gas reasons, the aToken balance is calculated by fetching `scaledBalancesOf` normalized debt, which\n   * is cheaper than fetching `balanceOf`\n   * @param user The address of the user\n   * @param reserve The data of the reserve for which the total aToken balance of the user is being calculated\n   * @param assetPrice The price of the asset for which the total aToken balance of the user is being calculated\n   * @param assetUnit The value representing one full unit of the asset (10^decimals)\n   * @return The total aToken balance of the user normalized to the base currency of the price oracle\n   */\n  function _getUserBalanceInBaseCurrency(\n    address user,\n    DataTypes.ReserveData storage reserve,\n    uint256 assetPrice,\n    uint256 assetUnit\n  ) private view returns (uint256) {\n    uint256 normalizedIncome = reserve.getNormalizedIncome();\n    uint256 balance = (\n      IScaledBalanceToken(reserve.aTokenAddress).scaledBalanceOf(user).rayMul(normalizedIncome)\n    ) * assetPrice;\n\n    unchecked {\n      return balance / assetUnit;\n    }\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/logic/IsolationModeLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {SafeCast} from '../../../dependencies/openzeppelin/contracts/SafeCast.sol';\n\n/**\n * @title IsolationModeLogic library\n * @author Aave\n * @notice Implements the base logic for handling repayments for assets borrowed in isolation mode\n */\nlibrary IsolationModeLogic {\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n  using SafeCast for uint256;\n\n  // See `IPool` for descriptions\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @notice updated the isolated debt whenever a position collateralized by an isolated asset is repaid or liquidated\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param userConfig The user configuration mapping\n   * @param reserveCache The cached data of the reserve\n   * @param repayAmount The amount being repaid\n   */\n  function updateIsolatedDebtIfIsolated(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.ReserveCache memory reserveCache,\n    uint256 repayAmount\n  ) internal {\n    (bool isolationModeActive, address isolationModeCollateralAddress, ) = userConfig\n      .getIsolationModeState(reservesData, reservesList);\n\n    if (isolationModeActive) {\n      uint128 isolationModeTotalDebt = reservesData[isolationModeCollateralAddress]\n        .isolationModeTotalDebt;\n\n      uint128 isolatedDebtRepaid = (repayAmount /\n        10 **\n          (reserveCache.reserveConfiguration.getDecimals() -\n            ReserveConfiguration.DEBT_CEILING_DECIMALS)).toUint128();\n\n      // since the debt ceiling does not take into account the interest accrued, it might happen that amount\n      // repaid > debt in isolation mode\n      if (isolationModeTotalDebt <= isolatedDebtRepaid) {\n        reservesData[isolationModeCollateralAddress].isolationModeTotalDebt = 0;\n        emit IsolationModeTotalDebtUpdated(isolationModeCollateralAddress, 0);\n      } else {\n        uint256 nextIsolationModeTotalDebt = reservesData[isolationModeCollateralAddress]\n          .isolationModeTotalDebt = isolationModeTotalDebt - isolatedDebtRepaid;\n        emit IsolationModeTotalDebtUpdated(\n          isolationModeCollateralAddress,\n          nextIsolationModeTotalDebt\n        );\n      }\n    }\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/logic/LiquidationLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts//IERC20.sol';\nimport {GPv2SafeERC20} from '../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {PercentageMath} from '../../libraries/math/PercentageMath.sol';\nimport {WadRayMath} from '../../libraries/math/WadRayMath.sol';\nimport {Helpers} from '../../libraries/helpers/Helpers.sol';\nimport {DataTypes} from '../../libraries/types/DataTypes.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {ValidationLogic} from './ValidationLogic.sol';\nimport {GenericLogic} from './GenericLogic.sol';\nimport {IsolationModeLogic} from './IsolationModeLogic.sol';\nimport {EModeLogic} from './EModeLogic.sol';\nimport {UserConfiguration} from '../../libraries/configuration/UserConfiguration.sol';\nimport {ReserveConfiguration} from '../../libraries/configuration/ReserveConfiguration.sol';\nimport {IAToken} from '../../../interfaces/IAToken.sol';\nimport {IStableDebtToken} from '../../../interfaces/IStableDebtToken.sol';\nimport {IVariableDebtToken} from '../../../interfaces/IVariableDebtToken.sol';\nimport {IPriceOracleGetter} from '../../../interfaces/IPriceOracleGetter.sol';\n\n/**\n * @title LiquidationLogic library\n * @author Aave\n * @notice Implements actions involving management of collateral in the protocol, the main one being the liquidations\n */\nlibrary LiquidationLogic {\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using ReserveLogic for DataTypes.ReserveCache;\n  using ReserveLogic for DataTypes.ReserveData;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using GPv2SafeERC20 for IERC20;\n\n  // See `IPool` for descriptions\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Default percentage of borrower's debt to be repaid in a liquidation.\n   * @dev Percentage applied when the users health factor is above `CLOSE_FACTOR_HF_THRESHOLD`\n   * Expressed in bps, a value of 0.5e4 results in 50.00%\n   */\n  uint256 internal constant DEFAULT_LIQUIDATION_CLOSE_FACTOR = 0.5e4;\n\n  /**\n   * @dev Maximum percentage of borrower's debt to be repaid in a liquidation\n   * @dev Percentage applied when the users health factor is below `CLOSE_FACTOR_HF_THRESHOLD`\n   * Expressed in bps, a value of 1e4 results in 100.00%\n   */\n  uint256 public constant MAX_LIQUIDATION_CLOSE_FACTOR = 1e4;\n\n  /**\n   * @dev This constant represents below which health factor value it is possible to liquidate\n   * an amount of debt corresponding to `MAX_LIQUIDATION_CLOSE_FACTOR`.\n   * A value of 0.95e18 results in 0.95\n   */\n  uint256 public constant CLOSE_FACTOR_HF_THRESHOLD = 0.95e18;\n\n  struct LiquidationCallLocalVars {\n    uint256 userCollateralBalance;\n    uint256 userVariableDebt;\n    uint256 userTotalDebt;\n    uint256 actualDebtToLiquidate;\n    uint256 actualCollateralToLiquidate;\n    uint256 liquidationBonus;\n    uint256 healthFactor;\n    uint256 liquidationProtocolFeeAmount;\n    address collateralPriceSource;\n    address debtPriceSource;\n    IAToken collateralAToken;\n    DataTypes.ReserveCache debtReserveCache;\n  }\n\n  /**\n   * @notice Function to liquidate a position if its Health Factor drops below 1. The caller (liquidator)\n   * covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   * a proportional amount of the `collateralAsset` plus a bonus to cover market risk\n   * @dev Emits the `LiquidationCall()` event\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param usersConfig The users configuration mapping that track the supplied/borrowed assets\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param params The additional parameters needed to execute the liquidation function\n   */\n  function executeLiquidationCall(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.ExecuteLiquidationCallParams memory params\n  ) external {\n    LiquidationCallLocalVars memory vars;\n\n    DataTypes.ReserveData storage collateralReserve = reservesData[params.collateralAsset];\n    DataTypes.ReserveData storage debtReserve = reservesData[params.debtAsset];\n    DataTypes.UserConfigurationMap storage userConfig = usersConfig[params.user];\n    vars.debtReserveCache = debtReserve.cache();\n    debtReserve.updateState(vars.debtReserveCache);\n\n    (, , , , vars.healthFactor, ) = GenericLogic.calculateUserAccountData(\n      reservesData,\n      reservesList,\n      eModeCategories,\n      DataTypes.CalculateUserAccountDataParams({\n        userConfig: userConfig,\n        reservesCount: params.reservesCount,\n        user: params.user,\n        oracle: params.priceOracle,\n        userEModeCategory: params.userEModeCategory\n      })\n    );\n\n    (vars.userVariableDebt, vars.userTotalDebt, vars.actualDebtToLiquidate) = _calculateDebt(\n      vars.debtReserveCache,\n      params,\n      vars.healthFactor\n    );\n\n    ValidationLogic.validateLiquidationCall(\n      userConfig,\n      collateralReserve,\n      DataTypes.ValidateLiquidationCallParams({\n        debtReserveCache: vars.debtReserveCache,\n        totalDebt: vars.userTotalDebt,\n        healthFactor: vars.healthFactor,\n        priceOracleSentinel: params.priceOracleSentinel\n      })\n    );\n\n    (\n      vars.collateralAToken,\n      vars.collateralPriceSource,\n      vars.debtPriceSource,\n      vars.liquidationBonus\n    ) = _getConfigurationData(eModeCategories, collateralReserve, params);\n\n    vars.userCollateralBalance = vars.collateralAToken.balanceOf(params.user);\n\n    (\n      vars.actualCollateralToLiquidate,\n      vars.actualDebtToLiquidate,\n      vars.liquidationProtocolFeeAmount\n    ) = _calculateAvailableCollateralToLiquidate(\n      collateralReserve,\n      vars.debtReserveCache,\n      vars.collateralPriceSource,\n      vars.debtPriceSource,\n      vars.actualDebtToLiquidate,\n      vars.userCollateralBalance,\n      vars.liquidationBonus,\n      IPriceOracleGetter(params.priceOracle)\n    );\n\n    if (vars.userTotalDebt == vars.actualDebtToLiquidate) {\n      userConfig.setBorrowing(debtReserve.id, false);\n    }\n\n    // If the collateral being liquidated is equal to the user balance,\n    // we set the currency as not being used as collateral anymore\n    if (\n      vars.actualCollateralToLiquidate + vars.liquidationProtocolFeeAmount ==\n      vars.userCollateralBalance\n    ) {\n      userConfig.setUsingAsCollateral(collateralReserve.id, false);\n      emit ReserveUsedAsCollateralDisabled(params.collateralAsset, params.user);\n    }\n\n    _burnDebtTokens(params, vars);\n\n    debtReserve.updateInterestRates(\n      vars.debtReserveCache,\n      params.debtAsset,\n      vars.actualDebtToLiquidate,\n      0\n    );\n\n    IsolationModeLogic.updateIsolatedDebtIfIsolated(\n      reservesData,\n      reservesList,\n      userConfig,\n      vars.debtReserveCache,\n      vars.actualDebtToLiquidate\n    );\n\n    if (params.receiveAToken) {\n      _liquidateATokens(reservesData, reservesList, usersConfig, collateralReserve, params, vars);\n    } else {\n      _burnCollateralATokens(collateralReserve, params, vars);\n    }\n\n    // Transfer fee to treasury if it is non-zero\n    if (vars.liquidationProtocolFeeAmount != 0) {\n      uint256 liquidityIndex = collateralReserve.getNormalizedIncome();\n      uint256 scaledDownLiquidationProtocolFee = vars.liquidationProtocolFeeAmount.rayDiv(\n        liquidityIndex\n      );\n      uint256 scaledDownUserBalance = vars.collateralAToken.scaledBalanceOf(params.user);\n      // To avoid trying to send more aTokens than available on balance, due to 1 wei imprecision\n      if (scaledDownLiquidationProtocolFee > scaledDownUserBalance) {\n        vars.liquidationProtocolFeeAmount = scaledDownUserBalance.rayMul(liquidityIndex);\n      }\n      vars.collateralAToken.transferOnLiquidation(\n        params.user,\n        vars.collateralAToken.RESERVE_TREASURY_ADDRESS(),\n        vars.liquidationProtocolFeeAmount\n      );\n    }\n\n    // Transfers the debt asset being repaid to the aToken, where the liquidity is kept\n    IERC20(params.debtAsset).safeTransferFrom(\n      msg.sender,\n      vars.debtReserveCache.aTokenAddress,\n      vars.actualDebtToLiquidate\n    );\n\n    IAToken(vars.debtReserveCache.aTokenAddress).handleRepayment(\n      msg.sender,\n      params.user,\n      vars.actualDebtToLiquidate\n    );\n\n    emit LiquidationCall(\n      params.collateralAsset,\n      params.debtAsset,\n      params.user,\n      vars.actualDebtToLiquidate,\n      vars.actualCollateralToLiquidate,\n      msg.sender,\n      params.receiveAToken\n    );\n  }\n\n  /**\n   * @notice Burns the collateral aTokens and transfers the underlying to the liquidator.\n   * @dev   The function also updates the state and the interest rate of the collateral reserve.\n   * @param collateralReserve The data of the collateral reserve\n   * @param params The additional parameters needed to execute the liquidation function\n   * @param vars The executeLiquidationCall() function local vars\n   */\n  function _burnCollateralATokens(\n    DataTypes.ReserveData storage collateralReserve,\n    DataTypes.ExecuteLiquidationCallParams memory params,\n    LiquidationCallLocalVars memory vars\n  ) internal {\n    DataTypes.ReserveCache memory collateralReserveCache = collateralReserve.cache();\n    collateralReserve.updateState(collateralReserveCache);\n    collateralReserve.updateInterestRates(\n      collateralReserveCache,\n      params.collateralAsset,\n      0,\n      vars.actualCollateralToLiquidate\n    );\n\n    // Burn the equivalent amount of aToken, sending the underlying to the liquidator\n    vars.collateralAToken.burn(\n      params.user,\n      msg.sender,\n      vars.actualCollateralToLiquidate,\n      collateralReserveCache.nextLiquidityIndex\n    );\n  }\n\n  /**\n   * @notice Liquidates the user aTokens by transferring them to the liquidator.\n   * @dev   The function also checks the state of the liquidator and activates the aToken as collateral\n   *        as in standard transfers if the isolation mode constraints are respected.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param usersConfig The users configuration mapping that track the supplied/borrowed assets\n   * @param collateralReserve The data of the collateral reserve\n   * @param params The additional parameters needed to execute the liquidation function\n   * @param vars The executeLiquidationCall() function local vars\n   */\n  function _liquidateATokens(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,\n    DataTypes.ReserveData storage collateralReserve,\n    DataTypes.ExecuteLiquidationCallParams memory params,\n    LiquidationCallLocalVars memory vars\n  ) internal {\n    uint256 liquidatorPreviousATokenBalance = IERC20(vars.collateralAToken).balanceOf(msg.sender);\n    vars.collateralAToken.transferOnLiquidation(\n      params.user,\n      msg.sender,\n      vars.actualCollateralToLiquidate\n    );\n\n    if (liquidatorPreviousATokenBalance == 0) {\n      DataTypes.UserConfigurationMap storage liquidatorConfig = usersConfig[msg.sender];\n      if (\n        ValidationLogic.validateUseAsCollateral(\n          reservesData,\n          reservesList,\n          liquidatorConfig,\n          collateralReserve.configuration\n        )\n      ) {\n        liquidatorConfig.setUsingAsCollateral(collateralReserve.id, true);\n        emit ReserveUsedAsCollateralEnabled(params.collateralAsset, msg.sender);\n      }\n    }\n  }\n\n  /**\n   * @notice Burns the debt tokens of the user up to the amount being repaid by the liquidator.\n   * @dev The function alters the `debtReserveCache` state in `vars` to update the debt related data.\n   * @param params The additional parameters needed to execute the liquidation function\n   * @param vars the executeLiquidationCall() function local vars\n   */\n  function _burnDebtTokens(\n    DataTypes.ExecuteLiquidationCallParams memory params,\n    LiquidationCallLocalVars memory vars\n  ) internal {\n    if (vars.userVariableDebt >= vars.actualDebtToLiquidate) {\n      vars.debtReserveCache.nextScaledVariableDebt = IVariableDebtToken(\n        vars.debtReserveCache.variableDebtTokenAddress\n      ).burn(\n          params.user,\n          vars.actualDebtToLiquidate,\n          vars.debtReserveCache.nextVariableBorrowIndex\n        );\n    } else {\n      // If the user doesn't have variable debt, no need to try to burn variable debt tokens\n      if (vars.userVariableDebt != 0) {\n        vars.debtReserveCache.nextScaledVariableDebt = IVariableDebtToken(\n          vars.debtReserveCache.variableDebtTokenAddress\n        ).burn(params.user, vars.userVariableDebt, vars.debtReserveCache.nextVariableBorrowIndex);\n      }\n      (\n        vars.debtReserveCache.nextTotalStableDebt,\n        vars.debtReserveCache.nextAvgStableBorrowRate\n      ) = IStableDebtToken(vars.debtReserveCache.stableDebtTokenAddress).burn(\n        params.user,\n        vars.actualDebtToLiquidate - vars.userVariableDebt\n      );\n    }\n  }\n\n  /**\n   * @notice Calculates the total debt of the user and the actual amount to liquidate depending on the health factor\n   * and corresponding close factor.\n   * @dev If the Health Factor is below CLOSE_FACTOR_HF_THRESHOLD, the close factor is increased to MAX_LIQUIDATION_CLOSE_FACTOR\n   * @param debtReserveCache The reserve cache data object of the debt reserve\n   * @param params The additional parameters needed to execute the liquidation function\n   * @param healthFactor The health factor of the position\n   * @return The variable debt of the user\n   * @return The total debt of the user\n   * @return The actual debt to liquidate as a function of the closeFactor\n   */\n  function _calculateDebt(\n    DataTypes.ReserveCache memory debtReserveCache,\n    DataTypes.ExecuteLiquidationCallParams memory params,\n    uint256 healthFactor\n  )\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    (uint256 userStableDebt, uint256 userVariableDebt) = Helpers.getUserCurrentDebt(\n      params.user,\n      debtReserveCache\n    );\n\n    uint256 userTotalDebt = userStableDebt + userVariableDebt;\n\n    uint256 closeFactor = healthFactor > CLOSE_FACTOR_HF_THRESHOLD\n      ? DEFAULT_LIQUIDATION_CLOSE_FACTOR\n      : MAX_LIQUIDATION_CLOSE_FACTOR;\n\n    uint256 maxLiquidatableDebt = userTotalDebt.percentMul(closeFactor);\n\n    uint256 actualDebtToLiquidate = params.debtToCover > maxLiquidatableDebt\n      ? maxLiquidatableDebt\n      : params.debtToCover;\n\n    return (userVariableDebt, userTotalDebt, actualDebtToLiquidate);\n  }\n\n  /**\n   * @notice Returns the configuration data for the debt and the collateral reserves.\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param collateralReserve The data of the collateral reserve\n   * @param params The additional parameters needed to execute the liquidation function\n   * @return The collateral aToken\n   * @return The address to use as price source for the collateral\n   * @return The address to use as price source for the debt\n   * @return The liquidation bonus to apply to the collateral\n   */\n  function _getConfigurationData(\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.ReserveData storage collateralReserve,\n    DataTypes.ExecuteLiquidationCallParams memory params\n  )\n    internal\n    view\n    returns (\n      IAToken,\n      address,\n      address,\n      uint256\n    )\n  {\n    IAToken collateralAToken = IAToken(collateralReserve.aTokenAddress);\n    uint256 liquidationBonus = collateralReserve.configuration.getLiquidationBonus();\n\n    address collateralPriceSource = params.collateralAsset;\n    address debtPriceSource = params.debtAsset;\n\n    if (params.userEModeCategory != 0) {\n      address eModePriceSource = eModeCategories[params.userEModeCategory].priceSource;\n\n      if (\n        EModeLogic.isInEModeCategory(\n          params.userEModeCategory,\n          collateralReserve.configuration.getEModeCategory()\n        )\n      ) {\n        liquidationBonus = eModeCategories[params.userEModeCategory].liquidationBonus;\n\n        if (eModePriceSource != address(0)) {\n          collateralPriceSource = eModePriceSource;\n        }\n      }\n\n      // when in eMode, debt will always be in the same eMode category, can skip matching category check\n      if (eModePriceSource != address(0)) {\n        debtPriceSource = eModePriceSource;\n      }\n    }\n\n    return (collateralAToken, collateralPriceSource, debtPriceSource, liquidationBonus);\n  }\n\n  struct AvailableCollateralToLiquidateLocalVars {\n    uint256 collateralPrice;\n    uint256 debtAssetPrice;\n    uint256 maxCollateralToLiquidate;\n    uint256 baseCollateral;\n    uint256 bonusCollateral;\n    uint256 debtAssetDecimals;\n    uint256 collateralDecimals;\n    uint256 collateralAssetUnit;\n    uint256 debtAssetUnit;\n    uint256 collateralAmount;\n    uint256 debtAmountNeeded;\n    uint256 liquidationProtocolFeePercentage;\n    uint256 liquidationProtocolFee;\n  }\n\n  /**\n   * @notice Calculates how much of a specific collateral can be liquidated, given\n   * a certain amount of debt asset.\n   * @dev This function needs to be called after all the checks to validate the liquidation have been performed,\n   *   otherwise it might fail.\n   * @param collateralReserve The data of the collateral reserve\n   * @param debtReserveCache The cached data of the debt reserve\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param userCollateralBalance The collateral balance for the specific `collateralAsset` of the user being liquidated\n   * @param liquidationBonus The collateral bonus percentage to receive as result of the liquidation\n   * @return The maximum amount that is possible to liquidate given all the liquidation constraints (user balance, close factor)\n   * @return The amount to repay with the liquidation\n   * @return The fee taken from the liquidation bonus amount to be paid to the protocol\n   */\n  function _calculateAvailableCollateralToLiquidate(\n    DataTypes.ReserveData storage collateralReserve,\n    DataTypes.ReserveCache memory debtReserveCache,\n    address collateralAsset,\n    address debtAsset,\n    uint256 debtToCover,\n    uint256 userCollateralBalance,\n    uint256 liquidationBonus,\n    IPriceOracleGetter oracle\n  )\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    AvailableCollateralToLiquidateLocalVars memory vars;\n\n    vars.collateralPrice = oracle.getAssetPrice(collateralAsset);\n    vars.debtAssetPrice = oracle.getAssetPrice(debtAsset);\n\n    vars.collateralDecimals = collateralReserve.configuration.getDecimals();\n    vars.debtAssetDecimals = debtReserveCache.reserveConfiguration.getDecimals();\n\n    unchecked {\n      vars.collateralAssetUnit = 10**vars.collateralDecimals;\n      vars.debtAssetUnit = 10**vars.debtAssetDecimals;\n    }\n\n    vars.liquidationProtocolFeePercentage = collateralReserve\n      .configuration\n      .getLiquidationProtocolFee();\n\n    // This is the base collateral to liquidate based on the given debt to cover\n    vars.baseCollateral =\n      ((vars.debtAssetPrice * debtToCover * vars.collateralAssetUnit)) /\n      (vars.collateralPrice * vars.debtAssetUnit);\n\n    vars.maxCollateralToLiquidate = vars.baseCollateral.percentMul(liquidationBonus);\n\n    if (vars.maxCollateralToLiquidate > userCollateralBalance) {\n      vars.collateralAmount = userCollateralBalance;\n      vars.debtAmountNeeded = ((vars.collateralPrice * vars.collateralAmount * vars.debtAssetUnit) /\n        (vars.debtAssetPrice * vars.collateralAssetUnit)).percentDiv(liquidationBonus);\n    } else {\n      vars.collateralAmount = vars.maxCollateralToLiquidate;\n      vars.debtAmountNeeded = debtToCover;\n    }\n\n    if (vars.liquidationProtocolFeePercentage != 0) {\n      vars.bonusCollateral =\n        vars.collateralAmount -\n        vars.collateralAmount.percentDiv(liquidationBonus);\n\n      vars.liquidationProtocolFee = vars.bonusCollateral.percentMul(\n        vars.liquidationProtocolFeePercentage\n      );\n\n      return (\n        vars.collateralAmount - vars.liquidationProtocolFee,\n        vars.debtAmountNeeded,\n        vars.liquidationProtocolFee\n      );\n    } else {\n      return (vars.collateralAmount, vars.debtAmountNeeded, 0);\n    }\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/logic/PoolLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {GPv2SafeERC20} from '../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {Address} from '../../../dependencies/openzeppelin/contracts/Address.sol';\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IAToken} from '../../../interfaces/IAToken.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {ValidationLogic} from './ValidationLogic.sol';\nimport {GenericLogic} from './GenericLogic.sol';\n\n/**\n * @title PoolLogic library\n * @author Aave\n * @notice Implements the logic for Pool specific functions\n */\nlibrary PoolLogic {\n  using GPv2SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  // See `IPool` for descriptions\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @notice Initialize an asset reserve and add the reserve to the list of reserves\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param params Additional parameters needed for initiation\n   * @return true if appended, false if inserted at existing empty spot\n   */\n  function executeInitReserve(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    DataTypes.InitReserveParams memory params\n  ) external returns (bool) {\n    require(Address.isContract(params.asset), Errors.NOT_CONTRACT);\n    reservesData[params.asset].init(\n      params.aTokenAddress,\n      params.stableDebtAddress,\n      params.variableDebtAddress,\n      params.interestRateStrategyAddress\n    );\n\n    bool reserveAlreadyAdded = reservesData[params.asset].id != 0 ||\n      reservesList[0] == params.asset;\n    require(!reserveAlreadyAdded, Errors.RESERVE_ALREADY_ADDED);\n\n    for (uint16 i = 0; i < params.reservesCount; i++) {\n      if (reservesList[i] == address(0)) {\n        reservesData[params.asset].id = i;\n        reservesList[i] = params.asset;\n        return false;\n      }\n    }\n\n    require(params.reservesCount < params.maxNumberReserves, Errors.NO_MORE_RESERVES_ALLOWED);\n    reservesData[params.asset].id = params.reservesCount;\n    reservesList[params.reservesCount] = params.asset;\n    return true;\n  }\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function executeRescueTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external {\n    IERC20(token).safeTransfer(to, amount);\n  }\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param reservesData The state of all the reserves\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function executeMintToTreasury(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    address[] calldata assets\n  ) external {\n    for (uint256 i = 0; i < assets.length; i++) {\n      address assetAddress = assets[i];\n\n      DataTypes.ReserveData storage reserve = reservesData[assetAddress];\n\n      // this cover both inactive reserves and invalid reserves since the flag will be 0 for both\n      if (!reserve.configuration.getActive()) {\n        continue;\n      }\n\n      uint256 accruedToTreasury = reserve.accruedToTreasury;\n\n      if (accruedToTreasury != 0) {\n        reserve.accruedToTreasury = 0;\n        uint256 normalizedIncome = reserve.getNormalizedIncome();\n        uint256 amountToMint = accruedToTreasury.rayMul(normalizedIncome);\n        IAToken(reserve.aTokenAddress).mintToTreasury(amountToMint, normalizedIncome);\n\n        emit MintedToTreasury(assetAddress, amountToMint);\n      }\n    }\n  }\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param reservesData The state of all the reserves\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function executeResetIsolationModeTotalDebt(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    address asset\n  ) external {\n    require(reservesData[asset].configuration.getDebtCeiling() == 0, Errors.DEBT_CEILING_NOT_ZERO);\n    reservesData[asset].isolationModeTotalDebt = 0;\n    emit IsolationModeTotalDebtUpdated(asset, 0);\n  }\n\n  /**\n   * @notice Drop a reserve\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function executeDropReserve(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    address asset\n  ) external {\n    DataTypes.ReserveData storage reserve = reservesData[asset];\n    ValidationLogic.validateDropReserve(reservesList, reserve, asset);\n    reservesList[reservesData[asset].id] = address(0);\n    delete reservesData[asset];\n  }\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param params Additional params needed for the calculation\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function executeGetUserAccountData(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.CalculateUserAccountDataParams memory params\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    )\n  {\n    (\n      totalCollateralBase,\n      totalDebtBase,\n      ltv,\n      currentLiquidationThreshold,\n      healthFactor,\n\n    ) = GenericLogic.calculateUserAccountData(reservesData, reservesList, eModeCategories, params);\n\n    availableBorrowsBase = GenericLogic.calculateAvailableBorrows(\n      totalCollateralBase,\n      totalDebtBase,\n      ltv\n    );\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/logic/ReserveLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {GPv2SafeERC20} from '../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {IStableDebtToken} from '../../../interfaces/IStableDebtToken.sol';\nimport {IVariableDebtToken} from '../../../interfaces/IVariableDebtToken.sol';\nimport {IReserveInterestRateStrategy} from '../../../interfaces/IReserveInterestRateStrategy.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {MathUtils} from '../math/MathUtils.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {SafeCast} from '../../../dependencies/openzeppelin/contracts/SafeCast.sol';\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements the logic to update the reserves state\n */\nlibrary ReserveLogic {\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeCast for uint256;\n  using GPv2SafeERC20 for IERC20;\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  // See `IPool` for descriptions\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @notice Returns the ongoing normalized income for the reserve.\n   * @dev A value of 1e27 means there is no income. As time passes, the income is accrued\n   * @dev A value of 2*1e27 means for each unit of asset one unit of income has been accrued\n   * @param reserve The reserve object\n   * @return The normalized income, expressed in ray\n   */\n  function getNormalizedIncome(DataTypes.ReserveData storage reserve)\n    internal\n    view\n    returns (uint256)\n  {\n    uint40 timestamp = reserve.lastUpdateTimestamp;\n\n    //solium-disable-next-line\n    if (timestamp == block.timestamp) {\n      //if the index was updated in the same block, no need to perform any calculation\n      return reserve.liquidityIndex;\n    } else {\n      return\n        MathUtils.calculateLinearInterest(reserve.currentLiquidityRate, timestamp).rayMul(\n          reserve.liquidityIndex\n        );\n    }\n  }\n\n  /**\n   * @notice Returns the ongoing normalized variable debt for the reserve.\n   * @dev A value of 1e27 means there is no debt. As time passes, the debt is accrued\n   * @dev A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\n   * @param reserve The reserve object\n   * @return The normalized variable debt, expressed in ray\n   */\n  function getNormalizedDebt(DataTypes.ReserveData storage reserve)\n    internal\n    view\n    returns (uint256)\n  {\n    uint40 timestamp = reserve.lastUpdateTimestamp;\n\n    //solium-disable-next-line\n    if (timestamp == block.timestamp) {\n      //if the index was updated in the same block, no need to perform any calculation\n      return reserve.variableBorrowIndex;\n    } else {\n      return\n        MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp).rayMul(\n          reserve.variableBorrowIndex\n        );\n    }\n  }\n\n  /**\n   * @notice Updates the liquidity cumulative index and the variable borrow index.\n   * @param reserve The reserve object\n   * @param reserveCache The caching layer for the reserve data\n   */\n  function updateState(\n    DataTypes.ReserveData storage reserve,\n    DataTypes.ReserveCache memory reserveCache\n  ) internal {\n    // If time didn't pass since last stored timestamp, skip state update\n    //solium-disable-next-line\n    if (reserve.lastUpdateTimestamp == uint40(block.timestamp)) {\n      return;\n    }\n\n    _updateIndexes(reserve, reserveCache);\n    _accrueToTreasury(reserve, reserveCache);\n\n    //solium-disable-next-line\n    reserve.lastUpdateTimestamp = uint40(block.timestamp);\n  }\n\n  /**\n   * @notice Accumulates a predefined amount of asset to the reserve as a fixed, instantaneous income. Used for example\n   * to accumulate the flashloan fee to the reserve, and spread it between all the suppliers.\n   * @param reserve The reserve object\n   * @param totalLiquidity The total liquidity available in the reserve\n   * @param amount The amount to accumulate\n   * @return The next liquidity index of the reserve\n   */\n  function cumulateToLiquidityIndex(\n    DataTypes.ReserveData storage reserve,\n    uint256 totalLiquidity,\n    uint256 amount\n  ) internal returns (uint256) {\n    //next liquidity index is calculated this way: `((amount / totalLiquidity) + 1) * liquidityIndex`\n    //division `amount / totalLiquidity` done in ray for precision\n    uint256 result = (amount.wadToRay().rayDiv(totalLiquidity.wadToRay()) + WadRayMath.RAY).rayMul(\n      reserve.liquidityIndex\n    );\n    reserve.liquidityIndex = result.toUint128();\n    return result;\n  }\n\n  /**\n   * @notice Initializes a reserve.\n   * @param reserve The reserve object\n   * @param aTokenAddress The address of the overlying atoken contract\n   * @param stableDebtTokenAddress The address of the overlying stable debt token contract\n   * @param variableDebtTokenAddress The address of the overlying variable debt token contract\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function init(\n    DataTypes.ReserveData storage reserve,\n    address aTokenAddress,\n    address stableDebtTokenAddress,\n    address variableDebtTokenAddress,\n    address interestRateStrategyAddress\n  ) internal {\n    require(reserve.aTokenAddress == address(0), Errors.RESERVE_ALREADY_INITIALIZED);\n\n    reserve.liquidityIndex = uint128(WadRayMath.RAY);\n    reserve.variableBorrowIndex = uint128(WadRayMath.RAY);\n    reserve.aTokenAddress = aTokenAddress;\n    reserve.stableDebtTokenAddress = stableDebtTokenAddress;\n    reserve.variableDebtTokenAddress = variableDebtTokenAddress;\n    reserve.interestRateStrategyAddress = interestRateStrategyAddress;\n  }\n\n  struct UpdateInterestRatesLocalVars {\n    uint256 nextLiquidityRate;\n    uint256 nextStableRate;\n    uint256 nextVariableRate;\n    uint256 totalVariableDebt;\n  }\n\n  /**\n   * @notice Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate.\n   * @param reserve The reserve reserve to be updated\n   * @param reserveCache The caching layer for the reserve data\n   * @param reserveAddress The address of the reserve to be updated\n   * @param liquidityAdded The amount of liquidity added to the protocol (supply or repay) in the previous action\n   * @param liquidityTaken The amount of liquidity taken from the protocol (redeem or borrow)\n   */\n  function updateInterestRates(\n    DataTypes.ReserveData storage reserve,\n    DataTypes.ReserveCache memory reserveCache,\n    address reserveAddress,\n    uint256 liquidityAdded,\n    uint256 liquidityTaken\n  ) internal {\n    UpdateInterestRatesLocalVars memory vars;\n\n    vars.totalVariableDebt = reserveCache.nextScaledVariableDebt.rayMul(\n      reserveCache.nextVariableBorrowIndex\n    );\n\n    (\n      vars.nextLiquidityRate,\n      vars.nextStableRate,\n      vars.nextVariableRate\n    ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates(\n      DataTypes.CalculateInterestRatesParams({\n        unbacked: reserve.unbacked,\n        liquidityAdded: liquidityAdded,\n        liquidityTaken: liquidityTaken,\n        totalStableDebt: reserveCache.nextTotalStableDebt,\n        totalVariableDebt: vars.totalVariableDebt,\n        averageStableBorrowRate: reserveCache.nextAvgStableBorrowRate,\n        reserveFactor: reserveCache.reserveFactor,\n        reserve: reserveAddress,\n        aToken: reserveCache.aTokenAddress\n      })\n    );\n\n    reserve.currentLiquidityRate = vars.nextLiquidityRate.toUint128();\n    reserve.currentStableBorrowRate = vars.nextStableRate.toUint128();\n    reserve.currentVariableBorrowRate = vars.nextVariableRate.toUint128();\n\n    emit ReserveDataUpdated(\n      reserveAddress,\n      vars.nextLiquidityRate,\n      vars.nextStableRate,\n      vars.nextVariableRate,\n      reserveCache.nextLiquidityIndex,\n      reserveCache.nextVariableBorrowIndex\n    );\n  }\n\n  struct AccrueToTreasuryLocalVars {\n    uint256 prevTotalStableDebt;\n    uint256 prevTotalVariableDebt;\n    uint256 currTotalVariableDebt;\n    uint256 cumulatedStableInterest;\n    uint256 totalDebtAccrued;\n    uint256 amountToMint;\n  }\n\n  /**\n   * @notice Mints part of the repaid interest to the reserve treasury as a function of the reserve factor for the\n   * specific asset.\n   * @param reserve The reserve to be updated\n   * @param reserveCache The caching layer for the reserve data\n   */\n  function _accrueToTreasury(\n    DataTypes.ReserveData storage reserve,\n    DataTypes.ReserveCache memory reserveCache\n  ) internal {\n    AccrueToTreasuryLocalVars memory vars;\n\n    if (reserveCache.reserveFactor == 0) {\n      return;\n    }\n\n    //calculate the total variable debt at moment of the last interaction\n    vars.prevTotalVariableDebt = reserveCache.currScaledVariableDebt.rayMul(\n      reserveCache.currVariableBorrowIndex\n    );\n\n    //calculate the new total variable debt after accumulation of the interest on the index\n    vars.currTotalVariableDebt = reserveCache.currScaledVariableDebt.rayMul(\n      reserveCache.nextVariableBorrowIndex\n    );\n\n    //calculate the stable debt until the last timestamp update\n    vars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest(\n      reserveCache.currAvgStableBorrowRate,\n      reserveCache.stableDebtLastUpdateTimestamp,\n      reserveCache.reserveLastUpdateTimestamp\n    );\n\n    vars.prevTotalStableDebt = reserveCache.currPrincipalStableDebt.rayMul(\n      vars.cumulatedStableInterest\n    );\n\n    //debt accrued is the sum of the current debt minus the sum of the debt at the last update\n    vars.totalDebtAccrued =\n      vars.currTotalVariableDebt +\n      reserveCache.currTotalStableDebt -\n      vars.prevTotalVariableDebt -\n      vars.prevTotalStableDebt;\n\n    vars.amountToMint = vars.totalDebtAccrued.percentMul(reserveCache.reserveFactor);\n\n    if (vars.amountToMint != 0) {\n      reserve.accruedToTreasury += vars\n        .amountToMint\n        .rayDiv(reserveCache.nextLiquidityIndex)\n        .toUint128();\n    }\n  }\n\n  /**\n   * @notice Updates the reserve indexes and the timestamp of the update.\n   * @param reserve The reserve reserve to be updated\n   * @param reserveCache The cache layer holding the cached protocol data\n   */\n  function _updateIndexes(\n    DataTypes.ReserveData storage reserve,\n    DataTypes.ReserveCache memory reserveCache\n  ) internal {\n    // Only cumulating on the supply side if there is any income being produced\n    // The case of Reserve Factor 100% is not a problem (currentLiquidityRate == 0),\n    // as liquidity index should not be updated\n    if (reserveCache.currLiquidityRate != 0) {\n      uint256 cumulatedLiquidityInterest = MathUtils.calculateLinearInterest(\n        reserveCache.currLiquidityRate,\n        reserveCache.reserveLastUpdateTimestamp\n      );\n      reserveCache.nextLiquidityIndex = cumulatedLiquidityInterest.rayMul(\n        reserveCache.currLiquidityIndex\n      );\n      reserve.liquidityIndex = reserveCache.nextLiquidityIndex.toUint128();\n    }\n\n    // Variable borrow index only gets updated if there is any variable debt.\n    // reserveCache.currVariableBorrowRate != 0 is not a correct validation,\n    // because a positive base variable rate can be stored on\n    // reserveCache.currVariableBorrowRate, but the index should not increase\n    if (reserveCache.currScaledVariableDebt != 0) {\n      uint256 cumulatedVariableBorrowInterest = MathUtils.calculateCompoundedInterest(\n        reserveCache.currVariableBorrowRate,\n        reserveCache.reserveLastUpdateTimestamp\n      );\n      reserveCache.nextVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(\n        reserveCache.currVariableBorrowIndex\n      );\n      reserve.variableBorrowIndex = reserveCache.nextVariableBorrowIndex.toUint128();\n    }\n  }\n\n  /**\n   * @notice Creates a cache object to avoid repeated storage reads and external contract calls when updating state and\n   * interest rates.\n   * @param reserve The reserve object for which the cache will be filled\n   * @return The cache object\n   */\n  function cache(DataTypes.ReserveData storage reserve)\n    internal\n    view\n    returns (DataTypes.ReserveCache memory)\n  {\n    DataTypes.ReserveCache memory reserveCache;\n\n    reserveCache.reserveConfiguration = reserve.configuration;\n    reserveCache.reserveFactor = reserveCache.reserveConfiguration.getReserveFactor();\n    reserveCache.currLiquidityIndex = reserveCache.nextLiquidityIndex = reserve.liquidityIndex;\n    reserveCache.currVariableBorrowIndex = reserveCache.nextVariableBorrowIndex = reserve\n      .variableBorrowIndex;\n    reserveCache.currLiquidityRate = reserve.currentLiquidityRate;\n    reserveCache.currVariableBorrowRate = reserve.currentVariableBorrowRate;\n\n    reserveCache.aTokenAddress = reserve.aTokenAddress;\n    reserveCache.stableDebtTokenAddress = reserve.stableDebtTokenAddress;\n    reserveCache.variableDebtTokenAddress = reserve.variableDebtTokenAddress;\n\n    reserveCache.reserveLastUpdateTimestamp = reserve.lastUpdateTimestamp;\n\n    reserveCache.currScaledVariableDebt = reserveCache.nextScaledVariableDebt = IVariableDebtToken(\n      reserveCache.variableDebtTokenAddress\n    ).scaledTotalSupply();\n\n    (\n      reserveCache.currPrincipalStableDebt,\n      reserveCache.currTotalStableDebt,\n      reserveCache.currAvgStableBorrowRate,\n      reserveCache.stableDebtLastUpdateTimestamp\n    ) = IStableDebtToken(reserveCache.stableDebtTokenAddress).getSupplyData();\n\n    // by default the actions are considered as not affecting the debt balances.\n    // if the action involves mint/burn of debt, the cache needs to be updated\n    reserveCache.nextTotalStableDebt = reserveCache.currTotalStableDebt;\n    reserveCache.nextAvgStableBorrowRate = reserveCache.currAvgStableBorrowRate;\n\n    return reserveCache;\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/logic/SupplyLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {GPv2SafeERC20} from '../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {IAToken} from '../../../interfaces/IAToken.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {ValidationLogic} from './ValidationLogic.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\n\n/**\n * @title SupplyLogic library\n * @author Aave\n * @notice Implements the base logic for supply/withdraw\n */\nlibrary SupplyLogic {\n  using ReserveLogic for DataTypes.ReserveCache;\n  using ReserveLogic for DataTypes.ReserveData;\n  using GPv2SafeERC20 for IERC20;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n\n  // See `IPool` for descriptions\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @notice Implements the supply feature. Through `supply()`, users supply assets to the Aave protocol.\n   * @dev Emits the `Supply()` event.\n   * @dev In the first supply action, `ReserveUsedAsCollateralEnabled()` is emitted, if the asset can be enabled as\n   * collateral.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n   * @param params The additional parameters needed to execute the supply function\n   */\n  function executeSupply(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.ExecuteSupplyParams memory params\n  ) external {\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n    reserve.updateState(reserveCache);\n\n    ValidationLogic.validateSupply(reserveCache, reserve, params.amount);\n\n    reserve.updateInterestRates(reserveCache, params.asset, params.amount, 0);\n\n    IERC20(params.asset).safeTransferFrom(msg.sender, reserveCache.aTokenAddress, params.amount);\n\n    bool isFirstSupply = IAToken(reserveCache.aTokenAddress).mint(\n      msg.sender,\n      params.onBehalfOf,\n      params.amount,\n      reserveCache.nextLiquidityIndex\n    );\n\n    if (isFirstSupply) {\n      if (\n        ValidationLogic.validateUseAsCollateral(\n          reservesData,\n          reservesList,\n          userConfig,\n          reserveCache.reserveConfiguration\n        )\n      ) {\n        userConfig.setUsingAsCollateral(reserve.id, true);\n        emit ReserveUsedAsCollateralEnabled(params.asset, params.onBehalfOf);\n      }\n    }\n\n    emit Supply(params.asset, msg.sender, params.onBehalfOf, params.amount, params.referralCode);\n  }\n\n  /**\n   * @notice Implements the withdraw feature. Through `withdraw()`, users redeem their aTokens for the underlying asset\n   * previously supplied in the Aave protocol.\n   * @dev Emits the `Withdraw()` event.\n   * @dev If the user withdraws everything, `ReserveUsedAsCollateralDisabled()` is emitted.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n   * @param params The additional parameters needed to execute the withdraw function\n   * @return The actual amount withdrawn\n   */\n  function executeWithdraw(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.ExecuteWithdrawParams memory params\n  ) external returns (uint256) {\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n    reserve.updateState(reserveCache);\n\n    uint256 userBalance = IAToken(reserveCache.aTokenAddress).scaledBalanceOf(msg.sender).rayMul(\n      reserveCache.nextLiquidityIndex\n    );\n\n    uint256 amountToWithdraw = params.amount;\n\n    if (params.amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    ValidationLogic.validateWithdraw(reserveCache, amountToWithdraw, userBalance);\n\n    reserve.updateInterestRates(reserveCache, params.asset, 0, amountToWithdraw);\n\n    bool isCollateral = userConfig.isUsingAsCollateral(reserve.id);\n\n    if (isCollateral && amountToWithdraw == userBalance) {\n      userConfig.setUsingAsCollateral(reserve.id, false);\n      emit ReserveUsedAsCollateralDisabled(params.asset, msg.sender);\n    }\n\n    IAToken(reserveCache.aTokenAddress).burn(\n      msg.sender,\n      params.to,\n      amountToWithdraw,\n      reserveCache.nextLiquidityIndex\n    );\n\n    if (isCollateral && userConfig.isBorrowingAny()) {\n      ValidationLogic.validateHFAndLtv(\n        reservesData,\n        reservesList,\n        eModeCategories,\n        userConfig,\n        params.asset,\n        msg.sender,\n        params.reservesCount,\n        params.oracle,\n        params.userEModeCategory\n      );\n    }\n\n    emit Withdraw(params.asset, msg.sender, params.to, amountToWithdraw);\n\n    return amountToWithdraw;\n  }\n\n  /**\n   * @notice Validates a transfer of aTokens. The sender is subjected to health factor validation to avoid\n   * collateralization constraints violation.\n   * @dev Emits the `ReserveUsedAsCollateralEnabled()` event for the `to` account, if the asset is being activated as\n   * collateral.\n   * @dev In case the `from` user transfers everything, `ReserveUsedAsCollateralDisabled()` is emitted for `from`.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param usersConfig The users configuration mapping that track the supplied/borrowed assets\n   * @param params The additional parameters needed to execute the finalizeTransfer function\n   */\n  function executeFinalizeTransfer(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,\n    DataTypes.FinalizeTransferParams memory params\n  ) external {\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n\n    ValidationLogic.validateTransfer(reserve);\n\n    uint256 reserveId = reserve.id;\n\n    if (params.from != params.to && params.amount != 0) {\n      DataTypes.UserConfigurationMap storage fromConfig = usersConfig[params.from];\n\n      if (fromConfig.isUsingAsCollateral(reserveId)) {\n        if (fromConfig.isBorrowingAny()) {\n          ValidationLogic.validateHFAndLtv(\n            reservesData,\n            reservesList,\n            eModeCategories,\n            usersConfig[params.from],\n            params.asset,\n            params.from,\n            params.reservesCount,\n            params.oracle,\n            params.fromEModeCategory\n          );\n        }\n        if (params.balanceFromBefore == params.amount) {\n          fromConfig.setUsingAsCollateral(reserveId, false);\n          emit ReserveUsedAsCollateralDisabled(params.asset, params.from);\n        }\n      }\n\n      if (params.balanceToBefore == 0) {\n        DataTypes.UserConfigurationMap storage toConfig = usersConfig[params.to];\n        if (\n          ValidationLogic.validateUseAsCollateral(\n            reservesData,\n            reservesList,\n            toConfig,\n            reserve.configuration\n          )\n        ) {\n          toConfig.setUsingAsCollateral(reserveId, true);\n          emit ReserveUsedAsCollateralEnabled(params.asset, params.to);\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Executes the 'set as collateral' feature. A user can choose to activate or deactivate an asset as\n   * collateral at any point in time. Deactivating an asset as collateral is subjected to the usual health factor\n   * checks to ensure collateralization.\n   * @dev Emits the `ReserveUsedAsCollateralEnabled()` event if the asset can be activated as collateral.\n   * @dev In case the asset is being deactivated as collateral, `ReserveUsedAsCollateralDisabled()` is emitted.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param userConfig The users configuration mapping that track the supplied/borrowed assets\n   * @param asset The address of the asset being configured as collateral\n   * @param useAsCollateral True if the user wants to set the asset as collateral, false otherwise\n   * @param reservesCount The number of initialized reserves\n   * @param priceOracle The address of the price oracle\n   * @param userEModeCategory The eMode category chosen by the user\n   */\n  function executeUseReserveAsCollateral(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.UserConfigurationMap storage userConfig,\n    address asset,\n    bool useAsCollateral,\n    uint256 reservesCount,\n    address priceOracle,\n    uint8 userEModeCategory\n  ) external {\n    DataTypes.ReserveData storage reserve = reservesData[asset];\n    DataTypes.ReserveCache memory reserveCache = reserve.cache();\n\n    uint256 userBalance = IERC20(reserveCache.aTokenAddress).balanceOf(msg.sender);\n\n    ValidationLogic.validateSetUseReserveAsCollateral(reserveCache, userBalance);\n\n    if (useAsCollateral == userConfig.isUsingAsCollateral(reserve.id)) return;\n\n    if (useAsCollateral) {\n      require(\n        ValidationLogic.validateUseAsCollateral(\n          reservesData,\n          reservesList,\n          userConfig,\n          reserveCache.reserveConfiguration\n        ),\n        Errors.USER_IN_ISOLATION_MODE\n      );\n\n      userConfig.setUsingAsCollateral(reserve.id, true);\n      emit ReserveUsedAsCollateralEnabled(asset, msg.sender);\n    } else {\n      userConfig.setUsingAsCollateral(reserve.id, false);\n      ValidationLogic.validateHFAndLtv(\n        reservesData,\n        reservesList,\n        eModeCategories,\n        userConfig,\n        asset,\n        msg.sender,\n        reservesCount,\n        priceOracle,\n        userEModeCategory\n      );\n\n      emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n    }\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/logic/ValidationLogic.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {Address} from '../../../dependencies/openzeppelin/contracts/Address.sol';\nimport {GPv2SafeERC20} from '../../../dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {IReserveInterestRateStrategy} from '../../../interfaces/IReserveInterestRateStrategy.sol';\nimport {IStableDebtToken} from '../../../interfaces/IStableDebtToken.sol';\nimport {IScaledBalanceToken} from '../../../interfaces/IScaledBalanceToken.sol';\nimport {IPriceOracleGetter} from '../../../interfaces/IPriceOracleGetter.sol';\nimport {IAToken} from '../../../interfaces/IAToken.sol';\nimport {IPriceOracleSentinel} from '../../../interfaces/IPriceOracleSentinel.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {GenericLogic} from './GenericLogic.sol';\nimport {SafeCast} from '../../../dependencies/openzeppelin/contracts/SafeCast.sol';\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeCast for uint256;\n  using GPv2SafeERC20 for IERC20;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n  using Address for address;\n\n  // Factor to apply to \"only-variable-debt\" liquidity rate to get threshold for rebalancing, expressed in bps\n  // A value of 0.9e4 results in 90%\n  uint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 0.9e4;\n\n  // Minimum health factor allowed under any circumstance\n  // A value of 0.95e18 results in 0.95\n  uint256 public constant MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 0.95e18;\n\n  /**\n   * @dev Minimum health factor to consider a user position healthy\n   * A value of 1e18 results in 1\n   */\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18;\n\n  /**\n   * @notice Validates a supply action.\n   * @param reserveCache The cached data of the reserve\n   * @param amount The amount to be supplied\n   */\n  function validateSupply(\n    DataTypes.ReserveCache memory reserveCache,\n    DataTypes.ReserveData storage reserve,\n    uint256 amount\n  ) internal view {\n    require(amount != 0, Errors.INVALID_AMOUNT);\n\n    (bool isActive, bool isFrozen, , , bool isPaused) = reserveCache\n      .reserveConfiguration\n      .getFlags();\n    require(isActive, Errors.RESERVE_INACTIVE);\n    require(!isPaused, Errors.RESERVE_PAUSED);\n    require(!isFrozen, Errors.RESERVE_FROZEN);\n\n    uint256 supplyCap = reserveCache.reserveConfiguration.getSupplyCap();\n    require(\n      supplyCap == 0 ||\n        ((IAToken(reserveCache.aTokenAddress).scaledTotalSupply() +\n          uint256(reserve.accruedToTreasury)).rayMul(reserveCache.nextLiquidityIndex) + amount) <=\n        supplyCap * (10**reserveCache.reserveConfiguration.getDecimals()),\n      Errors.SUPPLY_CAP_EXCEEDED\n    );\n  }\n\n  /**\n   * @notice Validates a withdraw action.\n   * @param reserveCache The cached data of the reserve\n   * @param amount The amount to be withdrawn\n   * @param userBalance The balance of the user\n   */\n  function validateWithdraw(\n    DataTypes.ReserveCache memory reserveCache,\n    uint256 amount,\n    uint256 userBalance\n  ) internal pure {\n    require(amount != 0, Errors.INVALID_AMOUNT);\n    require(amount <= userBalance, Errors.NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n    (bool isActive, , , , bool isPaused) = reserveCache.reserveConfiguration.getFlags();\n    require(isActive, Errors.RESERVE_INACTIVE);\n    require(!isPaused, Errors.RESERVE_PAUSED);\n  }\n\n  struct ValidateBorrowLocalVars {\n    uint256 currentLtv;\n    uint256 collateralNeededInBaseCurrency;\n    uint256 userCollateralInBaseCurrency;\n    uint256 userDebtInBaseCurrency;\n    uint256 availableLiquidity;\n    uint256 healthFactor;\n    uint256 totalDebt;\n    uint256 totalSupplyVariableDebt;\n    uint256 reserveDecimals;\n    uint256 borrowCap;\n    uint256 amountInBaseCurrency;\n    uint256 assetUnit;\n    address eModePriceSource;\n    address siloedBorrowingAddress;\n    bool isActive;\n    bool isFrozen;\n    bool isPaused;\n    bool borrowingEnabled;\n    bool stableRateBorrowingEnabled;\n    bool siloedBorrowingEnabled;\n  }\n\n  /**\n   * @notice Validates a borrow action.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param params Additional params needed for the validation\n   */\n  function validateBorrow(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.ValidateBorrowParams memory params\n  ) internal view {\n    require(params.amount != 0, Errors.INVALID_AMOUNT);\n\n    ValidateBorrowLocalVars memory vars;\n\n    (\n      vars.isActive,\n      vars.isFrozen,\n      vars.borrowingEnabled,\n      vars.stableRateBorrowingEnabled,\n      vars.isPaused\n    ) = params.reserveCache.reserveConfiguration.getFlags();\n\n    require(vars.isActive, Errors.RESERVE_INACTIVE);\n    require(!vars.isPaused, Errors.RESERVE_PAUSED);\n    require(!vars.isFrozen, Errors.RESERVE_FROZEN);\n    require(vars.borrowingEnabled, Errors.BORROWING_NOT_ENABLED);\n\n    require(\n      params.priceOracleSentinel == address(0) ||\n        IPriceOracleSentinel(params.priceOracleSentinel).isBorrowAllowed(),\n      Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n    );\n\n    //validate interest rate mode\n    require(\n      params.interestRateMode == DataTypes.InterestRateMode.VARIABLE ||\n        params.interestRateMode == DataTypes.InterestRateMode.STABLE,\n      Errors.INVALID_INTEREST_RATE_MODE_SELECTED\n    );\n\n    vars.reserveDecimals = params.reserveCache.reserveConfiguration.getDecimals();\n    vars.borrowCap = params.reserveCache.reserveConfiguration.getBorrowCap();\n    unchecked {\n      vars.assetUnit = 10**vars.reserveDecimals;\n    }\n\n    if (vars.borrowCap != 0) {\n      vars.totalSupplyVariableDebt = params.reserveCache.currScaledVariableDebt.rayMul(\n        params.reserveCache.nextVariableBorrowIndex\n      );\n\n      vars.totalDebt =\n        params.reserveCache.currTotalStableDebt +\n        vars.totalSupplyVariableDebt +\n        params.amount;\n\n      unchecked {\n        require(vars.totalDebt <= vars.borrowCap * vars.assetUnit, Errors.BORROW_CAP_EXCEEDED);\n      }\n    }\n\n    if (params.isolationModeActive) {\n      // check that the asset being borrowed is borrowable in isolation mode AND\n      // the total exposure is no bigger than the collateral debt ceiling\n      require(\n        params.reserveCache.reserveConfiguration.getBorrowableInIsolation(),\n        Errors.ASSET_NOT_BORROWABLE_IN_ISOLATION\n      );\n\n      require(\n        reservesData[params.isolationModeCollateralAddress].isolationModeTotalDebt +\n          (params.amount / 10**(vars.reserveDecimals - ReserveConfiguration.DEBT_CEILING_DECIMALS))\n            .toUint128() <=\n          params.isolationModeDebtCeiling,\n        Errors.DEBT_CEILING_EXCEEDED\n      );\n    }\n\n    if (params.userEModeCategory != 0) {\n      require(\n        params.reserveCache.reserveConfiguration.getEModeCategory() == params.userEModeCategory,\n        Errors.INCONSISTENT_EMODE_CATEGORY\n      );\n      vars.eModePriceSource = eModeCategories[params.userEModeCategory].priceSource;\n    }\n\n    (\n      vars.userCollateralInBaseCurrency,\n      vars.userDebtInBaseCurrency,\n      vars.currentLtv,\n      ,\n      vars.healthFactor,\n\n    ) = GenericLogic.calculateUserAccountData(\n      reservesData,\n      reservesList,\n      eModeCategories,\n      DataTypes.CalculateUserAccountDataParams({\n        userConfig: params.userConfig,\n        reservesCount: params.reservesCount,\n        user: params.userAddress,\n        oracle: params.oracle,\n        userEModeCategory: params.userEModeCategory\n      })\n    );\n\n    require(vars.userCollateralInBaseCurrency != 0, Errors.COLLATERAL_BALANCE_IS_ZERO);\n    require(vars.currentLtv != 0, Errors.LTV_VALIDATION_FAILED);\n\n    require(\n      vars.healthFactor > HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    vars.amountInBaseCurrency =\n      IPriceOracleGetter(params.oracle).getAssetPrice(\n        vars.eModePriceSource != address(0) ? vars.eModePriceSource : params.asset\n      ) *\n      params.amount;\n    unchecked {\n      vars.amountInBaseCurrency /= vars.assetUnit;\n    }\n\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n    vars.collateralNeededInBaseCurrency = (vars.userDebtInBaseCurrency + vars.amountInBaseCurrency)\n      .percentDiv(vars.currentLtv); //LTV is calculated in percentage\n\n    require(\n      vars.collateralNeededInBaseCurrency <= vars.userCollateralInBaseCurrency,\n      Errors.COLLATERAL_CANNOT_COVER_NEW_BORROW\n    );\n\n    /**\n     * Following conditions need to be met if the user is borrowing at a stable rate:\n     * 1. Reserve must be enabled for stable rate borrowing\n     * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\n     *    they are borrowing, to prevent abuses.\n     * 3. Users will be able to borrow only a portion of the total available liquidity\n     */\n\n    if (params.interestRateMode == DataTypes.InterestRateMode.STABLE) {\n      //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\n\n      require(vars.stableRateBorrowingEnabled, Errors.STABLE_BORROWING_NOT_ENABLED);\n\n      require(\n        !params.userConfig.isUsingAsCollateral(reservesData[params.asset].id) ||\n          params.reserveCache.reserveConfiguration.getLtv() == 0 ||\n          params.amount > IERC20(params.reserveCache.aTokenAddress).balanceOf(params.userAddress),\n        Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY\n      );\n\n      vars.availableLiquidity = IERC20(params.asset).balanceOf(params.reserveCache.aTokenAddress);\n\n      //calculate the max available loan size in stable rate mode as a percentage of the\n      //available liquidity\n      uint256 maxLoanSizeStable = vars.availableLiquidity.percentMul(params.maxStableLoanPercent);\n\n      require(params.amount <= maxLoanSizeStable, Errors.AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE);\n    }\n\n    if (params.userConfig.isBorrowingAny()) {\n      (vars.siloedBorrowingEnabled, vars.siloedBorrowingAddress) = params\n        .userConfig\n        .getSiloedBorrowingState(reservesData, reservesList);\n\n      if (vars.siloedBorrowingEnabled) {\n        require(vars.siloedBorrowingAddress == params.asset, Errors.SILOED_BORROWING_VIOLATION);\n      } else {\n        require(\n          !params.reserveCache.reserveConfiguration.getSiloedBorrowing(),\n          Errors.SILOED_BORROWING_VIOLATION\n        );\n      }\n    }\n  }\n\n  /**\n   * @notice Validates a repay action.\n   * @param reserveCache The cached data of the reserve\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\n   * @param interestRateMode The interest rate mode of the debt being repaid\n   * @param onBehalfOf The address of the user msg.sender is repaying for\n   * @param stableDebt The borrow balance of the user\n   * @param variableDebt The borrow balance of the user\n   */\n  function validateRepay(\n    DataTypes.ReserveCache memory reserveCache,\n    uint256 amountSent,\n    DataTypes.InterestRateMode interestRateMode,\n    address onBehalfOf,\n    uint256 stableDebt,\n    uint256 variableDebt\n  ) internal view {\n    require(amountSent != 0, Errors.INVALID_AMOUNT);\n    require(\n      amountSent != type(uint256).max || msg.sender == onBehalfOf,\n      Errors.NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF\n    );\n\n    (bool isActive, , , , bool isPaused) = reserveCache.reserveConfiguration.getFlags();\n    require(isActive, Errors.RESERVE_INACTIVE);\n    require(!isPaused, Errors.RESERVE_PAUSED);\n\n    require(\n      (stableDebt != 0 && interestRateMode == DataTypes.InterestRateMode.STABLE) ||\n        (variableDebt != 0 && interestRateMode == DataTypes.InterestRateMode.VARIABLE),\n      Errors.NO_DEBT_OF_SELECTED_TYPE\n    );\n  }\n\n  /**\n   * @notice Validates a swap of borrow rate mode.\n   * @param reserve The reserve state on which the user is swapping the rate\n   * @param reserveCache The cached data of the reserve\n   * @param userConfig The user reserves configuration\n   * @param stableDebt The stable debt of the user\n   * @param variableDebt The variable debt of the user\n   * @param currentRateMode The rate mode of the debt being swapped\n   */\n  function validateSwapRateMode(\n    DataTypes.ReserveData storage reserve,\n    DataTypes.ReserveCache memory reserveCache,\n    DataTypes.UserConfigurationMap storage userConfig,\n    uint256 stableDebt,\n    uint256 variableDebt,\n    DataTypes.InterestRateMode currentRateMode\n  ) internal view {\n    (bool isActive, bool isFrozen, , bool stableRateEnabled, bool isPaused) = reserveCache\n      .reserveConfiguration\n      .getFlags();\n    require(isActive, Errors.RESERVE_INACTIVE);\n    require(!isPaused, Errors.RESERVE_PAUSED);\n    require(!isFrozen, Errors.RESERVE_FROZEN);\n\n    if (currentRateMode == DataTypes.InterestRateMode.STABLE) {\n      require(stableDebt != 0, Errors.NO_OUTSTANDING_STABLE_DEBT);\n    } else if (currentRateMode == DataTypes.InterestRateMode.VARIABLE) {\n      require(variableDebt != 0, Errors.NO_OUTSTANDING_VARIABLE_DEBT);\n      /**\n       * user wants to swap to stable, before swapping we need to ensure that\n       * 1. stable borrow rate is enabled on the reserve\n       * 2. user is not trying to abuse the reserve by supplying\n       * more collateral than he is borrowing, artificially lowering\n       * the interest rate, borrowing at variable, and switching to stable\n       */\n      require(stableRateEnabled, Errors.STABLE_BORROWING_NOT_ENABLED);\n\n      require(\n        !userConfig.isUsingAsCollateral(reserve.id) ||\n          reserveCache.reserveConfiguration.getLtv() == 0 ||\n          stableDebt + variableDebt > IERC20(reserveCache.aTokenAddress).balanceOf(msg.sender),\n        Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY\n      );\n    } else {\n      revert(Errors.INVALID_INTEREST_RATE_MODE_SELECTED);\n    }\n  }\n\n  /**\n   * @notice Validates a stable borrow rate rebalance action.\n   * @dev Rebalancing is accepted when depositors are earning <= 90% of their earnings in pure supply/demand market (variable rate only)\n   * For this to be the case, there has to be quite large stable debt with an interest rate below the current variable rate.\n   * @param reserve The reserve state on which the user is getting rebalanced\n   * @param reserveCache The cached state of the reserve\n   * @param reserveAddress The address of the reserve\n   */\n  function validateRebalanceStableBorrowRate(\n    DataTypes.ReserveData storage reserve,\n    DataTypes.ReserveCache memory reserveCache,\n    address reserveAddress\n  ) internal view {\n    (bool isActive, , , , bool isPaused) = reserveCache.reserveConfiguration.getFlags();\n    require(isActive, Errors.RESERVE_INACTIVE);\n    require(!isPaused, Errors.RESERVE_PAUSED);\n\n    uint256 totalDebt = IERC20(reserveCache.stableDebtTokenAddress).totalSupply() +\n      IERC20(reserveCache.variableDebtTokenAddress).totalSupply();\n\n    (uint256 liquidityRateVariableDebtOnly, , ) = IReserveInterestRateStrategy(\n      reserve.interestRateStrategyAddress\n    ).calculateInterestRates(\n        DataTypes.CalculateInterestRatesParams({\n          unbacked: reserve.unbacked,\n          liquidityAdded: 0,\n          liquidityTaken: 0,\n          totalStableDebt: 0,\n          totalVariableDebt: totalDebt,\n          averageStableBorrowRate: 0,\n          reserveFactor: reserveCache.reserveFactor,\n          reserve: reserveAddress,\n          aToken: reserveCache.aTokenAddress\n        })\n      );\n\n    require(\n      reserveCache.currLiquidityRate <=\n        liquidityRateVariableDebtOnly.percentMul(REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD),\n      Errors.INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET\n    );\n  }\n\n  /**\n   * @notice Validates the action of setting an asset as collateral.\n   * @param reserveCache The cached data of the reserve\n   * @param userBalance The balance of the user\n   */\n  function validateSetUseReserveAsCollateral(\n    DataTypes.ReserveCache memory reserveCache,\n    uint256 userBalance\n  ) internal pure {\n    require(userBalance != 0, Errors.UNDERLYING_BALANCE_ZERO);\n\n    (bool isActive, , , , bool isPaused) = reserveCache.reserveConfiguration.getFlags();\n    require(isActive, Errors.RESERVE_INACTIVE);\n    require(!isPaused, Errors.RESERVE_PAUSED);\n  }\n\n  /**\n   * @notice Validates a flashloan action.\n   * @param reservesData The state of all the reserves\n   * @param assets The assets being flash-borrowed\n   * @param amounts The amounts for each asset being borrowed\n   */\n  function validateFlashloan(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    address[] memory assets,\n    uint256[] memory amounts\n  ) internal view {\n    require(assets.length == amounts.length, Errors.INCONSISTENT_FLASHLOAN_PARAMS);\n    for (uint256 i = 0; i < assets.length; i++) {\n      validateFlashloanSimple(reservesData[assets[i]]);\n    }\n  }\n\n  /**\n   * @notice Validates a flashloan action.\n   * @param reserve The state of the reserve\n   */\n  function validateFlashloanSimple(DataTypes.ReserveData storage reserve) internal view {\n    DataTypes.ReserveConfigurationMap memory configuration = reserve.configuration;\n    require(!configuration.getPaused(), Errors.RESERVE_PAUSED);\n    require(configuration.getActive(), Errors.RESERVE_INACTIVE);\n    require(configuration.getFlashLoanEnabled(), Errors.FLASHLOAN_DISABLED);\n  }\n\n  struct ValidateLiquidationCallLocalVars {\n    bool collateralReserveActive;\n    bool collateralReservePaused;\n    bool principalReserveActive;\n    bool principalReservePaused;\n    bool isCollateralEnabled;\n  }\n\n  /**\n   * @notice Validates the liquidation action.\n   * @param userConfig The user configuration mapping\n   * @param collateralReserve The reserve data of the collateral\n   * @param params Additional parameters needed for the validation\n   */\n  function validateLiquidationCall(\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.ReserveData storage collateralReserve,\n    DataTypes.ValidateLiquidationCallParams memory params\n  ) internal view {\n    ValidateLiquidationCallLocalVars memory vars;\n\n    (vars.collateralReserveActive, , , , vars.collateralReservePaused) = collateralReserve\n      .configuration\n      .getFlags();\n\n    (vars.principalReserveActive, , , , vars.principalReservePaused) = params\n      .debtReserveCache\n      .reserveConfiguration\n      .getFlags();\n\n    require(vars.collateralReserveActive && vars.principalReserveActive, Errors.RESERVE_INACTIVE);\n    require(!vars.collateralReservePaused && !vars.principalReservePaused, Errors.RESERVE_PAUSED);\n\n    require(\n      params.priceOracleSentinel == address(0) ||\n        params.healthFactor < MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD ||\n        IPriceOracleSentinel(params.priceOracleSentinel).isLiquidationAllowed(),\n      Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n    );\n\n    require(\n      params.healthFactor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.HEALTH_FACTOR_NOT_BELOW_THRESHOLD\n    );\n\n    vars.isCollateralEnabled =\n      collateralReserve.configuration.getLiquidationThreshold() != 0 &&\n      userConfig.isUsingAsCollateral(collateralReserve.id);\n\n    //if collateral isn't enabled as collateral by user, it cannot be liquidated\n    require(vars.isCollateralEnabled, Errors.COLLATERAL_CANNOT_BE_LIQUIDATED);\n    require(params.totalDebt != 0, Errors.SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER);\n  }\n\n  /**\n   * @notice Validates the health factor of a user.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param userConfig The state of the user for the specific reserve\n   * @param user The user to validate health factor of\n   * @param userEModeCategory The users active efficiency mode category\n   * @param reservesCount The number of available reserves\n   * @param oracle The price oracle\n   */\n  function validateHealthFactor(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.UserConfigurationMap memory userConfig,\n    address user,\n    uint8 userEModeCategory,\n    uint256 reservesCount,\n    address oracle\n  ) internal view returns (uint256, bool) {\n    (, , , , uint256 healthFactor, bool hasZeroLtvCollateral) = GenericLogic\n      .calculateUserAccountData(\n        reservesData,\n        reservesList,\n        eModeCategories,\n        DataTypes.CalculateUserAccountDataParams({\n          userConfig: userConfig,\n          reservesCount: reservesCount,\n          user: user,\n          oracle: oracle,\n          userEModeCategory: userEModeCategory\n        })\n      );\n\n    require(\n      healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    return (healthFactor, hasZeroLtvCollateral);\n  }\n\n  /**\n   * @notice Validates the health factor of a user and the ltv of the asset being withdrawn.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories The configuration of all the efficiency mode categories\n   * @param userConfig The state of the user for the specific reserve\n   * @param asset The asset for which the ltv will be validated\n   * @param from The user from which the aTokens are being transferred\n   * @param reservesCount The number of available reserves\n   * @param oracle The price oracle\n   * @param userEModeCategory The users active efficiency mode category\n   */\n  function validateHFAndLtv(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.UserConfigurationMap memory userConfig,\n    address asset,\n    address from,\n    uint256 reservesCount,\n    address oracle,\n    uint8 userEModeCategory\n  ) internal view {\n    DataTypes.ReserveData memory reserve = reservesData[asset];\n\n    (, bool hasZeroLtvCollateral) = validateHealthFactor(\n      reservesData,\n      reservesList,\n      eModeCategories,\n      userConfig,\n      from,\n      userEModeCategory,\n      reservesCount,\n      oracle\n    );\n\n    require(\n      !hasZeroLtvCollateral || reserve.configuration.getLtv() == 0,\n      Errors.LTV_VALIDATION_FAILED\n    );\n  }\n\n  /**\n   * @notice Validates a transfer action.\n   * @param reserve The reserve object\n   */\n  function validateTransfer(DataTypes.ReserveData storage reserve) internal view {\n    require(!reserve.configuration.getPaused(), Errors.RESERVE_PAUSED);\n  }\n\n  /**\n   * @notice Validates a drop reserve action.\n   * @param reservesList The addresses of all the active reserves\n   * @param reserve The reserve object\n   * @param asset The address of the reserve's underlying asset\n   */\n  function validateDropReserve(\n    mapping(uint256 => address) storage reservesList,\n    DataTypes.ReserveData storage reserve,\n    address asset\n  ) internal view {\n    require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n    require(reserve.id != 0 || reservesList[0] == asset, Errors.ASSET_NOT_LISTED);\n    require(IERC20(reserve.stableDebtTokenAddress).totalSupply() == 0, Errors.STABLE_DEBT_NOT_ZERO);\n    require(\n      IERC20(reserve.variableDebtTokenAddress).totalSupply() == 0,\n      Errors.VARIABLE_DEBT_SUPPLY_NOT_ZERO\n    );\n    require(\n      IERC20(reserve.aTokenAddress).totalSupply() == 0 && reserve.accruedToTreasury == 0,\n      Errors.UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO\n    );\n  }\n\n  /**\n   * @notice Validates the action of setting efficiency mode.\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param eModeCategories a mapping storing configurations for all efficiency mode categories\n   * @param userConfig the user configuration\n   * @param reservesCount The total number of valid reserves\n   * @param categoryId The id of the category\n   */\n  function validateSetUserEMode(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    mapping(uint8 => DataTypes.EModeCategory) storage eModeCategories,\n    DataTypes.UserConfigurationMap memory userConfig,\n    uint256 reservesCount,\n    uint8 categoryId\n  ) internal view {\n    // category is invalid if the liq threshold is not set\n    require(\n      categoryId == 0 || eModeCategories[categoryId].liquidationThreshold != 0,\n      Errors.INCONSISTENT_EMODE_CATEGORY\n    );\n\n    //eMode can always be enabled if the user hasn't supplied anything\n    if (userConfig.isEmpty()) {\n      return;\n    }\n\n    // if user is trying to set another category than default we require that\n    // either the user is not borrowing, or it's borrowing assets of categoryId\n    if (categoryId != 0) {\n      unchecked {\n        for (uint256 i = 0; i < reservesCount; i++) {\n          if (userConfig.isBorrowing(i)) {\n            DataTypes.ReserveConfigurationMap memory configuration = reservesData[reservesList[i]]\n              .configuration;\n            require(\n              configuration.getEModeCategory() == categoryId,\n              Errors.INCONSISTENT_EMODE_CATEGORY\n            );\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Validates if an asset can be activated as collateral in the following actions: supply, transfer,\n   * set as collateral, mint unbacked, and liquidate\n   * @dev This is used to ensure that the constraints for isolated assets are respected by all the actions that\n   * generate transfers of aTokens\n   * @param reservesData The state of all the reserves\n   * @param reservesList The addresses of all the active reserves\n   * @param userConfig the user configuration\n   * @param reserveConfig The reserve configuration\n   * @return True if the asset can be activated as collateral, false otherwise\n   */\n  function validateUseAsCollateral(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.ReserveConfigurationMap memory reserveConfig\n  ) internal view returns (bool) {\n    if (!userConfig.isUsingAsCollateralAny()) {\n      return true;\n    }\n    (bool isolationModeActive, , ) = userConfig.getIsolationModeState(reservesData, reservesList);\n\n    return (!isolationModeActive && reserveConfig.getDebtCeiling() == 0);\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/math/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {WadRayMath} from './WadRayMath.sol';\n\n/**\n * @title MathUtils library\n * @author Aave\n * @notice Provides functions to perform linear and compounded interest calculations\n */\nlibrary MathUtils {\n  using WadRayMath for uint256;\n\n  /// @dev Ignoring leap years\n  uint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n  /**\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\n   * @param rate The interest rate, in ray\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\n   * @return The interest rate linearly accumulated during the timeDelta, in ray\n   */\n  function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp)\n    internal\n    view\n    returns (uint256)\n  {\n    //solium-disable-next-line\n    uint256 result = rate * (block.timestamp - uint256(lastUpdateTimestamp));\n    unchecked {\n      result = result / SECONDS_PER_YEAR;\n    }\n\n    return WadRayMath.RAY + result;\n  }\n\n  /**\n   * @dev Function to calculate the interest using a compounded interest rate formula\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n   *\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n   *\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great\n   * gas cost reductions. The whitepaper contains reference to the approximation and a table showing the margin of\n   * error per different time periods\n   *\n   * @param rate The interest rate, in ray\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\n   * @return The interest rate compounded during the timeDelta, in ray\n   */\n  function calculateCompoundedInterest(\n    uint256 rate,\n    uint40 lastUpdateTimestamp,\n    uint256 currentTimestamp\n  ) internal pure returns (uint256) {\n    //solium-disable-next-line\n    uint256 exp = currentTimestamp - uint256(lastUpdateTimestamp);\n\n    if (exp == 0) {\n      return WadRayMath.RAY;\n    }\n\n    uint256 expMinusOne;\n    uint256 expMinusTwo;\n    uint256 basePowerTwo;\n    uint256 basePowerThree;\n    unchecked {\n      expMinusOne = exp - 1;\n\n      expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n      basePowerTwo = rate.rayMul(rate) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR);\n      basePowerThree = basePowerTwo.rayMul(rate) / SECONDS_PER_YEAR;\n    }\n\n    uint256 secondTerm = exp * expMinusOne * basePowerTwo;\n    unchecked {\n      secondTerm /= 2;\n    }\n    uint256 thirdTerm = exp * expMinusOne * expMinusTwo * basePowerThree;\n    unchecked {\n      thirdTerm /= 6;\n    }\n\n    return WadRayMath.RAY + (rate * exp) / SECONDS_PER_YEAR + secondTerm + thirdTerm;\n  }\n\n  /**\n   * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\n   * @param rate The interest rate (in ray)\n   * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\n   * @return The interest rate compounded between lastUpdateTimestamp and current block timestamp, in ray\n   */\n  function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp)\n    internal\n    view\n    returns (uint256)\n  {\n    return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/math/PercentageMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n */\nlibrary PercentageMath {\n  // Maximum percentage factor (100.00%)\n  uint256 internal constant PERCENTAGE_FACTOR = 1e4;\n\n  // Half percentage factor (50.00%)\n  uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\n\n  /**\n   * @notice Executes a percentage multiplication\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return result value percentmul percentage\n   */\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n    // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage\n    assembly {\n      if iszero(\n        or(\n          iszero(percentage),\n          iszero(gt(value, div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage)))\n        )\n      ) {\n        revert(0, 0)\n      }\n\n      result := div(add(mul(value, percentage), HALF_PERCENTAGE_FACTOR), PERCENTAGE_FACTOR)\n    }\n  }\n\n  /**\n   * @notice Executes a percentage division\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return result value percentdiv percentage\n   */\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n    // to avoid overflow, value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR\n    assembly {\n      if or(\n        iszero(percentage),\n        iszero(iszero(gt(value, div(sub(not(0), div(percentage, 2)), PERCENTAGE_FACTOR))))\n      ) {\n        revert(0, 0)\n      }\n\n      result := div(add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)), percentage)\n    }\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @notice Provides functions to perform calculations with Wad and Ray units\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\n * with 27 digits of precision)\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n */\nlibrary WadRayMath {\n  // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\n  uint256 internal constant WAD = 1e18;\n  uint256 internal constant HALF_WAD = 0.5e18;\n\n  uint256 internal constant RAY = 1e27;\n  uint256 internal constant HALF_RAY = 0.5e27;\n\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n  /**\n   * @dev Multiplies two wad, rounding half up to the nearest wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @param b Wad\n   * @return c = a*b, in wad\n   */\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\n    assembly {\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, b), HALF_WAD), WAD)\n    }\n  }\n\n  /**\n   * @dev Divides two wad, rounding half up to the nearest wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @param b Wad\n   * @return c = a/b, in wad\n   */\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\n    assembly {\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, WAD), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @notice Multiplies two ray, rounding half up to the nearest ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @param b Ray\n   * @return c = a raymul b\n   */\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\n    assembly {\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, b), HALF_RAY), RAY)\n    }\n  }\n\n  /**\n   * @notice Divides two ray, rounding half up to the nearest ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @param b Ray\n   * @return c = a raydiv b\n   */\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n    assembly {\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, RAY), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @dev Casts ray down to wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @return b = a converted to wad, rounded half up to the nearest wad\n   */\n  function rayToWad(uint256 a) internal pure returns (uint256 b) {\n    assembly {\n      b := div(a, WAD_RAY_RATIO)\n      let remainder := mod(a, WAD_RAY_RATIO)\n      if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\n        b := add(b, 1)\n      }\n    }\n  }\n\n  /**\n   * @dev Converts wad up to ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @return b = a converted in ray\n   */\n  function wadToRay(uint256 a) internal pure returns (uint256 b) {\n    // to avoid overflow, b/WAD_RAY_RATIO == a\n    assembly {\n      b := mul(a, WAD_RAY_RATIO)\n\n      if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\n        revert(0, 0)\n      }\n    }\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/types/ConfiguratorInputTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary ConfiguratorInputTypes {\n  struct InitReserveInput {\n    address aTokenImpl;\n    address stableDebtTokenImpl;\n    address variableDebtTokenImpl;\n    uint8 underlyingAssetDecimals;\n    address interestRateStrategyAddress;\n    address underlyingAsset;\n    address treasury;\n    address incentivesController;\n    string aTokenName;\n    string aTokenSymbol;\n    string variableDebtTokenName;\n    string variableDebtTokenSymbol;\n    string stableDebtTokenName;\n    string stableDebtTokenSymbol;\n    bytes params;\n  }\n\n  struct UpdateATokenInput {\n    address asset;\n    address treasury;\n    address incentivesController;\n    string name;\n    string symbol;\n    address implementation;\n    bytes params;\n  }\n\n  struct UpdateDebtTokenInput {\n    address asset;\n    address incentivesController;\n    string name;\n    string symbol;\n    address implementation;\n    bytes params;\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62-63: reserved\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/pool/Pool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol';\nimport {PoolLogic} from '../libraries/logic/PoolLogic.sol';\nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol';\nimport {EModeLogic} from '../libraries/logic/EModeLogic.sol';\nimport {SupplyLogic} from '../libraries/logic/SupplyLogic.sol';\nimport {FlashLoanLogic} from '../libraries/logic/FlashLoanLogic.sol';\nimport {BorrowLogic} from '../libraries/logic/BorrowLogic.sol';\nimport {LiquidationLogic} from '../libraries/logic/LiquidationLogic.sol';\nimport {DataTypes} from '../libraries/types/DataTypes.sol';\nimport {BridgeLogic} from '../libraries/logic/BridgeLogic.sol';\nimport {IERC20WithPermit} from '../../interfaces/IERC20WithPermit.sol';\nimport {IPoolAddressesProvider} from '../../interfaces/IPoolAddressesProvider.sol';\nimport {IPool} from '../../interfaces/IPool.sol';\nimport {IACLManager} from '../../interfaces/IACLManager.sol';\nimport {PoolStorage} from './PoolStorage.sol';\n\n/**\n * @title Pool contract\n * @author Aave\n * @notice Main point of interaction with an Aave protocol's market\n * - Users can:\n *   # Supply\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Swap their loans between variable and stable rate\n *   # Enable/disable their supplied assets as collateral rebalance stable rate borrow positions\n *   # Liquidate positions\n *   # Execute Flash Loans\n * @dev To be covered by a proxy contract, owned by the PoolAddressesProvider of the specific market\n * @dev All admin functions are callable by the PoolConfigurator contract defined also in the\n *   PoolAddressesProvider\n */\ncontract Pool is VersionedInitializable, PoolStorage, IPool {\n  using ReserveLogic for DataTypes.ReserveData;\n\n  uint256 public constant POOL_REVISION = 0x1;\n  IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n  /**\n   * @dev Only pool configurator can call functions marked by this modifier.\n   */\n  modifier onlyPoolConfigurator() {\n    _onlyPoolConfigurator();\n    _;\n  }\n\n  /**\n   * @dev Only pool admin can call functions marked by this modifier.\n   */\n  modifier onlyPoolAdmin() {\n    _onlyPoolAdmin();\n    _;\n  }\n\n  /**\n   * @dev Only bridge can call functions marked by this modifier.\n   */\n  modifier onlyBridge() {\n    _onlyBridge();\n    _;\n  }\n\n  function _onlyPoolConfigurator() internal view virtual {\n    require(\n      ADDRESSES_PROVIDER.getPoolConfigurator() == msg.sender,\n      Errors.CALLER_NOT_POOL_CONFIGURATOR\n    );\n  }\n\n  function _onlyPoolAdmin() internal view virtual {\n    require(\n      IACLManager(ADDRESSES_PROVIDER.getACLManager()).isPoolAdmin(msg.sender),\n      Errors.CALLER_NOT_POOL_ADMIN\n    );\n  }\n\n  function _onlyBridge() internal view virtual {\n    require(\n      IACLManager(ADDRESSES_PROVIDER.getACLManager()).isBridge(msg.sender),\n      Errors.CALLER_NOT_BRIDGE\n    );\n  }\n\n  function getRevision() internal pure virtual override returns (uint256) {\n    return POOL_REVISION;\n  }\n\n  /**\n   * @dev Constructor.\n   * @param provider The address of the PoolAddressesProvider contract\n   */\n  constructor(IPoolAddressesProvider provider) {\n    ADDRESSES_PROVIDER = provider;\n  }\n\n  /**\n   * @notice Initializes the Pool.\n   * @dev Function is invoked by the proxy contract when the Pool contract is added to the\n   * PoolAddressesProvider of the market.\n   * @dev Caching the address of the PoolAddressesProvider in order to reduce gas consumption on subsequent operations\n   * @param provider The address of the PoolAddressesProvider\n   */\n  function initialize(IPoolAddressesProvider provider) external virtual initializer {\n    require(provider == ADDRESSES_PROVIDER, Errors.INVALID_ADDRESSES_PROVIDER);\n    _maxStableRateBorrowSizePercent = 0.25e4;\n    _flashLoanPremiumTotal = 0.0009e4;\n    _flashLoanPremiumToProtocol = 0;\n  }\n\n  /// @inheritdoc IPool\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external virtual override onlyBridge {\n    BridgeLogic.executeMintUnbacked(\n      _reserves,\n      _reservesList,\n      _usersConfig[onBehalfOf],\n      asset,\n      amount,\n      onBehalfOf,\n      referralCode\n    );\n  }\n\n  /// @inheritdoc IPool\n  function backUnbacked(\n    address asset,\n    uint256 amount,\n    uint256 fee\n  ) external virtual override onlyBridge returns (uint256) {\n    return\n      BridgeLogic.executeBackUnbacked(_reserves[asset], asset, amount, fee, _bridgeProtocolFee);\n  }\n\n  /// @inheritdoc IPool\n  function supply(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) public virtual override {\n    SupplyLogic.executeSupply(\n      _reserves,\n      _reservesList,\n      _usersConfig[onBehalfOf],\n      DataTypes.ExecuteSupplyParams({\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /// @inheritdoc IPool\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) public virtual override {\n    IERC20WithPermit(asset).permit(\n      msg.sender,\n      address(this),\n      amount,\n      deadline,\n      permitV,\n      permitR,\n      permitS\n    );\n    SupplyLogic.executeSupply(\n      _reserves,\n      _reservesList,\n      _usersConfig[onBehalfOf],\n      DataTypes.ExecuteSupplyParams({\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n\n  /// @inheritdoc IPool\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) public virtual override returns (uint256) {\n    return\n      SupplyLogic.executeWithdraw(\n        _reserves,\n        _reservesList,\n        _eModeCategories,\n        _usersConfig[msg.sender],\n        DataTypes.ExecuteWithdrawParams({\n          asset: asset,\n          amount: amount,\n          to: to,\n          reservesCount: _reservesCount,\n          oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n          userEModeCategory: _usersEModeCategory[msg.sender]\n        })\n      );\n  }\n\n  /// @inheritdoc IPool\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) public virtual override {\n    BorrowLogic.executeBorrow(\n      _reserves,\n      _reservesList,\n      _eModeCategories,\n      _usersConfig[onBehalfOf],\n      DataTypes.ExecuteBorrowParams({\n        asset: asset,\n        user: msg.sender,\n        onBehalfOf: onBehalfOf,\n        amount: amount,\n        interestRateMode: DataTypes.InterestRateMode(interestRateMode),\n        referralCode: referralCode,\n        releaseUnderlying: true,\n        maxStableRateBorrowSizePercent: _maxStableRateBorrowSizePercent,\n        reservesCount: _reservesCount,\n        oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n        userEModeCategory: _usersEModeCategory[onBehalfOf],\n        priceOracleSentinel: ADDRESSES_PROVIDER.getPriceOracleSentinel()\n      })\n    );\n  }\n\n  /// @inheritdoc IPool\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) public virtual override returns (uint256) {\n    return\n      BorrowLogic.executeRepay(\n        _reserves,\n        _reservesList,\n        _usersConfig[onBehalfOf],\n        DataTypes.ExecuteRepayParams({\n          asset: asset,\n          amount: amount,\n          interestRateMode: DataTypes.InterestRateMode(interestRateMode),\n          onBehalfOf: onBehalfOf,\n          useATokens: false\n        })\n      );\n  }\n\n  /// @inheritdoc IPool\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) public virtual override returns (uint256) {\n    {\n      IERC20WithPermit(asset).permit(\n        msg.sender,\n        address(this),\n        amount,\n        deadline,\n        permitV,\n        permitR,\n        permitS\n      );\n    }\n    {\n      DataTypes.ExecuteRepayParams memory params = DataTypes.ExecuteRepayParams({\n        asset: asset,\n        amount: amount,\n        interestRateMode: DataTypes.InterestRateMode(interestRateMode),\n        onBehalfOf: onBehalfOf,\n        useATokens: false\n      });\n      return BorrowLogic.executeRepay(_reserves, _reservesList, _usersConfig[onBehalfOf], params);\n    }\n  }\n\n  /// @inheritdoc IPool\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) public virtual override returns (uint256) {\n    return\n      BorrowLogic.executeRepay(\n        _reserves,\n        _reservesList,\n        _usersConfig[msg.sender],\n        DataTypes.ExecuteRepayParams({\n          asset: asset,\n          amount: amount,\n          interestRateMode: DataTypes.InterestRateMode(interestRateMode),\n          onBehalfOf: msg.sender,\n          useATokens: true\n        })\n      );\n  }\n\n  /// @inheritdoc IPool\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) public virtual override {\n    BorrowLogic.executeSwapBorrowRateMode(\n      _reserves[asset],\n      _usersConfig[msg.sender],\n      asset,\n      DataTypes.InterestRateMode(interestRateMode)\n    );\n  }\n\n  /// @inheritdoc IPool\n  function rebalanceStableBorrowRate(address asset, address user) public virtual override {\n    BorrowLogic.executeRebalanceStableBorrowRate(_reserves[asset], asset, user);\n  }\n\n  /// @inheritdoc IPool\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\n    public\n    virtual\n    override\n  {\n    SupplyLogic.executeUseReserveAsCollateral(\n      _reserves,\n      _reservesList,\n      _eModeCategories,\n      _usersConfig[msg.sender],\n      asset,\n      useAsCollateral,\n      _reservesCount,\n      ADDRESSES_PROVIDER.getPriceOracle(),\n      _usersEModeCategory[msg.sender]\n    );\n  }\n\n  /// @inheritdoc IPool\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) public virtual override {\n    LiquidationLogic.executeLiquidationCall(\n      _reserves,\n      _reservesList,\n      _usersConfig,\n      _eModeCategories,\n      DataTypes.ExecuteLiquidationCallParams({\n        reservesCount: _reservesCount,\n        debtToCover: debtToCover,\n        collateralAsset: collateralAsset,\n        debtAsset: debtAsset,\n        user: user,\n        receiveAToken: receiveAToken,\n        priceOracle: ADDRESSES_PROVIDER.getPriceOracle(),\n        userEModeCategory: _usersEModeCategory[user],\n        priceOracleSentinel: ADDRESSES_PROVIDER.getPriceOracleSentinel()\n      })\n    );\n  }\n\n  /// @inheritdoc IPool\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) public virtual override {\n    DataTypes.FlashloanParams memory flashParams = DataTypes.FlashloanParams({\n      receiverAddress: receiverAddress,\n      assets: assets,\n      amounts: amounts,\n      interestRateModes: interestRateModes,\n      onBehalfOf: onBehalfOf,\n      params: params,\n      referralCode: referralCode,\n      flashLoanPremiumToProtocol: _flashLoanPremiumToProtocol,\n      flashLoanPremiumTotal: _flashLoanPremiumTotal,\n      maxStableRateBorrowSizePercent: _maxStableRateBorrowSizePercent,\n      reservesCount: _reservesCount,\n      addressesProvider: address(ADDRESSES_PROVIDER),\n      userEModeCategory: _usersEModeCategory[onBehalfOf],\n      isAuthorizedFlashBorrower: IACLManager(ADDRESSES_PROVIDER.getACLManager()).isFlashBorrower(\n        msg.sender\n      )\n    });\n\n    FlashLoanLogic.executeFlashLoan(\n      _reserves,\n      _reservesList,\n      _eModeCategories,\n      _usersConfig[onBehalfOf],\n      flashParams\n    );\n  }\n\n  /// @inheritdoc IPool\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) public virtual override {\n    DataTypes.FlashloanSimpleParams memory flashParams = DataTypes.FlashloanSimpleParams({\n      receiverAddress: receiverAddress,\n      asset: asset,\n      amount: amount,\n      params: params,\n      referralCode: referralCode,\n      flashLoanPremiumToProtocol: _flashLoanPremiumToProtocol,\n      flashLoanPremiumTotal: _flashLoanPremiumTotal\n    });\n    FlashLoanLogic.executeFlashLoanSimple(_reserves[asset], flashParams);\n  }\n\n  /// @inheritdoc IPool\n  function mintToTreasury(address[] calldata assets) external virtual override {\n    PoolLogic.executeMintToTreasury(_reserves, assets);\n  }\n\n  /// @inheritdoc IPool\n  function getReserveData(address asset)\n    external\n    view\n    virtual\n    override\n    returns (DataTypes.ReserveData memory)\n  {\n    return _reserves[asset];\n  }\n\n  /// @inheritdoc IPool\n  function getUserAccountData(address user)\n    external\n    view\n    virtual\n    override\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    )\n  {\n    return\n      PoolLogic.executeGetUserAccountData(\n        _reserves,\n        _reservesList,\n        _eModeCategories,\n        DataTypes.CalculateUserAccountDataParams({\n          userConfig: _usersConfig[user],\n          reservesCount: _reservesCount,\n          user: user,\n          oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n          userEModeCategory: _usersEModeCategory[user]\n        })\n      );\n  }\n\n  /// @inheritdoc IPool\n  function getConfiguration(address asset)\n    external\n    view\n    virtual\n    override\n    returns (DataTypes.ReserveConfigurationMap memory)\n  {\n    return _reserves[asset].configuration;\n  }\n\n  /// @inheritdoc IPool\n  function getUserConfiguration(address user)\n    external\n    view\n    virtual\n    override\n    returns (DataTypes.UserConfigurationMap memory)\n  {\n    return _usersConfig[user];\n  }\n\n  /// @inheritdoc IPool\n  function getReserveNormalizedIncome(address asset)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /// @inheritdoc IPool\n  function getReserveNormalizedVariableDebt(address asset)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _reserves[asset].getNormalizedDebt();\n  }\n\n  /// @inheritdoc IPool\n  function getReservesList() external view virtual override returns (address[] memory) {\n    uint256 reservesListCount = _reservesCount;\n    uint256 droppedReservesCount = 0;\n    address[] memory reservesList = new address[](reservesListCount);\n\n    for (uint256 i = 0; i < reservesListCount; i++) {\n      if (_reservesList[i] != address(0)) {\n        reservesList[i - droppedReservesCount] = _reservesList[i];\n      } else {\n        droppedReservesCount++;\n      }\n    }\n\n    // Reduces the length of the reserves array by `droppedReservesCount`\n    assembly {\n      mstore(reservesList, sub(reservesListCount, droppedReservesCount))\n    }\n    return reservesList;\n  }\n\n  /// @inheritdoc IPool\n  function getReserveAddressById(uint16 id) external view returns (address) {\n    return _reservesList[id];\n  }\n\n  /// @inheritdoc IPool\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() public view virtual override returns (uint256) {\n    return _maxStableRateBorrowSizePercent;\n  }\n\n  /// @inheritdoc IPool\n  function BRIDGE_PROTOCOL_FEE() public view virtual override returns (uint256) {\n    return _bridgeProtocolFee;\n  }\n\n  /// @inheritdoc IPool\n  function FLASHLOAN_PREMIUM_TOTAL() public view virtual override returns (uint128) {\n    return _flashLoanPremiumTotal;\n  }\n\n  /// @inheritdoc IPool\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() public view virtual override returns (uint128) {\n    return _flashLoanPremiumToProtocol;\n  }\n\n  /// @inheritdoc IPool\n  function MAX_NUMBER_RESERVES() public view virtual override returns (uint16) {\n    return ReserveConfiguration.MAX_RESERVES_COUNT;\n  }\n\n  /// @inheritdoc IPool\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external virtual override {\n    require(msg.sender == _reserves[asset].aTokenAddress, Errors.CALLER_NOT_ATOKEN);\n    SupplyLogic.executeFinalizeTransfer(\n      _reserves,\n      _reservesList,\n      _eModeCategories,\n      _usersConfig,\n      DataTypes.FinalizeTransferParams({\n        asset: asset,\n        from: from,\n        to: to,\n        amount: amount,\n        balanceFromBefore: balanceFromBefore,\n        balanceToBefore: balanceToBefore,\n        reservesCount: _reservesCount,\n        oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n        fromEModeCategory: _usersEModeCategory[from]\n      })\n    );\n  }\n\n  /// @inheritdoc IPool\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external virtual override onlyPoolConfigurator {\n    if (\n      PoolLogic.executeInitReserve(\n        _reserves,\n        _reservesList,\n        DataTypes.InitReserveParams({\n          asset: asset,\n          aTokenAddress: aTokenAddress,\n          stableDebtAddress: stableDebtAddress,\n          variableDebtAddress: variableDebtAddress,\n          interestRateStrategyAddress: interestRateStrategyAddress,\n          reservesCount: _reservesCount,\n          maxNumberReserves: MAX_NUMBER_RESERVES()\n        })\n      )\n    ) {\n      _reservesCount++;\n    }\n  }\n\n  /// @inheritdoc IPool\n  function dropReserve(address asset) external virtual override onlyPoolConfigurator {\n    PoolLogic.executeDropReserve(_reserves, _reservesList, asset);\n  }\n\n  /// @inheritdoc IPool\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\n    external\n    virtual\n    override\n    onlyPoolConfigurator\n  {\n    require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n    require(_reserves[asset].id != 0 || _reservesList[0] == asset, Errors.ASSET_NOT_LISTED);\n    _reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\n  }\n\n  /// @inheritdoc IPool\n  function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration)\n    external\n    virtual\n    override\n    onlyPoolConfigurator\n  {\n    require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n    require(_reserves[asset].id != 0 || _reservesList[0] == asset, Errors.ASSET_NOT_LISTED);\n    _reserves[asset].configuration = configuration;\n  }\n\n  /// @inheritdoc IPool\n  function updateBridgeProtocolFee(uint256 protocolFee)\n    external\n    virtual\n    override\n    onlyPoolConfigurator\n  {\n    _bridgeProtocolFee = protocolFee;\n  }\n\n  /// @inheritdoc IPool\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external virtual override onlyPoolConfigurator {\n    _flashLoanPremiumTotal = flashLoanPremiumTotal;\n    _flashLoanPremiumToProtocol = flashLoanPremiumToProtocol;\n  }\n\n  /// @inheritdoc IPool\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory category)\n    external\n    virtual\n    override\n    onlyPoolConfigurator\n  {\n    // category 0 is reserved for volatile heterogeneous assets and it's always disabled\n    require(id != 0, Errors.EMODE_CATEGORY_RESERVED);\n    _eModeCategories[id] = category;\n  }\n\n  /// @inheritdoc IPool\n  function getEModeCategoryData(uint8 id)\n    external\n    view\n    virtual\n    override\n    returns (DataTypes.EModeCategory memory)\n  {\n    return _eModeCategories[id];\n  }\n\n  /// @inheritdoc IPool\n  function setUserEMode(uint8 categoryId) external virtual override {\n    EModeLogic.executeSetUserEMode(\n      _reserves,\n      _reservesList,\n      _eModeCategories,\n      _usersEModeCategory,\n      _usersConfig[msg.sender],\n      DataTypes.ExecuteSetUserEModeParams({\n        reservesCount: _reservesCount,\n        oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n        categoryId: categoryId\n      })\n    );\n  }\n\n  /// @inheritdoc IPool\n  function getUserEMode(address user) external view virtual override returns (uint256) {\n    return _usersEModeCategory[user];\n  }\n\n  /// @inheritdoc IPool\n  function resetIsolationModeTotalDebt(address asset)\n    external\n    virtual\n    override\n    onlyPoolConfigurator\n  {\n    PoolLogic.executeResetIsolationModeTotalDebt(_reserves, asset);\n  }\n\n  /// @inheritdoc IPool\n  function rescueTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external virtual override onlyPoolAdmin {\n    PoolLogic.executeRescueTokens(token, to, amount);\n  }\n\n  /// @inheritdoc IPool\n  /// @dev Deprecated: maintained for compatibility purposes\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external virtual override {\n    SupplyLogic.executeSupply(\n      _reserves,\n      _reservesList,\n      _usersConfig[onBehalfOf],\n      DataTypes.ExecuteSupplyParams({\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/pool/PoolStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {UserConfiguration} from '../libraries/configuration/UserConfiguration.sol';\nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol';\nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol';\nimport {DataTypes} from '../libraries/types/DataTypes.sol';\n\n/**\n * @title PoolStorage\n * @author Aave\n * @notice Contract used as storage of the Pool contract.\n * @dev It defines the storage layout of the Pool contract.\n */\ncontract PoolStorage {\n  using ReserveLogic for DataTypes.ReserveData;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n\n  // Map of reserves and their data (underlyingAssetOfReserve => reserveData)\n  mapping(address => DataTypes.ReserveData) internal _reserves;\n\n  // Map of users address and their configuration data (userAddress => userConfiguration)\n  mapping(address => DataTypes.UserConfigurationMap) internal _usersConfig;\n\n  // List of reserves as a map (reserveId => reserve).\n  // It is structured as a mapping for gas savings reasons, using the reserve id as index\n  mapping(uint256 => address) internal _reservesList;\n\n  // List of eMode categories as a map (eModeCategoryId => eModeCategory).\n  // It is structured as a mapping for gas savings reasons, using the eModeCategoryId as index\n  mapping(uint8 => DataTypes.EModeCategory) internal _eModeCategories;\n\n  // Map of users address and their eMode category (userAddress => eModeCategoryId)\n  mapping(address => uint8) internal _usersEModeCategory;\n\n  // Fee of the protocol bridge, expressed in bps\n  uint256 internal _bridgeProtocolFee;\n\n  // Total FlashLoan Premium, expressed in bps\n  uint128 internal _flashLoanPremiumTotal;\n\n  // FlashLoan premium paid to protocol treasury, expressed in bps\n  uint128 internal _flashLoanPremiumToProtocol;\n\n  // Available liquidity that can be borrowed at once at stable rate, expressed in bps\n  uint64 internal _maxStableRateBorrowSizePercent;\n\n  // Maximum number of active reserves there have been in the protocol. It is the upper bound of the reserves list\n  uint16 internal _reservesCount;\n}\n"
    },
    "@aave/core-v3/contracts/protocol/tokenization/base/DebtTokenBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {Context} from '../../../dependencies/openzeppelin/contracts/Context.sol';\nimport {Errors} from '../../libraries/helpers/Errors.sol';\nimport {VersionedInitializable} from '../../libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {ICreditDelegationToken} from '../../../interfaces/ICreditDelegationToken.sol';\nimport {EIP712Base} from './EIP712Base.sol';\n\n/**\n * @title DebtTokenBase\n * @author Aave\n * @notice Base contract for different types of debt tokens, like StableDebtToken or VariableDebtToken\n */\nabstract contract DebtTokenBase is\n  VersionedInitializable,\n  EIP712Base,\n  Context,\n  ICreditDelegationToken\n{\n  // Map of borrow allowances (delegator => delegatee => borrowAllowanceAmount)\n  mapping(address => mapping(address => uint256)) internal _borrowAllowances;\n\n  // Credit Delegation Typehash\n  bytes32 public constant DELEGATION_WITH_SIG_TYPEHASH =\n    keccak256('DelegationWithSig(address delegatee,uint256 value,uint256 nonce,uint256 deadline)');\n\n  address internal _underlyingAsset;\n\n  /**\n   * @dev Constructor.\n   */\n  constructor() EIP712Base() {\n    // Intentionally left blank\n  }\n\n  /// @inheritdoc ICreditDelegationToken\n  function approveDelegation(address delegatee, uint256 amount) external override {\n    _approveDelegation(_msgSender(), delegatee, amount);\n  }\n\n  /// @inheritdoc ICreditDelegationToken\n  function delegationWithSig(\n    address delegator,\n    address delegatee,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    require(delegator != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n    //solium-disable-next-line\n    require(block.timestamp <= deadline, Errors.INVALID_EXPIRATION);\n    uint256 currentValidNonce = _nonces[delegator];\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        '\\x19\\x01',\n        DOMAIN_SEPARATOR(),\n        keccak256(\n          abi.encode(DELEGATION_WITH_SIG_TYPEHASH, delegatee, value, currentValidNonce, deadline)\n        )\n      )\n    );\n    require(delegator == ecrecover(digest, v, r, s), Errors.INVALID_SIGNATURE);\n    _nonces[delegator] = currentValidNonce + 1;\n    _approveDelegation(delegator, delegatee, value);\n  }\n\n  /// @inheritdoc ICreditDelegationToken\n  function borrowAllowance(address fromUser, address toUser)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _borrowAllowances[fromUser][toUser];\n  }\n\n  /**\n   * @notice Updates the borrow allowance of a user on the specific debt token.\n   * @param delegator The address delegating the borrowing power\n   * @param delegatee The address receiving the delegated borrowing power\n   * @param amount The allowance amount being delegated.\n   */\n  function _approveDelegation(\n    address delegator,\n    address delegatee,\n    uint256 amount\n  ) internal {\n    _borrowAllowances[delegator][delegatee] = amount;\n    emit BorrowAllowanceDelegated(delegator, delegatee, _underlyingAsset, amount);\n  }\n\n  /**\n   * @notice Decreases the borrow allowance of a user on the specific debt token.\n   * @param delegator The address delegating the borrowing power\n   * @param delegatee The address receiving the delegated borrowing power\n   * @param amount The amount to subtract from the current allowance\n   */\n  function _decreaseBorrowAllowance(\n    address delegator,\n    address delegatee,\n    uint256 amount\n  ) internal {\n    uint256 newAllowance = _borrowAllowances[delegator][delegatee] - amount;\n\n    _borrowAllowances[delegator][delegatee] = newAllowance;\n\n    emit BorrowAllowanceDelegated(delegator, delegatee, _underlyingAsset, newAllowance);\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/tokenization/base/EIP712Base.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/**\n * @title EIP712Base\n * @author Aave\n * @notice Base contract implementation of EIP712.\n */\nabstract contract EIP712Base {\n  bytes public constant EIP712_REVISION = bytes('1');\n  bytes32 internal constant EIP712_DOMAIN =\n    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\n\n  // Map of address nonces (address => nonce)\n  mapping(address => uint256) internal _nonces;\n\n  bytes32 internal _domainSeparator;\n  uint256 internal immutable _chainId;\n\n  /**\n   * @dev Constructor.\n   */\n  constructor() {\n    _chainId = block.chainid;\n  }\n\n  /**\n   * @notice Get the domain separator for the token\n   * @dev Return cached value if chainId matches cache, otherwise recomputes separator\n   * @return The domain separator of the token at current chain\n   */\n  function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n    if (block.chainid == _chainId) {\n      return _domainSeparator;\n    }\n    return _calculateDomainSeparator();\n  }\n\n  /**\n   * @notice Returns the nonce value for address specified as parameter\n   * @param owner The address for which the nonce is being returned\n   * @return The nonce value for the input address`\n   */\n  function nonces(address owner) public view virtual returns (uint256) {\n    return _nonces[owner];\n  }\n\n  /**\n   * @notice Compute the current domain separator\n   * @return The domain separator for the token\n   */\n  function _calculateDomainSeparator() internal view returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          EIP712_DOMAIN,\n          keccak256(bytes(_EIP712BaseId())),\n          keccak256(EIP712_REVISION),\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  /**\n   * @notice Returns the user readable name of signing domain (e.g. token name)\n   * @return The name of the signing domain\n   */\n  function _EIP712BaseId() internal view virtual returns (string memory);\n}\n"
    },
    "@aave/core-v3/contracts/protocol/tokenization/base/IncentivizedERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {Context} from '../../../dependencies/openzeppelin/contracts/Context.sol';\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IERC20Detailed} from '../../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {SafeCast} from '../../../dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {WadRayMath} from '../../libraries/math/WadRayMath.sol';\nimport {Errors} from '../../libraries/helpers/Errors.sol';\nimport {IAaveIncentivesController} from '../../../interfaces/IAaveIncentivesController.sol';\nimport {IPoolAddressesProvider} from '../../../interfaces/IPoolAddressesProvider.sol';\nimport {IPool} from '../../../interfaces/IPool.sol';\nimport {IACLManager} from '../../../interfaces/IACLManager.sol';\n\n/**\n * @title IncentivizedERC20\n * @author Aave, inspired by the Openzeppelin ERC20 implementation\n * @notice Basic ERC20 implementation\n */\nabstract contract IncentivizedERC20 is Context, IERC20Detailed {\n  using WadRayMath for uint256;\n  using SafeCast for uint256;\n\n  /**\n   * @dev Only pool admin can call functions marked by this modifier.\n   */\n  modifier onlyPoolAdmin() {\n    IACLManager aclManager = IACLManager(_addressesProvider.getACLManager());\n    require(aclManager.isPoolAdmin(msg.sender), Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  /**\n   * @dev Only pool can call functions marked by this modifier.\n   */\n  modifier onlyPool() {\n    require(_msgSender() == address(POOL), Errors.CALLER_MUST_BE_POOL);\n    _;\n  }\n\n  /**\n   * @dev UserState - additionalData is a flexible field.\n   * ATokens and VariableDebtTokens use this field store the index of the\n   * user's last supply/withdrawal/borrow/repayment. StableDebtTokens use\n   * this field to store the user's stable rate.\n   */\n  struct UserState {\n    uint128 balance;\n    uint128 additionalData;\n  }\n  // Map of users address and their state data (userAddress => userStateData)\n  mapping(address => UserState) internal _userState;\n\n  // Map of allowances (delegator => delegatee => allowanceAmount)\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 internal _totalSupply;\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n  IAaveIncentivesController internal _incentivesController;\n  IPoolAddressesProvider internal immutable _addressesProvider;\n  IPool public immutable POOL;\n\n  /**\n   * @dev Constructor.\n   * @param pool The reference to the main Pool contract\n   * @param name The name of the token\n   * @param symbol The symbol of the token\n   * @param decimals The number of decimals of the token\n   */\n  constructor(\n    IPool pool,\n    string memory name,\n    string memory symbol,\n    uint8 decimals\n  ) {\n    _addressesProvider = pool.ADDRESSES_PROVIDER();\n    _name = name;\n    _symbol = symbol;\n    _decimals = decimals;\n    POOL = pool;\n  }\n\n  /// @inheritdoc IERC20Detailed\n  function name() public view override returns (string memory) {\n    return _name;\n  }\n\n  /// @inheritdoc IERC20Detailed\n  function symbol() external view override returns (string memory) {\n    return _symbol;\n  }\n\n  /// @inheritdoc IERC20Detailed\n  function decimals() external view override returns (uint8) {\n    return _decimals;\n  }\n\n  /// @inheritdoc IERC20\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /// @inheritdoc IERC20\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return _userState[account].balance;\n  }\n\n  /**\n   * @notice Returns the address of the Incentives Controller contract\n   * @return The address of the Incentives Controller\n   */\n  function getIncentivesController() external view virtual returns (IAaveIncentivesController) {\n    return _incentivesController;\n  }\n\n  /**\n   * @notice Sets a new Incentives Controller\n   * @param controller the new Incentives controller\n   */\n  function setIncentivesController(IAaveIncentivesController controller) external onlyPoolAdmin {\n    _incentivesController = controller;\n  }\n\n  /// @inheritdoc IERC20\n  function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n    uint128 castAmount = amount.toUint128();\n    _transfer(_msgSender(), recipient, castAmount);\n    return true;\n  }\n\n  /// @inheritdoc IERC20\n  function allowance(address owner, address spender)\n    external\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  /// @inheritdoc IERC20\n  function approve(address spender, uint256 amount) external virtual override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /// @inheritdoc IERC20\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external virtual override returns (bool) {\n    uint128 castAmount = amount.toUint128();\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - castAmount);\n    _transfer(sender, recipient, castAmount);\n    return true;\n  }\n\n  /**\n   * @notice Increases the allowance of spender to spend _msgSender() tokens\n   * @param spender The user allowed to spend on behalf of _msgSender()\n   * @param addedValue The amount being added to the allowance\n   * @return `true`\n   */\n  function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n    return true;\n  }\n\n  /**\n   * @notice Decreases the allowance of spender to spend _msgSender() tokens\n   * @param spender The user allowed to spend on behalf of _msgSender()\n   * @param subtractedValue The amount being subtracted to the allowance\n   * @return `true`\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    external\n    virtual\n    returns (bool)\n  {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\n    return true;\n  }\n\n  /**\n   * @notice Transfers tokens between two users and apply incentives if defined.\n   * @param sender The source address\n   * @param recipient The destination address\n   * @param amount The amount getting transferred\n   */\n  function _transfer(\n    address sender,\n    address recipient,\n    uint128 amount\n  ) internal virtual {\n    uint128 oldSenderBalance = _userState[sender].balance;\n    _userState[sender].balance = oldSenderBalance - amount;\n    uint128 oldRecipientBalance = _userState[recipient].balance;\n    _userState[recipient].balance = oldRecipientBalance + amount;\n\n    IAaveIncentivesController incentivesControllerLocal = _incentivesController;\n    if (address(incentivesControllerLocal) != address(0)) {\n      uint256 currentTotalSupply = _totalSupply;\n      incentivesControllerLocal.handleAction(sender, currentTotalSupply, oldSenderBalance);\n      if (sender != recipient) {\n        incentivesControllerLocal.handleAction(recipient, currentTotalSupply, oldRecipientBalance);\n      }\n    }\n  }\n\n  /**\n   * @notice Approve `spender` to use `amount` of `owner`s balance\n   * @param owner The address owning the tokens\n   * @param spender The address approved for spending\n   * @param amount The amount of tokens to approve spending of\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @notice Update the name of the token\n   * @param newName The new name for the token\n   */\n  function _setName(string memory newName) internal {\n    _name = newName;\n  }\n\n  /**\n   * @notice Update the symbol for the token\n   * @param newSymbol The new symbol for the token\n   */\n  function _setSymbol(string memory newSymbol) internal {\n    _symbol = newSymbol;\n  }\n\n  /**\n   * @notice Update the number of decimals for the token\n   * @param newDecimals The new number of decimals for the token\n   */\n  function _setDecimals(uint8 newDecimals) internal {\n    _decimals = newDecimals;\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/tokenization/base/MintableIncentivizedERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IAaveIncentivesController} from '../../../interfaces/IAaveIncentivesController.sol';\nimport {IPool} from '../../../interfaces/IPool.sol';\nimport {IncentivizedERC20} from './IncentivizedERC20.sol';\n\n/**\n * @title MintableIncentivizedERC20\n * @author Aave\n * @notice Implements mint and burn functions for IncentivizedERC20\n */\nabstract contract MintableIncentivizedERC20 is IncentivizedERC20 {\n  /**\n   * @dev Constructor.\n   * @param pool The reference to the main Pool contract\n   * @param name The name of the token\n   * @param symbol The symbol of the token\n   * @param decimals The number of decimals of the token\n   */\n  constructor(\n    IPool pool,\n    string memory name,\n    string memory symbol,\n    uint8 decimals\n  ) IncentivizedERC20(pool, name, symbol, decimals) {\n    // Intentionally left blank\n  }\n\n  /**\n   * @notice Mints tokens to an account and apply incentives if defined\n   * @param account The address receiving tokens\n   * @param amount The amount of tokens to mint\n   */\n  function _mint(address account, uint128 amount) internal virtual {\n    uint256 oldTotalSupply = _totalSupply;\n    _totalSupply = oldTotalSupply + amount;\n\n    uint128 oldAccountBalance = _userState[account].balance;\n    _userState[account].balance = oldAccountBalance + amount;\n\n    IAaveIncentivesController incentivesControllerLocal = _incentivesController;\n    if (address(incentivesControllerLocal) != address(0)) {\n      incentivesControllerLocal.handleAction(account, oldTotalSupply, oldAccountBalance);\n    }\n  }\n\n  /**\n   * @notice Burns tokens from an account and apply incentives if defined\n   * @param account The account whose tokens are burnt\n   * @param amount The amount of tokens to burn\n   */\n  function _burn(address account, uint128 amount) internal virtual {\n    uint256 oldTotalSupply = _totalSupply;\n    _totalSupply = oldTotalSupply - amount;\n\n    uint128 oldAccountBalance = _userState[account].balance;\n    _userState[account].balance = oldAccountBalance - amount;\n\n    IAaveIncentivesController incentivesControllerLocal = _incentivesController;\n\n    if (address(incentivesControllerLocal) != address(0)) {\n      incentivesControllerLocal.handleAction(account, oldTotalSupply, oldAccountBalance);\n    }\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/tokenization/base/ScaledBalanceTokenBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {SafeCast} from '../../../dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {Errors} from '../../libraries/helpers/Errors.sol';\nimport {WadRayMath} from '../../libraries/math/WadRayMath.sol';\nimport {IPool} from '../../../interfaces/IPool.sol';\nimport {IScaledBalanceToken} from '../../../interfaces/IScaledBalanceToken.sol';\nimport {MintableIncentivizedERC20} from './MintableIncentivizedERC20.sol';\n\n/**\n * @title ScaledBalanceTokenBase\n * @author Aave\n * @notice Basic ERC20 implementation of scaled balance token\n */\nabstract contract ScaledBalanceTokenBase is MintableIncentivizedERC20, IScaledBalanceToken {\n  using WadRayMath for uint256;\n  using SafeCast for uint256;\n\n  /**\n   * @dev Constructor.\n   * @param pool The reference to the main Pool contract\n   * @param name The name of the token\n   * @param symbol The symbol of the token\n   * @param decimals The number of decimals of the token\n   */\n  constructor(\n    IPool pool,\n    string memory name,\n    string memory symbol,\n    uint8 decimals\n  ) MintableIncentivizedERC20(pool, name, symbol, decimals) {\n    // Intentionally left blank\n  }\n\n  /// @inheritdoc IScaledBalanceToken\n  function scaledBalanceOf(address user) external view override returns (uint256) {\n    return super.balanceOf(user);\n  }\n\n  /// @inheritdoc IScaledBalanceToken\n  function getScaledUserBalanceAndSupply(address user)\n    external\n    view\n    override\n    returns (uint256, uint256)\n  {\n    return (super.balanceOf(user), super.totalSupply());\n  }\n\n  /// @inheritdoc IScaledBalanceToken\n  function scaledTotalSupply() public view virtual override returns (uint256) {\n    return super.totalSupply();\n  }\n\n  /// @inheritdoc IScaledBalanceToken\n  function getPreviousIndex(address user) external view virtual override returns (uint256) {\n    return _userState[user].additionalData;\n  }\n\n  /**\n   * @notice Implements the basic logic to mint a scaled balance token.\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the scaled tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function _mintScaled(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) internal returns (bool) {\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.INVALID_MINT_AMOUNT);\n\n    uint256 scaledBalance = super.balanceOf(onBehalfOf);\n    uint256 balanceIncrease = scaledBalance.rayMul(index) -\n      scaledBalance.rayMul(_userState[onBehalfOf].additionalData);\n\n    _userState[onBehalfOf].additionalData = index.toUint128();\n\n    _mint(onBehalfOf, amountScaled.toUint128());\n\n    uint256 amountToMint = amount + balanceIncrease;\n    emit Transfer(address(0), onBehalfOf, amountToMint);\n    emit Mint(caller, onBehalfOf, amountToMint, balanceIncrease, index);\n\n    return (scaledBalance == 0);\n  }\n\n  /**\n   * @notice Implements the basic logic to burn a scaled balance token.\n   * @dev In some instances, a burn transaction will emit a mint event\n   * if the amount to burn is less than the interest that the user accrued\n   * @param user The user which debt is burnt\n   * @param target The address that will receive the underlying, if any\n   * @param amount The amount getting burned\n   * @param index The variable debt index of the reserve\n   */\n  function _burnScaled(\n    address user,\n    address target,\n    uint256 amount,\n    uint256 index\n  ) internal {\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.INVALID_BURN_AMOUNT);\n\n    uint256 scaledBalance = super.balanceOf(user);\n    uint256 balanceIncrease = scaledBalance.rayMul(index) -\n      scaledBalance.rayMul(_userState[user].additionalData);\n\n    _userState[user].additionalData = index.toUint128();\n\n    _burn(user, amountScaled.toUint128());\n\n    if (balanceIncrease > amount) {\n      uint256 amountToMint = balanceIncrease - amount;\n      emit Transfer(address(0), user, amountToMint);\n      emit Mint(user, user, amountToMint, balanceIncrease, index);\n    } else {\n      uint256 amountToBurn = amount - balanceIncrease;\n      emit Transfer(user, address(0), amountToBurn);\n      emit Burn(user, target, amountToBurn, balanceIncrease, index);\n    }\n  }\n\n  /**\n   * @notice Implements the basic logic to transfer scaled balance tokens between two users\n   * @dev It emits a mint event with the interest accrued per user\n   * @param sender The source address\n   * @param recipient The destination address\n   * @param amount The amount getting transferred\n   * @param index The next liquidity index of the reserve\n   */\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount,\n    uint256 index\n  ) internal {\n    uint256 senderScaledBalance = super.balanceOf(sender);\n    uint256 senderBalanceIncrease = senderScaledBalance.rayMul(index) -\n      senderScaledBalance.rayMul(_userState[sender].additionalData);\n\n    uint256 recipientScaledBalance = super.balanceOf(recipient);\n    uint256 recipientBalanceIncrease = recipientScaledBalance.rayMul(index) -\n      recipientScaledBalance.rayMul(_userState[recipient].additionalData);\n\n    _userState[sender].additionalData = index.toUint128();\n    _userState[recipient].additionalData = index.toUint128();\n\n    super._transfer(sender, recipient, amount.rayDiv(index).toUint128());\n\n    if (senderBalanceIncrease > 0) {\n      emit Transfer(address(0), sender, senderBalanceIncrease);\n      emit Mint(_msgSender(), sender, senderBalanceIncrease, senderBalanceIncrease, index);\n    }\n\n    if (sender != recipient && recipientBalanceIncrease > 0) {\n      emit Transfer(address(0), recipient, recipientBalanceIncrease);\n      emit Mint(_msgSender(), recipient, recipientBalanceIncrease, recipientBalanceIncrease, index);\n    }\n\n    emit Transfer(sender, recipient, amount);\n  }\n}\n"
    },
    "@aave/core-v3/contracts/protocol/tokenization/StableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {VersionedInitializable} from '../libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {MathUtils} from '../libraries/math/MathUtils.sol';\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol';\nimport {IInitializableDebtToken} from '../../interfaces/IInitializableDebtToken.sol';\nimport {IStableDebtToken} from '../../interfaces/IStableDebtToken.sol';\nimport {IPool} from '../../interfaces/IPool.sol';\nimport {EIP712Base} from './base/EIP712Base.sol';\nimport {DebtTokenBase} from './base/DebtTokenBase.sol';\nimport {IncentivizedERC20} from './base/IncentivizedERC20.sol';\nimport {SafeCast} from '../../dependencies/openzeppelin/contracts/SafeCast.sol';\n\n/**\n * @title StableDebtToken\n * @author Aave\n * @notice Implements a stable debt token to track the borrowing positions of users\n * at stable rate mode\n * @dev Transfer and approve functionalities are disabled since its a non-transferable token\n */\ncontract StableDebtToken is DebtTokenBase, IncentivizedERC20, IStableDebtToken {\n  using WadRayMath for uint256;\n  using SafeCast for uint256;\n\n  uint256 public constant DEBT_TOKEN_REVISION = 0x1;\n\n  // Map of users address and the timestamp of their last update (userAddress => lastUpdateTimestamp)\n  mapping(address => uint40) internal _timestamps;\n\n  uint128 internal _avgStableRate;\n\n  // Timestamp of the last update of the total supply\n  uint40 internal _totalSupplyTimestamp;\n\n  /**\n   * @dev Constructor.\n   * @param pool The address of the Pool contract\n   */\n  constructor(IPool pool)\n    DebtTokenBase()\n    IncentivizedERC20(pool, 'STABLE_DEBT_TOKEN_IMPL', 'STABLE_DEBT_TOKEN_IMPL', 0)\n  {\n    // Intentionally left blank\n  }\n\n  /// @inheritdoc IInitializableDebtToken\n  function initialize(\n    IPool initializingPool,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 debtTokenDecimals,\n    string memory debtTokenName,\n    string memory debtTokenSymbol,\n    bytes calldata params\n  ) external override initializer {\n    require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);\n    _setName(debtTokenName);\n    _setSymbol(debtTokenSymbol);\n    _setDecimals(debtTokenDecimals);\n\n    _underlyingAsset = underlyingAsset;\n    _incentivesController = incentivesController;\n\n    _domainSeparator = _calculateDomainSeparator();\n\n    emit Initialized(\n      underlyingAsset,\n      address(POOL),\n      address(incentivesController),\n      debtTokenDecimals,\n      debtTokenName,\n      debtTokenSymbol,\n      params\n    );\n  }\n\n  /// @inheritdoc VersionedInitializable\n  function getRevision() internal pure virtual override returns (uint256) {\n    return DEBT_TOKEN_REVISION;\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function getAverageStableRate() external view virtual override returns (uint256) {\n    return _avgStableRate;\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function getUserLastUpdated(address user) external view virtual override returns (uint40) {\n    return _timestamps[user];\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function getUserStableRate(address user) external view virtual override returns (uint256) {\n    return _userState[user].additionalData;\n  }\n\n  /// @inheritdoc IERC20\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    uint256 accountBalance = super.balanceOf(account);\n    uint256 stableRate = _userState[account].additionalData;\n    if (accountBalance == 0) {\n      return 0;\n    }\n    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(\n      stableRate,\n      _timestamps[account]\n    );\n    return accountBalance.rayMul(cumulatedInterest);\n  }\n\n  struct MintLocalVars {\n    uint256 previousSupply;\n    uint256 nextSupply;\n    uint256 amountInRay;\n    uint256 currentStableRate;\n    uint256 nextStableRate;\n    uint256 currentAvgStableRate;\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function mint(\n    address user,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 rate\n  )\n    external\n    virtual\n    override\n    onlyPool\n    returns (\n      bool,\n      uint256,\n      uint256\n    )\n  {\n    MintLocalVars memory vars;\n\n    if (user != onBehalfOf) {\n      _decreaseBorrowAllowance(onBehalfOf, user, amount);\n    }\n\n    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);\n\n    vars.previousSupply = totalSupply();\n    vars.currentAvgStableRate = _avgStableRate;\n    vars.nextSupply = _totalSupply = vars.previousSupply + amount;\n\n    vars.amountInRay = amount.wadToRay();\n\n    vars.currentStableRate = _userState[onBehalfOf].additionalData;\n    vars.nextStableRate = (vars.currentStableRate.rayMul(currentBalance.wadToRay()) +\n      vars.amountInRay.rayMul(rate)).rayDiv((currentBalance + amount).wadToRay());\n\n    _userState[onBehalfOf].additionalData = vars.nextStableRate.toUint128();\n\n    //solium-disable-next-line\n    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);\n\n    // Calculates the updated average stable rate\n    vars.currentAvgStableRate = _avgStableRate = (\n      (vars.currentAvgStableRate.rayMul(vars.previousSupply.wadToRay()) +\n        rate.rayMul(vars.amountInRay)).rayDiv(vars.nextSupply.wadToRay())\n    ).toUint128();\n\n    uint256 amountToMint = amount + balanceIncrease;\n    _mint(onBehalfOf, amountToMint, vars.previousSupply);\n\n    emit Transfer(address(0), onBehalfOf, amountToMint);\n    emit Mint(\n      user,\n      onBehalfOf,\n      amountToMint,\n      currentBalance,\n      balanceIncrease,\n      vars.nextStableRate,\n      vars.currentAvgStableRate,\n      vars.nextSupply\n    );\n\n    return (currentBalance == 0, vars.nextSupply, vars.currentAvgStableRate);\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function burn(address from, uint256 amount)\n    external\n    virtual\n    override\n    onlyPool\n    returns (uint256, uint256)\n  {\n    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(from);\n\n    uint256 previousSupply = totalSupply();\n    uint256 nextAvgStableRate = 0;\n    uint256 nextSupply = 0;\n    uint256 userStableRate = _userState[from].additionalData;\n\n    // Since the total supply and each single user debt accrue separately,\n    // there might be accumulation errors so that the last borrower repaying\n    // might actually try to repay more than the available debt supply.\n    // In this case we simply set the total supply and the avg stable rate to 0\n    if (previousSupply <= amount) {\n      _avgStableRate = 0;\n      _totalSupply = 0;\n    } else {\n      nextSupply = _totalSupply = previousSupply - amount;\n      uint256 firstTerm = uint256(_avgStableRate).rayMul(previousSupply.wadToRay());\n      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());\n\n      // For the same reason described above, when the last user is repaying it might\n      // happen that user rate * user balance > avg rate * total supply. In that case,\n      // we simply set the avg rate to 0\n      if (secondTerm >= firstTerm) {\n        nextAvgStableRate = _totalSupply = _avgStableRate = 0;\n      } else {\n        nextAvgStableRate = _avgStableRate = (\n          (firstTerm - secondTerm).rayDiv(nextSupply.wadToRay())\n        ).toUint128();\n      }\n    }\n\n    if (amount == currentBalance) {\n      _userState[from].additionalData = 0;\n      _timestamps[from] = 0;\n    } else {\n      //solium-disable-next-line\n      _timestamps[from] = uint40(block.timestamp);\n    }\n    //solium-disable-next-line\n    _totalSupplyTimestamp = uint40(block.timestamp);\n\n    if (balanceIncrease > amount) {\n      uint256 amountToMint = balanceIncrease - amount;\n      _mint(from, amountToMint, previousSupply);\n      emit Transfer(address(0), from, amountToMint);\n      emit Mint(\n        from,\n        from,\n        amountToMint,\n        currentBalance,\n        balanceIncrease,\n        userStableRate,\n        nextAvgStableRate,\n        nextSupply\n      );\n    } else {\n      uint256 amountToBurn = amount - balanceIncrease;\n      _burn(from, amountToBurn, previousSupply);\n      emit Transfer(from, address(0), amountToBurn);\n      emit Burn(from, amountToBurn, currentBalance, balanceIncrease, nextAvgStableRate, nextSupply);\n    }\n\n    return (nextSupply, nextAvgStableRate);\n  }\n\n  /**\n   * @notice Calculates the increase in balance since the last user interaction\n   * @param user The address of the user for which the interest is being accumulated\n   * @return The previous principal balance\n   * @return The new principal balance\n   * @return The balance increase\n   */\n  function _calculateBalanceIncrease(address user)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 previousPrincipalBalance = super.balanceOf(user);\n\n    if (previousPrincipalBalance == 0) {\n      return (0, 0, 0);\n    }\n\n    uint256 newPrincipalBalance = balanceOf(user);\n\n    return (\n      previousPrincipalBalance,\n      newPrincipalBalance,\n      newPrincipalBalance - previousPrincipalBalance\n    );\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function getSupplyData()\n    external\n    view\n    override\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint40\n    )\n  {\n    uint256 avgRate = _avgStableRate;\n    return (super.totalSupply(), _calcTotalSupply(avgRate), avgRate, _totalSupplyTimestamp);\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function getTotalSupplyAndAvgRate() external view override returns (uint256, uint256) {\n    uint256 avgRate = _avgStableRate;\n    return (_calcTotalSupply(avgRate), avgRate);\n  }\n\n  /// @inheritdoc IERC20\n  function totalSupply() public view virtual override returns (uint256) {\n    return _calcTotalSupply(_avgStableRate);\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function getTotalSupplyLastUpdated() external view override returns (uint40) {\n    return _totalSupplyTimestamp;\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function principalBalanceOf(address user) external view virtual override returns (uint256) {\n    return super.balanceOf(user);\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @notice Calculates the total supply\n   * @param avgRate The average rate at which the total supply increases\n   * @return The debt balance of the user since the last burn/mint action\n   */\n  function _calcTotalSupply(uint256 avgRate) internal view returns (uint256) {\n    uint256 principalSupply = super.totalSupply();\n\n    if (principalSupply == 0) {\n      return 0;\n    }\n\n    uint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(\n      avgRate,\n      _totalSupplyTimestamp\n    );\n\n    return principalSupply.rayMul(cumulatedInterest);\n  }\n\n  /**\n   * @notice Mints stable debt tokens to a user\n   * @param account The account receiving the debt tokens\n   * @param amount The amount being minted\n   * @param oldTotalSupply The total supply before the minting event\n   */\n  function _mint(\n    address account,\n    uint256 amount,\n    uint256 oldTotalSupply\n  ) internal {\n    uint128 castAmount = amount.toUint128();\n    uint128 oldAccountBalance = _userState[account].balance;\n    _userState[account].balance = oldAccountBalance + castAmount;\n\n    if (address(_incentivesController) != address(0)) {\n      _incentivesController.handleAction(account, oldTotalSupply, oldAccountBalance);\n    }\n  }\n\n  /**\n   * @notice Burns stable debt tokens of a user\n   * @param account The user getting his debt burned\n   * @param amount The amount being burned\n   * @param oldTotalSupply The total supply before the burning event\n   */\n  function _burn(\n    address account,\n    uint256 amount,\n    uint256 oldTotalSupply\n  ) internal {\n    uint128 castAmount = amount.toUint128();\n    uint128 oldAccountBalance = _userState[account].balance;\n    _userState[account].balance = oldAccountBalance - castAmount;\n\n    if (address(_incentivesController) != address(0)) {\n      _incentivesController.handleAction(account, oldTotalSupply, oldAccountBalance);\n    }\n  }\n\n  /// @inheritdoc EIP712Base\n  function _EIP712BaseId() internal view override returns (string memory) {\n    return name();\n  }\n\n  /**\n   * @dev Being non transferrable, the debt token does not implement any of the\n   * standard ERC20 functions for transfer and allowance.\n   */\n  function transfer(address, uint256) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function allowance(address, address) external view virtual override returns (uint256) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function approve(address, uint256) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function transferFrom(\n    address,\n    address,\n    uint256\n  ) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function increaseAllowance(address, uint256) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function decreaseAllowance(address, uint256) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n}\n"
    },
    "@aave/periphery-v3/contracts/mocks/testnet-helpers/TestnetERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Ownable} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/Ownable.sol';\nimport {ERC20} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/ERC20.sol';\nimport {IERC20WithPermit} from '@aave/core-v3/contracts/interfaces/IERC20WithPermit.sol';\n\n/**\n * @title TestnetERC20\n * @dev ERC20 minting logic\n */\ncontract TestnetERC20 is IERC20WithPermit, ERC20, Ownable {\n  bytes public constant EIP712_REVISION = bytes('1');\n  bytes32 internal constant EIP712_DOMAIN =\n    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  // Map of address nonces (address => nonce)\n  mapping(address => uint256) internal _nonces;\n\n  bytes32 public DOMAIN_SEPARATOR;\n\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint8 decimals,\n    address owner\n  ) ERC20(name, symbol) {\n    uint256 chainId = block.chainid;\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        EIP712_DOMAIN,\n        keccak256(bytes(name)),\n        keccak256(EIP712_REVISION),\n        chainId,\n        address(this)\n      )\n    );\n    _setupDecimals(decimals);\n    require(owner != address(0));\n    transferOwnership(owner);\n  }\n\n  /// @inheritdoc IERC20WithPermit\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    require(owner != address(0), 'INVALID_OWNER');\n    //solium-disable-next-line\n    require(block.timestamp <= deadline, 'INVALID_EXPIRATION');\n    uint256 currentValidNonce = _nonces[owner];\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        '\\x19\\x01',\n        DOMAIN_SEPARATOR,\n        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))\n      )\n    );\n    require(owner == ecrecover(digest, v, r, s), 'INVALID_SIGNATURE');\n    _nonces[owner] = currentValidNonce + 1;\n    _approve(owner, spender, value);\n  }\n\n  /**\n   * @dev Function to mint tokens\n   * @param value The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(uint256 value) public virtual onlyOwner returns (bool) {\n    _mint(_msgSender(), value);\n    return true;\n  }\n\n  /**\n   * @dev Function to mint tokens to address\n   * @param account The account to mint tokens.\n   * @param value The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(address account, uint256 value) public virtual onlyOwner returns (bool) {\n    _mint(account, value);\n    return true;\n  }\n\n  function nonces(address owner) public view returns (uint256) {\n    return _nonces[owner];\n  }\n}\n"
    },
    "@aave/periphery-v3/contracts/mocks/WETH9Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {WETH9} from \"@aave/core-v3/contracts/dependencies/weth/WETH9.sol\";\nimport {Ownable} from \"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/Ownable.sol\";\n\ncontract WETH9Mock is WETH9, Ownable {\n    constructor(\n        string memory mockName,\n        string memory mockSymbol,\n        address owner\n    ) {\n        name = mockName;\n        symbol = mockSymbol;\n\n        transferOwnership(owner);\n    }\n\n    function mint(address account, uint256 value)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        balanceOf[account] += value;\n        emit Transfer(address(0), account, value);\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"IERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\nimport \"../../../interfaces/IERC4626.sol\";\nimport \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * CAUTION: When the vault is empty or nearly empty, deposits are at high risk of being stolen through frontrunning with\n * a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * _Available since v4.7._\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20 private immutable _asset;\n    uint8 private immutable _decimals;\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\n     */\n    constructor(IERC20 asset_) {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _decimals = success ? assetDecimals : super.decimals();\n        _asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool, uint8) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeWithSelector(IERC20Metadata.decimals.selector)\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are read from the underlying asset in the constructor and cached. If this fails (e.g., the asset\n     * has not been created yet), the cached value is set to a default obtained by `super.decimals()` (which depends on\n     * inheritance but is most likely 18). Override this function in order to set a guaranteed hardcoded value.\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    /** @dev See {IERC4626-asset}. */\n    function asset() public view virtual override returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4626-totalAssets}. */\n    function totalAssets() public view virtual override returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4626-convertToShares}. */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\n        return _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-convertToAssets}. */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-maxDeposit}. */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return _isVaultCollateralized() ? type(uint256).max : 0;\n    }\n\n    /** @dev See {IERC4626-maxMint}. */\n    function maxMint(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-previewMint}. */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Up);\n    }\n\n    /** @dev See {IERC4626-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /** @dev See {IERC4626-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-deposit}. */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max\");\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint}.\n     *\n     * As opposed to {deposit}, minting is allowed even if the vault is in a state where the price of a share is zero.\n     * In this case, the shares will be minted without requiring any assets to be deposited.\n     */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw}. */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem}. */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     *\n     * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\n     * would represent an infinite amount of shares.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        return\n            (assets == 0 || supply == 0)\n                ? _initialConvertToShares(assets, rounding)\n                : assets.mulDiv(supply, totalAssets(), rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) to apply when the vault is empty.\n     *\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToAssets} when overriding it.\n     */\n    function _initialConvertToShares(\n        uint256 assets,\n        Math.Rounding /*rounding*/\n    ) internal view virtual returns (uint256 shares) {\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return\n            (supply == 0) ? _initialConvertToAssets(shares, rounding) : shares.mulDiv(totalAssets(), supply, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) to apply when the vault is empty.\n     *\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToShares} when overriding it.\n     */\n    function _initialConvertToAssets(\n        uint256 shares,\n        Math.Rounding /*rounding*/\n    ) internal view virtual returns (uint256 assets) {\n        return shares;\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    /**\n     * @dev Checks if vault is \"healthy\" in the sense of having assets backing the circulating shares.\n     */\n    function _isVaultCollateralized() private view returns (bool) {\n        return totalAssets() > 0 || totalSupply() == 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../Address.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\n            return true;\n        }\n\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length == 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "aave-address-book/AaveV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nimport {DataTypes} from 'aave-v3-core/contracts/protocol/libraries/types/DataTypes.sol';\nimport {Errors} from 'aave-v3-core/contracts/protocol/libraries/helpers/Errors.sol';\nimport {ConfiguratorInputTypes} from 'aave-v3-core/contracts/protocol/libraries/types/ConfiguratorInputTypes.sol';\nimport {IPoolAddressesProvider} from 'aave-v3-core/contracts/interfaces/IPoolAddressesProvider.sol';\nimport {IAToken} from 'aave-v3-core/contracts/interfaces/IAToken.sol';\nimport {IPool} from 'aave-v3-core/contracts/interfaces/IPool.sol';\nimport {IPoolConfigurator} from 'aave-v3-core/contracts/interfaces/IPoolConfigurator.sol';\nimport {IPriceOracleGetter} from 'aave-v3-core/contracts/interfaces/IPriceOracleGetter.sol';\nimport {IAaveOracle} from 'aave-v3-core/contracts/interfaces/IAaveOracle.sol';\nimport {IACLManager as BasicIACLManager} from 'aave-v3-core/contracts/interfaces/IACLManager.sol';\nimport {IPoolDataProvider} from 'aave-v3-core/contracts/interfaces/IPoolDataProvider.sol';\nimport {IDefaultInterestRateStrategy} from 'aave-v3-core/contracts/interfaces/IDefaultInterestRateStrategy.sol';\nimport {IReserveInterestRateStrategy} from 'aave-v3-core/contracts/interfaces/IReserveInterestRateStrategy.sol';\nimport {IPoolDataProvider as IAaveProtocolDataProvider} from 'aave-v3-core/contracts/interfaces/IPoolDataProvider.sol';\nimport {AggregatorInterface} from 'aave-v3-core/contracts/dependencies/chainlink/AggregatorInterface.sol';\n\ninterface IACLManager is BasicIACLManager {\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  function DEFAULT_ADMIN_ROLE() external pure returns (bytes32);\n\n  function renounceRole(bytes32 role, address account) external;\n\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  function grantRole(bytes32 role, address account) external;\n\n  function revokeRole(bytes32 role, address account) external;\n}\n"
    },
    "aave-address-book/AaveV3Arbitrum.sol": {
      "content": "// AUTOGENERATED - MANUALLY CHANGES WILL BE REVERTED BY THE GENERATOR\n// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nimport {IPoolAddressesProvider, IPool, IPoolConfigurator, IAaveOracle, IPoolDataProvider, IACLManager} from './AaveV3.sol';\nimport {ICollector} from './common/ICollector.sol';\n\nlibrary AaveV3Arbitrum {\n  // https://arbiscan.io/address/0xa97684ead0e402dC232d5A977953DF7ECBaB3CDb\n  IPoolAddressesProvider internal constant POOL_ADDRESSES_PROVIDER =\n    IPoolAddressesProvider(0xa97684ead0e402dC232d5A977953DF7ECBaB3CDb);\n\n  // https://arbiscan.io/address/0x794a61358D6845594F94dc1DB02A252b5b4814aD\n  IPool internal constant POOL = IPool(0x794a61358D6845594F94dc1DB02A252b5b4814aD);\n\n  // https://arbiscan.io/address/0x03e8C5Cd5E194659b16456bb43Dd5D38886FE541\n  address internal constant POOL_IMPL = 0x03e8C5Cd5E194659b16456bb43Dd5D38886FE541;\n\n  // https://arbiscan.io/address/0x8145eddDf43f50276641b55bd3AD95944510021E\n  IPoolConfigurator internal constant POOL_CONFIGURATOR =\n    IPoolConfigurator(0x8145eddDf43f50276641b55bd3AD95944510021E);\n\n  // https://arbiscan.io/address/0x04a8D477eE202aDCE1682F5902e1160455205b12\n  address internal constant POOL_CONFIGURATOR_IMPL = 0x04a8D477eE202aDCE1682F5902e1160455205b12;\n\n  // https://arbiscan.io/address/0xb56c2F0B653B2e0b10C9b928C8580Ac5Df02C7C7\n  IAaveOracle internal constant ORACLE = IAaveOracle(0xb56c2F0B653B2e0b10C9b928C8580Ac5Df02C7C7);\n\n  // https://arbiscan.io/address/0x7A9ff54A6eE4a21223036890bB8c4ea2D62c686b\n  address internal constant PRICE_ORACLE_SENTINEL = 0x7A9ff54A6eE4a21223036890bB8c4ea2D62c686b;\n\n  // https://arbiscan.io/address/0x6b4E260b765B3cA1514e618C0215A6B7839fF93e\n  IPoolDataProvider internal constant AAVE_PROTOCOL_DATA_PROVIDER =\n    IPoolDataProvider(0x6b4E260b765B3cA1514e618C0215A6B7839fF93e);\n\n  // https://arbiscan.io/address/0xa72636CbcAa8F5FF95B2cc47F3CDEe83F3294a0B\n  IACLManager internal constant ACL_MANAGER =\n    IACLManager(0xa72636CbcAa8F5FF95B2cc47F3CDEe83F3294a0B);\n\n  // https://arbiscan.io/address/0xFF1137243698CaA18EE364Cc966CF0e02A4e6327\n  address internal constant ACL_ADMIN = 0xFF1137243698CaA18EE364Cc966CF0e02A4e6327;\n\n  // https://arbiscan.io/address/0x053D55f9B5AF8694c503EB288a1B7E552f590710\n  ICollector internal constant COLLECTOR = ICollector(0x053D55f9B5AF8694c503EB288a1B7E552f590710);\n\n  // https://arbiscan.io/address/0x929EC64c34a17401F460460D4B9390518E5B473e\n  address internal constant DEFAULT_INCENTIVES_CONTROLLER =\n    0x929EC64c34a17401F460460D4B9390518E5B473e;\n\n  // https://arbiscan.io/address/0x1Be1798b70aEe431c2986f7ff48d9D1fa350786a\n  address internal constant DEFAULT_A_TOKEN_IMPL_REV_2 = 0x1Be1798b70aEe431c2986f7ff48d9D1fa350786a;\n\n  // https://arbiscan.io/address/0x5E76E98E0963EcDC6A065d1435F84065b7523f39\n  address internal constant DEFAULT_VARIABLE_DEBT_TOKEN_IMPL_REV_2 =\n    0x5E76E98E0963EcDC6A065d1435F84065b7523f39;\n\n  // https://arbiscan.io/address/0xCB7113D3d572613BbFCeCf80d1341cFFE2A92C00\n  address internal constant DEFAULT_STABLE_DEBT_TOKEN_IMPL_REV_3 =\n    0xCB7113D3d572613BbFCeCf80d1341cFFE2A92C00;\n\n  // https://arbiscan.io/address/0x048f2228D7Bf6776f99aB50cB1b1eaB4D1d4cA73\n  address internal constant EMISSION_MANAGER = 0x048f2228D7Bf6776f99aB50cB1b1eaB4D1d4cA73;\n\n  // https://arbiscan.io/address/0xADf86b537eF08591c2777E144322E8b0Ca7E82a7\n  address internal constant CAPS_PLUS_RISK_STEWARD = 0xADf86b537eF08591c2777E144322E8b0Ca7E82a7;\n\n  // https://arbiscan.io/address/0xe59470B3BE3293534603487E00A44C72f2CD466d\n  address internal constant FREEZING_STEWARD = 0xe59470B3BE3293534603487E00A44C72f2CD466d;\n\n  // https://arbiscan.io/address/0x9E8e9D6b0D24216F59043db68BDda1620892f549\n  address internal constant DEBT_SWAP_ADAPTER = 0x9E8e9D6b0D24216F59043db68BDda1620892f549;\n\n  // https://arbiscan.io/address/0x9abADECD08572e0eA5aF4d47A9C7984a5AA503dC\n  address internal constant L2_ENCODER = 0x9abADECD08572e0eA5aF4d47A9C7984a5AA503dC;\n\n  // https://arbiscan.io/address/0xc5de989E0D1BF605d19478Fdd32Aa827a10b464f\n  address internal constant CONFIG_ENGINE = 0xc5de989E0D1BF605d19478Fdd32Aa827a10b464f;\n\n  // https://arbiscan.io/address/0x770ef9f4fe897e59daCc474EF11238303F9552b6\n  address internal constant POOL_ADDRESSES_PROVIDER_REGISTRY =\n    0x770ef9f4fe897e59daCc474EF11238303F9552b6;\n\n  // https://arbiscan.io/address/0xcC47c4Fe1F7f29ff31A8b62197023aC8553C7896\n  address internal constant RATES_FACTORY = 0xcC47c4Fe1F7f29ff31A8b62197023aC8553C7896;\n\n  // https://arbiscan.io/address/0x28201C152DC5B69A86FA54FCfd21bcA4C0eff3BA\n  address internal constant REPAY_WITH_COLLATERAL_ADAPTER =\n    0x28201C152DC5B69A86FA54FCfd21bcA4C0eff3BA;\n\n  // https://arbiscan.io/address/0x411D79b8cC43384FDE66CaBf9b6a17180c842511\n  address internal constant STATIC_A_TOKEN_FACTORY = 0x411D79b8cC43384FDE66CaBf9b6a17180c842511;\n\n  // https://arbiscan.io/address/0xD61BF98649EA8F8D09e184184777b1867F00E5CB\n  address internal constant STATIC_A_TOKEN_ORACLE = 0xD61BF98649EA8F8D09e184184777b1867F00E5CB;\n\n  // https://arbiscan.io/address/0xF3C3F14dd7BDb7E03e6EBc3bc5Ffc6D66De12251\n  address internal constant SWAP_COLLATERAL_ADAPTER = 0xF3C3F14dd7BDb7E03e6EBc3bc5Ffc6D66De12251;\n\n  // https://arbiscan.io/address/0xDA67AF3403555Ce0AE3ffC22fDb7354458277358\n  address internal constant UI_INCENTIVE_DATA_PROVIDER = 0xDA67AF3403555Ce0AE3ffC22fDb7354458277358;\n\n  // https://arbiscan.io/address/0x145dE30c929a065582da84Cf96F88460dB9745A7\n  address internal constant UI_POOL_DATA_PROVIDER = 0x145dE30c929a065582da84Cf96F88460dB9745A7;\n\n  // https://arbiscan.io/address/0xBc790382B3686abffE4be14A030A96aC6154023a\n  address internal constant WALLET_BALANCE_PROVIDER = 0xBc790382B3686abffE4be14A030A96aC6154023a;\n\n  // https://arbiscan.io/address/0xecD4bd3121F9FD604ffaC631bF6d41ec12f1fafb\n  address internal constant WETH_GATEWAY = 0xecD4bd3121F9FD604ffaC631bF6d41ec12f1fafb;\n\n  // https://arbiscan.io/address/0x5598BbFA2f4fE8151f45bBA0a3edE1b54B51a0a9\n  address internal constant WITHDRAW_SWAP_ADAPTER = 0x5598BbFA2f4fE8151f45bBA0a3edE1b54B51a0a9;\n}\n\nlibrary AaveV3ArbitrumAssets {\n  // https://arbiscan.io/address/0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1\n  address internal constant DAI_UNDERLYING = 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1;\n\n  uint8 internal constant DAI_DECIMALS = 18;\n\n  // https://arbiscan.io/address/0x82E64f49Ed5EC1bC6e43DAD4FC8Af9bb3A2312EE\n  address internal constant DAI_A_TOKEN = 0x82E64f49Ed5EC1bC6e43DAD4FC8Af9bb3A2312EE;\n\n  // https://arbiscan.io/address/0x8619d80FB0141ba7F184CbF22fd724116D9f7ffC\n  address internal constant DAI_V_TOKEN = 0x8619d80FB0141ba7F184CbF22fd724116D9f7ffC;\n\n  // https://arbiscan.io/address/0xd94112B5B62d53C9402e7A60289c6810dEF1dC9B\n  address internal constant DAI_S_TOKEN = 0xd94112B5B62d53C9402e7A60289c6810dEF1dC9B;\n\n  // https://arbiscan.io/address/0x4a838a3Dac6633bB1fd932B6f356DecFCAf7803D\n  address internal constant DAI_ORACLE = 0x4a838a3Dac6633bB1fd932B6f356DecFCAf7803D;\n\n  // https://arbiscan.io/address/0x05F410A9EB94e0BEe0E47F12254E7Cb5F4E2A1f7\n  address internal constant DAI_INTEREST_RATE_STRATEGY = 0x05F410A9EB94e0BEe0E47F12254E7Cb5F4E2A1f7;\n\n  // https://arbiscan.io/address/0xc91c5297d7E161aCC74b482aAfCc75B85cc0bfeD\n  address internal constant DAI_STATA_TOKEN = 0xc91c5297d7E161aCC74b482aAfCc75B85cc0bfeD;\n\n  // https://arbiscan.io/address/0xf97f4df75117a78c1A5a0DBb814Af92458539FB4\n  address internal constant LINK_UNDERLYING = 0xf97f4df75117a78c1A5a0DBb814Af92458539FB4;\n\n  uint8 internal constant LINK_DECIMALS = 18;\n\n  // https://arbiscan.io/address/0x191c10Aa4AF7C30e871E70C95dB0E4eb77237530\n  address internal constant LINK_A_TOKEN = 0x191c10Aa4AF7C30e871E70C95dB0E4eb77237530;\n\n  // https://arbiscan.io/address/0x953A573793604aF8d41F306FEb8274190dB4aE0e\n  address internal constant LINK_V_TOKEN = 0x953A573793604aF8d41F306FEb8274190dB4aE0e;\n\n  // https://arbiscan.io/address/0x89D976629b7055ff1ca02b927BA3e020F22A44e4\n  address internal constant LINK_S_TOKEN = 0x89D976629b7055ff1ca02b927BA3e020F22A44e4;\n\n  // https://arbiscan.io/address/0x86E53CF1B870786351Da77A57575e79CB55812CB\n  address internal constant LINK_ORACLE = 0x86E53CF1B870786351Da77A57575e79CB55812CB;\n\n  // https://arbiscan.io/address/0x9b34E3e183c9b0d1a08fF57a8fb59c821616295f\n  address internal constant LINK_INTEREST_RATE_STRATEGY =\n    0x9b34E3e183c9b0d1a08fF57a8fb59c821616295f;\n\n  // https://arbiscan.io/address/0x27dE098EF2772386cBCf1a4c8BEb886368b7F9a9\n  address internal constant LINK_STATA_TOKEN = 0x27dE098EF2772386cBCf1a4c8BEb886368b7F9a9;\n\n  // https://arbiscan.io/address/0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8\n  address internal constant USDC_UNDERLYING = 0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8;\n\n  uint8 internal constant USDC_DECIMALS = 6;\n\n  // https://arbiscan.io/address/0x625E7708f30cA75bfd92586e17077590C60eb4cD\n  address internal constant USDC_A_TOKEN = 0x625E7708f30cA75bfd92586e17077590C60eb4cD;\n\n  // https://arbiscan.io/address/0xFCCf3cAbbe80101232d343252614b6A3eE81C989\n  address internal constant USDC_V_TOKEN = 0xFCCf3cAbbe80101232d343252614b6A3eE81C989;\n\n  // https://arbiscan.io/address/0x307ffe186F84a3bc2613D1eA417A5737D69A7007\n  address internal constant USDC_S_TOKEN = 0x307ffe186F84a3bc2613D1eA417A5737D69A7007;\n\n  // https://arbiscan.io/address/0xDe25a88F87FEd9F8999fAbF6729dCB121893623C\n  address internal constant USDC_ORACLE = 0xDe25a88F87FEd9F8999fAbF6729dCB121893623C;\n\n  // https://arbiscan.io/address/0xca719585f2E07BDe82c4a05D6E7C0E446c2D6601\n  address internal constant USDC_INTEREST_RATE_STRATEGY =\n    0xca719585f2E07BDe82c4a05D6E7C0E446c2D6601;\n\n  // https://arbiscan.io/address/0x0Bc9E52051f553E75550CA22C196bf132c52Cf0B\n  address internal constant USDC_STATA_TOKEN = 0x0Bc9E52051f553E75550CA22C196bf132c52Cf0B;\n\n  // https://arbiscan.io/address/0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f\n  address internal constant WBTC_UNDERLYING = 0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f;\n\n  uint8 internal constant WBTC_DECIMALS = 8;\n\n  // https://arbiscan.io/address/0x078f358208685046a11C85e8ad32895DED33A249\n  address internal constant WBTC_A_TOKEN = 0x078f358208685046a11C85e8ad32895DED33A249;\n\n  // https://arbiscan.io/address/0x92b42c66840C7AD907b4BF74879FF3eF7c529473\n  address internal constant WBTC_V_TOKEN = 0x92b42c66840C7AD907b4BF74879FF3eF7c529473;\n\n  // https://arbiscan.io/address/0x633b207Dd676331c413D4C013a6294B0FE47cD0e\n  address internal constant WBTC_S_TOKEN = 0x633b207Dd676331c413D4C013a6294B0FE47cD0e;\n\n  // https://arbiscan.io/address/0x6ce185860a4963106506C203335A2910413708e9\n  address internal constant WBTC_ORACLE = 0x6ce185860a4963106506C203335A2910413708e9;\n\n  // https://arbiscan.io/address/0x8F183Ee74C790CB558232a141099b316D6C8Ba6E\n  address internal constant WBTC_INTEREST_RATE_STRATEGY =\n    0x8F183Ee74C790CB558232a141099b316D6C8Ba6E;\n\n  // https://arbiscan.io/address/0x32B95Fbe04e5a51cF99FeeF4e57Cf7e3FC9c5A93\n  address internal constant WBTC_STATA_TOKEN = 0x32B95Fbe04e5a51cF99FeeF4e57Cf7e3FC9c5A93;\n\n  // https://arbiscan.io/address/0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\n  address internal constant WETH_UNDERLYING = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\n\n  uint8 internal constant WETH_DECIMALS = 18;\n\n  // https://arbiscan.io/address/0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8\n  address internal constant WETH_A_TOKEN = 0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8;\n\n  // https://arbiscan.io/address/0x0c84331e39d6658Cd6e6b9ba04736cC4c4734351\n  address internal constant WETH_V_TOKEN = 0x0c84331e39d6658Cd6e6b9ba04736cC4c4734351;\n\n  // https://arbiscan.io/address/0xD8Ad37849950903571df17049516a5CD4cbE55F6\n  address internal constant WETH_S_TOKEN = 0xD8Ad37849950903571df17049516a5CD4cbE55F6;\n\n  // https://arbiscan.io/address/0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612\n  address internal constant WETH_ORACLE = 0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612;\n\n  // https://arbiscan.io/address/0x42ec99A020B78C449d17d93bC4c89e0189B5811d\n  address internal constant WETH_INTEREST_RATE_STRATEGY =\n    0x42ec99A020B78C449d17d93bC4c89e0189B5811d;\n\n  // https://arbiscan.io/address/0x352F3475716261dCC991Bd5F2aF973eB3D0F5878\n  address internal constant WETH_STATA_TOKEN = 0x352F3475716261dCC991Bd5F2aF973eB3D0F5878;\n\n  // https://arbiscan.io/address/0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9\n  address internal constant USDT_UNDERLYING = 0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9;\n\n  uint8 internal constant USDT_DECIMALS = 6;\n\n  // https://arbiscan.io/address/0x6ab707Aca953eDAeFBc4fD23bA73294241490620\n  address internal constant USDT_A_TOKEN = 0x6ab707Aca953eDAeFBc4fD23bA73294241490620;\n\n  // https://arbiscan.io/address/0xfb00AC187a8Eb5AFAE4eACE434F493Eb62672df7\n  address internal constant USDT_V_TOKEN = 0xfb00AC187a8Eb5AFAE4eACE434F493Eb62672df7;\n\n  // https://arbiscan.io/address/0x70eFfc565DB6EEf7B927610155602d31b670e802\n  address internal constant USDT_S_TOKEN = 0x70eFfc565DB6EEf7B927610155602d31b670e802;\n\n  // https://arbiscan.io/address/0x84dC1C52D7C340AA54B4e8799FBB31C3D28E67aD\n  address internal constant USDT_ORACLE = 0x84dC1C52D7C340AA54B4e8799FBB31C3D28E67aD;\n\n  // https://arbiscan.io/address/0x05F410A9EB94e0BEe0E47F12254E7Cb5F4E2A1f7\n  address internal constant USDT_INTEREST_RATE_STRATEGY =\n    0x05F410A9EB94e0BEe0E47F12254E7Cb5F4E2A1f7;\n\n  // https://arbiscan.io/address/0xb165a74407fE1e519d6bCbDeC1Ed3202B35a4140\n  address internal constant USDT_STATA_TOKEN = 0xb165a74407fE1e519d6bCbDeC1Ed3202B35a4140;\n\n  // https://arbiscan.io/address/0xba5DdD1f9d7F570dc94a51479a000E3BCE967196\n  address internal constant AAVE_UNDERLYING = 0xba5DdD1f9d7F570dc94a51479a000E3BCE967196;\n\n  uint8 internal constant AAVE_DECIMALS = 18;\n\n  // https://arbiscan.io/address/0xf329e36C7bF6E5E86ce2150875a84Ce77f477375\n  address internal constant AAVE_A_TOKEN = 0xf329e36C7bF6E5E86ce2150875a84Ce77f477375;\n\n  // https://arbiscan.io/address/0xE80761Ea617F66F96274eA5e8c37f03960ecC679\n  address internal constant AAVE_V_TOKEN = 0xE80761Ea617F66F96274eA5e8c37f03960ecC679;\n\n  // https://arbiscan.io/address/0xfAeF6A702D15428E588d4C0614AEFb4348D83D48\n  address internal constant AAVE_S_TOKEN = 0xfAeF6A702D15428E588d4C0614AEFb4348D83D48;\n\n  // https://arbiscan.io/address/0xaD1d5344AaDE45F43E596773Bcc4c423EAbdD034\n  address internal constant AAVE_ORACLE = 0xaD1d5344AaDE45F43E596773Bcc4c423EAbdD034;\n\n  // https://arbiscan.io/address/0x9b34E3e183c9b0d1a08fF57a8fb59c821616295f\n  address internal constant AAVE_INTEREST_RATE_STRATEGY =\n    0x9b34E3e183c9b0d1a08fF57a8fb59c821616295f;\n\n  // https://arbiscan.io/address/0x1C0c8EcED17aE093b3C1a1a8fFeBE2E9513a9346\n  address internal constant AAVE_STATA_TOKEN = 0x1C0c8EcED17aE093b3C1a1a8fFeBE2E9513a9346;\n\n  // https://arbiscan.io/address/0xD22a58f79e9481D1a88e00c343885A588b34b68B\n  address internal constant EURS_UNDERLYING = 0xD22a58f79e9481D1a88e00c343885A588b34b68B;\n\n  uint8 internal constant EURS_DECIMALS = 2;\n\n  // https://arbiscan.io/address/0x6d80113e533a2C0fe82EaBD35f1875DcEA89Ea97\n  address internal constant EURS_A_TOKEN = 0x6d80113e533a2C0fe82EaBD35f1875DcEA89Ea97;\n\n  // https://arbiscan.io/address/0x4a1c3aD6Ed28a636ee1751C69071f6be75DEb8B8\n  address internal constant EURS_V_TOKEN = 0x4a1c3aD6Ed28a636ee1751C69071f6be75DEb8B8;\n\n  // https://arbiscan.io/address/0xF15F26710c827DDe8ACBA678682F3Ce24f2Fb56E\n  address internal constant EURS_S_TOKEN = 0xF15F26710c827DDe8ACBA678682F3Ce24f2Fb56E;\n\n  // https://arbiscan.io/address/0xA14d53bC1F1c0F31B4aA3BD109344E5009051a84\n  address internal constant EURS_ORACLE = 0xA14d53bC1F1c0F31B4aA3BD109344E5009051a84;\n\n  // https://arbiscan.io/address/0x2B3Ed91C6667d808b0401f439c4859ea635c6862\n  address internal constant EURS_INTEREST_RATE_STRATEGY =\n    0x2B3Ed91C6667d808b0401f439c4859ea635c6862;\n\n  // https://arbiscan.io/address/0x9a40747BE51185A416B181789B671E78a8d045dD\n  address internal constant EURS_STATA_TOKEN = 0x9a40747BE51185A416B181789B671E78a8d045dD;\n\n  // https://arbiscan.io/address/0x5979D7b546E38E414F7E9822514be443A4800529\n  address internal constant wstETH_UNDERLYING = 0x5979D7b546E38E414F7E9822514be443A4800529;\n\n  uint8 internal constant wstETH_DECIMALS = 18;\n\n  // https://arbiscan.io/address/0x513c7E3a9c69cA3e22550eF58AC1C0088e918FFf\n  address internal constant wstETH_A_TOKEN = 0x513c7E3a9c69cA3e22550eF58AC1C0088e918FFf;\n\n  // https://arbiscan.io/address/0x77CA01483f379E58174739308945f044e1a764dc\n  address internal constant wstETH_V_TOKEN = 0x77CA01483f379E58174739308945f044e1a764dc;\n\n  // https://arbiscan.io/address/0x08Cb71192985E936C7Cd166A8b268035e400c3c3\n  address internal constant wstETH_S_TOKEN = 0x08Cb71192985E936C7Cd166A8b268035e400c3c3;\n\n  // https://arbiscan.io/address/0x87fE1503beFBF98C35c7526B0c488d950F822C0F\n  address internal constant wstETH_ORACLE = 0x87fE1503beFBF98C35c7526B0c488d950F822C0F;\n\n  // https://arbiscan.io/address/0x4b8D3277d49E114C8F2D6E0B2eD310e29226fe16\n  address internal constant wstETH_INTEREST_RATE_STRATEGY =\n    0x4b8D3277d49E114C8F2D6E0B2eD310e29226fe16;\n\n  // https://arbiscan.io/address/0x7775d4Ae4Dbb79a624fB96AAcDB8Ca74F671c0DF\n  address internal constant wstETH_STATA_TOKEN = 0x7775d4Ae4Dbb79a624fB96AAcDB8Ca74F671c0DF;\n\n  // https://arbiscan.io/address/0x3F56e0c36d275367b8C502090EDF38289b3dEa0d\n  address internal constant MAI_UNDERLYING = 0x3F56e0c36d275367b8C502090EDF38289b3dEa0d;\n\n  uint8 internal constant MAI_DECIMALS = 18;\n\n  // https://arbiscan.io/address/0xc45A479877e1e9Dfe9FcD4056c699575a1045dAA\n  address internal constant MAI_A_TOKEN = 0xc45A479877e1e9Dfe9FcD4056c699575a1045dAA;\n\n  // https://arbiscan.io/address/0x34e2eD44EF7466D5f9E0b782B5c08b57475e7907\n  address internal constant MAI_V_TOKEN = 0x34e2eD44EF7466D5f9E0b782B5c08b57475e7907;\n\n  // https://arbiscan.io/address/0x78246294a4c6fBf614Ed73CcC9F8b875ca8eE841\n  address internal constant MAI_S_TOKEN = 0x78246294a4c6fBf614Ed73CcC9F8b875ca8eE841;\n\n  // https://arbiscan.io/address/0x7a7cE08a1057723CCEDeA2462407427Ae33FFEb2\n  address internal constant MAI_ORACLE = 0x7a7cE08a1057723CCEDeA2462407427Ae33FFEb2;\n\n  // https://arbiscan.io/address/0xA7D9302346d4C35724821cf98966B2257c9683c6\n  address internal constant MAI_INTEREST_RATE_STRATEGY = 0xA7D9302346d4C35724821cf98966B2257c9683c6;\n\n  // https://arbiscan.io/address/0xB4a0a2692D82301703B27082Cda45B083F68CAcE\n  address internal constant MAI_STATA_TOKEN = 0xB4a0a2692D82301703B27082Cda45B083F68CAcE;\n\n  // https://arbiscan.io/address/0xEC70Dcb4A1EFa46b8F2D97C310C9c4790ba5ffA8\n  address internal constant rETH_UNDERLYING = 0xEC70Dcb4A1EFa46b8F2D97C310C9c4790ba5ffA8;\n\n  uint8 internal constant rETH_DECIMALS = 18;\n\n  // https://arbiscan.io/address/0x8Eb270e296023E9D92081fdF967dDd7878724424\n  address internal constant rETH_A_TOKEN = 0x8Eb270e296023E9D92081fdF967dDd7878724424;\n\n  // https://arbiscan.io/address/0xCE186F6Cccb0c955445bb9d10C59caE488Fea559\n  address internal constant rETH_V_TOKEN = 0xCE186F6Cccb0c955445bb9d10C59caE488Fea559;\n\n  // https://arbiscan.io/address/0x3EF10DFf4928279c004308EbADc4Db8B7620d6fc\n  address internal constant rETH_S_TOKEN = 0x3EF10DFf4928279c004308EbADc4Db8B7620d6fc;\n\n  // https://arbiscan.io/address/0x256f33FC0110B1297f78f48524631D30B752480D\n  address internal constant rETH_ORACLE = 0x256f33FC0110B1297f78f48524631D30B752480D;\n\n  // https://arbiscan.io/address/0xC82dF96432346cFb632473eB619Db3B8AC280234\n  address internal constant rETH_INTEREST_RATE_STRATEGY =\n    0xC82dF96432346cFb632473eB619Db3B8AC280234;\n\n  // https://arbiscan.io/address/0x68235105d6d33A19369D24b746cb7481FB2b34fd\n  address internal constant rETH_STATA_TOKEN = 0x68235105d6d33A19369D24b746cb7481FB2b34fd;\n\n  // https://arbiscan.io/address/0x93b346b6BC2548dA6A1E7d98E9a421B42541425b\n  address internal constant LUSD_UNDERLYING = 0x93b346b6BC2548dA6A1E7d98E9a421B42541425b;\n\n  uint8 internal constant LUSD_DECIMALS = 18;\n\n  // https://arbiscan.io/address/0x8ffDf2DE812095b1D19CB146E4c004587C0A0692\n  address internal constant LUSD_A_TOKEN = 0x8ffDf2DE812095b1D19CB146E4c004587C0A0692;\n\n  // https://arbiscan.io/address/0xA8669021776Bc142DfcA87c21b4A52595bCbB40a\n  address internal constant LUSD_V_TOKEN = 0xA8669021776Bc142DfcA87c21b4A52595bCbB40a;\n\n  // https://arbiscan.io/address/0xa5e408678469d23efDB7694b1B0A85BB0669e8bd\n  address internal constant LUSD_S_TOKEN = 0xa5e408678469d23efDB7694b1B0A85BB0669e8bd;\n\n  // https://arbiscan.io/address/0x341B110bDF665A20F0D5f84A92FcAF5EbeEBC629\n  address internal constant LUSD_ORACLE = 0x341B110bDF665A20F0D5f84A92FcAF5EbeEBC629;\n\n  // https://arbiscan.io/address/0x22B409E1ab288DA6a895FE8251bEbfcA267f8805\n  address internal constant LUSD_INTEREST_RATE_STRATEGY =\n    0x22B409E1ab288DA6a895FE8251bEbfcA267f8805;\n\n  // https://arbiscan.io/address/0xDbB6314b5b07E63B7101844c0346309B79f8C20A\n  address internal constant LUSD_STATA_TOKEN = 0xDbB6314b5b07E63B7101844c0346309B79f8C20A;\n\n  // https://arbiscan.io/address/0xaf88d065e77c8cC2239327C5EDb3A432268e5831\n  address internal constant USDCn_UNDERLYING = 0xaf88d065e77c8cC2239327C5EDb3A432268e5831;\n\n  uint8 internal constant USDCn_DECIMALS = 6;\n\n  // https://arbiscan.io/address/0x724dc807b04555b71ed48a6896b6F41593b8C637\n  address internal constant USDCn_A_TOKEN = 0x724dc807b04555b71ed48a6896b6F41593b8C637;\n\n  // https://arbiscan.io/address/0xf611aEb5013fD2c0511c9CD55c7dc5C1140741A6\n  address internal constant USDCn_V_TOKEN = 0xf611aEb5013fD2c0511c9CD55c7dc5C1140741A6;\n\n  // https://arbiscan.io/address/0xDC1fad70953Bb3918592b6fCc374fe05F5811B6a\n  address internal constant USDCn_S_TOKEN = 0xDC1fad70953Bb3918592b6fCc374fe05F5811B6a;\n\n  // https://arbiscan.io/address/0xDe25a88F87FEd9F8999fAbF6729dCB121893623C\n  address internal constant USDCn_ORACLE = 0xDe25a88F87FEd9F8999fAbF6729dCB121893623C;\n\n  // https://arbiscan.io/address/0xf1e5355cEcaA71036CE21cdF8F9d04061B1BC6E1\n  address internal constant USDCn_INTEREST_RATE_STRATEGY =\n    0xf1e5355cEcaA71036CE21cdF8F9d04061B1BC6E1;\n\n  // https://arbiscan.io/address/0x7CFaDFD5645B50bE87d546f42699d863648251ad\n  address internal constant USDCn_STATA_TOKEN = 0x7CFaDFD5645B50bE87d546f42699d863648251ad;\n\n  // https://arbiscan.io/address/0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F\n  address internal constant FRAX_UNDERLYING = 0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F;\n\n  uint8 internal constant FRAX_DECIMALS = 18;\n\n  // https://arbiscan.io/address/0x38d693cE1dF5AaDF7bC62595A37D667aD57922e5\n  address internal constant FRAX_A_TOKEN = 0x38d693cE1dF5AaDF7bC62595A37D667aD57922e5;\n\n  // https://arbiscan.io/address/0x5D557B07776D12967914379C71a1310e917C7555\n  address internal constant FRAX_V_TOKEN = 0x5D557B07776D12967914379C71a1310e917C7555;\n\n  // https://arbiscan.io/address/0x8a9FdE6925a839F6B1932d16B36aC026F8d3FbdB\n  address internal constant FRAX_S_TOKEN = 0x8a9FdE6925a839F6B1932d16B36aC026F8d3FbdB;\n\n  // https://arbiscan.io/address/0x06919EB75Bd6BA817D38CC70C1CA588ac7a01C10\n  address internal constant FRAX_ORACLE = 0x06919EB75Bd6BA817D38CC70C1CA588ac7a01C10;\n\n  // https://arbiscan.io/address/0x05F410A9EB94e0BEe0E47F12254E7Cb5F4E2A1f7\n  address internal constant FRAX_INTEREST_RATE_STRATEGY =\n    0x05F410A9EB94e0BEe0E47F12254E7Cb5F4E2A1f7;\n\n  // https://arbiscan.io/address/0x89AEc2023f89E26Dbb7eaa7a98fe3996f9d112A8\n  address internal constant FRAX_STATA_TOKEN = 0x89AEc2023f89E26Dbb7eaa7a98fe3996f9d112A8;\n\n  // https://arbiscan.io/address/0x912CE59144191C1204E64559FE8253a0e49E6548\n  address internal constant ARB_UNDERLYING = 0x912CE59144191C1204E64559FE8253a0e49E6548;\n\n  uint8 internal constant ARB_DECIMALS = 18;\n\n  // https://arbiscan.io/address/0x6533afac2E7BCCB20dca161449A13A32D391fb00\n  address internal constant ARB_A_TOKEN = 0x6533afac2E7BCCB20dca161449A13A32D391fb00;\n\n  // https://arbiscan.io/address/0x44705f578135cC5d703b4c9c122528C73Eb87145\n  address internal constant ARB_V_TOKEN = 0x44705f578135cC5d703b4c9c122528C73Eb87145;\n\n  // https://arbiscan.io/address/0x6B4b37618D85Db2a7b469983C888040F7F05Ea3D\n  address internal constant ARB_S_TOKEN = 0x6B4b37618D85Db2a7b469983C888040F7F05Ea3D;\n\n  // https://arbiscan.io/address/0xb2A824043730FE05F3DA2efaFa1CBbe83fa548D6\n  address internal constant ARB_ORACLE = 0xb2A824043730FE05F3DA2efaFa1CBbe83fa548D6;\n\n  // https://arbiscan.io/address/0xD87974E8ED49AB16d5053ba793F4e17078Be0426\n  address internal constant ARB_INTEREST_RATE_STRATEGY = 0xD87974E8ED49AB16d5053ba793F4e17078Be0426;\n\n  // https://arbiscan.io/address/0x9b5637d7952BC9fa2D693aAE51f3103760Bf2693\n  address internal constant ARB_STATA_TOKEN = 0x9b5637d7952BC9fa2D693aAE51f3103760Bf2693;\n\n  // https://arbiscan.io/address/0x35751007a407ca6FEFfE80b3cB397736D2cf4dbe\n  address internal constant weETH_UNDERLYING = 0x35751007a407ca6FEFfE80b3cB397736D2cf4dbe;\n\n  uint8 internal constant weETH_DECIMALS = 18;\n\n  // https://arbiscan.io/address/0x8437d7C167dFB82ED4Cb79CD44B7a32A1dd95c77\n  address internal constant weETH_A_TOKEN = 0x8437d7C167dFB82ED4Cb79CD44B7a32A1dd95c77;\n\n  // https://arbiscan.io/address/0x3ca5FA07689F266e907439aFd1fBB59c44fe12f6\n  address internal constant weETH_V_TOKEN = 0x3ca5FA07689F266e907439aFd1fBB59c44fe12f6;\n\n  // https://arbiscan.io/address/0x40B4BAEcc69B882e8804f9286b12228C27F8c9BF\n  address internal constant weETH_S_TOKEN = 0x40B4BAEcc69B882e8804f9286b12228C27F8c9BF;\n\n  // https://arbiscan.io/address/0x517276B5972C4Db7E88B9F76Ee500E888a2D73C3\n  address internal constant weETH_ORACLE = 0x517276B5972C4Db7E88B9F76Ee500E888a2D73C3;\n\n  // https://arbiscan.io/address/0x4011fcd421b9E90f131B164EC1d162DBE269621C\n  address internal constant weETH_INTEREST_RATE_STRATEGY =\n    0x4011fcd421b9E90f131B164EC1d162DBE269621C;\n}\n\nlibrary AaveV3ArbitrumEModes {\n  uint8 internal constant NONE = 0;\n\n  uint8 internal constant STABLECOINS = 1;\n\n  uint8 internal constant ETH_CORRELATED = 2;\n}\n"
    },
    "aave-address-book/AaveV3Ethereum.sol": {
      "content": "// AUTOGENERATED - MANUALLY CHANGES WILL BE REVERTED BY THE GENERATOR\n// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nimport {IPoolAddressesProvider, IPool, IPoolConfigurator, IAaveOracle, IPoolDataProvider, IACLManager} from './AaveV3.sol';\nimport {ICollector} from './common/ICollector.sol';\n\nlibrary AaveV3Ethereum {\n  // https://etherscan.io/address/0x2f39d218133AFaB8F2B819B1066c7E434Ad94E9e\n  IPoolAddressesProvider internal constant POOL_ADDRESSES_PROVIDER =\n    IPoolAddressesProvider(0x2f39d218133AFaB8F2B819B1066c7E434Ad94E9e);\n\n  // https://etherscan.io/address/0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\n  IPool internal constant POOL = IPool(0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2);\n\n  // https://etherscan.io/address/0x5FAab9E1adbddaD0a08734BE8a52185Fd6558E14\n  address internal constant POOL_IMPL = 0x5FAab9E1adbddaD0a08734BE8a52185Fd6558E14;\n\n  // https://etherscan.io/address/0x64b761D848206f447Fe2dd461b0c635Ec39EbB27\n  IPoolConfigurator internal constant POOL_CONFIGURATOR =\n    IPoolConfigurator(0x64b761D848206f447Fe2dd461b0c635Ec39EbB27);\n\n  // https://etherscan.io/address/0xFDA7ffA872bDc906D43079EA134ebC9a511db0c2\n  address internal constant POOL_CONFIGURATOR_IMPL = 0xFDA7ffA872bDc906D43079EA134ebC9a511db0c2;\n\n  // https://etherscan.io/address/0x54586bE62E3c3580375aE3723C145253060Ca0C2\n  IAaveOracle internal constant ORACLE = IAaveOracle(0x54586bE62E3c3580375aE3723C145253060Ca0C2);\n\n  // https://etherscan.io/address/0x7B4EB56E7CD4b454BA8ff71E4518426369a138a3\n  IPoolDataProvider internal constant AAVE_PROTOCOL_DATA_PROVIDER =\n    IPoolDataProvider(0x7B4EB56E7CD4b454BA8ff71E4518426369a138a3);\n\n  // https://etherscan.io/address/0xc2aaCf6553D20d1e9d78E365AAba8032af9c85b0\n  IACLManager internal constant ACL_MANAGER =\n    IACLManager(0xc2aaCf6553D20d1e9d78E365AAba8032af9c85b0);\n\n  // https://etherscan.io/address/0x5300A1a15135EA4dc7aD5a167152C01EFc9b192A\n  address internal constant ACL_ADMIN = 0x5300A1a15135EA4dc7aD5a167152C01EFc9b192A;\n\n  // https://etherscan.io/address/0x464C71f6c2F760DdA6093dCB91C24c39e5d6e18c\n  ICollector internal constant COLLECTOR = ICollector(0x464C71f6c2F760DdA6093dCB91C24c39e5d6e18c);\n\n  // https://etherscan.io/address/0x8164Cc65827dcFe994AB23944CBC90e0aa80bFcb\n  address internal constant DEFAULT_INCENTIVES_CONTROLLER =\n    0x8164Cc65827dcFe994AB23944CBC90e0aa80bFcb;\n\n  // https://etherscan.io/address/0x7EfFD7b47Bfd17e52fB7559d3f924201b9DbfF3d\n  address internal constant DEFAULT_A_TOKEN_IMPL_REV_1 = 0x7EfFD7b47Bfd17e52fB7559d3f924201b9DbfF3d;\n\n  // https://etherscan.io/address/0xaC725CB59D16C81061BDeA61041a8A5e73DA9EC6\n  address internal constant DEFAULT_VARIABLE_DEBT_TOKEN_IMPL_REV_1 =\n    0xaC725CB59D16C81061BDeA61041a8A5e73DA9EC6;\n\n  // https://etherscan.io/address/0x15C5620dfFaC7c7366EED66C20Ad222DDbB1eD57\n  address internal constant DEFAULT_STABLE_DEBT_TOKEN_IMPL_REV_1 =\n    0x15C5620dfFaC7c7366EED66C20Ad222DDbB1eD57;\n\n  // https://etherscan.io/address/0x223d844fc4B006D67c0cDbd39371A9F73f69d974\n  address internal constant EMISSION_MANAGER = 0x223d844fc4B006D67c0cDbd39371A9F73f69d974;\n\n  // https://etherscan.io/address/0x82dcCF206Ae2Ab46E2099e663F70DeE77caE7778\n  address internal constant CAPS_PLUS_RISK_STEWARD = 0x82dcCF206Ae2Ab46E2099e663F70DeE77caE7778;\n\n  // https://etherscan.io/address/0x2eE68ACb6A1319de1b49DC139894644E424fefD6\n  address internal constant FREEZING_STEWARD = 0x2eE68ACb6A1319de1b49DC139894644E424fefD6;\n\n  // https://etherscan.io/address/0x8761e0370f94f68Db8EaA731f4fC581f6AD0Bd68\n  address internal constant DEBT_SWAP_ADAPTER = 0x8761e0370f94f68Db8EaA731f4fC581f6AD0Bd68;\n\n  // https://etherscan.io/address/0x21714092D90c7265F52fdfDae068EC11a23C6248\n  address internal constant DELEGATION_AWARE_A_TOKEN_IMPL_REV_1 =\n    0x21714092D90c7265F52fdfDae068EC11a23C6248;\n\n  // https://etherscan.io/address/0xA3e44d830440dF5098520F62Ebec285B1198c51E\n  address internal constant CONFIG_ENGINE = 0xA3e44d830440dF5098520F62Ebec285B1198c51E;\n\n  // https://etherscan.io/address/0xbaA999AC55EAce41CcAE355c77809e68Bb345170\n  address internal constant POOL_ADDRESSES_PROVIDER_REGISTRY =\n    0xbaA999AC55EAce41CcAE355c77809e68Bb345170;\n\n  // https://etherscan.io/address/0xcC47c4Fe1F7f29ff31A8b62197023aC8553C7896\n  address internal constant RATES_FACTORY = 0xcC47c4Fe1F7f29ff31A8b62197023aC8553C7896;\n\n  // https://etherscan.io/address/0x02e7B8511831B1b02d9018215a0f8f500Ea5c6B3\n  address internal constant REPAY_WITH_COLLATERAL_ADAPTER =\n    0x02e7B8511831B1b02d9018215a0f8f500Ea5c6B3;\n\n  // https://etherscan.io/address/0x411D79b8cC43384FDE66CaBf9b6a17180c842511\n  address internal constant STATIC_A_TOKEN_FACTORY = 0x411D79b8cC43384FDE66CaBf9b6a17180c842511;\n\n  // https://etherscan.io/address/0xADC0A53095A0af87F3aa29FE0715B5c28016364e\n  address internal constant SWAP_COLLATERAL_ADAPTER = 0xADC0A53095A0af87F3aa29FE0715B5c28016364e;\n\n  // https://etherscan.io/address/0x379c1EDD1A41218bdbFf960a9d5AD2818Bf61aE8\n  address internal constant UI_GHO_DATA_PROVIDER = 0x379c1EDD1A41218bdbFf960a9d5AD2818Bf61aE8;\n\n  // https://etherscan.io/address/0x162A7AC02f547ad796CA549f757e2b8d1D9b10a6\n  address internal constant UI_INCENTIVE_DATA_PROVIDER = 0x162A7AC02f547ad796CA549f757e2b8d1D9b10a6;\n\n  // https://etherscan.io/address/0x91c0eA31b49B69Ea18607702c5d9aC360bf3dE7d\n  address internal constant UI_POOL_DATA_PROVIDER = 0x91c0eA31b49B69Ea18607702c5d9aC360bf3dE7d;\n\n  // https://etherscan.io/address/0xC7be5307ba715ce89b152f3Df0658295b3dbA8E2\n  address internal constant WALLET_BALANCE_PROVIDER = 0xC7be5307ba715ce89b152f3Df0658295b3dbA8E2;\n\n  // https://etherscan.io/address/0x893411580e590D62dDBca8a703d61Cc4A8c7b2b9\n  address internal constant WETH_GATEWAY = 0x893411580e590D62dDBca8a703d61Cc4A8c7b2b9;\n\n  // https://etherscan.io/address/0x78F8Bd884C3D738B74B420540659c82f392820e0\n  address internal constant WITHDRAW_SWAP_ADAPTER = 0x78F8Bd884C3D738B74B420540659c82f392820e0;\n\n  // https://etherscan.io/address/0xE28E2c8d240dd5eBd0adcab86fbD79df7a052034\n  address internal constant SAVINGS_DAI_TOKEN_WRAPPER = 0xE28E2c8d240dd5eBd0adcab86fbD79df7a052034;\n}\n\nlibrary AaveV3EthereumAssets {\n  // https://etherscan.io/address/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n  address internal constant WETH_UNDERLYING = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n  uint8 internal constant WETH_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x4d5F47FA6A74757f35C14fD3a6Ef8E3C9BC514E8\n  address internal constant WETH_A_TOKEN = 0x4d5F47FA6A74757f35C14fD3a6Ef8E3C9BC514E8;\n\n  // https://etherscan.io/address/0xeA51d7853EEFb32b6ee06b1C12E6dcCA88Be0fFE\n  address internal constant WETH_V_TOKEN = 0xeA51d7853EEFb32b6ee06b1C12E6dcCA88Be0fFE;\n\n  // https://etherscan.io/address/0x102633152313C81cD80419b6EcF66d14Ad68949A\n  address internal constant WETH_S_TOKEN = 0x102633152313C81cD80419b6EcF66d14Ad68949A;\n\n  // https://etherscan.io/address/0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n  address internal constant WETH_ORACLE = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n\n  // https://etherscan.io/address/0x42ec99A020B78C449d17d93bC4c89e0189B5811d\n  address internal constant WETH_INTEREST_RATE_STRATEGY =\n    0x42ec99A020B78C449d17d93bC4c89e0189B5811d;\n\n  // https://etherscan.io/address/0x252231882FB38481497f3C767469106297c8d93b\n  address internal constant WETH_STATA_TOKEN = 0x252231882FB38481497f3C767469106297c8d93b;\n\n  // https://etherscan.io/address/0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0\n  address internal constant wstETH_UNDERLYING = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n\n  uint8 internal constant wstETH_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x0B925eD163218f6662a35e0f0371Ac234f9E9371\n  address internal constant wstETH_A_TOKEN = 0x0B925eD163218f6662a35e0f0371Ac234f9E9371;\n\n  // https://etherscan.io/address/0xC96113eED8cAB59cD8A66813bCB0cEb29F06D2e4\n  address internal constant wstETH_V_TOKEN = 0xC96113eED8cAB59cD8A66813bCB0cEb29F06D2e4;\n\n  // https://etherscan.io/address/0x39739943199c0fBFe9E5f1B5B160cd73a64CB85D\n  address internal constant wstETH_S_TOKEN = 0x39739943199c0fBFe9E5f1B5B160cd73a64CB85D;\n\n  // https://etherscan.io/address/0xB4aB0c94159bc2d8C133946E7241368fc2F2a010\n  address internal constant wstETH_ORACLE = 0xB4aB0c94159bc2d8C133946E7241368fc2F2a010;\n\n  // https://etherscan.io/address/0x7b8Fa4540246554e77FCFf140f9114de00F8bB8D\n  address internal constant wstETH_INTEREST_RATE_STRATEGY =\n    0x7b8Fa4540246554e77FCFf140f9114de00F8bB8D;\n\n  // https://etherscan.io/address/0x322AA5F5Be95644d6c36544B6c5061F072D16DF5\n  address internal constant wstETH_STATA_TOKEN = 0x322AA5F5Be95644d6c36544B6c5061F072D16DF5;\n\n  // https://etherscan.io/address/0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\n  address internal constant WBTC_UNDERLYING = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n\n  uint8 internal constant WBTC_DECIMALS = 8;\n\n  // https://etherscan.io/address/0x5Ee5bf7ae06D1Be5997A1A72006FE6C607eC6DE8\n  address internal constant WBTC_A_TOKEN = 0x5Ee5bf7ae06D1Be5997A1A72006FE6C607eC6DE8;\n\n  // https://etherscan.io/address/0x40aAbEf1aa8f0eEc637E0E7d92fbfFB2F26A8b7B\n  address internal constant WBTC_V_TOKEN = 0x40aAbEf1aa8f0eEc637E0E7d92fbfFB2F26A8b7B;\n\n  // https://etherscan.io/address/0xA1773F1ccF6DB192Ad8FE826D15fe1d328B03284\n  address internal constant WBTC_S_TOKEN = 0xA1773F1ccF6DB192Ad8FE826D15fe1d328B03284;\n\n  // https://etherscan.io/address/0x230E0321Cf38F09e247e50Afc7801EA2351fe56F\n  address internal constant WBTC_ORACLE = 0x230E0321Cf38F09e247e50Afc7801EA2351fe56F;\n\n  // https://etherscan.io/address/0x07Fa3744FeC271F80c2EA97679823F65c13CCDf4\n  address internal constant WBTC_INTEREST_RATE_STRATEGY =\n    0x07Fa3744FeC271F80c2EA97679823F65c13CCDf4;\n\n  // https://etherscan.io/address/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n  address internal constant USDC_UNDERLYING = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n  uint8 internal constant USDC_DECIMALS = 6;\n\n  // https://etherscan.io/address/0x98C23E9d8f34FEFb1B7BD6a91B7FF122F4e16F5c\n  address internal constant USDC_A_TOKEN = 0x98C23E9d8f34FEFb1B7BD6a91B7FF122F4e16F5c;\n\n  // https://etherscan.io/address/0x72E95b8931767C79bA4EeE721354d6E99a61D004\n  address internal constant USDC_V_TOKEN = 0x72E95b8931767C79bA4EeE721354d6E99a61D004;\n\n  // https://etherscan.io/address/0xB0fe3D292f4bd50De902Ba5bDF120Ad66E9d7a39\n  address internal constant USDC_S_TOKEN = 0xB0fe3D292f4bd50De902Ba5bDF120Ad66E9d7a39;\n\n  // https://etherscan.io/address/0x736bF902680e68989886e9807CD7Db4B3E015d3C\n  address internal constant USDC_ORACLE = 0x736bF902680e68989886e9807CD7Db4B3E015d3C;\n\n  // https://etherscan.io/address/0x0fc12Ad84210695dE8C0D5D8B6f720C37cEaB02f\n  address internal constant USDC_INTEREST_RATE_STRATEGY =\n    0x0fc12Ad84210695dE8C0D5D8B6f720C37cEaB02f;\n\n  // https://etherscan.io/address/0x73edDFa87C71ADdC275c2b9890f5c3a8480bC9E6\n  address internal constant USDC_STATA_TOKEN = 0x73edDFa87C71ADdC275c2b9890f5c3a8480bC9E6;\n\n  // https://etherscan.io/address/0x6B175474E89094C44Da98b954EedeAC495271d0F\n  address internal constant DAI_UNDERLYING = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n  uint8 internal constant DAI_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x018008bfb33d285247A21d44E50697654f754e63\n  address internal constant DAI_A_TOKEN = 0x018008bfb33d285247A21d44E50697654f754e63;\n\n  // https://etherscan.io/address/0xcF8d0c70c850859266f5C338b38F9D663181C314\n  address internal constant DAI_V_TOKEN = 0xcF8d0c70c850859266f5C338b38F9D663181C314;\n\n  // https://etherscan.io/address/0x413AdaC9E2Ef8683ADf5DDAEce8f19613d60D1bb\n  address internal constant DAI_S_TOKEN = 0x413AdaC9E2Ef8683ADf5DDAEce8f19613d60D1bb;\n\n  // https://etherscan.io/address/0xaEb897E1Dc6BbdceD3B9D551C71a8cf172F27AC4\n  address internal constant DAI_ORACLE = 0xaEb897E1Dc6BbdceD3B9D551C71a8cf172F27AC4;\n\n  // https://etherscan.io/address/0x05F410A9EB94e0BEe0E47F12254E7Cb5F4E2A1f7\n  address internal constant DAI_INTEREST_RATE_STRATEGY = 0x05F410A9EB94e0BEe0E47F12254E7Cb5F4E2A1f7;\n\n  // https://etherscan.io/address/0xaf270C38fF895EA3f95Ed488CEACe2386F038249\n  address internal constant DAI_STATA_TOKEN = 0xaf270C38fF895EA3f95Ed488CEACe2386F038249;\n\n  // https://etherscan.io/address/0x514910771AF9Ca656af840dff83E8264EcF986CA\n  address internal constant LINK_UNDERLYING = 0x514910771AF9Ca656af840dff83E8264EcF986CA;\n\n  uint8 internal constant LINK_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x5E8C8A7243651DB1384C0dDfDbE39761E8e7E51a\n  address internal constant LINK_A_TOKEN = 0x5E8C8A7243651DB1384C0dDfDbE39761E8e7E51a;\n\n  // https://etherscan.io/address/0x4228F8895C7dDA20227F6a5c6751b8Ebf19a6ba8\n  address internal constant LINK_V_TOKEN = 0x4228F8895C7dDA20227F6a5c6751b8Ebf19a6ba8;\n\n  // https://etherscan.io/address/0x63B1129ca97D2b9F97f45670787Ac12a9dF1110a\n  address internal constant LINK_S_TOKEN = 0x63B1129ca97D2b9F97f45670787Ac12a9dF1110a;\n\n  // https://etherscan.io/address/0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c\n  address internal constant LINK_ORACLE = 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c;\n\n  // https://etherscan.io/address/0x24701A6368Ff6D2874d6b8cDadd461552B8A5283\n  address internal constant LINK_INTEREST_RATE_STRATEGY =\n    0x24701A6368Ff6D2874d6b8cDadd461552B8A5283;\n\n  // https://etherscan.io/address/0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9\n  address internal constant AAVE_UNDERLYING = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\n\n  uint8 internal constant AAVE_DECIMALS = 18;\n\n  // https://etherscan.io/address/0xA700b4eB416Be35b2911fd5Dee80678ff64fF6C9\n  address internal constant AAVE_A_TOKEN = 0xA700b4eB416Be35b2911fd5Dee80678ff64fF6C9;\n\n  // https://etherscan.io/address/0xBae535520Abd9f8C85E58929e0006A2c8B372F74\n  address internal constant AAVE_V_TOKEN = 0xBae535520Abd9f8C85E58929e0006A2c8B372F74;\n\n  // https://etherscan.io/address/0x268497bF083388B1504270d0E717222d3A87D6F2\n  address internal constant AAVE_S_TOKEN = 0x268497bF083388B1504270d0E717222d3A87D6F2;\n\n  // https://etherscan.io/address/0x547a514d5e3769680Ce22B2361c10Ea13619e8a9\n  address internal constant AAVE_ORACLE = 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9;\n\n  // https://etherscan.io/address/0x24701A6368Ff6D2874d6b8cDadd461552B8A5283\n  address internal constant AAVE_INTEREST_RATE_STRATEGY =\n    0x24701A6368Ff6D2874d6b8cDadd461552B8A5283;\n\n  // https://etherscan.io/address/0xBe9895146f7AF43049ca1c1AE358B0541Ea49704\n  address internal constant cbETH_UNDERLYING = 0xBe9895146f7AF43049ca1c1AE358B0541Ea49704;\n\n  uint8 internal constant cbETH_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x977b6fc5dE62598B08C85AC8Cf2b745874E8b78c\n  address internal constant cbETH_A_TOKEN = 0x977b6fc5dE62598B08C85AC8Cf2b745874E8b78c;\n\n  // https://etherscan.io/address/0x0c91bcA95b5FE69164cE583A2ec9429A569798Ed\n  address internal constant cbETH_V_TOKEN = 0x0c91bcA95b5FE69164cE583A2ec9429A569798Ed;\n\n  // https://etherscan.io/address/0x82bE6012cea6D147B968eBAea5ceEcF6A5b4F493\n  address internal constant cbETH_S_TOKEN = 0x82bE6012cea6D147B968eBAea5ceEcF6A5b4F493;\n\n  // https://etherscan.io/address/0x6243d2F41b4ec944F731f647589E28d9745a2674\n  address internal constant cbETH_ORACLE = 0x6243d2F41b4ec944F731f647589E28d9745a2674;\n\n  // https://etherscan.io/address/0x24701A6368Ff6D2874d6b8cDadd461552B8A5283\n  address internal constant cbETH_INTEREST_RATE_STRATEGY =\n    0x24701A6368Ff6D2874d6b8cDadd461552B8A5283;\n\n  // https://etherscan.io/address/0xdAC17F958D2ee523a2206206994597C13D831ec7\n  address internal constant USDT_UNDERLYING = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n  uint8 internal constant USDT_DECIMALS = 6;\n\n  // https://etherscan.io/address/0x23878914EFE38d27C4D67Ab83ed1b93A74D4086a\n  address internal constant USDT_A_TOKEN = 0x23878914EFE38d27C4D67Ab83ed1b93A74D4086a;\n\n  // https://etherscan.io/address/0x6df1C1E379bC5a00a7b4C6e67A203333772f45A8\n  address internal constant USDT_V_TOKEN = 0x6df1C1E379bC5a00a7b4C6e67A203333772f45A8;\n\n  // https://etherscan.io/address/0x822Fa72Df1F229C3900f5AD6C3Fa2C424D691622\n  address internal constant USDT_S_TOKEN = 0x822Fa72Df1F229C3900f5AD6C3Fa2C424D691622;\n\n  // https://etherscan.io/address/0xC26D4a1c46d884cfF6dE9800B6aE7A8Cf48B4Ff8\n  address internal constant USDT_ORACLE = 0xC26D4a1c46d884cfF6dE9800B6aE7A8Cf48B4Ff8;\n\n  // https://etherscan.io/address/0xca719585f2E07BDe82c4a05D6E7C0E446c2D6601\n  address internal constant USDT_INTEREST_RATE_STRATEGY =\n    0xca719585f2E07BDe82c4a05D6E7C0E446c2D6601;\n\n  // https://etherscan.io/address/0x862c57d48becB45583AEbA3f489696D22466Ca1b\n  address internal constant USDT_STATA_TOKEN = 0x862c57d48becB45583AEbA3f489696D22466Ca1b;\n\n  // https://etherscan.io/address/0xae78736Cd615f374D3085123A210448E74Fc6393\n  address internal constant rETH_UNDERLYING = 0xae78736Cd615f374D3085123A210448E74Fc6393;\n\n  uint8 internal constant rETH_DECIMALS = 18;\n\n  // https://etherscan.io/address/0xCc9EE9483f662091a1de4795249E24aC0aC2630f\n  address internal constant rETH_A_TOKEN = 0xCc9EE9483f662091a1de4795249E24aC0aC2630f;\n\n  // https://etherscan.io/address/0xae8593DD575FE29A9745056aA91C4b746eee62C8\n  address internal constant rETH_V_TOKEN = 0xae8593DD575FE29A9745056aA91C4b746eee62C8;\n\n  // https://etherscan.io/address/0x1d1906f909CAe494c7441604DAfDDDbD0485A925\n  address internal constant rETH_S_TOKEN = 0x1d1906f909CAe494c7441604DAfDDDbD0485A925;\n\n  // https://etherscan.io/address/0x5AE8365D0a30D67145f0c55A08760C250559dB64\n  address internal constant rETH_ORACLE = 0x5AE8365D0a30D67145f0c55A08760C250559dB64;\n\n  // https://etherscan.io/address/0x24701A6368Ff6D2874d6b8cDadd461552B8A5283\n  address internal constant rETH_INTEREST_RATE_STRATEGY =\n    0x24701A6368Ff6D2874d6b8cDadd461552B8A5283;\n\n  // https://etherscan.io/address/0x5f98805A4E8be255a32880FDeC7F6728C6568bA0\n  address internal constant LUSD_UNDERLYING = 0x5f98805A4E8be255a32880FDeC7F6728C6568bA0;\n\n  uint8 internal constant LUSD_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x3Fe6a295459FAe07DF8A0ceCC36F37160FE86AA9\n  address internal constant LUSD_A_TOKEN = 0x3Fe6a295459FAe07DF8A0ceCC36F37160FE86AA9;\n\n  // https://etherscan.io/address/0x33652e48e4B74D18520f11BfE58Edd2ED2cEc5A2\n  address internal constant LUSD_V_TOKEN = 0x33652e48e4B74D18520f11BfE58Edd2ED2cEc5A2;\n\n  // https://etherscan.io/address/0x37A6B708FDB1483C231961b9a7F145261E815fc3\n  address internal constant LUSD_S_TOKEN = 0x37A6B708FDB1483C231961b9a7F145261E815fc3;\n\n  // https://etherscan.io/address/0x9eCdfaCca946614cc32aF63F3DBe50959244F3af\n  address internal constant LUSD_ORACLE = 0x9eCdfaCca946614cc32aF63F3DBe50959244F3af;\n\n  // https://etherscan.io/address/0x2B3Ed91C6667d808b0401f439c4859ea635c6862\n  address internal constant LUSD_INTEREST_RATE_STRATEGY =\n    0x2B3Ed91C6667d808b0401f439c4859ea635c6862;\n\n  // https://etherscan.io/address/0xDBf5E36569798D1E39eE9d7B1c61A7409a74F23A\n  address internal constant LUSD_STATA_TOKEN = 0xDBf5E36569798D1E39eE9d7B1c61A7409a74F23A;\n\n  // https://etherscan.io/address/0xD533a949740bb3306d119CC777fa900bA034cd52\n  address internal constant CRV_UNDERLYING = 0xD533a949740bb3306d119CC777fa900bA034cd52;\n\n  uint8 internal constant CRV_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x7B95Ec873268a6BFC6427e7a28e396Db9D0ebc65\n  address internal constant CRV_A_TOKEN = 0x7B95Ec873268a6BFC6427e7a28e396Db9D0ebc65;\n\n  // https://etherscan.io/address/0x1b7D3F4b3c032a5AE656e30eeA4e8E1Ba376068F\n  address internal constant CRV_V_TOKEN = 0x1b7D3F4b3c032a5AE656e30eeA4e8E1Ba376068F;\n\n  // https://etherscan.io/address/0x90D9CD005E553111EB8C9c31Abe9706a186b6048\n  address internal constant CRV_S_TOKEN = 0x90D9CD005E553111EB8C9c31Abe9706a186b6048;\n\n  // https://etherscan.io/address/0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f\n  address internal constant CRV_ORACLE = 0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f;\n\n  // https://etherscan.io/address/0x76884cAFeCf1f7d4146DA6C4053B18B76bf6ED14\n  address internal constant CRV_INTEREST_RATE_STRATEGY = 0x76884cAFeCf1f7d4146DA6C4053B18B76bf6ED14;\n\n  // https://etherscan.io/address/0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2\n  address internal constant MKR_UNDERLYING = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n\n  uint8 internal constant MKR_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x8A458A9dc9048e005d22849F470891b840296619\n  address internal constant MKR_A_TOKEN = 0x8A458A9dc9048e005d22849F470891b840296619;\n\n  // https://etherscan.io/address/0x6Efc73E54E41b27d2134fF9f98F15550f30DF9B1\n  address internal constant MKR_V_TOKEN = 0x6Efc73E54E41b27d2134fF9f98F15550f30DF9B1;\n\n  // https://etherscan.io/address/0x0496372BE7e426D28E89DEBF01f19F014d5938bE\n  address internal constant MKR_S_TOKEN = 0x0496372BE7e426D28E89DEBF01f19F014d5938bE;\n\n  // https://etherscan.io/address/0xec1D1B3b0443256cc3860e24a46F108e699484Aa\n  address internal constant MKR_ORACLE = 0xec1D1B3b0443256cc3860e24a46F108e699484Aa;\n\n  // https://etherscan.io/address/0x27eFE5db315b71753b2a38ED3d5dd7E9362ba93F\n  address internal constant MKR_INTEREST_RATE_STRATEGY = 0x27eFE5db315b71753b2a38ED3d5dd7E9362ba93F;\n\n  // https://etherscan.io/address/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F\n  address internal constant SNX_UNDERLYING = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n\n  uint8 internal constant SNX_DECIMALS = 18;\n\n  // https://etherscan.io/address/0xC7B4c17861357B8ABB91F25581E7263E08DCB59c\n  address internal constant SNX_A_TOKEN = 0xC7B4c17861357B8ABB91F25581E7263E08DCB59c;\n\n  // https://etherscan.io/address/0x8d0de040e8aAd872eC3c33A3776dE9152D3c34ca\n  address internal constant SNX_V_TOKEN = 0x8d0de040e8aAd872eC3c33A3776dE9152D3c34ca;\n\n  // https://etherscan.io/address/0x478E1ec1A2BeEd94c1407c951E4B9e22d53b2501\n  address internal constant SNX_S_TOKEN = 0x478E1ec1A2BeEd94c1407c951E4B9e22d53b2501;\n\n  // https://etherscan.io/address/0xDC3EA94CD0AC27d9A86C180091e7f78C683d3699\n  address internal constant SNX_ORACLE = 0xDC3EA94CD0AC27d9A86C180091e7f78C683d3699;\n\n  // https://etherscan.io/address/0xA6459195d60A797D278f58Ffbd2BA62Fb3F7FA1E\n  address internal constant SNX_INTEREST_RATE_STRATEGY = 0xA6459195d60A797D278f58Ffbd2BA62Fb3F7FA1E;\n\n  // https://etherscan.io/address/0xba100000625a3754423978a60c9317c58a424e3D\n  address internal constant BAL_UNDERLYING = 0xba100000625a3754423978a60c9317c58a424e3D;\n\n  uint8 internal constant BAL_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x2516E7B3F76294e03C42AA4c5b5b4DCE9C436fB8\n  address internal constant BAL_A_TOKEN = 0x2516E7B3F76294e03C42AA4c5b5b4DCE9C436fB8;\n\n  // https://etherscan.io/address/0x3D3efceb4Ff0966D34d9545D3A2fa2dcdBf451f2\n  address internal constant BAL_V_TOKEN = 0x3D3efceb4Ff0966D34d9545D3A2fa2dcdBf451f2;\n\n  // https://etherscan.io/address/0xB368d45aaAa07ee2c6275Cb320D140b22dE43CDD\n  address internal constant BAL_S_TOKEN = 0xB368d45aaAa07ee2c6275Cb320D140b22dE43CDD;\n\n  // https://etherscan.io/address/0xdF2917806E30300537aEB49A7663062F4d1F2b5F\n  address internal constant BAL_ORACLE = 0xdF2917806E30300537aEB49A7663062F4d1F2b5F;\n\n  // https://etherscan.io/address/0xd9d85499449f26d2A2c240defd75314f23920089\n  address internal constant BAL_INTEREST_RATE_STRATEGY = 0xd9d85499449f26d2A2c240defd75314f23920089;\n\n  // https://etherscan.io/address/0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\n  address internal constant UNI_UNDERLYING = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984;\n\n  uint8 internal constant UNI_DECIMALS = 18;\n\n  // https://etherscan.io/address/0xF6D2224916DDFbbab6e6bd0D1B7034f4Ae0CaB18\n  address internal constant UNI_A_TOKEN = 0xF6D2224916DDFbbab6e6bd0D1B7034f4Ae0CaB18;\n\n  // https://etherscan.io/address/0xF64178Ebd2E2719F2B1233bCb5Ef6DB4bCc4d09a\n  address internal constant UNI_V_TOKEN = 0xF64178Ebd2E2719F2B1233bCb5Ef6DB4bCc4d09a;\n\n  // https://etherscan.io/address/0x2FEc76324A0463c46f32e74A86D1cf94C02158DC\n  address internal constant UNI_S_TOKEN = 0x2FEc76324A0463c46f32e74A86D1cf94C02158DC;\n\n  // https://etherscan.io/address/0x553303d460EE0afB37EdFf9bE42922D8FF63220e\n  address internal constant UNI_ORACLE = 0x553303d460EE0afB37EdFf9bE42922D8FF63220e;\n\n  // https://etherscan.io/address/0x27eFE5db315b71753b2a38ED3d5dd7E9362ba93F\n  address internal constant UNI_INTEREST_RATE_STRATEGY = 0x27eFE5db315b71753b2a38ED3d5dd7E9362ba93F;\n\n  // https://etherscan.io/address/0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32\n  address internal constant LDO_UNDERLYING = 0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32;\n\n  uint8 internal constant LDO_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x9A44fd41566876A39655f74971a3A6eA0a17a454\n  address internal constant LDO_A_TOKEN = 0x9A44fd41566876A39655f74971a3A6eA0a17a454;\n\n  // https://etherscan.io/address/0xc30808705C01289A3D306ca9CAB081Ba9114eC82\n  address internal constant LDO_V_TOKEN = 0xc30808705C01289A3D306ca9CAB081Ba9114eC82;\n\n  // https://etherscan.io/address/0xa0a5bF5781Aeb548db9d4226363B9e89287C5FD2\n  address internal constant LDO_S_TOKEN = 0xa0a5bF5781Aeb548db9d4226363B9e89287C5FD2;\n\n  // https://etherscan.io/address/0xb01e6C9af83879B8e06a092f0DD94309c0D497E4\n  address internal constant LDO_ORACLE = 0xb01e6C9af83879B8e06a092f0DD94309c0D497E4;\n\n  // https://etherscan.io/address/0x27eFE5db315b71753b2a38ED3d5dd7E9362ba93F\n  address internal constant LDO_INTEREST_RATE_STRATEGY = 0x27eFE5db315b71753b2a38ED3d5dd7E9362ba93F;\n\n  // https://etherscan.io/address/0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72\n  address internal constant ENS_UNDERLYING = 0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72;\n\n  uint8 internal constant ENS_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x545bD6c032eFdde65A377A6719DEF2796C8E0f2e\n  address internal constant ENS_A_TOKEN = 0x545bD6c032eFdde65A377A6719DEF2796C8E0f2e;\n\n  // https://etherscan.io/address/0xd180D7fdD4092f07428eFE801E17BC03576b3192\n  address internal constant ENS_V_TOKEN = 0xd180D7fdD4092f07428eFE801E17BC03576b3192;\n\n  // https://etherscan.io/address/0x7617d02E311CdE347A0cb45BB7DF2926BBaf5347\n  address internal constant ENS_S_TOKEN = 0x7617d02E311CdE347A0cb45BB7DF2926BBaf5347;\n\n  // https://etherscan.io/address/0x5C00128d4d1c2F4f652C267d7bcdD7aC99C16E16\n  address internal constant ENS_ORACLE = 0x5C00128d4d1c2F4f652C267d7bcdD7aC99C16E16;\n\n  // https://etherscan.io/address/0xf6733B9842883BFE0e0a940eA2F572676af31bde\n  address internal constant ENS_INTEREST_RATE_STRATEGY = 0xf6733B9842883BFE0e0a940eA2F572676af31bde;\n\n  // https://etherscan.io/address/0x111111111117dC0aa78b770fA6A738034120C302\n  address internal constant ONE_INCH_UNDERLYING = 0x111111111117dC0aa78b770fA6A738034120C302;\n\n  uint8 internal constant ONE_INCH_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x71Aef7b30728b9BB371578f36c5A1f1502a5723e\n  address internal constant ONE_INCH_A_TOKEN = 0x71Aef7b30728b9BB371578f36c5A1f1502a5723e;\n\n  // https://etherscan.io/address/0xA38fCa8c6Bf9BdA52E76EB78f08CaA3BE7c5A970\n  address internal constant ONE_INCH_V_TOKEN = 0xA38fCa8c6Bf9BdA52E76EB78f08CaA3BE7c5A970;\n\n  // https://etherscan.io/address/0x4b62bFAff61AB3985798e5202D2d167F567D0BCD\n  address internal constant ONE_INCH_S_TOKEN = 0x4b62bFAff61AB3985798e5202D2d167F567D0BCD;\n\n  // https://etherscan.io/address/0xc929ad75B72593967DE83E7F7Cda0493458261D9\n  address internal constant ONE_INCH_ORACLE = 0xc929ad75B72593967DE83E7F7Cda0493458261D9;\n\n  // https://etherscan.io/address/0xf6733B9842883BFE0e0a940eA2F572676af31bde\n  address internal constant ONE_INCH_INTEREST_RATE_STRATEGY =\n    0xf6733B9842883BFE0e0a940eA2F572676af31bde;\n\n  // https://etherscan.io/address/0x853d955aCEf822Db058eb8505911ED77F175b99e\n  address internal constant FRAX_UNDERLYING = 0x853d955aCEf822Db058eb8505911ED77F175b99e;\n\n  uint8 internal constant FRAX_DECIMALS = 18;\n\n  // https://etherscan.io/address/0xd4e245848d6E1220DBE62e155d89fa327E43CB06\n  address internal constant FRAX_A_TOKEN = 0xd4e245848d6E1220DBE62e155d89fa327E43CB06;\n\n  // https://etherscan.io/address/0x88B8358F5BC87c2D7E116cCA5b65A9eEb2c5EA3F\n  address internal constant FRAX_V_TOKEN = 0x88B8358F5BC87c2D7E116cCA5b65A9eEb2c5EA3F;\n\n  // https://etherscan.io/address/0x219640546c0DFDDCb9ab3bcdA89B324e0a376367\n  address internal constant FRAX_S_TOKEN = 0x219640546c0DFDDCb9ab3bcdA89B324e0a376367;\n\n  // https://etherscan.io/address/0x45D270263BBee500CF8adcf2AbC0aC227097b036\n  address internal constant FRAX_ORACLE = 0x45D270263BBee500CF8adcf2AbC0aC227097b036;\n\n  // https://etherscan.io/address/0xA7D9302346d4C35724821cf98966B2257c9683c6\n  address internal constant FRAX_INTEREST_RATE_STRATEGY =\n    0xA7D9302346d4C35724821cf98966B2257c9683c6;\n\n  // https://etherscan.io/address/0xEE66abD4D0f9908A48E08AE354B0f425De3e237E\n  address internal constant FRAX_STATA_TOKEN = 0xEE66abD4D0f9908A48E08AE354B0f425De3e237E;\n\n  // https://etherscan.io/address/0x40D16FC0246aD3160Ccc09B8D0D3A2cD28aE6C2f\n  address internal constant GHO_UNDERLYING = 0x40D16FC0246aD3160Ccc09B8D0D3A2cD28aE6C2f;\n\n  uint8 internal constant GHO_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x00907f9921424583e7ffBfEdf84F92B7B2Be4977\n  address internal constant GHO_A_TOKEN = 0x00907f9921424583e7ffBfEdf84F92B7B2Be4977;\n\n  // https://etherscan.io/address/0x786dBff3f1292ae8F92ea68Cf93c30b34B1ed04B\n  address internal constant GHO_V_TOKEN = 0x786dBff3f1292ae8F92ea68Cf93c30b34B1ed04B;\n\n  // https://etherscan.io/address/0x3f3DF7266dA30102344A813F1a3D07f5F041B5AC\n  address internal constant GHO_S_TOKEN = 0x3f3DF7266dA30102344A813F1a3D07f5F041B5AC;\n\n  // https://etherscan.io/address/0xD110cac5d8682A3b045D5524a9903E031d70FCCd\n  address internal constant GHO_ORACLE = 0xD110cac5d8682A3b045D5524a9903E031d70FCCd;\n\n  // https://etherscan.io/address/0x4001afa0E0B6A882bE51499932a6f82F133D03F9\n  address internal constant GHO_INTEREST_RATE_STRATEGY = 0x4001afa0E0B6A882bE51499932a6f82F133D03F9;\n\n  // https://etherscan.io/address/0xD33526068D116cE69F19A9ee46F0bd304F21A51f\n  address internal constant RPL_UNDERLYING = 0xD33526068D116cE69F19A9ee46F0bd304F21A51f;\n\n  uint8 internal constant RPL_DECIMALS = 18;\n\n  // https://etherscan.io/address/0xB76CF92076adBF1D9C39294FA8e7A67579FDe357\n  address internal constant RPL_A_TOKEN = 0xB76CF92076adBF1D9C39294FA8e7A67579FDe357;\n\n  // https://etherscan.io/address/0x8988ECA19D502fd8b9CCd03fA3bD20a6f599bc2A\n  address internal constant RPL_V_TOKEN = 0x8988ECA19D502fd8b9CCd03fA3bD20a6f599bc2A;\n\n  // https://etherscan.io/address/0x41e330fd8F7eA31E2e8F02cC0C9392D1403597B4\n  address internal constant RPL_S_TOKEN = 0x41e330fd8F7eA31E2e8F02cC0C9392D1403597B4;\n\n  // https://etherscan.io/address/0x4E155eD98aFE9034b7A5962f6C84c86d869daA9d\n  address internal constant RPL_ORACLE = 0x4E155eD98aFE9034b7A5962f6C84c86d869daA9d;\n\n  // https://etherscan.io/address/0xD87974E8ED49AB16d5053ba793F4e17078Be0426\n  address internal constant RPL_INTEREST_RATE_STRATEGY = 0xD87974E8ED49AB16d5053ba793F4e17078Be0426;\n\n  // https://etherscan.io/address/0x83F20F44975D03b1b09e64809B757c47f942BEeA\n  address internal constant sDAI_UNDERLYING = 0x83F20F44975D03b1b09e64809B757c47f942BEeA;\n\n  uint8 internal constant sDAI_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x4C612E3B15b96Ff9A6faED838F8d07d479a8dD4c\n  address internal constant sDAI_A_TOKEN = 0x4C612E3B15b96Ff9A6faED838F8d07d479a8dD4c;\n\n  // https://etherscan.io/address/0x8Db9D35e117d8b93C6Ca9b644b25BaD5d9908141\n  address internal constant sDAI_V_TOKEN = 0x8Db9D35e117d8b93C6Ca9b644b25BaD5d9908141;\n\n  // https://etherscan.io/address/0x48Bc45f084988bC01933EA93EeFfEBC0416534f6\n  address internal constant sDAI_S_TOKEN = 0x48Bc45f084988bC01933EA93EeFfEBC0416534f6;\n\n  // https://etherscan.io/address/0x29081f7aB5a644716EfcDC10D5c926c5fEe9F72B\n  address internal constant sDAI_ORACLE = 0x29081f7aB5a644716EfcDC10D5c926c5fEe9F72B;\n\n  // https://etherscan.io/address/0xdef8F50155A6cf21181E29E400E8CffAE2d50968\n  address internal constant sDAI_INTEREST_RATE_STRATEGY =\n    0xdef8F50155A6cf21181E29E400E8CffAE2d50968;\n\n  // https://etherscan.io/address/0xAf5191B0De278C7286d6C7CC6ab6BB8A73bA2Cd6\n  address internal constant STG_UNDERLYING = 0xAf5191B0De278C7286d6C7CC6ab6BB8A73bA2Cd6;\n\n  uint8 internal constant STG_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x1bA9843bD4327c6c77011406dE5fA8749F7E3479\n  address internal constant STG_A_TOKEN = 0x1bA9843bD4327c6c77011406dE5fA8749F7E3479;\n\n  // https://etherscan.io/address/0x655568bDd6168325EC7e58Bf39b21A856F906Dc2\n  address internal constant STG_V_TOKEN = 0x655568bDd6168325EC7e58Bf39b21A856F906Dc2;\n\n  // https://etherscan.io/address/0xc3115D0660b93AeF10F298886ae22E3Dd477E482\n  address internal constant STG_S_TOKEN = 0xc3115D0660b93AeF10F298886ae22E3Dd477E482;\n\n  // https://etherscan.io/address/0x7A9f34a0Aa917D438e9b6E630067062B7F8f6f3d\n  address internal constant STG_ORACLE = 0x7A9f34a0Aa917D438e9b6E630067062B7F8f6f3d;\n\n  // https://etherscan.io/address/0x27eFE5db315b71753b2a38ED3d5dd7E9362ba93F\n  address internal constant STG_INTEREST_RATE_STRATEGY = 0x27eFE5db315b71753b2a38ED3d5dd7E9362ba93F;\n\n  // https://etherscan.io/address/0xdeFA4e8a7bcBA345F687a2f1456F5Edd9CE97202\n  address internal constant KNC_UNDERLYING = 0xdeFA4e8a7bcBA345F687a2f1456F5Edd9CE97202;\n\n  uint8 internal constant KNC_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x5b502e3796385E1e9755d7043B9C945C3aCCeC9C\n  address internal constant KNC_A_TOKEN = 0x5b502e3796385E1e9755d7043B9C945C3aCCeC9C;\n\n  // https://etherscan.io/address/0x253127Ffc04981cEA8932F406710661c2f2c3fD2\n  address internal constant KNC_V_TOKEN = 0x253127Ffc04981cEA8932F406710661c2f2c3fD2;\n\n  // https://etherscan.io/address/0xdfEE0C9eA1309cB9611F33972E72a72166fcF548\n  address internal constant KNC_S_TOKEN = 0xdfEE0C9eA1309cB9611F33972E72a72166fcF548;\n\n  // https://etherscan.io/address/0xf8fF43E991A81e6eC886a3D281A2C6cC19aE70Fc\n  address internal constant KNC_ORACLE = 0xf8fF43E991A81e6eC886a3D281A2C6cC19aE70Fc;\n\n  // https://etherscan.io/address/0xf6733B9842883BFE0e0a940eA2F572676af31bde\n  address internal constant KNC_INTEREST_RATE_STRATEGY = 0xf6733B9842883BFE0e0a940eA2F572676af31bde;\n\n  // https://etherscan.io/address/0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0\n  address internal constant FXS_UNDERLYING = 0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0;\n\n  uint8 internal constant FXS_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x82F9c5ad306BBa1AD0De49bB5FA6F01bf61085ef\n  address internal constant FXS_A_TOKEN = 0x82F9c5ad306BBa1AD0De49bB5FA6F01bf61085ef;\n\n  // https://etherscan.io/address/0x68e9f0aD4e6f8F5DB70F6923d4d6d5b225B83b16\n  address internal constant FXS_V_TOKEN = 0x68e9f0aD4e6f8F5DB70F6923d4d6d5b225B83b16;\n\n  // https://etherscan.io/address/0x61dFd349140C239d3B61fEe203Efc811b518a317\n  address internal constant FXS_S_TOKEN = 0x61dFd349140C239d3B61fEe203Efc811b518a317;\n\n  // https://etherscan.io/address/0x6Ebc52C8C1089be9eB3945C4350B68B8E4C2233f\n  address internal constant FXS_ORACLE = 0x6Ebc52C8C1089be9eB3945C4350B68B8E4C2233f;\n\n  // https://etherscan.io/address/0xf6733B9842883BFE0e0a940eA2F572676af31bde\n  address internal constant FXS_INTEREST_RATE_STRATEGY = 0xf6733B9842883BFE0e0a940eA2F572676af31bde;\n\n  // https://etherscan.io/address/0xf939E0A03FB07F59A73314E73794Be0E57ac1b4E\n  address internal constant crvUSD_UNDERLYING = 0xf939E0A03FB07F59A73314E73794Be0E57ac1b4E;\n\n  uint8 internal constant crvUSD_DECIMALS = 18;\n\n  // https://etherscan.io/address/0xb82fa9f31612989525992FCfBB09AB22Eff5c85A\n  address internal constant crvUSD_A_TOKEN = 0xb82fa9f31612989525992FCfBB09AB22Eff5c85A;\n\n  // https://etherscan.io/address/0x028f7886F3e937f8479efaD64f31B3fE1119857a\n  address internal constant crvUSD_V_TOKEN = 0x028f7886F3e937f8479efaD64f31B3fE1119857a;\n\n  // https://etherscan.io/address/0xb55C604075D79486b8A329c396Fc711Be54B5330\n  address internal constant crvUSD_S_TOKEN = 0xb55C604075D79486b8A329c396Fc711Be54B5330;\n\n  // https://etherscan.io/address/0x02AeE5b225366302339748951E1a924617b8814F\n  address internal constant crvUSD_ORACLE = 0x02AeE5b225366302339748951E1a924617b8814F;\n\n  // https://etherscan.io/address/0x22B409E1ab288DA6a895FE8251bEbfcA267f8805\n  address internal constant crvUSD_INTEREST_RATE_STRATEGY =\n    0x22B409E1ab288DA6a895FE8251bEbfcA267f8805;\n\n  // https://etherscan.io/address/0x848107491E029AFDe0AC543779c7790382f15929\n  address internal constant crvUSD_STATA_TOKEN = 0x848107491E029AFDe0AC543779c7790382f15929;\n\n  // https://etherscan.io/address/0x6c3ea9036406852006290770BEdFcAbA0e23A0e8\n  address internal constant PYUSD_UNDERLYING = 0x6c3ea9036406852006290770BEdFcAbA0e23A0e8;\n\n  uint8 internal constant PYUSD_DECIMALS = 6;\n\n  // https://etherscan.io/address/0x0C0d01AbF3e6aDfcA0989eBbA9d6e85dD58EaB1E\n  address internal constant PYUSD_A_TOKEN = 0x0C0d01AbF3e6aDfcA0989eBbA9d6e85dD58EaB1E;\n\n  // https://etherscan.io/address/0x57B67e4DE077085Fd0AF2174e9c14871BE664546\n  address internal constant PYUSD_V_TOKEN = 0x57B67e4DE077085Fd0AF2174e9c14871BE664546;\n\n  // https://etherscan.io/address/0x5B393DB4c72B1Bd82CE2834F6485d61b137Bc7aC\n  address internal constant PYUSD_S_TOKEN = 0x5B393DB4c72B1Bd82CE2834F6485d61b137Bc7aC;\n\n  // https://etherscan.io/address/0x150bAe7Ce224555D39AfdBc6Cb4B8204E594E022\n  address internal constant PYUSD_ORACLE = 0x150bAe7Ce224555D39AfdBc6Cb4B8204E594E022;\n\n  // https://etherscan.io/address/0x22B409E1ab288DA6a895FE8251bEbfcA267f8805\n  address internal constant PYUSD_INTEREST_RATE_STRATEGY =\n    0x22B409E1ab288DA6a895FE8251bEbfcA267f8805;\n\n  // https://etherscan.io/address/0x00F2a835758B33f3aC53516Ebd69f3dc77B0D152\n  address internal constant PYUSD_STATA_TOKEN = 0x00F2a835758B33f3aC53516Ebd69f3dc77B0D152;\n\n  // https://etherscan.io/address/0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee\n  address internal constant weETH_UNDERLYING = 0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee;\n\n  uint8 internal constant weETH_DECIMALS = 18;\n\n  // https://etherscan.io/address/0xBdfa7b7893081B35Fb54027489e2Bc7A38275129\n  address internal constant weETH_A_TOKEN = 0xBdfa7b7893081B35Fb54027489e2Bc7A38275129;\n\n  // https://etherscan.io/address/0x77ad9BF13a52517AD698D65913e8D381300c8Bf3\n  address internal constant weETH_V_TOKEN = 0x77ad9BF13a52517AD698D65913e8D381300c8Bf3;\n\n  // https://etherscan.io/address/0xBad6eF8e76E26F39e985474aD0974FDcabF85d37\n  address internal constant weETH_S_TOKEN = 0xBad6eF8e76E26F39e985474aD0974FDcabF85d37;\n\n  // https://etherscan.io/address/0xf112aF6F0A332B815fbEf3Ff932c057E570b62d3\n  address internal constant weETH_ORACLE = 0xf112aF6F0A332B815fbEf3Ff932c057E570b62d3;\n\n  // https://etherscan.io/address/0xf1e5355cEcaA71036CE21cdF8F9d04061B1BC6E1\n  address internal constant weETH_INTEREST_RATE_STRATEGY =\n    0xf1e5355cEcaA71036CE21cdF8F9d04061B1BC6E1;\n\n  // https://etherscan.io/address/0xf1C9acDc66974dFB6dEcB12aA385b9cD01190E38\n  address internal constant osETH_UNDERLYING = 0xf1C9acDc66974dFB6dEcB12aA385b9cD01190E38;\n\n  uint8 internal constant osETH_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x927709711794F3De5DdBF1D176bEE2D55Ba13c21\n  address internal constant osETH_A_TOKEN = 0x927709711794F3De5DdBF1D176bEE2D55Ba13c21;\n\n  // https://etherscan.io/address/0x8838eefF2af391863E1Bb8b1dF563F86743a8470\n  address internal constant osETH_V_TOKEN = 0x8838eefF2af391863E1Bb8b1dF563F86743a8470;\n\n  // https://etherscan.io/address/0x48Fa27f511F40d16f9E7C913e9388d52d95bC6d2\n  address internal constant osETH_S_TOKEN = 0x48Fa27f511F40d16f9E7C913e9388d52d95bC6d2;\n\n  // https://etherscan.io/address/0x0A2AF898cEc35197e6944D9E0F525C2626393442\n  address internal constant osETH_ORACLE = 0x0A2AF898cEc35197e6944D9E0F525C2626393442;\n\n  // https://etherscan.io/address/0x48AF11111764E710fcDcE2750db848C63edab57B\n  address internal constant osETH_INTEREST_RATE_STRATEGY =\n    0x48AF11111764E710fcDcE2750db848C63edab57B;\n\n  // https://etherscan.io/address/0x4c9EDD5852cd905f086C759E8383e09bff1E68B3\n  address internal constant USDe_UNDERLYING = 0x4c9EDD5852cd905f086C759E8383e09bff1E68B3;\n\n  uint8 internal constant USDe_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x4F5923Fc5FD4a93352581b38B7cD26943012DECF\n  address internal constant USDe_A_TOKEN = 0x4F5923Fc5FD4a93352581b38B7cD26943012DECF;\n\n  // https://etherscan.io/address/0x015396E1F286289aE23a762088E863b3ec465145\n  address internal constant USDe_V_TOKEN = 0x015396E1F286289aE23a762088E863b3ec465145;\n\n  // https://etherscan.io/address/0x43Cc8AD0c223b38D9c04802bB184A2D97e497D38\n  address internal constant USDe_S_TOKEN = 0x43Cc8AD0c223b38D9c04802bB184A2D97e497D38;\n\n  // https://etherscan.io/address/0x55B6C4D3E8A27b8A1F5a263321b602e0fdEEcC17\n  address internal constant USDe_ORACLE = 0x55B6C4D3E8A27b8A1F5a263321b602e0fdEEcC17;\n\n  // https://etherscan.io/address/0x4011fcd421b9E90f131B164EC1d162DBE269621C\n  address internal constant USDe_INTEREST_RATE_STRATEGY =\n    0x4011fcd421b9E90f131B164EC1d162DBE269621C;\n\n  // https://etherscan.io/address/0xA35b1B31Ce002FBF2058D22F30f95D405200A15b\n  address internal constant ETHx_UNDERLYING = 0xA35b1B31Ce002FBF2058D22F30f95D405200A15b;\n\n  uint8 internal constant ETHx_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x1c0E06a0b1A4c160c17545FF2A951bfcA57C0002\n  address internal constant ETHx_A_TOKEN = 0x1c0E06a0b1A4c160c17545FF2A951bfcA57C0002;\n\n  // https://etherscan.io/address/0x08a8Dc81AeA67F84745623aC6c72CDA3967aab8b\n  address internal constant ETHx_V_TOKEN = 0x08a8Dc81AeA67F84745623aC6c72CDA3967aab8b;\n\n  // https://etherscan.io/address/0xBDfa7DE5CF7a7DdE4F023Cac842BF520fcF5395C\n  address internal constant ETHx_S_TOKEN = 0xBDfa7DE5CF7a7DdE4F023Cac842BF520fcF5395C;\n\n  // https://etherscan.io/address/0xD6270dAabFe4862306190298C2B48fed9e15C847\n  address internal constant ETHx_ORACLE = 0xD6270dAabFe4862306190298C2B48fed9e15C847;\n\n  // https://etherscan.io/address/0x48AF11111764E710fcDcE2750db848C63edab57B\n  address internal constant ETHx_INTEREST_RATE_STRATEGY =\n    0x48AF11111764E710fcDcE2750db848C63edab57B;\n\n  // https://etherscan.io/address/0x9D39A5DE30e57443BfF2A8307A4256c8797A3497\n  address internal constant sUSDe_UNDERLYING = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497;\n\n  uint8 internal constant sUSDe_DECIMALS = 18;\n\n  // https://etherscan.io/address/0x4579a27aF00A62C0EB156349f31B345c08386419\n  address internal constant sUSDe_A_TOKEN = 0x4579a27aF00A62C0EB156349f31B345c08386419;\n\n  // https://etherscan.io/address/0xeFFDE9BFA8EC77c14C364055a200746d6e12BeD6\n  address internal constant sUSDe_V_TOKEN = 0xeFFDE9BFA8EC77c14C364055a200746d6e12BeD6;\n\n  // https://etherscan.io/address/0xc9335dE638f4C96a8330b2FFc44353Bab58774e3\n  address internal constant sUSDe_S_TOKEN = 0xc9335dE638f4C96a8330b2FFc44353Bab58774e3;\n\n  // https://etherscan.io/address/0xb37aE8aBa6C0C1Bf2c509fc06E11aa4AF29B665A\n  address internal constant sUSDe_ORACLE = 0xb37aE8aBa6C0C1Bf2c509fc06E11aa4AF29B665A;\n\n  // https://etherscan.io/address/0x36d32fD7a72AD600be60Ccb71D3718E455025CaA\n  address internal constant sUSDe_INTEREST_RATE_STRATEGY =\n    0x36d32fD7a72AD600be60Ccb71D3718E455025CaA;\n}\n\nlibrary AaveV3EthereumEModes {\n  uint8 internal constant NONE = 0;\n\n  uint8 internal constant ETH_CORRELATED = 1;\n}\n"
    },
    "aave-address-book/common/IAaveEcosystemReserveController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\ninterface IAaveEcosystemReserveController {\n  /**\n   * @notice Proxy function for ERC20's approve(), pointing to a specific collector contract\n   * @param collector The collector contract with funds (Aave ecosystem reserve)\n   * @param token The asset address\n   * @param recipient Allowance's recipient\n   * @param amount Allowance to approve\n   **/\n  function approve(\n    address collector,\n    // IERC20 token,\n    address token,\n    address recipient,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Proxy function for ERC20's transfer(), pointing to a specific collector contract\n   * @param collector The collector contract with funds (Aave ecosystem reserve)\n   * @param token The asset address\n   * @param recipient Transfer's recipient\n   * @param amount Amount to transfer\n   **/\n  function transfer(\n    address collector,\n    // IERC20 token,\n    address token,\n    address recipient,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Proxy function to create a stream of token on a specific collector contract\n   * @param collector The collector contract with funds (Aave ecosystem reserve)\n   * @param recipient The recipient of the stream of token\n   * @param deposit Total amount to be streamed\n   * @param tokenAddress The ERC20 token to use as streaming asset\n   * @param startTime The unix timestamp for when the stream starts\n   * @param stopTime The unix timestamp for when the stream stops\n   * @return uint256 The stream id created\n   **/\n  function createStream(\n    address collector,\n    address recipient,\n    uint256 deposit,\n    // IERC20 tokenAddress,\n    address tokenAddress,\n    uint256 startTime,\n    uint256 stopTime\n  ) external returns (uint256);\n\n  /**\n   * @notice Proxy function to withdraw from a stream of token on a specific collector contract\n   * @param collector The collector contract with funds (Aave ecosystem reserve)\n   * @param streamId The id of the stream to withdraw tokens from\n   * @param funds Amount to withdraw\n   * @return bool If the withdrawal finished properly\n   **/\n  function withdrawFromStream(\n    address collector,\n    uint256 streamId,\n    uint256 funds\n  ) external returns (bool);\n\n  /**\n   * @notice Proxy function to cancel a stream of token on a specific collector contract\n   * @param collector The collector contract with funds (Aave ecosystem reserve)\n   * @param streamId The id of the stream to cancel\n   * @return bool If the cancellation happened correctly\n   **/\n  function cancelStream(address collector, uint256 streamId) external returns (bool);\n}\n"
    },
    "aave-address-book/common/ICollector.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\n/**\n * @title ICollector\n * @notice Defines the interface of the Collector contract\n * @author Aave\n **/\ninterface ICollector {\n  struct Stream {\n    uint256 deposit;\n    uint256 ratePerSecond;\n    uint256 remainingBalance;\n    uint256 startTime;\n    uint256 stopTime;\n    address recipient;\n    address sender;\n    address tokenAddress;\n    bool isEntity;\n  }\n\n  /** @notice Emitted when the funds admin changes\n   * @param fundsAdmin The new funds admin.\n   **/\n  event NewFundsAdmin(address indexed fundsAdmin);\n\n  /** @notice Emitted when the new stream is created\n   * @param streamId The identifier of the stream.\n   * @param sender The address of the collector.\n   * @param recipient The address towards which the money is streamed.\n   * @param deposit The amount of money to be streamed.\n   * @param tokenAddress The ERC20 token to use as streaming currency.\n   * @param startTime The unix timestamp for when the stream starts.\n   * @param stopTime The unix timestamp for when the stream stops.\n   **/\n  event CreateStream(\n    uint256 indexed streamId,\n    address indexed sender,\n    address indexed recipient,\n    uint256 deposit,\n    address tokenAddress,\n    uint256 startTime,\n    uint256 stopTime\n  );\n\n  /**\n   * @notice Emmitted when withdraw happens from the contract to the recipient's account.\n   * @param streamId The id of the stream to withdraw tokens from.\n   * @param recipient The address towards which the money is streamed.\n   * @param amount The amount of tokens to withdraw.\n   */\n  event WithdrawFromStream(uint256 indexed streamId, address indexed recipient, uint256 amount);\n\n  /**\n   * @notice Emmitted when the stream is canceled.\n   * @param streamId The id of the stream to withdraw tokens from.\n   * @param sender The address of the collector.\n   * @param recipient The address towards which the money is streamed.\n   * @param senderBalance The sender's balance at the moment of cancelling.\n   * @param recipientBalance The recipient's balance at the moment of cancelling.\n   */\n  event CancelStream(\n    uint256 indexed streamId,\n    address indexed sender,\n    address indexed recipient,\n    uint256 senderBalance,\n    uint256 recipientBalance\n  );\n\n  /** @notice Returns the mock ETH reference address\n   * @return address The address\n   **/\n  function ETH_MOCK_ADDRESS() external pure returns (address);\n\n  /** @notice Initializes the contracts\n   * @param fundsAdmin Funds admin address\n   * @param nextStreamId StreamId to set, applied if greater than 0\n   **/\n  function initialize(address fundsAdmin, uint256 nextStreamId) external;\n\n  /**\n   * @notice Return the funds admin, only entity to be able to interact with this contract (controller of reserve)\n   * @return address The address of the funds admin\n   **/\n  function getFundsAdmin() external view returns (address);\n\n  /**\n   * @notice Returns the available funds for the given stream id and address.\n   * @param streamId The id of the stream for which to query the balance.\n   * @param who The address for which to query the balance.\n   * @notice Returns the total funds allocated to `who` as uint256.\n   */\n  function balanceOf(uint256 streamId, address who) external view returns (uint256 balance);\n\n  /**\n   * @dev Function for the funds admin to give ERC20 allowance to other parties\n   * @param token The address of the token to give allowance from\n   * @param recipient Allowance's recipient\n   * @param amount Allowance to approve\n   **/\n  function approve(\n    //IERC20 token,\n    address token,\n    address recipient,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Function for the funds admin to transfer ERC20 tokens to other parties\n   * @param token The address of the token to transfer\n   * @param recipient Transfer's recipient\n   * @param amount Amount to transfer\n   **/\n  function transfer(\n    //IERC20 token,\n    address token,\n    address recipient,\n    uint256 amount\n  ) external;\n\n  /**\n   * @dev Transfer the ownership of the funds administrator role.\n          This function should only be callable by the current funds administrator.\n   * @param admin The address of the new funds administrator\n   */\n  function setFundsAdmin(address admin) external;\n\n  /**\n   * @notice Creates a new stream funded by this contracts itself and paid towards `recipient`.\n   * @param recipient The address towards which the money is streamed.\n   * @param deposit The amount of money to be streamed.\n   * @param tokenAddress The ERC20 token to use as streaming currency.\n   * @param startTime The unix timestamp for when the stream starts.\n   * @param stopTime The unix timestamp for when the stream stops.\n   * @return streamId the uint256 id of the newly created stream.\n   */\n  function createStream(\n    address recipient,\n    uint256 deposit,\n    address tokenAddress,\n    uint256 startTime,\n    uint256 stopTime\n  ) external returns (uint256 streamId);\n\n  /**\n   * @notice Returns the stream with all its properties.\n   * @dev Throws if the id does not point to a valid stream.\n   * @param streamId The id of the stream to query.\n   * @notice Returns the stream object.\n   */\n  function getStream(\n    uint256 streamId\n  )\n    external\n    view\n    returns (\n      address sender,\n      address recipient,\n      uint256 deposit,\n      address tokenAddress,\n      uint256 startTime,\n      uint256 stopTime,\n      uint256 remainingBalance,\n      uint256 ratePerSecond\n    );\n\n  /**\n   * @notice Withdraws from the contract to the recipient's account.\n   * @param streamId The id of the stream to withdraw tokens from.\n   * @param amount The amount of tokens to withdraw.\n   * @return bool Returns true if successful.\n   */\n  function withdrawFromStream(uint256 streamId, uint256 amount) external returns (bool);\n\n  /**\n   * @notice Cancels the stream and transfers the tokens back on a pro rata basis.\n   * @param streamId The id of the stream to cancel.\n   * @return bool Returns true if successful.\n   */\n  function cancelStream(uint256 streamId) external returns (bool);\n\n  /**\n   * @notice Returns the next available stream id\n   * @return nextStreamId Returns the stream id.\n   */\n  function getNextStreamId() external view returns (uint256);\n}\n"
    },
    "aave-address-book/common/IStreamable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\ninterface IStreamable {\n  struct Stream {\n    uint256 deposit;\n    uint256 ratePerSecond;\n    uint256 remainingBalance;\n    uint256 startTime;\n    uint256 stopTime;\n    address recipient;\n    address sender;\n    address tokenAddress;\n    bool isEntity;\n  }\n\n  event CreateStream(\n    uint256 indexed streamId,\n    address indexed sender,\n    address indexed recipient,\n    uint256 deposit,\n    address tokenAddress,\n    uint256 startTime,\n    uint256 stopTime\n  );\n\n  event WithdrawFromStream(uint256 indexed streamId, address indexed recipient, uint256 amount);\n\n  event CancelStream(\n    uint256 indexed streamId,\n    address indexed sender,\n    address indexed recipient,\n    uint256 senderBalance,\n    uint256 recipientBalance\n  );\n\n  function balanceOf(uint256 streamId, address who) external view returns (uint256 balance);\n\n  function getStream(\n    uint256 streamId\n  )\n    external\n    view\n    returns (\n      address sender,\n      address recipient,\n      uint256 deposit,\n      address token,\n      uint256 startTime,\n      uint256 stopTime,\n      uint256 remainingBalance,\n      uint256 ratePerSecond\n    );\n\n  function createStream(\n    address recipient,\n    uint256 deposit,\n    address tokenAddress,\n    uint256 startTime,\n    uint256 stopTime\n  ) external returns (uint256 streamId);\n\n  function withdrawFromStream(uint256 streamId, uint256 funds) external returns (bool);\n\n  function cancelStream(uint256 streamId) external returns (bool);\n\n  function initialize(address fundsAdmin) external;\n\n  /**\n   * @notice Returns the next available stream id\n   * @return nextStreamId Returns the stream id.\n   */\n  function getNextStreamId() external view returns (uint256);\n}\n"
    },
    "aave-address-book/governance-v3/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Errors {\n  string public constant VOTING_PORTALS_COUNT_NOT_0 = '1'; // to be able to rescue voting portals count must be 0\n  string public constant AT_LEAST_ONE_PAYLOAD = '2'; // to create a proposal, it must have at least one payload\n  string public constant VOTING_PORTAL_NOT_APPROVED = '3'; // the voting portal used to vote on proposal must be approved\n  string public constant PROPOSITION_POWER_IS_TOO_LOW = '4'; // proposition power of proposal creator must be equal or higher than the specified threshold for the access level\n  string public constant PROPOSAL_NOT_IN_CREATED_STATE = '5'; // proposal should be in the CREATED state\n  string public constant PROPOSAL_NOT_IN_ACTIVE_STATE = '6'; // proposal must be in an ACTIVE state\n  string public constant PROPOSAL_NOT_IN_QUEUED_STATE = '7'; // proposal must be in a QUEUED state\n  string public constant VOTING_START_COOLDOWN_PERIOD_NOT_PASSED = '8'; // to activate a proposal vote, the cool down delay must pass\n  string public constant CALLER_NOT_A_VALID_VOTING_PORTAL = '9'; // only an allowed voting portal can queue a proposal\n  string public constant QUEUE_COOLDOWN_PERIOD_NOT_PASSED = '10'; // to execute a proposal a cooldown delay must pass\n  string public constant PROPOSAL_NOT_IN_THE_CORRECT_STATE = '11'; // proposal must be created but not executed yet to be able to be canceled\n  string public constant CALLER_NOT_GOVERNANCE = '12'; // caller must be governance\n  string public constant VOTER_ALREADY_VOTED_ON_PROPOSAL = '13'; // voter can only vote once per proposal using voting portal\n  string public constant WRONG_MESSAGE_ORIGIN = '14'; // received message must come from registered source address, chain id, CrossChainController\n  string public constant NO_VOTING_ASSETS = '15'; // Strategy must have voting assets\n  string public constant PROPOSAL_VOTE_ALREADY_CREATED = '16'; // vote on proposal can only be created once\n  string public constant INVALID_SIGNATURE = '17'; // submitted signature is not valid\n  string public constant PROPOSAL_VOTE_NOT_FINISHED = '18'; // proposal vote must be finished\n  string public constant PROPOSAL_VOTE_NOT_IN_ACTIVE_STATE = '19'; // proposal vote must be in active state\n  string public constant PROPOSAL_VOTE_ALREADY_EXISTS = '20'; // proposal vote already exists\n  string public constant VOTE_ONCE_FOR_ASSET = '21'; // an asset can only be used once per vote\n  string public constant USER_BALANCE_DOES_NOT_EXISTS = '22'; // to vote an user must have balance in the token the user is voting with\n  string public constant USER_VOTING_BALANCE_IS_ZERO = '23'; // to vote an user must have some balance between all the tokens selected for voting\n  string public constant MISSING_AAVE_ROOTS = '24'; // must have AAVE roots registered to use strategy\n  string public constant MISSING_STK_AAVE_ROOTS = '25'; // must have stkAAVE roots registered to use strategy\n  string public constant MISSING_STK_AAVE_SLASHING_EXCHANGE_RATE = '26'; // must have stkAAVE slashing exchange rate registered to use strategy\n  string public constant UNPROCESSED_STORAGE_ROOT = '27'; // root must be registered beforehand\n  string public constant NOT_ENOUGH_MSG_VALUE = '28'; // method was not called with enough value to execute the call\n  string public constant FAILED_ACTION_EXECUTION = '29'; // action failed to execute\n  string public constant SHOULD_BE_AT_LEAST_ONE_EXECUTOR = '30'; // at least one executor is needed\n  string public constant INVALID_EMPTY_TARGETS = '31'; // target of the payload execution must not be empty\n  string public constant EXECUTOR_WAS_NOT_SPECIFIED_FOR_REQUESTED_ACCESS_LEVEL = '32'; // payload executor must be registered for the specified payload access level\n  string public constant PAYLOAD_NOT_IN_QUEUED_STATE = '33'; // payload must be en the queued state\n  string public constant TIMELOCK_NOT_FINISHED = '34'; // delay has not passed before execution can be called\n  string public constant PAYLOAD_NOT_IN_THE_CORRECT_STATE = '35'; // payload must be created but not executed yet to be able to be canceled\n  string public constant PAYLOAD_NOT_IN_CREATED_STATE = '36'; // payload must be in the created state\n  string public constant MISSING_A_AAVE_ROOTS = '37'; // must have aAAVE roots registered to use strategy\n  string public constant MISSING_PROPOSAL_BLOCK_HASH = '38'; // block hash for this proposal was not bridged before\n  string public constant PROPOSAL_VOTE_CONFIGURATION_ALREADY_BRIDGED = '39'; // configuration for this proposal bridged already\n  string public constant INVALID_VOTING_PORTAL_ADDRESS = '40'; // voting portal address can't be 0x0\n  string public constant INVALID_POWER_STRATEGY = '41'; // 0x0 is not valid as the power strategy\n  string public constant INVALID_EXECUTOR_ADDRESS = '42'; // executor address can't be 0x0\n  string public constant EXECUTOR_ALREADY_SET_IN_DIFFERENT_LEVEL = '43'; // executor address already being used as executor of a different level\n  string public constant INVALID_VOTING_DURATION = '44'; // voting duration can not be bigger than the time it takes to execute a proposal\n  string public constant VOTING_DURATION_NOT_PASSED = '45'; // at least votingDuration should have passed since voting started for a proposal to be queued\n  string public constant INVALID_PROPOSAL_ACCESS_LEVEL = '46'; // the bridged proposal access level does not correspond with the maximum access level required by the payload\n  string public constant PAYLOAD_NOT_CREATED_BEFORE_PROPOSAL = '47'; // payload must be created before proposal\n  string public constant INVALID_CROSS_CHAIN_CONTROLLER_ADDRESS = '48';\n  string public constant INVALID_MESSAGE_ORIGINATOR_ADDRESS = '49';\n  string public constant INVALID_ORIGIN_CHAIN_ID = '50';\n  string public constant INVALID_ACTION_TARGET = '51';\n  string public constant INVALID_ACTION_ACCESS_LEVEL = '52';\n  string public constant INVALID_EXECUTOR_ACCESS_LEVEL = '53';\n  string public constant INVALID_VOTING_PORTAL_CROSS_CHAIN_CONTROLLER = '54';\n  string public constant INVALID_VOTING_PORTAL_VOTING_MACHINE = '55';\n  string public constant INVALID_VOTING_PORTAL_GOVERNANCE = '56';\n  string public constant INVALID_VOTING_MACHINE_CHAIN_ID = '57';\n  string public constant G_INVALID_CROSS_CHAIN_CONTROLLER_ADDRESS = '58';\n  string public constant G_INVALID_IPFS_HASH = '59';\n  string public constant G_INVALID_PAYLOAD_ACCESS_LEVEL = '60';\n  string public constant G_INVALID_PAYLOADS_CONTROLLER = '61';\n  string public constant G_INVALID_PAYLOAD_CHAIN = '62';\n  string public constant POWER_STRATEGY_HAS_NO_TOKENS = '63'; // power strategy should at least have\n  string public constant INVALID_VOTING_CONFIG_ACCESS_LEVEL = '64';\n  string public constant VOTING_DURATION_TOO_SMALL = '65';\n  string public constant NO_BRIDGED_VOTING_ASSETS = '66';\n  string public constant INVALID_VOTER = '67';\n  string public constant INVALID_DATA_WAREHOUSE = '68';\n  string public constant INVALID_VOTING_MACHINE_CROSS_CHAIN_CONTROLLER = '69';\n  string public constant INVALID_L1_VOTING_PORTAL = '70';\n  string public constant INVALID_VOTING_PORTAL_CHAIN_ID = '71';\n  string public constant INVALID_VOTING_STRATEGY = '72';\n  string public constant INVALID_VOTE_CONFIGURATION_BLOCKHASH = '73';\n  string public constant INVALID_VOTE_CONFIGURATION_VOTING_DURATION = '74';\n  string public constant INVALID_GAS_LIMIT = '75';\n  string public constant INVALID_VOTING_CONFIGS = '76'; // a lvl2 voting configuration must be sent to initializer\n  string public constant INVALID_EXECUTOR_DELAY = '77';\n  string public constant REPEATED_STRATEGY_ASSET = '78';\n  string public constant EMPTY_ASSET_STORAGE_SLOTS = '79';\n  string public constant REPEATED_STRATEGY_ASSET_SLOT = '80';\n  string public constant INVALID_EXECUTION_TARGET = '81';\n  string public constant MISSING_VOTING_CONFIGURATIONS = '82'; // voting configurations for lvl1 and lvl2 must be included on initialization\n  string public constant INVALID_PROPOSITION_POWER = '83';\n  string public constant INVALID_YES_THRESHOLD = '84';\n  string public constant INVALID_YES_NO_DIFFERENTIAL = '85';\n  string public constant ETH_TRANSFER_FAILED = '86';\n  string public constant INVALID_INITIAL_VOTING_CONFIGS = '87'; // initial voting configurations can not be of the same level\n  string public constant INVALID_VOTING_PORTAL_ADDRESS_IN_VOTING_MACHINE = '88';\n  string public constant INVALID_VOTING_PORTAL_OWNER = '89';\n  string public constant CANCELLATION_FEE_REDEEM_FAILED = '90'; // cancellation fee was not able to be redeemed\n  string public constant INVALID_CANCELLATION_FEE_COLLECTOR = '91'; // collector can not be address 0\n  string public constant INVALID_CANCELLATION_FEE_SENT = '92'; // cancellation fee sent does not match the needed amount\n  string public constant CANCELLATION_FEE_ALREADY_REDEEMED = '93'; // cancellation fee already redeemed\n  string public constant INVALID_STATE_TO_REDEEM_CANCELLATION_FEE = '94'; // proposal state is not a valid state to redeem cancellation fee\n  string public constant MISSING_REPRESENTATION_ROOTS = '95'; // to represent a voter the representation roots need to be registered\n  string public constant CALLER_IS_NOT_VOTER_REPRESENTATIVE = '96'; // to represent a voter, caller must be the stored representative\n  string public constant VM_INVALID_GOVERNANCE_ADDRESS = '97'; // governance address can not be 0\n}\n"
    },
    "aave-address-book/governance-v3/IBaseReceiverPortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IBaseReceiverPortal\n * @author BGD Labs\n * @notice interface defining the method that needs to be implemented by all receiving portals, as its the one that\n           will be called when a received message gets confirmed\n */\ninterface IBaseReceiverPortal {\n  /**\n   * @notice method called by CrossChainController when a message has been confirmed\n   * @param originSender address of the sender of the bridged message\n   * @param originChainId id of the chain where the message originated\n   * @param message bytes bridged containing the desired information\n   */\n  function receiveCrossChainMessage(\n    address originSender,\n    uint256 originChainId,\n    bytes memory message\n  ) external;\n}\n"
    },
    "aave-address-book/governance-v3/IDataWarehouse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IDataWarehouse {\n  struct SlotValue {\n    bool exists;\n    uint256 value;\n  }\n  /**\n   * @notice event emitted when a storage root has been processed successfully\n   * @param caller address that called the processStorageRoot method\n   * @param account address where the root is generated\n   * @param blockHash hash of the block where the root was generated\n   */\n  event StorageRootProcessed(\n    address indexed caller,\n    address indexed account,\n    bytes32 indexed blockHash\n  );\n\n  /**\n   * @notice event emitted when a storage root has been processed successfully\n   * @param caller address that called the processStorageSlot method\n   * @param account address where the slot is processed\n   * @param blockHash hash of the block where the storage proof was generated\n   * @param slot storage location to search\n   * @param value storage information on the specified location\n   */\n  event StorageSlotProcessed(\n    address indexed caller,\n    address indexed account,\n    bytes32 indexed blockHash,\n    bytes32 slot,\n    uint256 value\n  );\n\n  /**\n   * @notice method to get the storage roots of an account (token) in a certain block hash\n   * @param account address of the token to get the storage roots from\n   * @param blockHash hash of the block from where the roots are generated\n   * @return state root hash of the account on the block hash specified\n   */\n  function getStorageRoots(address account, bytes32 blockHash) external view returns (bytes32);\n\n  /**\n   * @notice method to process the storage root from an account on a block hash.\n   * @param account address of the token to get the storage roots from\n   * @param blockHash hash of the block from where the roots are generated\n   * @param blockHeaderRLP rlp encoded block header. At same block where the block hash was taken\n   * @param accountStateProofRLP rlp encoded account state proof, taken in same block as block hash\n   * @return the storage root\n   */\n  function processStorageRoot(\n    address account,\n    bytes32 blockHash,\n    bytes memory blockHeaderRLP,\n    bytes memory accountStateProofRLP\n  ) external returns (bytes32);\n\n  /**\n   * @notice method to get the storage value at a certain slot and block hash for a certain address\n   * @param account address of the token to get the storage roots from\n   * @param blockHash hash of the block from where the roots are generated\n   * @param slot hash of the explicit storage placement where the value to get is found.\n   * @param storageProof generated proof containing the storage, at block hash\n   * @return an object containing the slot value at the specified storage slot\n   */\n  function getStorage(\n    address account,\n    bytes32 blockHash,\n    bytes32 slot,\n    bytes memory storageProof\n  ) external view returns (SlotValue memory);\n\n  /**\n   * @notice method to register the storage value at a certain slot and block hash for a certain address\n   * @param account address of the token to get the storage roots from\n   * @param blockHash hash of the block from where the roots are generated\n   * @param slot hash of the explicit storage placement where the value to get is found.\n   * @param storageProof generated proof containing the storage, at block hash\n   */\n  function processStorageSlot(\n    address account,\n    bytes32 blockHash,\n    bytes32 slot,\n    bytes calldata storageProof\n  ) external;\n\n  /**\n   * @notice method to get the value from storage at a certain block hash, previously registered.\n   * @param blockHash hash of the block from where the roots are generated\n   * @param account address of the token to get the storage roots from\n   * @param slot hash of the explicit storage placement where the value to get is found.\n   * @return numeric slot value of the slot. The value must be decoded to get the actual stored information\n   */\n  function getRegisteredSlot(\n    bytes32 blockHash,\n    address account,\n    bytes32 slot\n  ) external view returns (uint256);\n}\n"
    },
    "aave-address-book/governance-v3/IExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IExecutor {\n  /**\n   * @notice emitted when an action got executed\n   * @param target address of the targeted contract\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param executionTime time at which to execute the transaction\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   * @param resultData the actual callData used on the target\n   **/\n  event ExecutedAction(\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 executionTime,\n    bool withDelegatecall,\n    bytes resultData\n  );\n\n  /**\n   * @notice Function, called by Governance, that executes a transaction, returns the callData executed\n   * @param target smart contract target\n   * @param value wei value of the transaction\n   * @param signature function signature of the transaction\n   * @param data function arguments of the transaction or callData if signature empty\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\n   * @return result data of the execution call.\n   **/\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    bool withDelegatecall\n  ) external payable returns (bytes memory);\n}\n"
    },
    "aave-address-book/governance-v3/IGovernanceCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PayloadsControllerUtils} from './PayloadsControllerUtils.sol';\nimport {IVotingMachineWithProofs} from './IVotingMachineWithProofs.sol';\nimport {IGovernancePowerStrategy} from './IGovernancePowerStrategy.sol';\n\ninterface IGovernanceCore {\n  /**\n   * @notice Object with the necessary information of a representative\n   * @param representative address that represents the voter\n   * @param chainId id of the chain where the representative is on\n   */\n  struct RepresentativeInput {\n    address representative;\n    uint256 chainId;\n  }\n\n  /**\n   * @notice Object storing the vote configuration for a specific access level\n   * @param coolDownBeforeVotingStart number of seconds indicating how much time should pass before proposal will be moved to vote\n   * @param votingDuration number of seconds indicating the duration of a vote\n   * @param yesThreshold minimum number of yes votes needed for a proposal to pass.\n            FOR VOTES > YES THRESHOLD\n            we consider that this param in case of AAVE don't need decimal places\n   * @param yesNoDifferential number of for votes that need to be bigger than against votes to pass a proposal.\n            FOR VOTES - AGAINST VOTES > YES NO DIFFERENTIAL\n            we consider that this param in case of AAVE don't need decimal places\n   * @param minPropositionPower the minimum needed power to create a proposal.\n            we consider that this param in case of AAVE don't need decimal places\n   */\n  struct VotingConfig {\n    uint24 coolDownBeforeVotingStart;\n    uint24 votingDuration;\n    uint56 yesThreshold;\n    uint56 yesNoDifferential;\n    uint56 minPropositionPower;\n  }\n\n  /**\n   * @notice object storing the input parameters of a voting configuration\n   * @param accessLevel number of access level needed to execute a proposal in this settings\n   * @param coolDownBeforeVotingStart number of seconds indicating the time that must pass from proposal creation for\n            the voting to be activated\n   * @param votingDuration number of seconds indicating the duration of a vote\n   * @param yesThreshold minimum number of yes votes needed for a proposal to pass.\n            FOR VOTES > YES THRESHOLD\n            in normal units with 18 decimals\n   * @param yesNoDifferential number of for votes that need to be bigger than against votes to pass a proposal.\n            FOR VOTES - AGAINST VOTES > YES NO DIFFERENTIAL\n            in normal units with 18 decimals\n   * @param minPropositionPower the minimum needed power to create a proposal.\n            in normal units with 18 decimals\n   */\n  struct SetVotingConfigInput {\n    PayloadsControllerUtils.AccessControl accessLevel;\n    uint24 coolDownBeforeVotingStart;\n    uint24 votingDuration;\n    uint256 yesThreshold;\n    uint256 yesNoDifferential;\n    uint256 minPropositionPower;\n  }\n\n  /**\n   * @notice enum storing the different states of a proposal\n   * @dev State enum defines the state machine of a proposal so the order on which the state is defined is important.\n          Check logic correctness if new states are added / removed\n   */\n  enum State {\n    Null, // proposal does not exists\n    Created, // created, waiting for a cooldown to initiate the balances snapshot\n    Active, // balances snapshot set, voting in progress\n    Queued, // voting results submitted, but proposal is under grace period when guardian can cancel it\n    Executed, // results sent to the execution chain(s)\n    Failed, // voting was not successful\n    Cancelled, // got cancelled by guardian, or because proposition power of creator dropped below allowed minimum\n    Expired\n  }\n\n  /**\n   * @notice object storing all the information of a proposal including the different states in time that can have\n   * @param state current state of the proposal\n   * @param accessLevel minimum level needed to be able to execute this proposal\n   * @param votingDuration number of seconds indicating the duration of a vote. max is: 16'777'216 (ie 194.18 days)\n   * @param creationTime timestamp in seconds of when the proposal was created. max is: 1.099511628×10¹² (ie 34'865 years)\n   * @param votingActivationTime timestamp in seconds of when the voting activates for the proposal\n   * @param queuingTime timestamp in seconds of when the proposal was queued\n   * @param cancelTimestamp timestamp in seconds of when the proposal was canceled\n   * @param creator address of the creator of the proposal\n   * @param votingPortal address of the votingPortal used to communicate with the voting chain\n   * @param snapshotBlockHash block hash of when the proposal was created, as to be able to get the correct balances on this specific block\n   * @param ipfsHash ipfs has containing the proposal metadata information\n   * @param forVotes number of votes in favor of the proposal\n   * @param againstVotes number of votes against the proposal\n   * @param cancellationFee amount in eth that will be retained if proposal is cancelled\n   * @param payloads list of objects containing the payload information necessary for execution\n   */\n  struct Proposal {\n    State state;\n    PayloadsControllerUtils.AccessControl accessLevel;\n    uint40 creationTime;\n    uint24 votingDuration;\n    uint40 votingActivationTime;\n    uint40 queuingTime;\n    uint40 cancelTimestamp;\n    address creator;\n    address votingPortal;\n    bytes32 snapshotBlockHash;\n    bytes32 ipfsHash;\n    uint128 forVotes;\n    uint128 againstVotes;\n    uint256 cancellationFee;\n    PayloadsControllerUtils.Payload[] payloads;\n  }\n\n  /**\n   * @notice emitted when powerStrategy got updated\n   * @param newPowerStrategy address of the new powerStrategy\n   */\n  event PowerStrategyUpdated(address indexed newPowerStrategy);\n\n  /**\n   * @notice emitted when one of the _votingConfigs got updated\n   * @param accessLevel minimum level needed to be able to execute this proposal\n   * @param votingDuration duration of the voting period in seconds\n   * @param coolDownBeforeVotingStart time in seconds between proposal creation and voting activation\n   * @param yesThreshold min amount of yes votes needed to pass a proposal\n   * @param yesNoDifferential minimal difference between you and no votes for proposal to pass\n   * @param minPropositionPower minimal proposition power of a user to be able to create proposal\n   */\n  event VotingConfigUpdated(\n    PayloadsControllerUtils.AccessControl indexed accessLevel,\n    uint24 votingDuration,\n    uint24 coolDownBeforeVotingStart,\n    uint256 yesThreshold,\n    uint256 yesNoDifferential,\n    uint256 minPropositionPower\n  );\n\n  /**\n   * @notice emitted when a proposal is created.\n   * @param proposalId id of the proposal\n   * @param creator address of the creator of the proposal\n   * @param accessLevel minimum level needed to be able to execute this proposal\n   * @param ipfsHash ipfs has containing the proposal metadata information\n   */\n  event ProposalCreated(\n    uint256 indexed proposalId,\n    address indexed creator,\n    PayloadsControllerUtils.AccessControl indexed accessLevel,\n    bytes32 ipfsHash\n  );\n  /**\n   * @notice emitted when voting is activated. Meaning that the vote configuration will be sent to voting machine\n   * @param proposalId id of the proposal\n   * @param snapshotBlockHash block hash of when the proposal was created, as to be able to get the correct balances on this specific block\n   * @param votingDuration duration of the voting period in seconds\n   */\n  event VotingActivated(\n    uint256 indexed proposalId,\n    bytes32 indexed snapshotBlockHash,\n    uint24 votingDuration\n  );\n\n  /**\n   * @notice emitted when proposal change state to Queued\n   * @param proposalId id of the proposal\n   * @param votesFor votes for proposal\n   * @param votesAgainst votes against proposal\n   */\n  event ProposalQueued(uint256 indexed proposalId, uint128 votesFor, uint128 votesAgainst);\n\n  /**\n   * @notice emitted when proposal change state to Executed\n   * @param proposalId id of the proposal\n   */\n  event ProposalExecuted(uint256 indexed proposalId);\n\n  /**\n   * @notice emitted when proposal change state to Canceled\n   * @param proposalId id of the proposal\n   */\n  event ProposalCanceled(uint256 indexed proposalId);\n\n  /**\n   * @notice emitted when proposal change state to Failed\n   * @param proposalId id of the proposal\n   * @param votesFor votes for proposal\n   * @param votesAgainst votes against proposal\n   */\n  event ProposalFailed(uint256 indexed proposalId, uint128 votesFor, uint128 votesAgainst);\n\n  /**\n   * @notice emitted when a voting machine gets updated\n   * @param votingPortal address of the voting portal updated\n   * @param approved boolean indicating if a voting portal has been added or removed\n   */\n  event VotingPortalUpdated(address indexed votingPortal, bool indexed approved);\n\n  /**\n   * @notice emitted when a payload is successfully sent to the execution chain\n   * @param proposalId id of the proposal containing the payload sent for execution\n   * @param payloadId id of the payload sent for execution\n   * @param payloadsController address of the payloads controller on the execution chain\n   * @param chainId id of the execution chain\n   * @param payloadNumberOnProposal number of payload sent for execution, from the number of payloads contained in proposal\n   * @param numberOfPayloadsOnProposal number of payloads that are in the proposal\n   */\n  event PayloadSent(\n    uint256 indexed proposalId,\n    uint40 payloadId,\n    address indexed payloadsController,\n    uint256 indexed chainId,\n    uint256 payloadNumberOnProposal,\n    uint256 numberOfPayloadsOnProposal\n  );\n\n  /**\n   * @notice emitted when a vote is successfully sent to voting chain\n   * @param proposalId id of the proposal the vote is for\n   * @param voter address that wants to vote on a proposal\n   * @param support indicates if vote is in favor or against the proposal\n   * @param votingAssetsWithSlot list of token addresses with the base storage slot to use for the vote\n   */\n  event VoteForwarded(\n    uint256 indexed proposalId,\n    address indexed voter,\n    bool indexed support,\n    IVotingMachineWithProofs.VotingAssetWithSlot[] votingAssetsWithSlot\n  );\n\n  /**\n   * @notice emitted when the cancellation fee is updated\n   * @param cancellationFee amount of the new cancellation fee\n   */\n  event CancellationFeeUpdated(uint256 cancellationFee);\n\n  /**\n   * @notice emitted when the cancellation fee is redeemed\n   * @param proposalId id of the proposal the fee was redeemed from\n   * @param to address that will receive the cancellation fee\n   * @param cancellationFee amount of the cancellation fee redeemed\n   * @param success flag indicating if the transfer was successful or not\n   */\n  event CancellationFeeRedeemed(\n    uint256 indexed proposalId,\n    address indexed to,\n    uint256 cancellationFee,\n    bool indexed success\n  );\n\n  /**\n   * @notice method to get the Cancellation Fee Collector address\n   * @return cancellation fee collector address\n   */\n  function CANCELLATION_FEE_COLLECTOR() external view returns (address);\n\n  /**\n   * @notice method to update the cancellation fee\n   * @param cancellationFee the fee amount to collateralize against a proposal cancellation\n   */\n  function updateCancellationFee(uint256 cancellationFee) external;\n\n  /**\n   * @notice method to get the cancellation fee\n   * @return cancellation fee amount\n   */\n  function getCancellationFee() external view returns (uint256);\n\n  /**\n   * @notice method to redeem the cancellation fee from a proposal\n   * @param proposalIds array of ids of the proposals to redeem the cancellation fee from\n   */\n  function redeemCancellationFee(uint256[] calldata proposalIds) external;\n\n  /**\n   * @notice emitted when a voter updates its representative\n   * @param voter address of the voter that updates\n   * @param representative address of the chosen representative\n   * @param chainId id of the chain where representative is representing the voter on\n   */\n  event RepresentativeUpdated(\n    address indexed voter,\n    address indexed representative,\n    uint256 indexed chainId\n  );\n\n  /**\n   * @notice method to get the number of registered voting portals\n   * @return number of registered voting portals\n   */\n  function getVotingPortalsCount() external view returns (uint256);\n\n  /**\n   * @notice method to approve new voting machines\n   * @param votingPortals array of voting portal addresses to approve\n   */\n  function addVotingPortals(address[] calldata votingPortals) external;\n\n  /**\n   * @notice method to add a new voting portal\n   * @param votingPortal address of the new voting portal\n   * @dev This method is only callable by the Guardian.\n   * @dev This method is only callable when there are no voting portals registered. Its rationale is for the Guardian\n          to be able to \"rescue\" the system in case all voting portals were removed by mistake. This is needed because\n          to add a new voting portal a full governance flow is required, and without the portal, the system would be bricked.\n          To limit the Guardian's power, can only happen if there are no voting portals registered, and the guardian\n          could only add one voting portal.\n   */\n  function rescueVotingPortal(address votingPortal) external;\n\n  /**\n   * @notice method to remove an accepted voting portal.\n   * @param votingPortals list of addresses of the voting machines that are no longer valid\n   * @dev removing a voting portal effectively removes a voting machine\n   */\n  function removeVotingPortals(address[] calldata votingPortals) external;\n\n  /**\n   * @notice creates a proposal, with configuration specified in VotingConfig corresponding to the accessLevel\n   * @param payloads which user propose to vote for\n   * @param votingPortal address of the contract which will bootstrap voting, and provide results in the end\n   * @param ipfsHash ipfs hash of a document with proposal description\n   * @return created proposal ID\n   */\n  function createProposal(\n    PayloadsControllerUtils.Payload[] calldata payloads,\n    address votingPortal,\n    bytes32 ipfsHash\n  ) external payable returns (uint256);\n\n  /**\n   * @notice executes a proposal, can be called by anyone if proposal in Queued state\n   * @notice and passed more then COOLDOWN_PERIOD seconds after proposal entered this state\n   * @param proposalId id of the proposal\n   */\n  function executeProposal(uint256 proposalId) external;\n\n  /**\n   * @notice cancels a proposal, can be initiated by guardian,\n   * @notice or if proposition power of proposal creator will go below minPropositionPower specified in VotingConfig\n   * @param proposalId id of the proposal\n   */\n  function cancelProposal(uint256 proposalId) external;\n\n  /**\n   * @notice gets the state of a proposal\n   * @param proposalId id of the proposal\n   * @return state of the proposal\n   */\n  function getProposalState(uint256 proposalId) external view returns (State);\n\n  /**\n   * @notice method to set a new powerStrategy contract\n   * @param newPowerStrategy address of the new contract containing the voting a voting strategy\n   */\n\n  function setPowerStrategy(IGovernancePowerStrategy newPowerStrategy) external;\n\n  /**\n   * @notice method to set the voting configuration for a determined access level\n   * @param votingConfigs object containing configuration for an access level\n   */\n  function setVotingConfigs(SetVotingConfigInput[] calldata votingConfigs) external;\n\n  /**\n   * @notice method to get the voting configuration from an access level\n   * @param accessLevel level for which to get the configuration of a vote\n   * @return the voting configuration assigned to the specified accessLevel\n   */\n  function getVotingConfig(\n    PayloadsControllerUtils.AccessControl accessLevel\n  ) external view returns (VotingConfig memory);\n\n  /**\n   * @notice method to get the reasonably achievable voting participation, taking into total supply, and market situation\n   * @return maximum voting participation in wei\n   */\n  function ACHIEVABLE_VOTING_PARTICIPATION() external view returns (uint256);\n\n  /**\n   * @notice method to get the cool down period between queuing and execution\n   * @return time in seconds\n   */\n  function COOLDOWN_PERIOD() external view returns (uint256);\n\n  /**\n   * @notice method to get the minimum voting duration time in seconds\n   * @return time in seconds\n   */\n  function MIN_VOTING_DURATION() external view returns (uint256);\n\n  /**\n   * @notice method to get the precision divider used to remove unneeded decimals\n   * @return decimals of 1 ether (18)\n   */\n  function PRECISION_DIVIDER() external view returns (uint256);\n\n  /**\n   * @notice method to get the the voting tokens cap\n   * @return cap for the voting tokens\n   * @dev This cap is used to limit the number of voting tokens, so as to not drain the bridging funds\n          with a message too big.\n   */\n  function VOTING_TOKENS_CAP() external view returns (uint256);\n\n  /**\n   * @notice method to get the expiration time from creation from which the proposal will be invalid\n   * @return time in seconds\n   */\n  function PROPOSAL_EXPIRATION_TIME() external view returns (uint256);\n\n  /**\n   * @notice method to get the name of the contract\n   * @return name string\n   */\n  function NAME() external view returns (string memory);\n\n  /**\n   * @notice method to get the proposal identified by passed id\n   * @param proposalId id of the proposal to get the information of\n   * @return proposal object containing all the information\n   */\n  function getProposal(uint256 proposalId) external view returns (Proposal memory);\n\n  /**\n   * @notice address of the current voting strategy to use on the governance\n   * @return address of the voting strategy\n   */\n  function getPowerStrategy() external view returns (IGovernancePowerStrategy);\n\n  /**\n   * @notice proposals counter.\n   * @return the current number proposals created\n   */\n  function getProposalsCount() external view returns (uint256);\n\n  /**\n   * @notice method to get if a voting portal is approved by the governance\n   * @param votingPortal address of the voting portal to check if approved\n   * @return flag indicating the approval status of the voting portal\n   */\n  function isVotingPortalApproved(address votingPortal) external view returns (bool);\n\n  /**\n   * @notice method to queue a proposal for execution\n   * @param proposalId the id of the proposal to queue\n   * @param forVotes number of votes in favor of the proposal\n   * @param againstVotes number of votes against of the proposal\n   */\n  function queueProposal(uint256 proposalId, uint128 forVotes, uint128 againstVotes) external;\n\n  /**\n   * @notice method to send proposal to votingMachine\n   * @param proposalId id of the proposal to start the voting on\n   */\n  function activateVoting(uint256 proposalId) external;\n\n  /**\n   * @notice method to get the representative of a voter on a chain\n   * @param voter address of the voter\n   * @param chainId id of the chain to get the representative from\n   * @return address of the representative of the voter on chainId\n   */\n  function getRepresentativeByChain(address voter, uint256 chainId) external view returns (address);\n\n  /**\n   * @notice method to update the representative of a voter on certain chain.\n   * @param representatives Array of objects with the representative information\n   */\n  function updateRepresentativesForChain(RepresentativeInput[] calldata representatives) external;\n\n  /**\n   * @notice method to get the voters a representative is representing\n   * @param representative address of the representative\n   * @param chainId id of the chain to search for represented voters\n   */\n  function getRepresentedVotersByChain(\n    address representative,\n    uint256 chainId\n  ) external view returns (address[] memory);\n}\n"
    },
    "aave-address-book/governance-v3/IGovernancePowerStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGovernancePowerStrategy {\n  /**\n * @notice method to get the full voting power of an user. This method is only use for consulting purposes.\n             As its not used for voting calculations, it is not needed to force blockNumber - 1 to protect against\n             FlashLoan attacks.\n   * @param user address where we want to get the power from\n   * @return full voting power of a user\n   */\n  function getFullVotingPower(address user) external view returns (uint256);\n\n  /**\n   * @notice method to get the full proposal power of an user. It is not needed to protect against FlashLoan\n             attacks because once user returns the tokens (power) the proposal will get canceled as proposal creator\n             will loose the proposition power.\n   * @param user address where we want to get the power from\n   * @return full proposition power of a user\n   */\n  function getFullPropositionPower(address user) external view returns (uint256);\n}\n"
    },
    "aave-address-book/governance-v3/IPayloadsControllerCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PayloadsControllerUtils} from './PayloadsControllerUtils.sol';\n\ninterface IPayloadsControllerCore {\n  /// @notice Enum indicating the possible payload states\n  enum PayloadState {\n    None, // state 0 left as empty\n    Created,\n    Queued,\n    Executed,\n    Cancelled,\n    Expired\n  }\n\n  /**\n   * @notice holds configuration of the executor\n   * @param executor address of the executor\n   * @param delay time in seconds between queuing and execution\n   */\n  struct ExecutorConfig {\n    address executor;\n    uint40 delay;\n  }\n\n  /**\n   * @notice Object containing the information necessary to set a new executor\n   * @param accessLevel level of access that the executor will be assigned to\n   * @param executorConfig object containing the configurations for the accessLevel specified\n   */\n  struct UpdateExecutorInput {\n    PayloadsControllerUtils.AccessControl accessLevel;\n    ExecutorConfig executorConfig;\n  }\n\n  /**\n   * @notice Object containing the information necessary to define a payload action\n   * @param target address of the contract that needs to be executed\n   * @param withDelegateCall boolean indicating if execution needs to be delegated\n   * @param accessLevel access level of the executor needed for the execution\n   * @param value value amount that needs to be sent to the executeTransaction method\n   * @param signature method signature that will be executed\n   * @param callData data needed for the execution of the signature\n   */\n  struct ExecutionAction {\n    address target;\n    bool withDelegateCall;\n    PayloadsControllerUtils.AccessControl accessLevel;\n    uint256 value;\n    string signature;\n    bytes callData;\n  }\n\n  /**\n   * @notice Object containing a payload information\n   * @param creator address of the createPayload method caller\n   * @param maximumAccessLevelRequired min level needed to be able to execute all actions\n   * @param state indicates the current state of the payload\n   * @param createdAt time indicating when payload has been created. In seconds // max is: 1.099511628×10¹² (ie 34'865 years)\n   * @param queuedAt time indicating when payload has been queued. In seconds  // max is: 1.099511628×10¹² (ie 34'865 years)\n   * @param executedAt time indicating when a payload has been executed. In seconds  // max is: 1.099511628×10¹² (ie 34'865 years)\n   * @param cancelledAt time indicating when the payload has been cancelled. In seconds\n   * @param expirationTime time indicating when the Payload will expire\n   * @param delay time in seconds that a payload must remain queued before execution\n   * @param gracePeriod time in seconds that a payload has to be executed\n   * @param actions array of actions to be executed\n   */\n  struct Payload {\n    address creator;\n    PayloadsControllerUtils.AccessControl maximumAccessLevelRequired;\n    PayloadState state;\n    uint40 createdAt;\n    uint40 queuedAt;\n    uint40 executedAt;\n    uint40 cancelledAt;\n    uint40 expirationTime;\n    uint40 delay;\n    uint40 gracePeriod;\n    ExecutionAction[] actions;\n  }\n\n  /**\n   * @notice Event emitted when an executor has been set for a determined access level\n   * @param accessLevel level of access that the executor will be set to\n   * @param executor address that will be set for the determined access level\n   * @param delay time in seconds between queuing and execution\n   */\n  event ExecutorSet(\n    PayloadsControllerUtils.AccessControl indexed accessLevel,\n    address indexed executor,\n    uint40 delay\n  );\n\n  /**\n   * @notice Event emitted when a payload has been created\n   * @param payloadId id of the payload created\n   * @param creator address pertaining to the caller of the method createPayload\n   * @param actions array of the actions conforming the payload\n   * @param maximumAccessLevelRequired maximum level of the access control\n   */\n  event PayloadCreated(\n    uint40 indexed payloadId,\n    address indexed creator,\n    ExecutionAction[] actions,\n    PayloadsControllerUtils.AccessControl indexed maximumAccessLevelRequired\n  );\n\n  /**\n   * @notice emitted when a cross chain message gets received\n   * @param originSender address that sent the message on the origin chain\n   * @param originChainId id of the chain where the message originated\n   * @param delivered flag indicating if message has been delivered\n   * @param message bytes containing the necessary information to queue the bridged payload id\n   * @param reason bytes with the revert information\n   */\n  event PayloadExecutionMessageReceived(\n    address indexed originSender,\n    uint256 indexed originChainId,\n    bool indexed delivered,\n    bytes message,\n    bytes reason\n  );\n\n  /**\n   * @notice Event emitted when a payload has been executed\n   * @param payloadId id of the payload being enqueued\n   */\n  event PayloadExecuted(uint40 payloadId);\n\n  /**\n   * @notice Event emitted when a payload has been queued\n   * @param payloadId id of the payload being enqueued\n   */\n  event PayloadQueued(uint40 payloadId);\n\n  /**\n   * @notice Event emitted when cancelling a payload\n   * @param payloadId id of the cancelled payload\n   */\n  event PayloadCancelled(uint40 payloadId);\n\n  /**\n   * @notice get the expiration delay of a payload\n   * @return expiration delay in seconds\n   */\n  function EXPIRATION_DELAY() external view returns (uint40);\n\n  /**\n   * @notice get the maximum time in seconds that a proposal must spend being queued\n   * @return max delay in seconds\n   */\n  function MAX_EXECUTION_DELAY() external view returns (uint40);\n\n  /**\n   * @notice get the minimum time in seconds that a proposal must spend being queued\n   * @return min delay in seconds\n   */\n  function MIN_EXECUTION_DELAY() external view returns (uint40);\n\n  /**\n   * @notice time in seconds where the proposal can be executed (from executionTime) before it expires\n   * @return grace period in seconds\n   */\n  function GRACE_PERIOD() external view returns (uint40);\n\n  /**\n   * @notice get a previously created payload object\n   * @param payloadId id of the payload to retrieve\n   * @return payload information\n   */\n  function getPayloadById(uint40 payloadId) external view returns (Payload memory);\n\n  /**\n   * @notice get the current state of a payload\n   * @param payloadId id of the payload to retrieve the state from\n   * @return payload state\n   */\n  function getPayloadState(uint40 payloadId) external view returns (PayloadState);\n\n  /**\n   * @notice get the total count of payloads created\n   * @return number of payloads\n   */\n  function getPayloadsCount() external view returns (uint40);\n\n  /**\n   * @notice method that will create a Payload object for every action sent\n   * @param actions array of actions which this proposal payload will contain\n   * @return id of the created payload\n   */\n  function createPayload(ExecutionAction[] calldata actions) external returns (uint40);\n\n  /**\n   * @notice method to execute a payload\n   * @param payloadId id of the payload that needs to be executed\n   */\n  function executePayload(uint40 payloadId) external payable;\n\n  /**\n   * @notice method to cancel a payload\n   * @param payloadId id of the payload that needs to be canceled\n   */\n  function cancelPayload(uint40 payloadId) external;\n\n  /**\n   * @notice method to add executors and its configuration\n   * @param executors array of UpdateExecutorInput objects\n   */\n  function updateExecutors(UpdateExecutorInput[] calldata executors) external;\n\n  /**\n   * @notice method to get the executor configuration assigned to the specified level\n   * @param accessControl level of which we want to get the executor configuration from\n   * @return executor configuration\n   */\n  function getExecutorSettingsByAccessControl(\n    PayloadsControllerUtils.AccessControl accessControl\n  ) external view returns (ExecutorConfig memory);\n}\n"
    },
    "aave-address-book/governance-v3/IVotingMachineWithProofs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDataWarehouse} from './IDataWarehouse.sol';\nimport {IVotingStrategy} from './IVotingStrategy.sol';\n\ninterface IVotingMachineWithProofs {\n  /**\n   * @notice Object containing the signature parameters to be able to vote as a representative\n   * @param v v part of the voter signature\n   * @param r r part of the voter signature\n   * @param s s part of the voter signature\n   */\n  struct SignatureParams {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n\n  /**\n   * @notice Object to use over submitVoteBySignature and in case of bridging for protect against wrong roots inclusion\n   * @param underlyingAsset address of the token on L1, used for voting\n   * @param slot base storage position where the balance on underlyingAsset contract resides on L1. (Normally position 0)\n   */\n  struct VotingAssetWithSlot {\n    address underlyingAsset;\n    uint128 slot;\n  }\n\n  /**\n   * @notice object containing the information of a bridged vote\n   * @param support indicates if vote is in favor or against the proposal\n   * @param votingAssetsWithSlots list of token addresses with storage slots, that the voter will use for voting\n   */\n  struct BridgedVote {\n    bool support;\n    VotingAssetWithSlot[] votingAssetsWithSlot;\n  }\n\n  /**\n   * @notice enum delimiting the possible states a proposal can have on the voting machine\n   * @dev ProposalState enum defines the state machine of a proposal being voted, so the order on which the state is\n          defined is important. Check logic correctness if new states are added / removed\n   */\n  enum ProposalState {\n    NotCreated,\n    Active,\n    Finished,\n    SentToGovernance\n  }\n\n  /**\n   * @notice Object with vote information\n   * @param support boolean indicating if the vote is in favor or against a proposal\n   * @param votingPower the power used for voting\n   */\n  struct Vote {\n    bool support;\n    uint248 votingPower;\n  }\n\n  /**\n   * @notice Object containing a proposal information\n   * @param id numeric identification of the proposal\n   * @param sentToGovernance boolean indication if the proposal results have been sent back to L1 governance\n   * @param startTime timestamp of the start of voting on the proposal\n   * @param endTime timestamp when the voting on the proposal finishes (startTime + votingDuration)\n   * @param votingClosedAndSentTimestamp timestamp indicating when the vote has been closed and sent to governance chain\n   * @param forVotes votes cast in favor of the proposal\n   * @param againstVotes votes cast against the proposal\n   * @param creationBlockNumber blockNumber from when the proposal has been created in votingMachine\n   * @param votingClosedAndSentBlockNumber block from when the vote has been closed and sent to governance chain\n   * @param votes mapping indication for every voter of the proposal the information of that vote\n   */\n  struct Proposal {\n    uint256 id;\n    bool sentToGovernance;\n    uint40 startTime;\n    uint40 endTime;\n    uint40 votingClosedAndSentTimestamp;\n    uint128 forVotes;\n    uint128 againstVotes;\n    uint256 creationBlockNumber;\n    uint256 votingClosedAndSentBlockNumber;\n    mapping(address => Vote) votes;\n  }\n\n  /**\n   * @notice Object containing a proposal information\n   * @param id numeric identification of the proposal\n   * @param sentToGovernance boolean indication if the proposal results have been sent back to L1 governance\n   * @param startTime timestamp of the start of voting on the proposal\n   * @param endTime timestamp when the voting on the proposal finishes (startTime + votingDuration)\n   * @param votingClosedAndSentTimestamp timestamp indicating when the vote has been closed and sent to governance chain\n   * @param forVotes votes cast in favor of the proposal\n   * @param againstVotes votes cast against the proposal\n   * @param creationBlockNumber blockNumber from when the proposal has been created in votingMachine\n   * @param votingClosedAndSentBlockNumber block from when the vote has been closed and sent back to governance chain\n   */\n  struct ProposalWithoutVotes {\n    uint256 id;\n    bool sentToGovernance;\n    uint40 startTime;\n    uint40 endTime;\n    uint40 votingClosedAndSentTimestamp;\n    uint128 forVotes;\n    uint128 againstVotes;\n    uint256 creationBlockNumber;\n    uint256 votingClosedAndSentBlockNumber;\n  }\n\n  /**\n   * @notice vote configuration passed from l1\n   * @param votingDuration duration in seconds of the vote for a proposal\n   * @param l1BlockHash hash of the block on L1 from the block when the proposal was activated for voting (sent to voting machine)\n            this block hash is used to delimit from when the voting power is accounted for voting\n   */\n  struct ProposalVoteConfiguration {\n    uint24 votingDuration;\n    bytes32 l1ProposalBlockHash;\n  }\n\n  /**\n   * @notice Object with the necessary information to process a vote\n   * @param underlyingAsset address of the token on L1, used for voting\n   * @param slot base storage position where the balance on underlyingAsset contract resides on L1. (Normally position 0)\n   * @param proof bytes of the generated proof on L1 with the slot information of underlying asset.\n   */\n  struct VotingBalanceProof {\n    address underlyingAsset;\n    uint128 slot;\n    bytes proof;\n  }\n\n  /**\n   * @notice emitted when a proposal is created\n   * @param proposalId numeric id of the created proposal\n   * @param l1BlockHash block hash from the block on l1 from when the proposal was activated for voting\n   * @param startTime timestamp when the proposal was created and ready for voting\n   * @param endTime timestamp of when the voting period ends. (startTime + votingDuration)\n   */\n  event ProposalVoteStarted(\n    uint256 indexed proposalId,\n    bytes32 indexed l1BlockHash,\n    uint256 startTime,\n    uint256 endTime\n  );\n\n  /**\n   * @notice emitted when the results of a vote on a proposal are sent to L1\n   * @param proposalId numeric id of the proposal which results are sent to L1\n   * @param forVotes votes cast in favor of proposal\n   * @param againstVotes votes cast against the proposal\n   */\n  event ProposalResultsSent(uint256 indexed proposalId, uint256 forVotes, uint256 againstVotes);\n\n  /**\n   * @notice emitted when a vote is registered\n   * @param proposalId Id of the proposal\n   * @param voter address of the voter\n   * @param support boolean, true = vote for, false = vote against\n   * @param votingPower Power of the voter/vote\n   */\n  event VoteEmitted(\n    uint256 indexed proposalId,\n    address indexed voter,\n    bool indexed support,\n    uint256 votingPower\n  );\n\n  /**\n   * @notice emitted when a voting configuration of a proposal gets received. Meaning that has been bridged successfully\n   * @param proposalId id of the proposal bridged to start the vote on\n   * @param blockHash hash of the block on L1 when the proposal was activated for voting\n   * @param votingDuration duration in seconds of the vote\n   * @param voteCreated boolean indicating if the vote has been created or not.\n   * @dev the vote will only be created automatically if when the configuration is bridged, all necessary roots\n          have been registered already.\n   */\n  event ProposalVoteConfigurationBridged(\n    uint256 indexed proposalId,\n    bytes32 indexed blockHash,\n    uint24 votingDuration,\n    bool indexed voteCreated\n  );\n\n  /**\n   * @notice method to get the representatives mapping slot in Governance contract\n   * @return representatives slot\n   */\n  function REPRESENTATIVES_SLOT() external view returns (uint256);\n\n  /**\n   * @notice method to get the Governance contract address\n   * @return Governance address\n   */\n  function GOVERNANCE() external view returns (address);\n\n  /**\n   * @notice method to get the voting asset with slot signature\n   * @return signature of the voting asset with slot method\n   */\n  function VOTING_ASSET_WITH_SLOT_RAW() external view returns (string memory);\n\n  /**\n   * @notice method to get the DataWarehouse contract\n   * @return DataWarehouse contract\n   */\n  function DATA_WAREHOUSE() external view returns (IDataWarehouse);\n\n  /**\n   * @notice method to get the VotingStrategy contract\n   * @return VotingStrategy contract\n   */\n  function VOTING_STRATEGY() external view returns (IVotingStrategy);\n\n  /**\n   * @notice Get the v4 compatible domain separator\n   * @dev Return cached value if chainId matches cache, otherwise recomputes separator\n   * @return The domain separator of the token at current chain\n   */\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /**\n   * @notice method to get the vote submitted type hash for permits digest\n   * @return hash of vote submitted string\n   */\n  function VOTE_SUBMITTED_TYPEHASH() external view returns (bytes32);\n\n  /**\n   * @notice method to get the vote submitted by representative type hash for permits digest\n   * @return hash of vote submitted by representative string\n   */\n  function VOTE_SUBMITTED_BY_REPRESENTATIVE_TYPEHASH() external view returns (bytes32);\n\n  /**\n   * @notice method to get the voting asset with slot type hash for permits digest\n   * @return hash of vote submitted string\n   */\n  function VOTING_ASSET_WITH_SLOT_TYPEHASH() external view returns (bytes32);\n\n  /**\n   * @notice method to get the contract name for permits digest\n   * @return contract name string\n   */\n  function NAME() external view returns (string memory);\n\n  /**\n   * @notice method to get a proposal information specified by its id\n   * @param proposalId id of the proposal to retrieve\n   * @return the proposal information without the users vote\n   */\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\n\n  /**\n   * @notice method to get the state of a proposal specified by its id\n   * @param proposalId id of the proposal to retrieve the state of\n   * @return the state of the proposal\n   */\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\n\n  /**\n   * @notice method to get the voting configuration of a proposal specified by its id\n   * @param proposalId id of the proposal to retrieve the voting configuration from\n   * @return the proposal vote configuration object\n   */\n  function getProposalVoteConfiguration(\n    uint256 proposalId\n  ) external view returns (ProposalVoteConfiguration memory);\n\n  /**\n  * @notice method to get a paginated list of proposalIds. The proposals are taken from a list of proposals that have\n            received vote configuration from governance chain\n  * @param skip number of proposal ids to skip. from latest in the list of proposal ids with voting configuration\n  * @param size length of proposal ids to ask for.\n  * @return list of proposal ids\n  * @dev This is mainly used to get a list of proposals that require automation in some step of the proposal live cycle.\n  */\n  function getProposalsVoteConfigurationIds(\n    uint256 skip,\n    uint256 size\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @notice method to get the vote set by a user on a proposal specified by its id\n   * @param user address of the user that voted\n   * @param proposalId id of the proposal to retrieve the vote from\n   * @return the vote (support and voting power) emitted\n   */\n  function getUserProposalVote(\n    address user,\n    uint256 proposalId\n  ) external view returns (Vote memory);\n\n  /**\n    * @notice method to start a vote on a proposal specified by its id.\n    * @param proposalId id of the proposal to start the vote on.\n    * @return the id of the proposal that had the vote started on.\n    * @dev this method can be called by anyone, requiring that the appropriate conditions are met.\n           basically that the proper roots have been registered.\n           It can also be called internally when the bridged message is received and the the required roots\n           have been registered\n    */\n  function startProposalVote(uint256 proposalId) external returns (uint256);\n\n  /**\n    * @notice method to cast a vote on a proposal specified by its id\n    * @param proposalId id of the proposal on which the vote will be cast\n    * @param support boolean indicating if the vote is in favor or against the proposal\n    * @param votingBalanceProofs list of objects containing the information necessary to vote using the tokens\n             allowed on the voting strategy.\n    * @dev A vote does not need to use all the tokens allowed, can be a subset\n    */\n  function submitVote(\n    uint256 proposalId,\n    bool support,\n    VotingBalanceProof[] calldata votingBalanceProofs\n  ) external;\n\n  /**\n   * @notice Function to register the vote of user that has voted offchain via signature\n   * @param proposalId id of the proposal\n   * @param voter the voter address\n   * @param support boolean, true = vote for, false = vote against\n   * @param votingBalanceProofs list of voting assets proofs\n   * @param v v part of the voter signature\n   * @param r r part of the voter signature\n   * @param s s part of the voter signature\n   */\n  function submitVoteBySignature(\n    uint256 proposalId,\n    address voter,\n    bool support,\n    VotingBalanceProof[] calldata votingBalanceProofs,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @notice method to close a vote on a proposal specified by its id and send the results back to governance\n   * @param proposalId id of the proposal to close the vote on and send the voting result to governance\n   * @dev This method will trigger the bridging flow\n   */\n  function closeAndSendVote(uint256 proposalId) external;\n\n  /**\n   * @notice Function to register the vote of user as its representative\n   * @param proposalId id of the proposal\n   * @param support boolean, true = vote for, false = vote against\n   * @param voter the voter address\n   * @param proofOfRepresentation proof that can validate that msg.sender is the voter representative\n   * @param votingBalanceProofs list of voting assets proofs\n   */\n  function submitVoteAsRepresentative(\n    uint256 proposalId,\n    bool support,\n    address voter,\n    bytes memory proofOfRepresentation,\n    VotingBalanceProof[] calldata votingBalanceProofs\n  ) external;\n\n  /**\n   * @notice Function to register the vote of user as its representative with a signed message\n   * @param proposalId id of the proposal\n   * @param voter the voter address\n   * @param proofOfRepresentation proof that can validate that msg.sender is the voter representative\n   * @param votingBalanceProofs list of voting assets proofs\n   * @param signatureParams object containing the necessary signature parameters\n   */\n  function submitVoteAsRepresentativeBySignature(\n    uint256 proposalId,\n    address voter,\n    address representative,\n    bool support,\n    bytes memory proofOfRepresentation,\n    VotingBalanceProof[] calldata votingBalanceProofs,\n    SignatureParams memory signatureParams\n  ) external;\n}\n"
    },
    "aave-address-book/governance-v3/IVotingPortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBaseReceiverPortal} from './IBaseReceiverPortal.sol';\nimport {IVotingMachineWithProofs} from './IVotingMachineWithProofs.sol';\n\n/**\n * @title IVotingPortal\n * @author BGD Labs\n * @notice interface containing the objects, events and methods definitions of the VotingPortal contract\n */\ninterface IVotingPortal is IBaseReceiverPortal {\n  /**\n   * @notice enum containing the different type of messages that can be bridged\n   * @param Null empty state\n   * @param Proposal indicates that the message is to bridge a proposal configuration\n   */\n  enum MessageType {\n    Null,\n    Proposal\n  }\n\n  /**\n   * @notice emitted when \"Start voting\" gas limit gets updated\n   * @param gasLimit the new gas limit\n   */\n  event StartVotingGasLimitUpdated(uint128 gasLimit);\n\n  /**\n   * @notice emitted when a vote message is received\n   * @param originSender address that sent the message on the origin chain\n   * @param originChainId id of the chain where the message originated\n   * @param delivered flag indicating if message has been delivered\n   * @param message bytes containing the necessary information to queue the bridged proposal id\n   * @param reason bytes with the revert information\n   */\n  event VoteMessageReceived(\n    address indexed originSender,\n    uint256 indexed originChainId,\n    bool indexed delivered,\n    bytes message,\n    bytes reason\n  );\n\n  /**\n   * @notice get the chain id where the voting machine which is deployed\n   * @return network id\n   */\n  function VOTING_MACHINE_CHAIN_ID() external view returns (uint256);\n\n  /**\n   * @notice gets the address of the voting machine on the destination network\n   * @return voting machine address\n   */\n  function VOTING_MACHINE() external view returns (address);\n\n  /**\n   * @notice gets the address of the connected governance\n   * @return governance address\n   */\n  function GOVERNANCE() external view returns (address);\n\n  /**\n   * @notice gets the address of the CrossChainController deployed on current network\n   * @return CrossChainController address\n   */\n  function CROSS_CHAIN_CONTROLLER() external view returns (address);\n\n  /**\n   * @notice method to set the gas limit for \"Start voting\" bridging tx\n   * @param gasLimit the new gas limit\n   */\n  function setStartVotingGasLimit(uint128 gasLimit) external;\n\n  /**\n   * @notice method to get the gas limit for \"Start voting\" bridging tx\n   * @return the gas limit\n   */\n  function getStartVotingGasLimit() external view returns (uint128);\n\n  /**\n   * @notice method to bridge the vote configuration to voting chain, so a vote can be started.\n   * @param proposalId id of the proposal bridged to start the vote on\n   * @param blockHash hash of the block on L1 when the proposal was activated for voting\n   * @param votingDuration duration in seconds of the vote\n   */\n  function forwardStartVotingMessage(\n    uint256 proposalId,\n    bytes32 blockHash,\n    uint24 votingDuration\n  ) external;\n\n  /**\n   * @notice method to decode a message from from voting machine chain\n   * @param message encoded message with message type\n   * @return proposalId, forVotes, againstVotes from the decoded message\n   */\n  function decodeMessage(bytes memory message) external pure returns (uint256, uint128, uint128);\n}\n"
    },
    "aave-address-book/governance-v3/IVotingStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDataWarehouse} from './IDataWarehouse.sol';\n\ninterface IVotingStrategy {\n  /**\n   * @notice method to get the DataWarehouse contract\n   * @return DataWarehouse contract\n   */\n  function DATA_WAREHOUSE() external view returns (IDataWarehouse);\n\n  /**\n   * @notice method to get the exchange rate precision. Taken from stkTokenV3 contract\n   * @return exchange rate precission\n   */\n  function STK_AAVE_SLASHING_EXCHANGE_RATE_PRECISION() external view returns (uint256);\n\n  /**\n   * @notice method to get the slot of the stkAave exchange rate in the stkAave contract\n   * @return stkAave exchange rate slot\n   */\n  function STK_AAVE_SLASHING_EXCHANGE_RATE_SLOT() external view returns (uint256);\n\n  /**\n   * @notice method to get the power scale factor of the delegated balances\n   * @return power scale factor\n   */\n  function POWER_SCALE_FACTOR() external view returns (uint256);\n\n  /**\n   * @notice method to get the power of an asset\n   * @param asset address of the token to get the power\n   * @param storageSlot storage position of the balance mapping\n   * @param power balance of a determined asset to be used for the vote\n   * @param blockHash block hash of when we want to get the power. Optional parameter\n   * @return voting power of the specified asset\n   */\n  function getVotingPower(\n    address asset,\n    uint128 storageSlot,\n    uint256 power,\n    bytes32 blockHash\n  ) external view returns (uint256);\n\n  /**\n   * @notice method to check that the roots for all the tokens in the voting strategy have been registered. Including\n             the registry of the stkAave exchange rate slot\n   * @param blockHash hash of the block from where the roots have been registered.\n   */\n  function hasRequiredRoots(bytes32 blockHash) external view;\n}\n"
    },
    "aave-address-book/governance-v3/PayloadsControllerUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nlibrary PayloadsControllerUtils {\n  /// @notice enum with supported access levels\n  enum AccessControl {\n    Level_null, // to not use 0\n    Level_1, // LEVEL_1 - short executor before, listing assets, changes of assets params, updates of the protocol etc\n    Level_2 // LEVEL_2 - long executor before, payloads controller updates\n  }\n\n  /**\n   * @notice Object containing the necessary payload information.\n   * @param chain\n   * @param accessLevel\n   * @param payloadsController\n   * @param payloadId\n   */\n  struct Payload {\n    uint256 chain;\n    AccessControl accessLevel;\n    address payloadsController; // address which holds the logic to execute after success proposal voting\n    uint40 payloadId; // number of the payload placed to payloadsController, max is: ~10¹²\n  }\n}\n"
    },
    "aave-address-book/GovernanceV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Errors} from './governance-v3/Errors.sol';\nimport {IBaseReceiverPortal} from './governance-v3/IBaseReceiverPortal.sol';\nimport {IDataWarehouse} from './governance-v3/IDataWarehouse.sol';\nimport {IExecutor} from './governance-v3/IExecutor.sol';\nimport {IGovernanceCore} from './governance-v3/IGovernanceCore.sol';\nimport {IGovernancePowerStrategy} from './governance-v3/IGovernancePowerStrategy.sol';\nimport {IPayloadsControllerCore} from './governance-v3/IPayloadsControllerCore.sol';\nimport {IVotingMachineWithProofs} from './governance-v3/IVotingMachineWithProofs.sol';\nimport {IVotingPortal} from './governance-v3/IVotingPortal.sol';\nimport {IVotingStrategy} from './governance-v3/IVotingStrategy.sol';\nimport {PayloadsControllerUtils} from './governance-v3/PayloadsControllerUtils.sol';\n"
    },
    "aave-address-book/GovernanceV3Ethereum.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\n// AUTOGENERATED - MANUALLY CHANGES WILL BE REVERTED BY THE GENERATOR\nimport {IGovernanceCore, IPayloadsControllerCore, IDataWarehouse, IVotingStrategy} from './GovernanceV3.sol';\n\nlibrary GovernanceV3Ethereum {\n  // https://etherscan.io/address/0xEd42a7D8559a463722Ca4beD50E0Cc05a386b0e1\n  address internal constant CROSS_CHAIN_CONTROLLER = 0xEd42a7D8559a463722Ca4beD50E0Cc05a386b0e1;\n\n  // https://etherscan.io/address/0x9AEE0B04504CeF83A65AC3f0e838D0593BCb2BC7\n  IGovernanceCore internal constant GOVERNANCE =\n    IGovernanceCore(0x9AEE0B04504CeF83A65AC3f0e838D0593BCb2BC7);\n\n  // https://etherscan.io/address/0xdAbad81aF85554E9ae636395611C58F7eC1aAEc5\n  IPayloadsControllerCore internal constant PAYLOADS_CONTROLLER =\n    IPayloadsControllerCore(0xdAbad81aF85554E9ae636395611C58F7eC1aAEc5);\n\n  // https://etherscan.io/address/0x617332a777780F546261247F621051d0b98975Eb\n  address internal constant VOTING_MACHINE = 0x617332a777780F546261247F621051d0b98975Eb;\n\n  // https://etherscan.io/address/0xf23f7De3AC42F22eBDA17e64DC4f51FB66b8E21f\n  address internal constant VOTING_PORTAL_ETH_ETH = 0xf23f7De3AC42F22eBDA17e64DC4f51FB66b8E21f;\n\n  // https://etherscan.io/address/0x33aCEf7365809218485873B7d0d67FeE411B5D79\n  address internal constant VOTING_PORTAL_ETH_AVAX = 0x33aCEf7365809218485873B7d0d67FeE411B5D79;\n\n  // https://etherscan.io/address/0x9b24C168d6A76b5459B1d47071a54962a4df36c3\n  address internal constant VOTING_PORTAL_ETH_POL = 0x9b24C168d6A76b5459B1d47071a54962a4df36c3;\n\n  // https://etherscan.io/address/0xE3B770Dc4ae3f8bECaB3Ed12dE692c741603e16A\n  address internal constant PC_DATA_HELPER = 0xE3B770Dc4ae3f8bECaB3Ed12dE692c741603e16A;\n\n  // https://etherscan.io/address/0x971c82c8316aD611904F95616c21ce90837f1856\n  address internal constant GOV_DATA_HELPER = 0x971c82c8316aD611904F95616c21ce90837f1856;\n\n  // https://etherscan.io/address/0x77976B51569896523EE215962Ee91ff236Fa50E8\n  address internal constant VM_DATA_HELPER = 0x77976B51569896523EE215962Ee91ff236Fa50E8;\n\n  // https://etherscan.io/address/0x94363B11b37BC3ffe43AB09cff5A010352FE85dC\n  address internal constant META_DELEGATE_HELPER = 0x94363B11b37BC3ffe43AB09cff5A010352FE85dC;\n\n  // https://etherscan.io/address/0x73C6Fb358dDA8e84D50e98A98F7c0dF32e15C7e9\n  address internal constant EMERGENCY_REGISTRY = 0x73C6Fb358dDA8e84D50e98A98F7c0dF32e15C7e9;\n\n  // https://etherscan.io/address/0xa198Fac58E02A5C5F8F7e877895d50cFa9ad1E04\n  address internal constant GOVERNANCE_POWER_STRATEGY = 0xa198Fac58E02A5C5F8F7e877895d50cFa9ad1E04;\n\n  // https://etherscan.io/address/0x5300A1a15135EA4dc7aD5a167152C01EFc9b192A\n  address internal constant EXECUTOR_LVL_1 = 0x5300A1a15135EA4dc7aD5a167152C01EFc9b192A;\n\n  // https://etherscan.io/address/0x17Dd33Ed0e3dD2a80E37489B8A63063161BE6957\n  address internal constant EXECUTOR_LVL_2 = 0x17Dd33Ed0e3dD2a80E37489B8A63063161BE6957;\n\n  // https://etherscan.io/address/0x5642A5A5Ec284B4145563aBF319620204aCCA7f4\n  IVotingStrategy internal constant VOTING_STRATEGY =\n    IVotingStrategy(0x5642A5A5Ec284B4145563aBF319620204aCCA7f4);\n\n  // https://etherscan.io/address/0x1699FE9CaDC8a0b6c93E06B62Ab4592a0fFEcF61\n  IDataWarehouse internal constant DATA_WAREHOUSE =\n    IDataWarehouse(0x1699FE9CaDC8a0b6c93E06B62Ab4592a0fFEcF61);\n}\n"
    },
    "aave-address-book/MiscArbitrum.sol": {
      "content": "// AUTOGENERATED - MANUALLY CHANGES WILL BE REVERTED BY THE GENERATOR\n// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nlibrary MiscArbitrum {\n  // https://arbiscan.io/address/0x9abf798f5314BFd793A9E57A654BEd35af4A1D60\n  address internal constant PARASWAP_FEE_CLAIMER = 0x9abf798f5314BFd793A9E57A654BEd35af4A1D60;\n\n  // https://arbiscan.io/address/0xB4e496f70602fE2AC6Ae511D028BA4D194773B29\n  address internal constant TRANSPARENT_PROXY_FACTORY = 0xB4e496f70602fE2AC6Ae511D028BA4D194773B29;\n\n  // https://arbiscan.io/address/0xD3cF979e676265e4f6379749DECe4708B9A22476\n  address internal constant PROXY_ADMIN = 0xD3cF979e676265e4f6379749DECe4708B9A22476;\n\n  // https://arbiscan.io/address/0x3b56998Ec06477704622ca8e2eA1b4db134cec32\n  address internal constant CREATE_3_FACTORY = 0x3b56998Ec06477704622ca8e2eA1b4db134cec32;\n\n  // https://arbiscan.io/address/0xaa944aD95e51CB83C1f35FAEEDfC7d2c31B0BB4d\n  address internal constant AAVE_CL_ROBOT_OPERATOR = 0xaa944aD95e51CB83C1f35FAEEDfC7d2c31B0BB4d;\n\n  // https://arbiscan.io/address/0xbbd9f90699c1FA0D7A65870D241DD1f1217c96Eb\n  address internal constant PROTOCOL_GUARDIAN = 0xbbd9f90699c1FA0D7A65870D241DD1f1217c96Eb;\n\n  // https://arbiscan.io/address/0xB1552C5e96B312d0Bf8b554186F846C40614a540\n  address internal constant wstETH_stETH_AGGREGATOR = 0xB1552C5e96B312d0Bf8b554186F846C40614a540;\n\n  // https://arbiscan.io/address/0xF3272CAfe65b190e76caAF483db13424a3e23dD2\n  address internal constant rETH_ETH_AGGREGATOR = 0xF3272CAfe65b190e76caAF483db13424a3e23dD2;\n\n  // https://arbiscan.io/address/0xF168B83598516A532a85995b52504a2Fa058C068\n  address internal constant GHO_CCIP_TOKEN_POOL = 0xF168B83598516A532a85995b52504a2Fa058C068;\n}\n"
    },
    "aave-address-book/MiscEthereum.sol": {
      "content": "// AUTOGENERATED - MANUALLY CHANGES WILL BE REVERTED BY THE GENERATOR\n// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nimport {IAaveEcosystemReserveController} from './common/IAaveEcosystemReserveController.sol';\nimport {IStreamable} from './common/IStreamable.sol';\n\nlibrary MiscEthereum {\n  // https://etherscan.io/address/0x3d569673dAa0575c936c7c67c4E6AedA69CC630C\n  IAaveEcosystemReserveController internal constant AAVE_ECOSYSTEM_RESERVE_CONTROLLER =\n    IAaveEcosystemReserveController(0x3d569673dAa0575c936c7c67c4E6AedA69CC630C);\n\n  // https://etherscan.io/address/0x25F2226B597E8F9514B3F68F00f494cF4f286491\n  address internal constant ECOSYSTEM_RESERVE = 0x25F2226B597E8F9514B3F68F00f494cF4f286491;\n\n  // https://etherscan.io/address/0x86C3FfeE349A7cFf7cA88C449717B1b133bfb517\n  address internal constant PROXY_ADMIN_LONG = 0x86C3FfeE349A7cFf7cA88C449717B1b133bfb517;\n\n  // https://etherscan.io/address/0x3ea64b1C0194524b48F9118462C8E9cd61a243c7\n  address internal constant AAVE_SWAPPER = 0x3ea64b1C0194524b48F9118462C8E9cd61a243c7;\n\n  // https://etherscan.io/address/0x1C2BA5b8ab8e795fF44387ba6d251fa65AD20b36\n  address internal constant AAVE_POL_ETH_BRIDGE = 0x1C2BA5b8ab8e795fF44387ba6d251fa65AD20b36;\n\n  // https://etherscan.io/address/0x9abf798f5314BFd793A9E57A654BEd35af4A1D60\n  address internal constant PARASWAP_FEE_CLAIMER = 0x9abf798f5314BFd793A9E57A654BEd35af4A1D60;\n\n  // https://etherscan.io/address/0xB4e496f70602fE2AC6Ae511D028BA4D194773B29\n  address internal constant TRANSPARENT_PROXY_FACTORY = 0xB4e496f70602fE2AC6Ae511D028BA4D194773B29;\n\n  // https://etherscan.io/address/0xD3cF979e676265e4f6379749DECe4708B9A22476\n  address internal constant PROXY_ADMIN = 0xD3cF979e676265e4f6379749DECe4708B9A22476;\n\n  // https://etherscan.io/address/0xcc3C54B95f3f1867A43009B80ed4DD930E3cE2F7\n  address internal constant CREATE_3_FACTORY = 0xcc3C54B95f3f1867A43009B80ed4DD930E3cE2F7;\n\n  // https://etherscan.io/address/0x1cDF8879eC8bE012bA959EB515b11008E0cb6323\n  address internal constant AAVE_CL_ROBOT_OPERATOR = 0x1cDF8879eC8bE012bA959EB515b11008E0cb6323;\n\n  // https://etherscan.io/address/0xCA76Ebd8617a03126B6FB84F9b1c1A0fB71C2633\n  address internal constant PROTOCOL_GUARDIAN = 0xCA76Ebd8617a03126B6FB84F9b1c1A0fB71C2633;\n\n  // https://etherscan.io/address/0xa88c6D90eAe942291325f9ae3c66f3563B93FE10\n  address internal constant AAVE_MERKLE_DISTRIBUTOR = 0xa88c6D90eAe942291325f9ae3c66f3563B93FE10;\n\n  // https://etherscan.io/address/0x40D16FC0246aD3160Ccc09B8D0D3A2cD28aE6C2f\n  address internal constant GHO_TOKEN = 0x40D16FC0246aD3160Ccc09B8D0D3A2cD28aE6C2f;\n\n  // https://etherscan.io/address/0xb639D208Bcf0589D54FaC24E655C79EC529762B8\n  address internal constant GHO_FLASHMINTER_FACILITATOR =\n    0xb639D208Bcf0589D54FaC24E655C79EC529762B8;\n\n  // https://etherscan.io/address/0x5756880B6a1EAba0175227bf02a7E87c1e02B28C\n  address internal constant GHO_CCIP_TOKEN_POOL = 0x5756880B6a1EAba0175227bf02a7E87c1e02B28C;\n\n  // https://etherscan.io/address/0x167527DB01325408696326e3580cd8e55D99Dc1A\n  address internal constant GSM_REGISTRY = 0x167527DB01325408696326e3580cd8e55D99Dc1A;\n\n  // https://etherscan.io/address/0x0d8eFfC11dF3F229AA1EA0509BC9DFa632A13578\n  address internal constant GSM_USDC = 0x0d8eFfC11dF3F229AA1EA0509BC9DFa632A13578;\n\n  // https://etherscan.io/address/0x686F8D21520f4ecEc7ba577be08354F4d1EB8262\n  address internal constant GSM_USDT = 0x686F8D21520f4ecEc7ba577be08354F4d1EB8262;\n\n  // https://etherscan.io/address/0xD4478A76aCeA81D3768A0ACB6e38f25eEB6Eb1B5\n  address internal constant GSM_USDC_FEE_STRATEGY = 0xD4478A76aCeA81D3768A0ACB6e38f25eEB6Eb1B5;\n\n  // https://etherscan.io/address/0xD4478A76aCeA81D3768A0ACB6e38f25eEB6Eb1B5\n  address internal constant GSM_USDT_FEE_STRATEGY = 0xD4478A76aCeA81D3768A0ACB6e38f25eEB6Eb1B5;\n\n  // https://etherscan.io/address/0x430BEdcA5DfA6f94d1205Cb33AB4f008D0d9942a\n  address internal constant GSM_USDC_PRICE_STRATEGY = 0x430BEdcA5DfA6f94d1205Cb33AB4f008D0d9942a;\n\n  // https://etherscan.io/address/0x4c707764cbFB4FFa078e169e6b8A6AdbE7526a2c\n  address internal constant GSM_USDT_PRICE_STRATEGY = 0x4c707764cbFB4FFa078e169e6b8A6AdbE7526a2c;\n\n  // https://etherscan.io/address/0xef6beCa8D9543eC007bceA835aF768B58F730C1f\n  address internal constant GSM_USDC_ORACLE_SWAP_FREEZER =\n    0xef6beCa8D9543eC007bceA835aF768B58F730C1f;\n\n  // https://etherscan.io/address/0x71381e6718b37C12155CB961Ca3D374A8BfFa0e5\n  address internal constant GSM_USDT_ORACLE_SWAP_FREEZER =\n    0x71381e6718b37C12155CB961Ca3D374A8BfFa0e5;\n\n  // https://etherscan.io/address/0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7\n  address internal constant sDAI_POT = 0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7;\n\n  // https://etherscan.io/address/0x004626A008B1aCdC4c74ab51644093b155e59A23\n  address internal constant stEUR = 0x004626A008B1aCdC4c74ab51644093b155e59A23;\n\n  // https://etherscan.io/address/0xb4d5289C58CE36080b0748B47F859D8F50dFAACb\n  address internal constant agEUR_EUR_AGGREGATOR = 0xb4d5289C58CE36080b0748B47F859D8F50dFAACb;\n\n  // https://etherscan.io/address/0xb49f677943BC038e9857d61E7d053CaA2C1734C1\n  address internal constant EUR_USD_AGGREGATOR = 0xb49f677943BC038e9857d61E7d053CaA2C1734C1;\n\n  // https://etherscan.io/address/0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee\n  address internal constant weETH_RATIO_PROVIDER = 0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee;\n}\n"
    },
    "aave-stk-v1-5/src/contracts/AaveDistributionManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\n\n/**\n * @title AaveDistributionManager\n * @notice Accounting contract to manage multiple staking distributions\n * @author Aave\n */\ncontract AaveDistributionManager {\n  struct AssetData {\n    uint128 emissionPerSecond;\n    uint128 lastUpdateTimestamp;\n    uint256 index;\n    mapping(address => uint256) users;\n  }\n\n  uint256 public immutable DISTRIBUTION_END;\n\n  address public immutable EMISSION_MANAGER;\n\n  uint8 public constant PRECISION = 18;\n\n  mapping(address => AssetData) public assets;\n\n  event AssetConfigUpdated(address indexed asset, uint256 emission);\n  event AssetIndexUpdated(address indexed asset, uint256 index);\n  event UserIndexUpdated(\n    address indexed user,\n    address indexed asset,\n    uint256 index\n  );\n\n  constructor(address emissionManager, uint256 distributionDuration) {\n    DISTRIBUTION_END = block.timestamp + distributionDuration;\n    EMISSION_MANAGER = emissionManager;\n  }\n\n  /**\n   * @dev Configures the distribution of rewards for a list of assets\n   * @param assetsConfigInput The list of configurations to apply\n   */\n  function _configureAssets(\n    DistributionTypes.AssetConfigInput[] memory assetsConfigInput\n  ) internal {\n    for (uint256 i = 0; i < assetsConfigInput.length; i++) {\n      AssetData storage assetConfig = assets[\n        assetsConfigInput[i].underlyingAsset\n      ];\n\n      _updateAssetStateInternal(\n        assetsConfigInput[i].underlyingAsset,\n        assetConfig,\n        assetsConfigInput[i].totalStaked\n      );\n\n      assetConfig.emissionPerSecond = assetsConfigInput[i].emissionPerSecond;\n\n      emit AssetConfigUpdated(\n        assetsConfigInput[i].underlyingAsset,\n        assetsConfigInput[i].emissionPerSecond\n      );\n    }\n  }\n\n  /**\n   * @dev Updates the state of one distribution, mainly rewards index and timestamp\n   * @param underlyingAsset The address used as key in the distribution, for example sAAVE or the aTokens addresses on Aave\n   * @param assetConfig Storage pointer to the distribution's config\n   * @param totalStaked Current total of staked assets for this distribution\n   * @return The new distribution index\n   */\n  function _updateAssetStateInternal(\n    address underlyingAsset,\n    AssetData storage assetConfig,\n    uint256 totalStaked\n  ) internal returns (uint256) {\n    uint256 oldIndex = assetConfig.index;\n    uint128 lastUpdateTimestamp = assetConfig.lastUpdateTimestamp;\n\n    if (block.timestamp == lastUpdateTimestamp) {\n      return oldIndex;\n    }\n\n    uint256 newIndex = _getAssetIndex(\n      oldIndex,\n      assetConfig.emissionPerSecond,\n      lastUpdateTimestamp,\n      totalStaked\n    );\n\n    if (newIndex != oldIndex) {\n      assetConfig.index = newIndex;\n      emit AssetIndexUpdated(underlyingAsset, newIndex);\n    }\n\n    assetConfig.lastUpdateTimestamp = uint128(block.timestamp);\n\n    return newIndex;\n  }\n\n  /**\n   * @dev Updates the state of an user in a distribution\n   * @param user The user's address\n   * @param asset The address of the reference asset of the distribution\n   * @param stakedByUser Amount of tokens staked by the user in the distribution at the moment\n   * @param totalStaked Total tokens staked in the distribution\n   * @return The accrued rewards for the user until the moment\n   */\n  function _updateUserAssetInternal(\n    address user,\n    address asset,\n    uint256 stakedByUser,\n    uint256 totalStaked\n  ) internal returns (uint256) {\n    AssetData storage assetData = assets[asset];\n    uint256 userIndex = assetData.users[user];\n    uint256 accruedRewards = 0;\n\n    uint256 newIndex = _updateAssetStateInternal(asset, assetData, totalStaked);\n\n    if (userIndex != newIndex) {\n      if (stakedByUser != 0) {\n        accruedRewards = _getRewards(stakedByUser, newIndex, userIndex);\n      }\n\n      assetData.users[user] = newIndex;\n      emit UserIndexUpdated(user, asset, newIndex);\n    }\n\n    return accruedRewards;\n  }\n\n  /**\n   * @dev Used by \"frontend\" stake contracts to update the data of an user when claiming rewards from there\n   * @param user The address of the user\n   * @param stakes List of structs of the user data related with his stake\n   * @return The accrued rewards for the user until the moment\n   */\n  function _claimRewards(\n    address user,\n    DistributionTypes.UserStakeInput[] memory stakes\n  ) internal returns (uint256) {\n    uint256 accruedRewards = 0;\n\n    for (uint256 i = 0; i < stakes.length; i++) {\n      accruedRewards =\n        accruedRewards +\n        _updateUserAssetInternal(\n          user,\n          stakes[i].underlyingAsset,\n          stakes[i].stakedByUser,\n          stakes[i].totalStaked\n        );\n    }\n\n    return accruedRewards;\n  }\n\n  /**\n   * @dev Return the accrued rewards for an user over a list of distribution\n   * @param user The address of the user\n   * @param stakes List of structs of the user data related with his stake\n   * @return The accrued rewards for the user until the moment\n   */\n  function _getUnclaimedRewards(\n    address user,\n    DistributionTypes.UserStakeInput[] memory stakes\n  ) internal view returns (uint256) {\n    uint256 accruedRewards = 0;\n\n    for (uint256 i = 0; i < stakes.length; i++) {\n      AssetData storage assetConfig = assets[stakes[i].underlyingAsset];\n      uint256 assetIndex = _getAssetIndex(\n        assetConfig.index,\n        assetConfig.emissionPerSecond,\n        assetConfig.lastUpdateTimestamp,\n        stakes[i].totalStaked\n      );\n\n      accruedRewards =\n        accruedRewards +\n        _getRewards(\n          stakes[i].stakedByUser,\n          assetIndex,\n          assetConfig.users[user]\n        );\n    }\n    return accruedRewards;\n  }\n\n  /**\n   * @dev Internal function for the calculation of user's rewards on a distribution\n   * @param principalUserBalance Amount staked by the user on a distribution\n   * @param reserveIndex Current index of the distribution\n   * @param userIndex Index stored for the user, representation his staking moment\n   * @return The rewards\n   */\n  function _getRewards(\n    uint256 principalUserBalance,\n    uint256 reserveIndex,\n    uint256 userIndex\n  ) internal pure returns (uint256) {\n    return\n      (principalUserBalance * (reserveIndex - userIndex)) /\n      (10**uint256(PRECISION));\n  }\n\n  /**\n   * @dev Calculates the next value of an specific distribution index, with validations\n   * @param currentIndex Current index of the distribution\n   * @param emissionPerSecond Representing the total rewards distributed per second per asset unit, on the distribution\n   * @param lastUpdateTimestamp Last moment this distribution was updated\n   * @param totalBalance of tokens considered for the distribution\n   * @return The new index.\n   */\n  function _getAssetIndex(\n    uint256 currentIndex,\n    uint256 emissionPerSecond,\n    uint128 lastUpdateTimestamp,\n    uint256 totalBalance\n  ) internal view returns (uint256) {\n    if (\n      emissionPerSecond == 0 ||\n      totalBalance == 0 ||\n      lastUpdateTimestamp == block.timestamp ||\n      lastUpdateTimestamp >= DISTRIBUTION_END\n    ) {\n      return currentIndex;\n    }\n\n    uint256 currentTimestamp = block.timestamp > DISTRIBUTION_END\n      ? DISTRIBUTION_END\n      : block.timestamp;\n    uint256 timeDelta = currentTimestamp - lastUpdateTimestamp;\n    return\n      ((emissionPerSecond * timeDelta * (10**uint256(PRECISION))) /\n        totalBalance) + currentIndex;\n  }\n\n  /**\n   * @dev Returns the data of an user on a distribution\n   * @param user Address of the user\n   * @param asset The address of the reference asset of the distribution\n   * @return The new index\n   */\n  function getUserAssetData(address user, address asset)\n    public\n    view\n    returns (uint256)\n  {\n    return assets[asset].users[user];\n  }\n}\n"
    },
    "aave-stk-v1-5/src/contracts/StakedAaveV3.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../interfaces/IERC20.sol';\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\nimport {GovernancePowerDelegationERC20} from '../lib/GovernancePowerDelegationERC20.sol';\nimport {StakedTokenV3} from './StakedTokenV3.sol';\nimport {IGhoVariableDebtTokenTransferHook} from '../interfaces/IGhoVariableDebtTokenTransferHook.sol';\nimport {SafeCast} from '../lib/SafeCast.sol';\nimport {IStakedAaveV3} from '../interfaces/IStakedAaveV3.sol';\nimport {IERC20WithPermit} from '../interfaces/IERC20WithPermit.sol';\n\n/**\n * @title StakedAaveV3\n * @notice StakedTokenV3 with AAVE token as staked token\n * @author BGD Labs\n */\ncontract StakedAaveV3 is StakedTokenV3, IStakedAaveV3 {\n  using SafeCast for uint256;\n\n  uint32 internal _exchangeRateSnapshotsCount;\n  /// @notice Snapshots of the exchangeRate for a given block\n  mapping(uint256 => ExchangeRateSnapshot) public _exchangeRateSnapshots;\n\n  /// @notice GHO debt token to be used in the _beforeTokenTransfer hook\n  IGhoVariableDebtTokenTransferHook public ghoDebtToken;\n\n  function REVISION() public pure virtual override returns (uint256) {\n    return 5;\n  }\n\n  constructor(\n    IERC20 stakedToken,\n    IERC20 rewardToken,\n    uint256 unstakeWindow,\n    address rewardsVault,\n    address emissionManager,\n    uint128 distributionDuration\n  )\n    StakedTokenV3(\n      stakedToken,\n      rewardToken,\n      unstakeWindow,\n      rewardsVault,\n      emissionManager,\n      distributionDuration\n    )\n  {\n    // brick initialize\n    lastInitializedRevision = REVISION();\n  }\n\n  /**\n   * @dev Called by the proxy contract\n   */\n  function initialize(\n    address slashingAdmin,\n    address cooldownPauseAdmin,\n    address claimHelper,\n    uint256 maxSlashablePercentage,\n    uint256 cooldownSeconds\n  ) external override initializer {\n    _initialize(\n      slashingAdmin,\n      cooldownPauseAdmin,\n      claimHelper,\n      maxSlashablePercentage,\n      cooldownSeconds\n    );\n\n    // needed to claimRewardsAndStake works without a custom approval each time\n    STAKED_TOKEN.approve(address(this), type(uint256).max);\n  }\n\n  /// @inheritdoc IStakedAaveV3\n  function setGHODebtToken(IGhoVariableDebtTokenTransferHook newGHODebtToken)\n    external\n  {\n    require(msg.sender == 0xEE56e2B3D491590B5b31738cC34d5232F378a8D5); // Short executor\n    ghoDebtToken = newGHODebtToken;\n    emit GHODebtTokenChanged(address(newGHODebtToken));\n  }\n\n  /// @inheritdoc IStakedAaveV3\n  function claimRewardsAndStake(address to, uint256 amount)\n    external\n    override\n    returns (uint256)\n  {\n    return _claimRewardsAndStakeOnBehalf(msg.sender, to, amount);\n  }\n\n  /// @inheritdoc IStakedAaveV3\n  function claimRewardsAndStakeOnBehalf(\n    address from,\n    address to,\n    uint256 amount\n  ) external override onlyClaimHelper returns (uint256) {\n    return _claimRewardsAndStakeOnBehalf(from, to, amount);\n  }\n\n  /// @inheritdoc IStakedAaveV3\n  function stakeWithPermit(\n    address from,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    IERC20WithPermit(address(STAKED_TOKEN)).permit(\n      from,\n      address(this),\n      amount,\n      deadline,\n      v,\n      r,\n      s\n    );\n    _stake(from, from, amount);\n  }\n\n  /**\n   * @dev Writes a snapshot before any operation involving transfer of value: _transfer, _mint and _burn\n   * - On _transfer, it writes snapshots for both \"from\" and \"to\"\n   * - On _mint, only for _to\n   * - On _burn, only for _from\n   * @param from the from address\n   * @param to the to address\n   * @param amount the amount to transfer\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override {\n    IGhoVariableDebtTokenTransferHook cachedGhoDebtToken = ghoDebtToken;\n    if (address(cachedGhoDebtToken) != address(0)) {\n      try\n        cachedGhoDebtToken.updateDiscountDistribution(\n          from,\n          to,\n          balanceOf(from),\n          balanceOf(to),\n          amount\n        )\n      {} catch (bytes memory) {}\n    }\n    address votingFromDelegatee = _votingDelegates[from];\n    address votingToDelegatee = _votingDelegates[to];\n\n    if (votingFromDelegatee == address(0)) {\n      votingFromDelegatee = from;\n    }\n    if (votingToDelegatee == address(0)) {\n      votingToDelegatee = to;\n    }\n\n    _moveDelegatesByType(\n      votingFromDelegatee,\n      votingToDelegatee,\n      amount,\n      DelegationType.VOTING_POWER\n    );\n\n    address propPowerFromDelegatee = _propositionPowerDelegates[from];\n    address propPowerToDelegatee = _propositionPowerDelegates[to];\n\n    if (propPowerFromDelegatee == address(0)) {\n      propPowerFromDelegatee = from;\n    }\n    if (propPowerToDelegatee == address(0)) {\n      propPowerToDelegatee = to;\n    }\n\n    _moveDelegatesByType(\n      propPowerFromDelegatee,\n      propPowerToDelegatee,\n      amount,\n      DelegationType.PROPOSITION_POWER\n    );\n  }\n\n  /// @dev Modified version accounting for exchange rate at block\n  /// @inheritdoc GovernancePowerDelegationERC20\n  function _searchByBlockNumber(\n    mapping(address => mapping(uint256 => Snapshot)) storage snapshots,\n    mapping(address => uint256) storage snapshotsCounts,\n    address user,\n    uint256 blockNumber\n  ) internal view override returns (uint256) {\n    return\n      (super._searchByBlockNumber(\n        snapshots,\n        snapshotsCounts,\n        user,\n        blockNumber\n      ) * EXCHANGE_RATE_UNIT) /\n      _binarySearchExchangeRate(\n        _exchangeRateSnapshots,\n        _exchangeRateSnapshotsCount,\n        blockNumber\n      );\n  }\n\n  /**\n   * @dev Updates the exchangeRate and emits events accordingly\n   * @param newExchangeRate the new exchange rate\n   */\n  function _updateExchangeRate(uint216 newExchangeRate) internal override {\n    _exchangeRateSnapshots[_exchangeRateSnapshotsCount] = ExchangeRateSnapshot(\n      block.number.toUint40(),\n      newExchangeRate\n    );\n    ++_exchangeRateSnapshotsCount;\n    super._updateExchangeRate(newExchangeRate);\n  }\n\n  function _binarySearchExchangeRate(\n    mapping(uint256 => ExchangeRateSnapshot) storage snapshots,\n    uint256 snapshotsCount,\n    uint256 blockNumber\n  ) internal view returns (uint256) {\n    unchecked {\n      // First check most recent balance\n      if (snapshots[snapshotsCount - 1].blockNumber <= blockNumber) {\n        return snapshots[snapshotsCount - 1].value;\n      }\n\n      uint256 lower = 0;\n      uint256 upper = snapshotsCount - 1;\n      while (upper > lower) {\n        uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n        ExchangeRateSnapshot memory snapshot = snapshots[center];\n        if (snapshot.blockNumber == blockNumber) {\n          return snapshot.value;\n        } else if (snapshot.blockNumber < blockNumber) {\n          lower = center;\n        } else {\n          upper = center - 1;\n        }\n      }\n      return snapshots[lower].value;\n    }\n  }\n}\n"
    },
    "aave-stk-v1-5/src/contracts/StakedTokenV2.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../interfaces/IERC20.sol';\nimport {IStakedTokenV2} from '../interfaces/IStakedTokenV2.sol';\n\nimport {ERC20} from '../lib/ERC20.sol';\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\nimport {SafeERC20} from '../lib/SafeERC20.sol';\n\nimport {VersionedInitializable} from '../utils/VersionedInitializable.sol';\nimport {AaveDistributionManager} from './AaveDistributionManager.sol';\nimport {GovernancePowerWithSnapshot} from '../lib/GovernancePowerWithSnapshot.sol';\n\n/**\n * @title StakedTokenV2\n * @notice Contract to stake Aave token, tokenize the position and get rewards, inheriting from a distribution manager contract\n * @author BGD Labs\n */\nabstract contract StakedTokenV2 is\n  IStakedTokenV2,\n  GovernancePowerWithSnapshot,\n  VersionedInitializable,\n  AaveDistributionManager\n{\n  using SafeERC20 for IERC20;\n\n  IERC20 public immutable STAKED_TOKEN;\n  IERC20 public immutable REWARD_TOKEN;\n\n  /// @notice Seconds available to redeem once the cooldown period is fulfilled\n  uint256 public immutable UNSTAKE_WINDOW;\n\n  /// @notice Address to pull from the rewards, needs to have approved this contract\n  address public immutable REWARDS_VAULT;\n\n  mapping(address => uint256) public stakerRewardsToClaim;\n  mapping(address => CooldownSnapshot) public stakersCooldowns;\n\n  /// @dev End of Storage layout from StakedToken v1\n\n  /// @dev To see the voting mappings, go to GovernancePowerWithSnapshot.sol\n  mapping(address => address) internal _votingDelegates;\n\n  mapping(address => mapping(uint256 => Snapshot))\n    internal _propositionPowerSnapshots;\n  mapping(address => uint256) internal _propositionPowerSnapshotsCounts;\n  mapping(address => address) internal _propositionPowerDelegates;\n\n  bytes32 public DOMAIN_SEPARATOR;\n  bytes public constant EIP712_REVISION = bytes('1');\n  bytes32 internal constant EIP712_DOMAIN =\n    keccak256(\n      'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n    );\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256(\n      'Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)'\n    );\n\n  /// @dev owner => next valid nonce to submit with permit()\n  mapping(address => uint256) public _nonces;\n\n  constructor(\n    IERC20 stakedToken,\n    IERC20 rewardToken,\n    uint256 unstakeWindow,\n    address rewardsVault,\n    address emissionManager,\n    uint128 distributionDuration\n  ) ERC20() AaveDistributionManager(emissionManager, distributionDuration) {\n    STAKED_TOKEN = stakedToken;\n    REWARD_TOKEN = rewardToken;\n    UNSTAKE_WINDOW = unstakeWindow;\n    REWARDS_VAULT = rewardsVault;\n  }\n\n  /// @inheritdoc IStakedTokenV2\n  function stake(address onBehalfOf, uint256 amount) external virtual override;\n\n  /// @inheritdoc IStakedTokenV2\n  function redeem(address to, uint256 amount) external virtual override;\n\n  /// @inheritdoc IStakedTokenV2\n  function cooldown() external virtual override;\n\n  /// @inheritdoc IStakedTokenV2\n  function claimRewards(address to, uint256 amount) external virtual override;\n\n  /// @inheritdoc IStakedTokenV2\n  function getTotalRewardsBalance(address staker)\n    external\n    view\n    returns (uint256)\n  {\n    DistributionTypes.UserStakeInput[]\n      memory userStakeInputs = new DistributionTypes.UserStakeInput[](1);\n    userStakeInputs[0] = DistributionTypes.UserStakeInput({\n      underlyingAsset: address(this),\n      stakedByUser: balanceOf(staker),\n      totalStaked: totalSupply()\n    });\n    return\n      stakerRewardsToClaim[staker] +\n      _getUnclaimedRewards(staker, userStakeInputs);\n  }\n\n  /// @inheritdoc IStakedTokenV2\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    require(owner != address(0), 'INVALID_OWNER');\n    //solium-disable-next-line\n    require(block.timestamp <= deadline, 'INVALID_EXPIRATION');\n    uint256 currentValidNonce = _nonces[owner];\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        '\\x19\\x01',\n        DOMAIN_SEPARATOR,\n        keccak256(\n          abi.encode(\n            PERMIT_TYPEHASH,\n            owner,\n            spender,\n            value,\n            currentValidNonce,\n            deadline\n          )\n        )\n      )\n    );\n\n    require(owner == ecrecover(digest, v, r, s), 'INVALID_SIGNATURE');\n    unchecked {\n      _nonces[owner] = currentValidNonce + 1;\n    }\n    _approve(owner, spender, value);\n  }\n\n  /**\n   * @dev Delegates power from signatory to `delegatee`\n   * @param delegatee The address to delegate votes to\n   * @param delegationType the type of delegation (VOTING_POWER, PROPOSITION_POWER)\n   * @param nonce The contract state required to match the signature\n   * @param expiry The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function delegateByTypeBySig(\n    address delegatee,\n    DelegationType delegationType,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    bytes32 structHash = keccak256(\n      abi.encode(\n        DELEGATE_BY_TYPE_TYPEHASH,\n        delegatee,\n        uint256(delegationType),\n        nonce,\n        expiry\n      )\n    );\n    bytes32 digest = keccak256(\n      abi.encodePacked('\\x19\\x01', DOMAIN_SEPARATOR, structHash)\n    );\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), 'INVALID_SIGNATURE');\n    require(nonce == _nonces[signatory]++, 'INVALID_NONCE');\n    require(block.timestamp <= expiry, 'INVALID_EXPIRATION');\n    _delegateByType(signatory, delegatee, delegationType);\n  }\n\n  /**\n   * @dev Delegates power from signatory to `delegatee`\n   * @param delegatee The address to delegate votes to\n   * @param nonce The contract state required to match the signature\n   * @param expiry The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function delegateBySig(\n    address delegatee,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    bytes32 structHash = keccak256(\n      abi.encode(DELEGATE_TYPEHASH, delegatee, nonce, expiry)\n    );\n    bytes32 digest = keccak256(\n      abi.encodePacked('\\x19\\x01', DOMAIN_SEPARATOR, structHash)\n    );\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), 'INVALID_SIGNATURE');\n    require(nonce == _nonces[signatory]++, 'INVALID_NONCE');\n    require(block.timestamp <= expiry, 'INVALID_EXPIRATION');\n    _delegateByType(signatory, delegatee, DelegationType.VOTING_POWER);\n    _delegateByType(signatory, delegatee, DelegationType.PROPOSITION_POWER);\n  }\n\n  /**\n   * @dev Updates the user state related with his accrued rewards\n   * @param user Address of the user\n   * @param userBalance The current balance of the user\n   * @param updateStorage Boolean flag used to update or not the stakerRewardsToClaim of the user\n   * @return The unclaimed rewards that were added to the total accrued\n   */\n  function _updateCurrentUnclaimedRewards(\n    address user,\n    uint256 userBalance,\n    bool updateStorage\n  ) internal returns (uint256) {\n    uint256 accruedRewards = _updateUserAssetInternal(\n      user,\n      address(this),\n      userBalance,\n      totalSupply()\n    );\n    uint256 unclaimedRewards = stakerRewardsToClaim[user] + accruedRewards;\n\n    if (accruedRewards != 0) {\n      if (updateStorage) {\n        stakerRewardsToClaim[user] = unclaimedRewards;\n      }\n      emit RewardsAccrued(user, accruedRewards);\n    }\n\n    return unclaimedRewards;\n  }\n\n  /**\n   * @dev returns relevant storage slots for a DelegationType\n   * @param delegationType the requested DelegationType\n   * @return the relevant storage\n   */\n  function _getDelegationDataByType(DelegationType delegationType)\n    internal\n    view\n    override\n    returns (\n      mapping(address => mapping(uint256 => Snapshot)) storage, //snapshots\n      mapping(address => uint256) storage, //snapshots count\n      mapping(address => address) storage //delegatees list\n    )\n  {\n    if (delegationType == DelegationType.VOTING_POWER) {\n      return (_votingSnapshots, _votingSnapshotsCounts, _votingDelegates);\n    } else {\n      return (\n        _propositionPowerSnapshots,\n        _propositionPowerSnapshotsCounts,\n        _propositionPowerDelegates\n      );\n    }\n  }\n}\n"
    },
    "aave-stk-v1-5/src/contracts/StakedTokenV3.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../interfaces/IERC20.sol';\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\nimport {SafeERC20} from '../lib/SafeERC20.sol';\nimport {IAaveDistributionManager} from '../interfaces/IAaveDistributionManager.sol';\nimport {IERC20Metadata} from '../interfaces/IERC20Metadata.sol';\nimport {IStakedTokenV2} from '../interfaces/IStakedTokenV2.sol';\nimport {StakedTokenV2} from './StakedTokenV2.sol';\nimport {IStakedTokenV3} from '../interfaces/IStakedTokenV3.sol';\nimport {PercentageMath} from '../lib/PercentageMath.sol';\nimport {RoleManager} from '../utils/RoleManager.sol';\nimport {SafeCast} from '../lib/SafeCast.sol';\n\n/**\n * @title StakedTokenV3\n * @notice Contract to stake Aave token, tokenize the position and get rewards, inheriting from a distribution manager contract\n * @author BGD Labs\n */\ncontract StakedTokenV3 is\n  StakedTokenV2,\n  IStakedTokenV3,\n  RoleManager,\n  IAaveDistributionManager\n{\n  using SafeERC20 for IERC20;\n  using PercentageMath for uint256;\n  using SafeCast for uint256;\n\n  uint256 public constant SLASH_ADMIN_ROLE = 0;\n  uint256 public constant COOLDOWN_ADMIN_ROLE = 1;\n  uint256 public constant CLAIM_HELPER_ROLE = 2;\n  uint216 public constant INITIAL_EXCHANGE_RATE = 1e18;\n  uint256 public constant EXCHANGE_RATE_UNIT = 1e18;\n\n  /// @notice lower bound to prevent spam & avoid exchangeRate issues\n  // as returnFunds can be called permissionless an attacker could spam returnFunds(1) to produce exchangeRate snapshots making voting expensive\n  uint256 public immutable LOWER_BOUND;\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[8] private ______gap;\n  /// @notice Seconds between starting cooldown and being able to withdraw\n  uint256 internal _cooldownSeconds;\n  /// @notice The maximum amount of funds that can be slashed at any given time\n  uint256 internal _maxSlashablePercentage;\n  /// @notice Mirror of latest snapshot value for cheaper access\n  uint216 internal _currentExchangeRate;\n  /// @notice Flag determining if there's an ongoing slashing event that needs to be settled\n  bool public inPostSlashingPeriod;\n\n  modifier onlySlashingAdmin() {\n    require(\n      msg.sender == getAdmin(SLASH_ADMIN_ROLE),\n      'CALLER_NOT_SLASHING_ADMIN'\n    );\n    _;\n  }\n\n  modifier onlyCooldownAdmin() {\n    require(\n      msg.sender == getAdmin(COOLDOWN_ADMIN_ROLE),\n      'CALLER_NOT_COOLDOWN_ADMIN'\n    );\n    _;\n  }\n\n  modifier onlyClaimHelper() {\n    require(\n      msg.sender == getAdmin(CLAIM_HELPER_ROLE),\n      'CALLER_NOT_CLAIM_HELPER'\n    );\n    _;\n  }\n\n  constructor(\n    IERC20 stakedToken,\n    IERC20 rewardToken,\n    uint256 unstakeWindow,\n    address rewardsVault,\n    address emissionManager,\n    uint128 distributionDuration\n  )\n    StakedTokenV2(\n      stakedToken,\n      rewardToken,\n      unstakeWindow,\n      rewardsVault,\n      emissionManager,\n      distributionDuration\n    )\n  {\n    // brick initialize\n    lastInitializedRevision = REVISION();\n    uint256 decimals = IERC20Metadata(address(stakedToken)).decimals();\n    LOWER_BOUND = 10**decimals;\n  }\n\n  /**\n   * @dev returns the revision of the implementation contract\n   * @return The revision\n   */\n  function REVISION() public pure virtual returns (uint256) {\n    return 3;\n  }\n\n  /**\n   * @dev returns the revision of the implementation contract\n   * @return The revision\n   */\n  function getRevision() internal pure virtual override returns (uint256) {\n    return REVISION();\n  }\n\n  /**\n   * @dev Called by the proxy contract\n   */\n  function initialize(\n    address slashingAdmin,\n    address cooldownPauseAdmin,\n    address claimHelper,\n    uint256 maxSlashablePercentage,\n    uint256 cooldownSeconds\n  ) external virtual initializer {\n    _initialize(\n      slashingAdmin,\n      cooldownPauseAdmin,\n      claimHelper,\n      maxSlashablePercentage,\n      cooldownSeconds\n    );\n  }\n\n  function _initialize(\n    address slashingAdmin,\n    address cooldownPauseAdmin,\n    address claimHelper,\n    uint256 maxSlashablePercentage,\n    uint256 cooldownSeconds\n  ) internal {\n    InitAdmin[] memory initAdmins = new InitAdmin[](3);\n    initAdmins[0] = InitAdmin(SLASH_ADMIN_ROLE, slashingAdmin);\n    initAdmins[1] = InitAdmin(COOLDOWN_ADMIN_ROLE, cooldownPauseAdmin);\n    initAdmins[2] = InitAdmin(CLAIM_HELPER_ROLE, claimHelper);\n\n    _initAdmins(initAdmins);\n\n    _setMaxSlashablePercentage(maxSlashablePercentage);\n    _setCooldownSeconds(cooldownSeconds);\n    _updateExchangeRate(INITIAL_EXCHANGE_RATE);\n  }\n\n  /// @inheritdoc IAaveDistributionManager\n  function configureAssets(\n    DistributionTypes.AssetConfigInput[] memory assetsConfigInput\n  ) external override {\n    require(msg.sender == EMISSION_MANAGER, 'ONLY_EMISSION_MANAGER');\n\n    for (uint256 i = 0; i < assetsConfigInput.length; i++) {\n      assetsConfigInput[i].totalStaked = totalSupply();\n    }\n\n    _configureAssets(assetsConfigInput);\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function previewStake(uint256 assets) public view returns (uint256) {\n    return (assets * _currentExchangeRate) / EXCHANGE_RATE_UNIT;\n  }\n\n  /// @inheritdoc IStakedTokenV2\n  function stake(address to, uint256 amount)\n    external\n    override(IStakedTokenV2, StakedTokenV2)\n  {\n    _stake(msg.sender, to, amount);\n  }\n\n  /// @inheritdoc IStakedTokenV2\n  function cooldown() external override(IStakedTokenV2, StakedTokenV2) {\n    _cooldown(msg.sender);\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function cooldownOnBehalfOf(address from) external override onlyClaimHelper {\n    _cooldown(from);\n  }\n\n  function _cooldown(address from) internal {\n    uint256 amount = balanceOf(from);\n    require(amount != 0, 'INVALID_BALANCE_ON_COOLDOWN');\n    stakersCooldowns[from] = CooldownSnapshot({\n      timestamp: uint40(block.timestamp),\n      amount: uint216(amount)\n    });\n\n    emit Cooldown(from, amount);\n  }\n\n  /// @inheritdoc IStakedTokenV2\n  function redeem(address to, uint256 amount)\n    external\n    override(IStakedTokenV2, StakedTokenV2)\n  {\n    _redeem(msg.sender, to, amount);\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function redeemOnBehalf(\n    address from,\n    address to,\n    uint256 amount\n  ) external override onlyClaimHelper {\n    _redeem(from, to, amount);\n  }\n\n  /// @inheritdoc IStakedTokenV2\n  function claimRewards(address to, uint256 amount)\n    external\n    override(IStakedTokenV2, StakedTokenV2)\n  {\n    _claimRewards(msg.sender, to, amount);\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function claimRewardsOnBehalf(\n    address from,\n    address to,\n    uint256 amount\n  ) external override onlyClaimHelper returns (uint256) {\n    return _claimRewards(from, to, amount);\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function claimRewardsAndRedeem(\n    address to,\n    uint256 claimAmount,\n    uint256 redeemAmount\n  ) external override {\n    _claimRewards(msg.sender, to, claimAmount);\n    _redeem(msg.sender, to, redeemAmount);\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function claimRewardsAndRedeemOnBehalf(\n    address from,\n    address to,\n    uint256 claimAmount,\n    uint256 redeemAmount\n  ) external override onlyClaimHelper {\n    _claimRewards(from, to, claimAmount);\n    _redeem(from, to, redeemAmount);\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function getExchangeRate() public view override returns (uint216) {\n    return _currentExchangeRate;\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function previewRedeem(uint256 shares)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return (EXCHANGE_RATE_UNIT * shares) / _currentExchangeRate;\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function slash(address destination, uint256 amount)\n    external\n    override\n    onlySlashingAdmin\n    returns (uint256)\n  {\n    require(!inPostSlashingPeriod, 'PREVIOUS_SLASHING_NOT_SETTLED');\n    require(amount > 0, 'ZERO_AMOUNT');\n    uint256 currentShares = totalSupply();\n    uint256 balance = previewRedeem(currentShares);\n\n    uint256 maxSlashable = balance.percentMul(_maxSlashablePercentage);\n\n    if (amount > maxSlashable) {\n      amount = maxSlashable;\n    }\n    require(balance - amount >= LOWER_BOUND, 'REMAINING_LT_MINIMUM');\n\n    inPostSlashingPeriod = true;\n    _updateExchangeRate(_getExchangeRate(balance - amount, currentShares));\n\n    STAKED_TOKEN.safeTransfer(destination, amount);\n\n    emit Slashed(destination, amount);\n    return amount;\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function returnFunds(uint256 amount) external override {\n    require(amount >= LOWER_BOUND, 'AMOUNT_LT_MINIMUM');\n    uint256 currentShares = totalSupply();\n    require(currentShares >= LOWER_BOUND, 'SHARES_LT_MINIMUM');\n    uint256 assets = previewRedeem(currentShares);\n    _updateExchangeRate(_getExchangeRate(assets + amount, currentShares));\n\n    STAKED_TOKEN.safeTransferFrom(msg.sender, address(this), amount);\n    emit FundsReturned(amount);\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function settleSlashing() external override onlySlashingAdmin {\n    inPostSlashingPeriod = false;\n    emit SlashingSettled();\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function setMaxSlashablePercentage(uint256 percentage)\n    external\n    override\n    onlySlashingAdmin\n  {\n    _setMaxSlashablePercentage(percentage);\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function getMaxSlashablePercentage()\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _maxSlashablePercentage;\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function setCooldownSeconds(uint256 cooldownSeconds)\n    external\n    onlyCooldownAdmin\n  {\n    _setCooldownSeconds(cooldownSeconds);\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function getCooldownSeconds() external view returns (uint256) {\n    return _cooldownSeconds;\n  }\n\n  /// @inheritdoc IStakedTokenV3\n  function COOLDOWN_SECONDS() external view returns (uint256) {\n    return _cooldownSeconds;\n  }\n\n  /**\n   * @dev sets the max slashable percentage\n   * @param percentage must be strictly lower 100% as otherwise the exchange rate calculation would result in 0 division\n   */\n  function _setMaxSlashablePercentage(uint256 percentage) internal {\n    require(\n      percentage < PercentageMath.PERCENTAGE_FACTOR,\n      'INVALID_SLASHING_PERCENTAGE'\n    );\n\n    _maxSlashablePercentage = percentage;\n    emit MaxSlashablePercentageChanged(percentage);\n  }\n\n  /**\n   * @dev sets the cooldown seconds\n   * @param cooldownSeconds the new amount of cooldown seconds\n   */\n  function _setCooldownSeconds(uint256 cooldownSeconds) internal {\n    _cooldownSeconds = cooldownSeconds;\n    emit CooldownSecondsChanged(cooldownSeconds);\n  }\n\n  /**\n   * @dev claims the rewards for a specified address to a specified address\n   * @param from The address of the from from which to claim\n   * @param to Address to receive the rewards\n   * @param amount Amount to claim\n   * @return amount claimed\n   */\n  function _claimRewards(\n    address from,\n    address to,\n    uint256 amount\n  ) internal returns (uint256) {\n    require(amount != 0, 'INVALID_ZERO_AMOUNT');\n    uint256 newTotalRewards = _updateCurrentUnclaimedRewards(\n      from,\n      balanceOf(from),\n      false\n    );\n\n    uint256 amountToClaim = (amount > newTotalRewards)\n      ? newTotalRewards\n      : amount;\n    require(amountToClaim != 0, 'INVALID_ZERO_AMOUNT');\n\n    stakerRewardsToClaim[from] = newTotalRewards - amountToClaim;\n    REWARD_TOKEN.safeTransferFrom(REWARDS_VAULT, to, amountToClaim);\n    emit RewardsClaimed(from, to, amountToClaim);\n    return amountToClaim;\n  }\n\n  /**\n   * @dev Claims an `amount` of `REWARD_TOKEN` and stakes.\n   * @param from The address of the from from which to claim\n   * @param to Address to stake to\n   * @param amount Amount to claim\n   * @return amount claimed\n   */\n  function _claimRewardsAndStakeOnBehalf(\n    address from,\n    address to,\n    uint256 amount\n  ) internal returns (uint256) {\n    require(REWARD_TOKEN == STAKED_TOKEN, 'REWARD_TOKEN_IS_NOT_STAKED_TOKEN');\n\n    uint256 userUpdatedRewards = _updateCurrentUnclaimedRewards(\n      from,\n      balanceOf(from),\n      true\n    );\n    uint256 amountToClaim = (amount > userUpdatedRewards)\n      ? userUpdatedRewards\n      : amount;\n\n    if (amountToClaim != 0) {\n      _claimRewards(from, address(this), amountToClaim);\n      _stake(address(this), to, amountToClaim);\n    }\n\n    return amountToClaim;\n  }\n\n  /**\n   * @dev Allows staking a specified amount of STAKED_TOKEN\n   * @param to The address to receiving the shares\n   * @param amount The amount of assets to be staked\n   */\n  function _stake(\n    address from,\n    address to,\n    uint256 amount\n  ) internal {\n    require(!inPostSlashingPeriod, 'SLASHING_ONGOING');\n    require(amount != 0, 'INVALID_ZERO_AMOUNT');\n\n    uint256 balanceOfTo = balanceOf(to);\n\n    uint256 accruedRewards = _updateUserAssetInternal(\n      to,\n      address(this),\n      balanceOfTo,\n      totalSupply()\n    );\n\n    if (accruedRewards != 0) {\n      stakerRewardsToClaim[to] = stakerRewardsToClaim[to] + accruedRewards;\n      emit RewardsAccrued(to, accruedRewards);\n    }\n\n    uint256 sharesToMint = previewStake(amount);\n\n    STAKED_TOKEN.safeTransferFrom(from, address(this), amount);\n\n    _mint(to, sharesToMint);\n\n    emit Staked(from, to, amount, sharesToMint);\n  }\n\n  /**\n   * @dev Redeems staked tokens, and stop earning rewards\n   * @param from Address to redeem from\n   * @param to Address to redeem to\n   * @param amount Amount to redeem\n   */\n  function _redeem(\n    address from,\n    address to,\n    uint256 amount\n  ) internal {\n    require(amount != 0, 'INVALID_ZERO_AMOUNT');\n\n    CooldownSnapshot memory cooldownSnapshot = stakersCooldowns[from];\n    if (!inPostSlashingPeriod) {\n      require(\n        (block.timestamp > cooldownSnapshot.timestamp + _cooldownSeconds),\n        'INSUFFICIENT_COOLDOWN'\n      );\n      require(\n        (block.timestamp - (cooldownSnapshot.timestamp + _cooldownSeconds) <=\n          UNSTAKE_WINDOW),\n        'UNSTAKE_WINDOW_FINISHED'\n      );\n    }\n\n    uint256 balanceOfFrom = balanceOf(from);\n    uint256 maxRedeemable = inPostSlashingPeriod\n      ? balanceOfFrom\n      : cooldownSnapshot.amount;\n    require(maxRedeemable != 0, 'INVALID_ZERO_MAX_REDEEMABLE');\n\n    uint256 amountToRedeem = (amount > maxRedeemable) ? maxRedeemable : amount;\n\n    _updateCurrentUnclaimedRewards(from, balanceOfFrom, true);\n\n    uint256 underlyingToRedeem = previewRedeem(amountToRedeem);\n\n    _burn(from, amountToRedeem);\n\n    if (cooldownSnapshot.timestamp != 0) {\n      if (cooldownSnapshot.amount - amountToRedeem == 0) {\n        delete stakersCooldowns[from];\n      } else {\n        stakersCooldowns[from].amount =\n          stakersCooldowns[from].amount -\n          amountToRedeem.toUint184();\n      }\n    }\n\n    IERC20(STAKED_TOKEN).safeTransfer(to, underlyingToRedeem);\n\n    emit Redeem(from, to, underlyingToRedeem, amountToRedeem);\n  }\n\n  /**\n   * @dev Updates the exchangeRate and emits events accordingly\n   * @param newExchangeRate the new exchange rate\n   */\n  function _updateExchangeRate(uint216 newExchangeRate) internal virtual {\n    require(newExchangeRate != 0, 'ZERO_EXCHANGE_RATE');\n    _currentExchangeRate = newExchangeRate;\n    emit ExchangeRateChanged(newExchangeRate);\n  }\n\n  /**\n   * @dev calculates the exchange rate based on totalAssets and totalShares\n   * @dev always rounds up to ensure 100% backing of shares by rounding in favor of the contract\n   * @param totalAssets The total amount of assets staked\n   * @param totalShares The total amount of shares\n   * @return exchangeRate as 18 decimal precision uint216\n   */\n  function _getExchangeRate(uint256 totalAssets, uint256 totalShares)\n    internal\n    pure\n    returns (uint216)\n  {\n    return\n      (((totalShares * EXCHANGE_RATE_UNIT) + totalAssets - 1) / totalAssets)\n        .toUint216();\n  }\n\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override {\n    uint256 balanceOfFrom = balanceOf(from);\n    // Sender\n    _updateCurrentUnclaimedRewards(from, balanceOfFrom, true);\n\n    // Recipient\n    if (from != to) {\n      uint256 balanceOfTo = balanceOf(to);\n      _updateCurrentUnclaimedRewards(to, balanceOfTo, true);\n\n      CooldownSnapshot memory previousSenderCooldown = stakersCooldowns[from];\n      if (previousSenderCooldown.timestamp != 0) {\n        // if cooldown was set and whole balance of sender was transferred - clear cooldown\n        if (balanceOfFrom == amount) {\n          delete stakersCooldowns[from];\n        } else if (balanceOfFrom - amount < previousSenderCooldown.amount) {\n          stakersCooldowns[from].amount = uint184(balanceOfFrom - amount);\n        }\n      }\n    }\n\n    super._transfer(from, to, amount);\n  }\n}\n"
    },
    "aave-stk-v1-5/src/interfaces/IAaveDistributionManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\n\ninterface IAaveDistributionManager {\n  function configureAssets(\n    DistributionTypes.AssetConfigInput[] memory assetsConfigInput\n  ) external;\n}\n"
    },
    "aave-stk-v1-5/src/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n}\n"
    },
    "aave-stk-v1-5/src/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport './IERC20.sol';\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "aave-stk-v1-5/src/interfaces/IERC20WithPermit.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from './IERC20.sol';\n\ninterface IERC20WithPermit is IERC20 {\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n"
    },
    "aave-stk-v1-5/src/interfaces/IGhoVariableDebtTokenTransferHook.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IGhoVariableDebtTokenTransferHook {\n  /**\n   * @dev updates the discount when discount token is transferred\n   * @dev Only callable by discount token\n   * @param sender address of sender\n   * @param recipient address of recipient\n   * @param senderDiscountTokenBalance sender discount token balance\n   * @param recipientDiscountTokenBalance recipient discount token balance\n   * @param amount amount of discount token being transferred\n   **/\n  function updateDiscountDistribution(\n    address sender,\n    address recipient,\n    uint256 senderDiscountTokenBalance,\n    uint256 recipientDiscountTokenBalance,\n    uint256 amount\n  ) external;\n}\n"
    },
    "aave-stk-v1-5/src/interfaces/IGovernancePowerDelegationToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IGovernancePowerDelegationToken {\n  enum DelegationType {\n    VOTING_POWER,\n    PROPOSITION_POWER\n  }\n\n  /**\n   * @dev emitted when a user delegates to another\n   * @param delegator the delegator\n   * @param delegatee the delegatee\n   * @param delegationType the type of delegation (VOTING_POWER, PROPOSITION_POWER)\n   **/\n  event DelegateChanged(\n    address indexed delegator,\n    address indexed delegatee,\n    DelegationType delegationType\n  );\n\n  /**\n   * @dev emitted when an action changes the delegated power of a user\n   * @param user the user which delegated power has changed\n   * @param amount the amount of delegated power for the user\n   * @param delegationType the type of delegation (VOTING_POWER, PROPOSITION_POWER)\n   **/\n  event DelegatedPowerChanged(\n    address indexed user,\n    uint256 amount,\n    DelegationType delegationType\n  );\n\n  /**\n   * @dev delegates the specific power to a delegatee\n   * @param delegatee the user which delegated power has changed\n   * @param delegationType the type of delegation (VOTING_POWER, PROPOSITION_POWER)\n   **/\n  function delegateByType(address delegatee, DelegationType delegationType)\n    external;\n\n  /**\n   * @dev delegates all the powers to a specific user\n   * @param delegatee the user to which the power will be delegated\n   **/\n  function delegate(address delegatee) external;\n\n  /**\n   * @dev returns the delegatee of an user\n   * @param delegator the address of the delegator\n   **/\n  function getDelegateeByType(address delegator, DelegationType delegationType)\n    external\n    view\n    returns (address);\n\n  /**\n   * @dev returns the current delegated power of a user. The current power is the\n   * power delegated at the time of the last snapshot\n   * @param user the user\n   **/\n  function getPowerCurrent(address user, DelegationType delegationType)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev returns the delegated power of a user at a certain block\n   * @param user the user\n   **/\n  function getPowerAtBlock(\n    address user,\n    uint256 blockNumber,\n    DelegationType delegationType\n  ) external view returns (uint256);\n\n  /**\n   * @dev returns the total supply at a certain block number\n   **/\n  function totalSupplyAt(uint256 blockNumber) external view returns (uint256);\n}\n"
    },
    "aave-stk-v1-5/src/interfaces/IStakedAaveV3.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport {IStakedTokenV3} from './IStakedTokenV3.sol';\nimport {IGhoVariableDebtTokenTransferHook} from './IGhoVariableDebtTokenTransferHook.sol';\n\ninterface IStakedAaveV3 is IStakedTokenV3 {\n  struct ExchangeRateSnapshot {\n    uint40 blockNumber;\n    uint216 value;\n  }\n\n  event GHODebtTokenChanged(address indexed newDebtToken);\n\n  /**\n   * @dev Sets the GHO debt token (only callable by SHORT_EXECUTOR)\n   * @param newGHODebtToken Address to GHO debt token\n   */\n  function setGHODebtToken(IGhoVariableDebtTokenTransferHook newGHODebtToken)\n    external;\n\n  /**\n   * @dev Claims an `amount` of `REWARD_TOKEN` and stakes.\n   * @param to Address to stake to\n   * @param amount Amount to claim\n   */\n  function claimRewardsAndStake(address to, uint256 amount)\n    external\n    returns (uint256);\n\n  /**\n   * @dev Claims an `amount` of `REWARD_TOKEN` and stakes. Only the claim helper contract is allowed to call this function\n   * @param from The address of the from from which to claim\n   * @param to Address to stake to\n   * @param amount Amount to claim\n   */\n  function claimRewardsAndStakeOnBehalf(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows staking a certain amount of STAKED_TOKEN with gasless approvals (permit)\n   * @param from The address staking the token\n   * @param amount The amount to be staked\n   * @param deadline The permit execution deadline\n   * @param v The v component of the signed message\n   * @param r The r component of the signed message\n   * @param s The s component of the signed message\n   */\n  function stakeWithPermit(\n    address from,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n"
    },
    "aave-stk-v1-5/src/interfaces/IStakedTokenV2.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IStakedTokenV2 {\n  struct CooldownSnapshot {\n    uint40 timestamp;\n    uint216 amount;\n  }\n\n  event RewardsAccrued(address user, uint256 amount);\n  event RewardsClaimed(\n    address indexed from,\n    address indexed to,\n    uint256 amount\n  );\n  event Cooldown(address indexed user, uint256 amount);\n\n  /**\n   * @dev Allows staking a specified amount of STAKED_TOKEN\n   * @param to The address to receiving the shares\n   * @param amount The amount of assets to be staked\n   */\n  function stake(address to, uint256 amount) external;\n\n  /**\n   * @dev Redeems shares, and stop earning rewards\n   * @param to Address to redeem to\n   * @param amount Amount of shares to redeem\n   */\n  function redeem(address to, uint256 amount) external;\n\n  /**\n   * @dev Activates the cooldown period to unstake\n   * - It can't be called if the user is not staking\n   */\n  function cooldown() external;\n\n  /**\n   * @dev Claims an `amount` of `REWARD_TOKEN` to the address `to`\n   * @param to Address to send the claimed rewards\n   * @param amount Amount to stake\n   */\n  function claimRewards(address to, uint256 amount) external;\n\n  /**\n   * @dev Return the total rewards pending to claim by an staker\n   * @param staker The staker address\n   * @return The rewards\n   */\n  function getTotalRewardsBalance(address staker)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev implements the permit function as for https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n   * @param owner the owner of the funds\n   * @param spender the spender\n   * @param value the amount\n   * @param deadline the deadline timestamp, type(uint256).max for no deadline\n   * @param v signature param\n   * @param s signature param\n   * @param r signature param\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n"
    },
    "aave-stk-v1-5/src/interfaces/IStakedTokenV3.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport {IStakedTokenV2} from './IStakedTokenV2.sol';\n\ninterface IStakedTokenV3 is IStakedTokenV2 {\n  event Staked(\n    address indexed from,\n    address indexed to,\n    uint256 assets,\n    uint256 shares\n  );\n  event Redeem(\n    address indexed from,\n    address indexed to,\n    uint256 assets,\n    uint256 shares\n  );\n  event MaxSlashablePercentageChanged(uint256 newPercentage);\n  event Slashed(address indexed destination, uint256 amount);\n  event SlashingExitWindowDurationChanged(uint256 windowSeconds);\n  event CooldownSecondsChanged(uint256 cooldownSeconds);\n  event ExchangeRateChanged(uint216 exchangeRate);\n  event FundsReturned(uint256 amount);\n  event SlashingSettled();\n\n  /**\n   * @dev Returns the current exchange rate\n   * @return exchangeRate as 18 decimal precision uint216\n   */\n  function getExchangeRate() external view returns (uint216);\n\n  /**\n   * @dev Executes a slashing of the underlying of a certain amount, transferring the seized funds\n   * to destination. Decreasing the amount of underlying will automatically adjust the exchange rate.\n   * A call to `slash` will start a slashing event which has to be settled via `settleSlashing`.\n   * As long as the slashing event is ongoing, stake and slash are deactivated.\n   * - MUST NOT be called when a previous slashing is still ongoing\n   * @param destination the address where seized funds will be transferred\n   * @param amount the amount to be slashed\n   * - if the amount bigger than maximum allowed, the maximum will be slashed instead.\n   * @return amount the amount slashed\n   */\n  function slash(address destination, uint256 amount)\n    external\n    returns (uint256);\n\n  /**\n   * @dev Settles an ongoing slashing event\n   */\n  function settleSlashing() external;\n\n  /**\n   * @dev Pulls STAKE_TOKEN and distributes them amongst current stakers by altering the exchange rate.\n   * This method is permissionless and intended to be used after a slashing event to return potential excess funds.\n   * @param amount amount of STAKE_TOKEN to pull.\n   */\n  function returnFunds(uint256 amount) external;\n\n  /**\n   * @dev Getter of the cooldown seconds\n   * @return cooldownSeconds the amount of seconds between starting the cooldown and being able to redeem\n   */\n  function getCooldownSeconds() external view returns (uint256);\n\n  /**\n   * @dev Getter of the cooldown seconds\n   * @return cooldownSeconds the amount of seconds between starting the cooldown and being able to redeem\n   */\n  function COOLDOWN_SECONDS() external view returns (uint256); // @deprecated\n\n  /**\n   * @dev Setter of cooldown seconds\n   * Can only be called by the cooldown admin\n   * @param cooldownSeconds the new amount of seconds you have to wait between starting the cooldown and being able to redeem\n   */\n  function setCooldownSeconds(uint256 cooldownSeconds) external;\n\n  /**\n   * @dev Getter of the max slashable percentage of the total staked amount.\n   * @return percentage the maximum slashable percentage\n   */\n  function getMaxSlashablePercentage() external view returns (uint256);\n\n  /**\n   * @dev Setter of max slashable percentage of the total staked amount.\n   * Can only be called by the slashing admin\n   * @param percentage the new maximum slashable percentage\n   */\n  function setMaxSlashablePercentage(uint256 percentage) external;\n\n  /**\n   * @dev returns the exact amount of shares that would be received for the provided number of assets\n   * @param assets the number of assets to stake\n   * @return uint256 shares the number of shares that would be received\n   */\n  function previewStake(uint256 assets) external view returns (uint256);\n\n  /**\n   * @dev Activates the cooldown period to unstake\n   * - It can't be called if the user is not staking\n   */\n  function cooldownOnBehalfOf(address from) external;\n\n  /**\n   * @dev Claims an `amount` of `REWARD_TOKEN` to the address `to` on behalf of the user. Only the claim helper contract is allowed to call this function\n   * @param from The address of the user from to claim\n   * @param to Address to send the claimed rewards\n   * @param amount Amount to claim\n   */\n  function claimRewardsOnBehalf(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (uint256);\n\n  /**\n   * @dev returns the exact amount of assets that would be redeemed for the provided number of shares\n   * @param shares the number of shares to redeem\n   * @return uint256 assets the number of assets that would be redeemed\n   */\n  function previewRedeem(uint256 shares) external view returns (uint256);\n\n  /**\n   * @dev Redeems shares for a user. Only the claim helper contract is allowed to call this function\n   * @param from Address to redeem from\n   * @param to Address to redeem to\n   * @param amount Amount of shares to redeem\n   */\n  function redeemOnBehalf(\n    address from,\n    address to,\n    uint256 amount\n  ) external;\n\n  /**\n   * @dev Claims an `amount` of `REWARD_TOKEN` and redeems to the provided address\n   * @param to Address to claim and redeem to\n   * @param claimAmount Amount to claim\n   * @param redeemAmount Amount to redeem\n   */\n  function claimRewardsAndRedeem(\n    address to,\n    uint256 claimAmount,\n    uint256 redeemAmount\n  ) external;\n\n  /**\n   * @dev Claims an `amount` of `REWARD_TOKEN` and redeems the `redeemAmount` to an address. Only the claim helper contract is allowed to call this function\n   * @param from The address of the from\n   * @param to Address to claim and redeem to\n   * @param claimAmount Amount to claim\n   * @param redeemAmount Amount to redeem\n   */\n  function claimRewardsAndRedeemOnBehalf(\n    address from,\n    address to,\n    uint256 claimAmount,\n    uint256 redeemAmount\n  ) external;\n}\n"
    },
    "aave-stk-v1-5/src/interfaces/ITransferHook.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface ITransferHook {\n  function onTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) external;\n}\n"
    },
    "aave-stk-v1-5/src/lib/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "aave-stk-v1-5/src/lib/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "aave-stk-v1-5/src/lib/DistributionTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nlibrary DistributionTypes {\n    struct AssetConfigInput {\n        uint128 emissionPerSecond;\n        uint256 totalStaked;\n        address underlyingAsset;\n    }\n\n    struct UserStakeInput {\n        address underlyingAsset;\n        uint256 stakedByUser;\n        uint256 totalStaked;\n    }\n}\n"
    },
    "aave-stk-v1-5/src/lib/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"./Context.sol\";\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) internal _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 internal _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals; // @deprecated\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor() {}\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "aave-stk-v1-5/src/lib/GovernancePowerDelegationERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport {ERC20} from './ERC20.sol';\nimport {\n  IGovernancePowerDelegationToken\n} from '../interfaces/IGovernancePowerDelegationToken.sol';\n\n/**\n * @notice implementation of the AAVE token contract\n * @author Aave\n */\nabstract contract GovernancePowerDelegationERC20 is ERC20, IGovernancePowerDelegationToken {\n  /// @notice The EIP-712 typehash for the delegation struct used by the contract\n  bytes32 public constant DELEGATE_BY_TYPE_TYPEHASH = keccak256(\n    'DelegateByType(address delegatee,uint256 type,uint256 nonce,uint256 expiry)'\n  );\n\n  bytes32 public constant DELEGATE_TYPEHASH = keccak256(\n    'Delegate(address delegatee,uint256 nonce,uint256 expiry)'\n  );\n\n  /// @dev snapshot of a value on a specific block, used for votes\n  struct Snapshot {\n    uint128 blockNumber;\n    uint128 value;\n  }\n\n  /**\n   * @dev delegates one specific power to a delegatee\n   * @param delegatee the user which delegated power has changed\n   * @param delegationType the type of delegation (VOTING_POWER, PROPOSITION_POWER)\n   **/\n  function delegateByType(address delegatee, DelegationType delegationType) external override {\n    _delegateByType(msg.sender, delegatee, delegationType);\n  }\n\n  /**\n   * @dev delegates all the powers to a specific user\n   * @param delegatee the user to which the power will be delegated\n   **/\n  function delegate(address delegatee) external override {\n    _delegateByType(msg.sender, delegatee, DelegationType.VOTING_POWER);\n    _delegateByType(msg.sender, delegatee, DelegationType.PROPOSITION_POWER);\n  }\n\n  /**\n   * @dev returns the delegatee of an user\n   * @param delegator the address of the delegator\n   **/\n  function getDelegateeByType(address delegator, DelegationType delegationType)\n    external\n    override\n    view\n    returns (address)\n  {\n    (, , mapping(address => address) storage delegates) = _getDelegationDataByType(delegationType);\n\n    return _getDelegatee(delegator, delegates);\n  }\n\n  /**\n   * @dev returns the current delegated power of a user. The current power is the\n   * power delegated at the time of the last snapshot\n   * @param user the user\n   **/\n  function getPowerCurrent(address user, DelegationType delegationType)\n    external\n    override\n    view\n    returns (uint256)\n  {\n    (\n      mapping(address => mapping(uint256 => Snapshot)) storage snapshots,\n      mapping(address => uint256) storage snapshotsCounts,\n\n    ) = _getDelegationDataByType(delegationType);\n\n    return _searchByBlockNumber(snapshots, snapshotsCounts, user, block.number);\n  }\n\n  /**\n   * @dev returns the delegated power of a user at a certain block\n   * @param user the user\n   **/\n  function getPowerAtBlock(\n    address user,\n    uint256 blockNumber,\n    DelegationType delegationType\n  ) external override view returns (uint256) {\n    (\n      mapping(address => mapping(uint256 => Snapshot)) storage snapshots,\n      mapping(address => uint256) storage snapshotsCounts,\n\n    ) = _getDelegationDataByType(delegationType);\n\n    return _searchByBlockNumber(snapshots, snapshotsCounts, user, blockNumber);\n  }\n\n  /**\n   * @dev returns the total supply at a certain block number\n   * used by the voting strategy contracts to calculate the total votes needed for threshold/quorum\n   * In this initial implementation with no AAVE minting, simply returns the current supply\n   * A snapshots mapping will need to be added in case a mint function is added to the AAVE token in the future\n   **/\n  function totalSupplyAt(uint256) external override view returns (uint256) {\n    return super.totalSupply();\n  }\n\n  /**\n   * @dev delegates the specific power to a delegatee\n   * @param delegatee the user which delegated power has changed\n   * @param delegationType the type of delegation (VOTING_POWER, PROPOSITION_POWER)\n   **/\n  function _delegateByType(\n    address delegator,\n    address delegatee,\n    DelegationType delegationType\n  ) internal {\n    require(delegatee != address(0), 'INVALID_DELEGATEE');\n\n    (, , mapping(address => address) storage delegates) = _getDelegationDataByType(delegationType);\n\n    uint256 delegatorBalance = balanceOf(delegator);\n\n    address previousDelegatee = _getDelegatee(delegator, delegates);\n\n    delegates[delegator] = delegatee;\n\n    _moveDelegatesByType(previousDelegatee, delegatee, delegatorBalance, delegationType);\n    emit DelegateChanged(delegator, delegatee, delegationType);\n  }\n\n  /**\n   * @dev moves delegated power from one user to another\n   * @param from the user from which delegated power is moved\n   * @param to the user that will receive the delegated power\n   * @param amount the amount of delegated power to be moved\n   * @param delegationType the type of delegation (VOTING_POWER, PROPOSITION_POWER)\n   **/\n  function _moveDelegatesByType(\n    address from,\n    address to,\n    uint256 amount,\n    DelegationType delegationType\n  ) internal {\n    if (from == to) {\n      return;\n    }\n\n    (\n      mapping(address => mapping(uint256 => Snapshot)) storage snapshots,\n      mapping(address => uint256) storage snapshotsCounts,\n\n    ) = _getDelegationDataByType(delegationType);\n\n    if (from != address(0)) {\n      uint256 previous = 0;\n      uint256 fromSnapshotsCount = snapshotsCounts[from];\n\n      if (fromSnapshotsCount != 0) {\n        previous = snapshots[from][fromSnapshotsCount - 1].value;\n      } else {\n        previous = balanceOf(from);\n      }\n\n      _writeSnapshot(\n        snapshots,\n        snapshotsCounts,\n        from,\n        uint128(previous),\n        uint128(previous - amount)\n      );\n\n      emit DelegatedPowerChanged(from, previous - amount, delegationType);\n    }\n    if (to != address(0)) {\n      uint256 previous = 0;\n      uint256 toSnapshotsCount = snapshotsCounts[to];\n      if (toSnapshotsCount != 0) {\n        previous = snapshots[to][toSnapshotsCount - 1].value;\n      } else {\n        previous = balanceOf(to);\n      }\n\n      _writeSnapshot(\n        snapshots,\n        snapshotsCounts,\n        to,\n        uint128(previous),\n        uint128(previous + amount)\n      );\n\n      emit DelegatedPowerChanged(to, previous + amount, delegationType);\n    }\n  }\n\n  /**\n   * @dev searches a snapshot by block number. Uses binary search.\n   * @param snapshots the snapshots mapping\n   * @param snapshotsCounts the number of snapshots\n   * @param user the user for which the snapshot is being searched\n   * @param blockNumber the block number being searched\n   **/\n  function _searchByBlockNumber(\n    mapping(address => mapping(uint256 => Snapshot)) storage snapshots,\n    mapping(address => uint256) storage snapshotsCounts,\n    address user,\n    uint256 blockNumber\n  ) internal virtual view returns (uint256) {\n    require(blockNumber <= block.number, 'INVALID_BLOCK_NUMBER');\n\n    uint256 snapshotsCount = snapshotsCounts[user];\n\n    if (snapshotsCount == 0) {\n      return balanceOf(user);\n    }\n\n    // Check implicit zero balance\n    if (snapshots[user][0].blockNumber > blockNumber) {\n      return 0;\n    }\n\n    return _binarySearch(snapshots[user], snapshotsCount, blockNumber);\n  }\n\n  function _binarySearch(mapping(uint256 => Snapshot) storage snapshots, uint256 snapshotsCount, uint256 blockNumber) internal view returns (uint256) {\n    unchecked {\n      // First check most recent balance\n      if (snapshots[snapshotsCount - 1].blockNumber <= blockNumber) {\n        return snapshots[snapshotsCount - 1].value;\n      }\n\n      uint256 lower = 0;\n      uint256 upper = snapshotsCount - 1;\n      while (upper > lower) {\n        uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n        Snapshot memory snapshot = snapshots[center];\n        if (snapshot.blockNumber == blockNumber) {\n          return snapshot.value;\n        } else if (snapshot.blockNumber < blockNumber) {\n          lower = center;\n        } else {\n          upper = center - 1;\n        }\n      }\n      return snapshots[lower].value;\n    }\n  }\n\n  /**\n   * @dev returns the delegation data (snapshot, snapshotsCount, list of delegates) by delegation type\n   * NOTE: Ideal implementation would have mapped this in a struct by delegation type. Unfortunately,\n   * the AAVE token and StakeToken already include a mapping for the snapshots, so we require contracts\n   * who inherit from this to provide access to the delegation data by overriding this method.\n   * @param delegationType the type of delegation\n   **/\n  function _getDelegationDataByType(DelegationType delegationType)\n    internal\n    virtual\n    view\n    returns (\n      mapping(address => mapping(uint256 => Snapshot)) storage, //snapshots\n      mapping(address => uint256) storage, //snapshots count\n      mapping(address => address) storage //delegatees list\n    );\n\n  /**\n   * @dev Writes a snapshot for an owner of tokens\n   * @param owner The owner of the tokens\n   * @param oldValue The value before the operation that is gonna be executed after the snapshot\n   * @param newValue The value after the operation\n   */\n  function _writeSnapshot(\n    mapping(address => mapping(uint256 => Snapshot)) storage snapshots,\n    mapping(address => uint256) storage snapshotsCounts,\n    address owner,\n    uint128 oldValue,\n    uint128 newValue\n  ) internal {\n    uint128 currentBlock = uint128(block.number);\n\n    uint256 ownerSnapshotsCount = snapshotsCounts[owner];\n    mapping(uint256 => Snapshot) storage snapshotsOwner = snapshots[owner];\n\n    // Doing multiple operations in the same block\n    if (\n      ownerSnapshotsCount != 0 &&\n      snapshotsOwner[ownerSnapshotsCount - 1].blockNumber == currentBlock\n    ) {\n      snapshotsOwner[ownerSnapshotsCount - 1].value = newValue;\n    } else {\n      snapshotsOwner[ownerSnapshotsCount] = Snapshot(currentBlock, newValue);\n      snapshotsCounts[owner] = ownerSnapshotsCount + 1;\n    }\n  }\n\n  /**\n   * @dev returns the user delegatee. If a user never performed any delegation,\n   * his delegated address will be 0x0. In that case we simply return the user itself\n   * @param delegator the address of the user for which return the delegatee\n   * @param delegates the array of delegates for a particular type of delegation\n   **/\n  function _getDelegatee(address delegator, mapping(address => address) storage delegates)\n    internal\n    view\n    returns (address)\n  {\n    address previousDelegatee = delegates[delegator];\n\n    if (previousDelegatee == address(0)) {\n      return delegator;\n    }\n\n    return previousDelegatee;\n  }\n}\n"
    },
    "aave-stk-v1-5/src/lib/GovernancePowerWithSnapshot.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport {ERC20} from '../lib/ERC20.sol';\nimport {ITransferHook} from '../interfaces/ITransferHook.sol';\nimport {\n  GovernancePowerDelegationERC20\n} from './GovernancePowerDelegationERC20.sol';\n\n/**\n * @title ERC20WithSnapshot\n * @notice ERC20 including snapshots of balances on transfer-related actions\n * @author Aave\n **/\nabstract contract GovernancePowerWithSnapshot is GovernancePowerDelegationERC20 {\n  /**\n   * @dev The following storage layout points to the prior StakedToken.sol implementation:\n   * _snapshots => _votingSnapshots\n   * _snapshotsCounts =>  _votingSnapshotsCounts\n   * _aaveGovernance => _aaveGovernance\n   */\n  mapping(address => mapping(uint256 => Snapshot)) public _votingSnapshots;\n  mapping(address => uint256) public _votingSnapshotsCounts;\n\n  /// @dev reference to the Aave governance contract to call (if initialized) on _beforeTokenTransfer\n  /// !!! IMPORTANT The Aave governance is considered a trustable contract, being its responsibility\n  /// to control all potential reentrancies by calling back the this contract\n  /// @dev DEPRECATED\n  ITransferHook public _aaveGovernance;\n}\n"
    },
    "aave-stk-v1-5/src/lib/PercentageMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded half up\n **/\n\nlibrary PercentageMath {\n    uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\n    uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\n\n    /**\n     * @dev Executes a percentage multiplication\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return The percentage of value\n     **/\n    function percentMul(uint256 value, uint256 percentage)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (value == 0 || percentage == 0) {\n            return 0;\n        }\n\n        require(\n            value <= (type(uint256).max) / percentage,\n            \"MATH_MULTIPLICATION_OVERFLOW\"\n        );\n\n        return (value * percentage) / PERCENTAGE_FACTOR;\n    }\n\n    /**\n     * @dev Executes a percentage division\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return The value divided the percentage\n     **/\n    function percentDiv(uint256 value, uint256 percentage)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(percentage != 0, \"MATH_DIVISION_BY_ZERO\");\n\n        require(\n            value <= type(uint256).max / PERCENTAGE_FACTOR,\n            \"MATH_MULTIPLICATION_OVERFLOW\"\n        );\n\n        return (value * PERCENTAGE_FACTOR) / percentage;\n    }\n}\n"
    },
    "aave-stk-v1-5/src/lib/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "aave-stk-v1-5/src/lib/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(\n                oldAllowance >= value,\n                \"SafeERC20: decreased allowance below zero\"\n            );\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(\n                token,\n                abi.encodeWithSelector(\n                    token.approve.selector,\n                    spender,\n                    newAllowance\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n"
    },
    "aave-stk-v1-5/src/utils/RoleManager.sol": {
      "content": "pragma solidity ^0.8.0;\n\n/**\n * @title RoleManager\n * @notice Generic role manager to manage slashing and cooldown admin in StakedAaveV3.\n *         It implements a claim admin role pattern to safely migrate between different admin addresses\n * @author Aave\n **/\ncontract RoleManager {\n  struct InitAdmin {\n    uint256 role;\n    address admin;\n  }\n\n  mapping(uint256 => address) private _admins;\n  mapping(uint256 => address) private _pendingAdmins;\n\n  event PendingAdminChanged(address indexed newPendingAdmin, uint256 role);\n  event RoleClaimed(address indexed newAdmin, uint256 role);\n\n  modifier onlyRoleAdmin(uint256 role) {\n    require(_admins[role] == msg.sender, 'CALLER_NOT_ROLE_ADMIN');\n    _;\n  }\n\n  modifier onlyPendingRoleAdmin(uint256 role) {\n    require(\n      _pendingAdmins[role] == msg.sender,\n      'CALLER_NOT_PENDING_ROLE_ADMIN'\n    );\n    _;\n  }\n\n  /**\n   * @dev returns the admin associated with the specific role\n   * @param role the role associated with the admin being returned\n   **/\n  function getAdmin(uint256 role) public view returns (address) {\n    return _admins[role];\n  }\n\n  /**\n   * @dev returns the pending admin associated with the specific role\n   * @param role the role associated with the pending admin being returned\n   **/\n  function getPendingAdmin(uint256 role) public view returns (address) {\n    return _pendingAdmins[role];\n  }\n\n  /**\n   * @dev sets the pending admin for a specific role\n   * @param role the role associated with the new pending admin being set\n   * @param newPendingAdmin the address of the new pending admin\n   **/\n  function setPendingAdmin(uint256 role, address newPendingAdmin)\n    public\n    onlyRoleAdmin(role)\n  {\n    _pendingAdmins[role] = newPendingAdmin;\n    emit PendingAdminChanged(newPendingAdmin, role);\n  }\n\n  /**\n   * @dev allows the caller to become a specific role admin\n   * @param role the role associated with the admin claiming the new role\n   **/\n  function claimRoleAdmin(uint256 role) external onlyPendingRoleAdmin(role) {\n    _admins[role] = msg.sender;\n    _pendingAdmins[role] = address(0);\n    emit RoleClaimed(msg.sender, role);\n  }\n\n  function _initAdmins(InitAdmin[] memory initAdmins) internal {\n    for (uint256 i = 0; i < initAdmins.length; i++) {\n      require(\n        _admins[initAdmins[i].role] == address(0) &&\n          initAdmins[i].admin != address(0),\n        'ADMIN_CANNOT_BE_INITIALIZED'\n      );\n      _admins[initAdmins[i].role] = initAdmins[i].admin;\n      emit RoleClaimed(initAdmins[i].admin, initAdmins[i].role);\n    }\n  }\n}\n"
    },
    "aave-stk-v1-5/src/utils/VersionedInitializable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title VersionedInitializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n *\n * @author Aave, inspired by the OpenZeppelin Initializable contract\n */\nabstract contract VersionedInitializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  uint256 internal lastInitializedRevision = 0;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    uint256 revision = getRevision();\n    require(\n      revision > lastInitializedRevision,\n      'Contract instance has already been initialized'\n    );\n\n    lastInitializedRevision = revision;\n\n    _;\n  }\n\n  /// @dev returns the revision number of the contract.\n  /// Needs to be defined in the inherited class as a constant.\n  function getRevision() internal pure virtual returns (uint256);\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
    },
    "aave-v3-core/contracts/dependencies/chainlink/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Chainlink Contracts v0.8\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "aave-v3-core/contracts/dependencies/openzeppelin/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "aave-v3-core/contracts/interfaces/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IAaveIncentivesController\n * @author Aave\n * @notice Defines the basic interface for an Aave Incentives Controller.\n * @dev It only contains one single function, needed as a hook on aToken and debtToken transfers.\n */\ninterface IAaveIncentivesController {\n  /**\n   * @dev Called by the corresponding asset on transfer hook in order to update the rewards distribution.\n   * @dev The units of `totalSupply` and `userBalance` should be the same.\n   * @param user The address of the user whose asset balance has changed\n   * @param totalSupply The total supply of the asset prior to user balance change\n   * @param userBalance The previous user balance prior to balance change\n   */\n  function handleAction(address user, uint256 totalSupply, uint256 userBalance) external;\n}\n"
    },
    "aave-v3-core/contracts/interfaces/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPriceOracleGetter} from './IPriceOracleGetter.sol';\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IAaveOracle\n * @author Aave\n * @notice Defines the basic interface for the Aave Oracle\n */\ninterface IAaveOracle is IPriceOracleGetter {\n  /**\n   * @dev Emitted after the base currency is set\n   * @param baseCurrency The base currency of used for price quotes\n   * @param baseCurrencyUnit The unit of the base currency\n   */\n  event BaseCurrencySet(address indexed baseCurrency, uint256 baseCurrencyUnit);\n\n  /**\n   * @dev Emitted after the price source of an asset is updated\n   * @param asset The address of the asset\n   * @param source The price source of the asset\n   */\n  event AssetSourceUpdated(address indexed asset, address indexed source);\n\n  /**\n   * @dev Emitted after the address of fallback oracle is updated\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  event FallbackOracleUpdated(address indexed fallbackOracle);\n\n  /**\n   * @notice Returns the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Sets or replaces price sources of assets\n   * @param assets The addresses of the assets\n   * @param sources The addresses of the price sources\n   */\n  function setAssetSources(address[] calldata assets, address[] calldata sources) external;\n\n  /**\n   * @notice Sets the fallback oracle\n   * @param fallbackOracle The address of the fallback oracle\n   */\n  function setFallbackOracle(address fallbackOracle) external;\n\n  /**\n   * @notice Returns a list of prices from a list of assets addresses\n   * @param assets The list of assets addresses\n   * @return The prices of the given assets\n   */\n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory);\n\n  /**\n   * @notice Returns the address of the source for an asset address\n   * @param asset The address of the asset\n   * @return The address of the source\n   */\n  function getSourceOfAsset(address asset) external view returns (address);\n\n  /**\n   * @notice Returns the address of the fallback oracle\n   * @return The address of the fallback oracle\n   */\n  function getFallbackOracle() external view returns (address);\n}\n"
    },
    "aave-v3-core/contracts/interfaces/IACLManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IACLManager\n * @author Aave\n * @notice Defines the basic interface for the ACL Manager\n */\ninterface IACLManager {\n  /**\n   * @notice Returns the contract address of the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the identifier of the PoolAdmin role\n   * @return The id of the PoolAdmin role\n   */\n  function POOL_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the EmergencyAdmin role\n   * @return The id of the EmergencyAdmin role\n   */\n  function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the RiskAdmin role\n   * @return The id of the RiskAdmin role\n   */\n  function RISK_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the FlashBorrower role\n   * @return The id of the FlashBorrower role\n   */\n  function FLASH_BORROWER_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the Bridge role\n   * @return The id of the Bridge role\n   */\n  function BRIDGE_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the AssetListingAdmin role\n   * @return The id of the AssetListingAdmin role\n   */\n  function ASSET_LISTING_ADMIN_ROLE() external view returns (bytes32);\n\n  /**\n   * @notice Set the role as admin of a specific role.\n   * @dev By default the admin role for all roles is `DEFAULT_ADMIN_ROLE`.\n   * @param role The role to be managed by the admin role\n   * @param adminRole The admin role\n   */\n  function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\n\n  /**\n   * @notice Adds a new admin as PoolAdmin\n   * @param admin The address of the new admin\n   */\n  function addPoolAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as PoolAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removePoolAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is PoolAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is PoolAdmin, false otherwise\n   */\n  function isPoolAdmin(address admin) external view returns (bool);\n\n  /**\n   * @notice Adds a new admin as EmergencyAdmin\n   * @param admin The address of the new admin\n   */\n  function addEmergencyAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as EmergencyAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removeEmergencyAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is EmergencyAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is EmergencyAdmin, false otherwise\n   */\n  function isEmergencyAdmin(address admin) external view returns (bool);\n\n  /**\n   * @notice Adds a new admin as RiskAdmin\n   * @param admin The address of the new admin\n   */\n  function addRiskAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as RiskAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removeRiskAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is RiskAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is RiskAdmin, false otherwise\n   */\n  function isRiskAdmin(address admin) external view returns (bool);\n\n  /**\n   * @notice Adds a new address as FlashBorrower\n   * @param borrower The address of the new FlashBorrower\n   */\n  function addFlashBorrower(address borrower) external;\n\n  /**\n   * @notice Removes an address as FlashBorrower\n   * @param borrower The address of the FlashBorrower to remove\n   */\n  function removeFlashBorrower(address borrower) external;\n\n  /**\n   * @notice Returns true if the address is FlashBorrower, false otherwise\n   * @param borrower The address to check\n   * @return True if the given address is FlashBorrower, false otherwise\n   */\n  function isFlashBorrower(address borrower) external view returns (bool);\n\n  /**\n   * @notice Adds a new address as Bridge\n   * @param bridge The address of the new Bridge\n   */\n  function addBridge(address bridge) external;\n\n  /**\n   * @notice Removes an address as Bridge\n   * @param bridge The address of the bridge to remove\n   */\n  function removeBridge(address bridge) external;\n\n  /**\n   * @notice Returns true if the address is Bridge, false otherwise\n   * @param bridge The address to check\n   * @return True if the given address is Bridge, false otherwise\n   */\n  function isBridge(address bridge) external view returns (bool);\n\n  /**\n   * @notice Adds a new admin as AssetListingAdmin\n   * @param admin The address of the new admin\n   */\n  function addAssetListingAdmin(address admin) external;\n\n  /**\n   * @notice Removes an admin as AssetListingAdmin\n   * @param admin The address of the admin to remove\n   */\n  function removeAssetListingAdmin(address admin) external;\n\n  /**\n   * @notice Returns true if the address is AssetListingAdmin, false otherwise\n   * @param admin The address to check\n   * @return True if the given address is AssetListingAdmin, false otherwise\n   */\n  function isAssetListingAdmin(address admin) external view returns (bool);\n}\n"
    },
    "aave-v3-core/contracts/interfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\nimport {IInitializableAToken} from './IInitializableAToken.sol';\n\n/**\n * @title IAToken\n * @author Aave\n * @notice Defines the basic interface for an AToken.\n */\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\n  /**\n   * @dev Emitted during the transfer action\n   * @param from The user whose tokens are being transferred\n   * @param to The recipient\n   * @param value The scaled amount being transferred\n   * @param index The next liquidity index of the reserve\n   */\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n  /**\n   * @notice Mints `amount` aTokens to `user`\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted aTokens\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool);\n\n  /**\n   * @notice Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * @dev In some instances, the mint event could be emitted from a burn transaction\n   * if the amount to burn is less than the interest that the user accrued\n   * @param from The address from which the aTokens will be burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The next liquidity index of the reserve\n   */\n  function burn(address from, address receiverOfUnderlying, uint256 amount, uint256 index) external;\n\n  /**\n   * @notice Mints aTokens to the reserve treasury\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external;\n\n  /**\n   * @notice Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n   * @param from The address getting liquidated, current owner of the aTokens\n   * @param to The recipient\n   * @param value The amount of tokens getting transferred\n   */\n  function transferOnLiquidation(address from, address to, uint256 value) external;\n\n  /**\n   * @notice Transfers the underlying asset to `target`.\n   * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()\n   * @param target The recipient of the underlying\n   * @param amount The amount getting transferred\n   */\n  function transferUnderlyingTo(address target, uint256 amount) external;\n\n  /**\n   * @notice Handles the underlying received by the aToken after the transfer has been completed.\n   * @dev The default implementation is empty as with standard ERC20 tokens, nothing needs to be done after the\n   * transfer is concluded. However in the future there may be aTokens that allow for example to stake the underlying\n   * to receive LM rewards. In that case, `handleRepayment()` would perform the staking of the underlying asset.\n   * @param user The user executing the repayment\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed\n   * @param amount The amount getting repaid\n   */\n  function handleRepayment(address user, address onBehalfOf, uint256 amount) external;\n\n  /**\n   * @notice Allow passing a signed message to approve spending\n   * @dev implements the permit function as for\n   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n   * @param owner The owner of the funds\n   * @param spender The spender\n   * @param value The amount\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param v Signature param\n   * @param s Signature param\n   * @param r Signature param\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @notice Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @return The address of the underlying asset\n   */\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n\n  /**\n   * @notice Returns the address of the Aave treasury, receiving the fees on this aToken.\n   * @return Address of the Aave treasury\n   */\n  function RESERVE_TREASURY_ADDRESS() external view returns (address);\n\n  /**\n   * @notice Get the domain separator for the token\n   * @dev Return cached value if chainId matches cache, otherwise recomputes separator\n   * @return The domain separator of the token at current chain\n   */\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /**\n   * @notice Returns the nonce for owner.\n   * @param owner The address of the owner\n   * @return The nonce of the owner\n   */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n}\n"
    },
    "aave-v3-core/contracts/interfaces/IDefaultInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IReserveInterestRateStrategy} from './IReserveInterestRateStrategy.sol';\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IDefaultInterestRateStrategy\n * @author Aave\n * @notice Defines the basic interface of the DefaultReserveInterestRateStrategy\n */\ninterface IDefaultInterestRateStrategy is IReserveInterestRateStrategy {\n  /**\n   * @notice Returns the usage ratio at which the pool aims to obtain most competitive borrow rates.\n   * @return The optimal usage ratio, expressed in ray.\n   */\n  function OPTIMAL_USAGE_RATIO() external view returns (uint256);\n\n  /**\n   * @notice Returns the optimal stable to total debt ratio of the reserve.\n   * @return The optimal stable to total debt ratio, expressed in ray.\n   */\n  function OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO() external view returns (uint256);\n\n  /**\n   * @notice Returns the excess usage ratio above the optimal.\n   * @dev It's always equal to 1-optimal usage ratio (added as constant for gas optimizations)\n   * @return The max excess usage ratio, expressed in ray.\n   */\n  function MAX_EXCESS_USAGE_RATIO() external view returns (uint256);\n\n  /**\n   * @notice Returns the excess stable debt ratio above the optimal.\n   * @dev It's always equal to 1-optimal stable to total debt ratio (added as constant for gas optimizations)\n   * @return The max excess stable to total debt ratio, expressed in ray.\n   */\n  function MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the variable rate slope below optimal usage ratio\n   * @dev It's the variable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\n   * @return The variable rate slope, expressed in ray\n   */\n  function getVariableRateSlope1() external view returns (uint256);\n\n  /**\n   * @notice Returns the variable rate slope above optimal usage ratio\n   * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\n   * @return The variable rate slope, expressed in ray\n   */\n  function getVariableRateSlope2() external view returns (uint256);\n\n  /**\n   * @notice Returns the stable rate slope below optimal usage ratio\n   * @dev It's the stable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\n   * @return The stable rate slope, expressed in ray\n   */\n  function getStableRateSlope1() external view returns (uint256);\n\n  /**\n   * @notice Returns the stable rate slope above optimal usage ratio\n   * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\n   * @return The stable rate slope, expressed in ray\n   */\n  function getStableRateSlope2() external view returns (uint256);\n\n  /**\n   * @notice Returns the stable rate excess offset\n   * @dev It's an additional premium applied to the stable when stable debt > OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO\n   * @return The stable rate excess offset, expressed in ray\n   */\n  function getStableRateExcessOffset() external view returns (uint256);\n\n  /**\n   * @notice Returns the base stable borrow rate\n   * @return The base stable borrow rate, expressed in ray\n   */\n  function getBaseStableBorrowRate() external view returns (uint256);\n\n  /**\n   * @notice Returns the base variable borrow rate\n   * @return The base variable borrow rate, expressed in ray\n   */\n  function getBaseVariableBorrowRate() external view returns (uint256);\n\n  /**\n   * @notice Returns the maximum variable borrow rate\n   * @return The maximum variable borrow rate, expressed in ray\n   */\n  function getMaxVariableBorrowRate() external view returns (uint256);\n}\n"
    },
    "aave-v3-core/contracts/interfaces/IInitializableAToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\nimport {IPool} from './IPool.sol';\n\n/**\n * @title IInitializableAToken\n * @author Aave\n * @notice Interface for the initialize function on AToken\n */\ninterface IInitializableAToken {\n  /**\n   * @dev Emitted when an aToken is initialized\n   * @param underlyingAsset The address of the underlying asset\n   * @param pool The address of the associated pool\n   * @param treasury The address of the treasury\n   * @param incentivesController The address of the incentives controller for this aToken\n   * @param aTokenDecimals The decimals of the underlying\n   * @param aTokenName The name of the aToken\n   * @param aTokenSymbol The symbol of the aToken\n   * @param params A set of encoded parameters for additional initialization\n   */\n  event Initialized(\n    address indexed underlyingAsset,\n    address indexed pool,\n    address treasury,\n    address incentivesController,\n    uint8 aTokenDecimals,\n    string aTokenName,\n    string aTokenSymbol,\n    bytes params\n  );\n\n  /**\n   * @notice Initializes the aToken\n   * @param pool The pool contract that is initializing this contract\n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @param incentivesController The smart contract managing potential incentives distribution\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n   * @param aTokenName The name of the aToken\n   * @param aTokenSymbol The symbol of the aToken\n   * @param params A set of encoded parameters for additional initialization\n   */\n  function initialize(\n    IPool pool,\n    address treasury,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 aTokenDecimals,\n    string calldata aTokenName,\n    string calldata aTokenSymbol,\n    bytes calldata params\n  ) external;\n}\n"
    },
    "aave-v3-core/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(\n    address asset\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(\n    address user\n  ) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n}\n"
    },
    "aave-v3-core/contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "aave-v3-core/contracts/interfaces/IPoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {ConfiguratorInputTypes} from '../protocol/libraries/types/ConfiguratorInputTypes.sol';\n\n/**\n * @title IPoolConfigurator\n * @author Aave\n * @notice Defines the basic interface for a Pool configurator.\n */\ninterface IPoolConfigurator {\n  /**\n   * @dev Emitted when a reserve is initialized.\n   * @param asset The address of the underlying asset of the reserve\n   * @param aToken The address of the associated aToken contract\n   * @param stableDebtToken The address of the associated stable rate debt token\n   * @param variableDebtToken The address of the associated variable rate debt token\n   * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve\n   */\n  event ReserveInitialized(\n    address indexed asset,\n    address indexed aToken,\n    address stableDebtToken,\n    address variableDebtToken,\n    address interestRateStrategyAddress\n  );\n\n  /**\n   * @dev Emitted when borrowing is enabled or disabled on a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if borrowing is enabled, false otherwise\n   */\n  event ReserveBorrowing(address indexed asset, bool enabled);\n\n  /**\n   * @dev Emitted when flashloans are enabled or disabled on a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if flashloans are enabled, false otherwise\n   */\n  event ReserveFlashLoaning(address indexed asset, bool enabled);\n\n  /**\n   * @dev Emitted when the collateralization risk parameters for the specified asset are updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param ltv The loan to value of the asset when used as collateral\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset\n   */\n  event CollateralConfigurationChanged(\n    address indexed asset,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus\n  );\n\n  /**\n   * @dev Emitted when stable rate borrowing is enabled or disabled on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if stable rate borrowing is enabled, false otherwise\n   */\n  event ReserveStableRateBorrowing(address indexed asset, bool enabled);\n\n  /**\n   * @dev Emitted when a reserve is activated or deactivated\n   * @param asset The address of the underlying asset of the reserve\n   * @param active True if reserve is active, false otherwise\n   */\n  event ReserveActive(address indexed asset, bool active);\n\n  /**\n   * @dev Emitted when a reserve is frozen or unfrozen\n   * @param asset The address of the underlying asset of the reserve\n   * @param frozen True if reserve is frozen, false otherwise\n   */\n  event ReserveFrozen(address indexed asset, bool frozen);\n\n  /**\n   * @dev Emitted when a reserve is paused or unpaused\n   * @param asset The address of the underlying asset of the reserve\n   * @param paused True if reserve is paused, false otherwise\n   */\n  event ReservePaused(address indexed asset, bool paused);\n\n  /**\n   * @dev Emitted when a reserve is dropped.\n   * @param asset The address of the underlying asset of the reserve\n   */\n  event ReserveDropped(address indexed asset);\n\n  /**\n   * @dev Emitted when a reserve factor is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldReserveFactor The old reserve factor, expressed in bps\n   * @param newReserveFactor The new reserve factor, expressed in bps\n   */\n  event ReserveFactorChanged(\n    address indexed asset,\n    uint256 oldReserveFactor,\n    uint256 newReserveFactor\n  );\n\n  /**\n   * @dev Emitted when the borrow cap of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldBorrowCap The old borrow cap\n   * @param newBorrowCap The new borrow cap\n   */\n  event BorrowCapChanged(address indexed asset, uint256 oldBorrowCap, uint256 newBorrowCap);\n\n  /**\n   * @dev Emitted when the supply cap of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldSupplyCap The old supply cap\n   * @param newSupplyCap The new supply cap\n   */\n  event SupplyCapChanged(address indexed asset, uint256 oldSupplyCap, uint256 newSupplyCap);\n\n  /**\n   * @dev Emitted when the liquidation protocol fee of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldFee The old liquidation protocol fee, expressed in bps\n   * @param newFee The new liquidation protocol fee, expressed in bps\n   */\n  event LiquidationProtocolFeeChanged(address indexed asset, uint256 oldFee, uint256 newFee);\n\n  /**\n   * @dev Emitted when the unbacked mint cap of a reserve is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldUnbackedMintCap The old unbacked mint cap\n   * @param newUnbackedMintCap The new unbacked mint cap\n   */\n  event UnbackedMintCapChanged(\n    address indexed asset,\n    uint256 oldUnbackedMintCap,\n    uint256 newUnbackedMintCap\n  );\n\n  /**\n   * @dev Emitted when the category of an asset in eMode is changed.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldCategoryId The old eMode asset category\n   * @param newCategoryId The new eMode asset category\n   */\n  event EModeAssetCategoryChanged(address indexed asset, uint8 oldCategoryId, uint8 newCategoryId);\n\n  /**\n   * @dev Emitted when a new eMode category is added.\n   * @param categoryId The new eMode category id\n   * @param ltv The ltv for the asset category in eMode\n   * @param liquidationThreshold The liquidationThreshold for the asset category in eMode\n   * @param liquidationBonus The liquidationBonus for the asset category in eMode\n   * @param oracle The optional address of the price oracle specific for this category\n   * @param label A human readable identifier for the category\n   */\n  event EModeCategoryAdded(\n    uint8 indexed categoryId,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus,\n    address oracle,\n    string label\n  );\n\n  /**\n   * @dev Emitted when a reserve interest strategy contract is updated.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldStrategy The address of the old interest strategy contract\n   * @param newStrategy The address of the new interest strategy contract\n   */\n  event ReserveInterestRateStrategyChanged(\n    address indexed asset,\n    address oldStrategy,\n    address newStrategy\n  );\n\n  /**\n   * @dev Emitted when an aToken implementation is upgraded.\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The aToken proxy address\n   * @param implementation The new aToken implementation\n   */\n  event ATokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the implementation of a stable debt token is upgraded.\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The stable debt token proxy address\n   * @param implementation The new aToken implementation\n   */\n  event StableDebtTokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the implementation of a variable debt token is upgraded.\n   * @param asset The address of the underlying asset of the reserve\n   * @param proxy The variable debt token proxy address\n   * @param implementation The new aToken implementation\n   */\n  event VariableDebtTokenUpgraded(\n    address indexed asset,\n    address indexed proxy,\n    address indexed implementation\n  );\n\n  /**\n   * @dev Emitted when the debt ceiling of an asset is set.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldDebtCeiling The old debt ceiling\n   * @param newDebtCeiling The new debt ceiling\n   */\n  event DebtCeilingChanged(address indexed asset, uint256 oldDebtCeiling, uint256 newDebtCeiling);\n\n  /**\n   * @dev Emitted when the the siloed borrowing state for an asset is changed.\n   * @param asset The address of the underlying asset of the reserve\n   * @param oldState The old siloed borrowing state\n   * @param newState The new siloed borrowing state\n   */\n  event SiloedBorrowingChanged(address indexed asset, bool oldState, bool newState);\n\n  /**\n   * @dev Emitted when the bridge protocol fee is updated.\n   * @param oldBridgeProtocolFee The old protocol fee, expressed in bps\n   * @param newBridgeProtocolFee The new protocol fee, expressed in bps\n   */\n  event BridgeProtocolFeeUpdated(uint256 oldBridgeProtocolFee, uint256 newBridgeProtocolFee);\n\n  /**\n   * @dev Emitted when the total premium on flashloans is updated.\n   * @param oldFlashloanPremiumTotal The old premium, expressed in bps\n   * @param newFlashloanPremiumTotal The new premium, expressed in bps\n   */\n  event FlashloanPremiumTotalUpdated(\n    uint128 oldFlashloanPremiumTotal,\n    uint128 newFlashloanPremiumTotal\n  );\n\n  /**\n   * @dev Emitted when the part of the premium that goes to protocol is updated.\n   * @param oldFlashloanPremiumToProtocol The old premium, expressed in bps\n   * @param newFlashloanPremiumToProtocol The new premium, expressed in bps\n   */\n  event FlashloanPremiumToProtocolUpdated(\n    uint128 oldFlashloanPremiumToProtocol,\n    uint128 newFlashloanPremiumToProtocol\n  );\n\n  /**\n   * @dev Emitted when the reserve is set as borrowable/non borrowable in isolation mode.\n   * @param asset The address of the underlying asset of the reserve\n   * @param borrowable True if the reserve is borrowable in isolation, false otherwise\n   */\n  event BorrowableInIsolationChanged(address asset, bool borrowable);\n\n  /**\n   * @notice Initializes multiple reserves.\n   * @param input The array of initialization parameters\n   */\n  function initReserves(ConfiguratorInputTypes.InitReserveInput[] calldata input) external;\n\n  /**\n   * @dev Updates the aToken implementation for the reserve.\n   * @param input The aToken update parameters\n   */\n  function updateAToken(ConfiguratorInputTypes.UpdateATokenInput calldata input) external;\n\n  /**\n   * @notice Updates the stable debt token implementation for the reserve.\n   * @param input The stableDebtToken update parameters\n   */\n  function updateStableDebtToken(\n    ConfiguratorInputTypes.UpdateDebtTokenInput calldata input\n  ) external;\n\n  /**\n   * @notice Updates the variable debt token implementation for the asset.\n   * @param input The variableDebtToken update parameters\n   */\n  function updateVariableDebtToken(\n    ConfiguratorInputTypes.UpdateDebtTokenInput calldata input\n  ) external;\n\n  /**\n   * @notice Configures borrowing on a reserve.\n   * @dev Can only be disabled (set to false) if stable borrowing is disabled\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if borrowing needs to be enabled, false otherwise\n   */\n  function setReserveBorrowing(address asset, bool enabled) external;\n\n  /**\n   * @notice Configures the reserve collateralization parameters.\n   * @dev All the values are expressed in bps. A value of 10000, results in 100.00%\n   * @dev The `liquidationBonus` is always above 100%. A value of 105% means the liquidator will receive a 5% bonus\n   * @param asset The address of the underlying asset of the reserve\n   * @param ltv The loan to value of the asset when used as collateral\n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset\n   */\n  function configureReserveAsCollateral(\n    address asset,\n    uint256 ltv,\n    uint256 liquidationThreshold,\n    uint256 liquidationBonus\n  ) external;\n\n  /**\n   * @notice Enable or disable stable rate borrowing on a reserve.\n   * @dev Can only be enabled (set to true) if borrowing is enabled\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if stable rate borrowing needs to be enabled, false otherwise\n   */\n  function setReserveStableRateBorrowing(address asset, bool enabled) external;\n\n  /**\n   * @notice Enable or disable flashloans on a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param enabled True if flashloans need to be enabled, false otherwise\n   */\n  function setReserveFlashLoaning(address asset, bool enabled) external;\n\n  /**\n   * @notice Activate or deactivate a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param active True if the reserve needs to be active, false otherwise\n   */\n  function setReserveActive(address asset, bool active) external;\n\n  /**\n   * @notice Freeze or unfreeze a reserve. A frozen reserve doesn't allow any new supply, borrow\n   * or rate swap but allows repayments, liquidations, rate rebalances and withdrawals.\n   * @param asset The address of the underlying asset of the reserve\n   * @param freeze True if the reserve needs to be frozen, false otherwise\n   */\n  function setReserveFreeze(address asset, bool freeze) external;\n\n  /**\n   * @notice Sets the borrowable in isolation flag for the reserve.\n   * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the\n   * borrowed amount will be accumulated in the isolated collateral's total debt exposure\n   * @dev Only assets of the same family (e.g. USD stablecoins) should be borrowable in isolation mode to keep\n   * consistency in the debt ceiling calculations\n   * @param asset The address of the underlying asset of the reserve\n   * @param borrowable True if the asset should be borrowable in isolation, false otherwise\n   */\n  function setBorrowableInIsolation(address asset, bool borrowable) external;\n\n  /**\n   * @notice Pauses a reserve. A paused reserve does not allow any interaction (supply, borrow, repay,\n   * swap interest rate, liquidate, atoken transfers).\n   * @param asset The address of the underlying asset of the reserve\n   * @param paused True if pausing the reserve, false if unpausing\n   */\n  function setReservePause(address asset, bool paused) external;\n\n  /**\n   * @notice Updates the reserve factor of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newReserveFactor The new reserve factor of the reserve\n   */\n  function setReserveFactor(address asset, uint256 newReserveFactor) external;\n\n  /**\n   * @notice Sets the interest rate strategy of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newRateStrategyAddress The address of the new interest strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address newRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Pauses or unpauses all the protocol reserves. In the paused state all the protocol interactions\n   * are suspended.\n   * @param paused True if protocol needs to be paused, false otherwise\n   */\n  function setPoolPause(bool paused) external;\n\n  /**\n   * @notice Updates the borrow cap of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newBorrowCap The new borrow cap of the reserve\n   */\n  function setBorrowCap(address asset, uint256 newBorrowCap) external;\n\n  /**\n   * @notice Updates the supply cap of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newSupplyCap The new supply cap of the reserve\n   */\n  function setSupplyCap(address asset, uint256 newSupplyCap) external;\n\n  /**\n   * @notice Updates the liquidation protocol fee of reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newFee The new liquidation protocol fee of the reserve, expressed in bps\n   */\n  function setLiquidationProtocolFee(address asset, uint256 newFee) external;\n\n  /**\n   * @notice Updates the unbacked mint cap of reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newUnbackedMintCap The new unbacked mint cap of the reserve\n   */\n  function setUnbackedMintCap(address asset, uint256 newUnbackedMintCap) external;\n\n  /**\n   * @notice Assign an efficiency mode (eMode) category to asset.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newCategoryId The new category id of the asset\n   */\n  function setAssetEModeCategory(address asset, uint8 newCategoryId) external;\n\n  /**\n   * @notice Adds a new efficiency mode (eMode) category.\n   * @dev If zero is provided as oracle address, the default asset oracles will be used to compute the overall debt and\n   * overcollateralization of the users using this category.\n   * @dev The new ltv and liquidation threshold must be greater than the base\n   * ltvs and liquidation thresholds of all assets within the eMode category\n   * @param categoryId The id of the category to be configured\n   * @param ltv The ltv associated with the category\n   * @param liquidationThreshold The liquidation threshold associated with the category\n   * @param liquidationBonus The liquidation bonus associated with the category\n   * @param oracle The oracle associated with the category\n   * @param label A label identifying the category\n   */\n  function setEModeCategory(\n    uint8 categoryId,\n    uint16 ltv,\n    uint16 liquidationThreshold,\n    uint16 liquidationBonus,\n    address oracle,\n    string calldata label\n  ) external;\n\n  /**\n   * @notice Drops a reserve entirely.\n   * @param asset The address of the reserve to drop\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the bridge fee collected by the protocol reserves.\n   * @param newBridgeProtocolFee The part of the fee sent to the protocol treasury, expressed in bps\n   */\n  function updateBridgeProtocolFee(uint256 newBridgeProtocolFee) external;\n\n  /**\n   * @notice Updates the total flash loan premium.\n   * Total flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra balance\n   * - A part is collected by the protocol reserves\n   * @dev Expressed in bps\n   * @dev The premium is calculated on the total amount borrowed\n   * @param newFlashloanPremiumTotal The total flashloan premium\n   */\n  function updateFlashloanPremiumTotal(uint128 newFlashloanPremiumTotal) external;\n\n  /**\n   * @notice Updates the flash loan premium collected by protocol reserves\n   * @dev Expressed in bps\n   * @dev The premium to protocol is calculated on the total flashloan premium\n   * @param newFlashloanPremiumToProtocol The part of the flashloan premium sent to the protocol treasury\n   */\n  function updateFlashloanPremiumToProtocol(uint128 newFlashloanPremiumToProtocol) external;\n\n  /**\n   * @notice Sets the debt ceiling for an asset.\n   * @param newDebtCeiling The new debt ceiling\n   */\n  function setDebtCeiling(address asset, uint256 newDebtCeiling) external;\n\n  /**\n   * @notice Sets siloed borrowing for an asset\n   * @param siloed The new siloed borrowing state\n   */\n  function setSiloedBorrowing(address asset, bool siloed) external;\n}\n"
    },
    "aave-v3-core/contracts/interfaces/IPoolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\n\n/**\n * @title IPoolDataProvider\n * @author Aave\n * @notice Defines the basic interface of a PoolDataProvider\n */\ninterface IPoolDataProvider {\n  struct TokenData {\n    string symbol;\n    address tokenAddress;\n  }\n\n  /**\n   * @notice Returns the address for the PoolAddressesProvider contract.\n   * @return The address for the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the list of the existing reserves in the pool.\n   * @dev Handling MKR and ETH in a different way since they do not have standard `symbol` functions.\n   * @return The list of reserves, pairs of symbols and addresses\n   */\n  function getAllReservesTokens() external view returns (TokenData[] memory);\n\n  /**\n   * @notice Returns the list of the existing ATokens in the pool.\n   * @return The list of ATokens, pairs of symbols and addresses\n   */\n  function getAllATokens() external view returns (TokenData[] memory);\n\n  /**\n   * @notice Returns the configuration data of the reserve\n   * @dev Not returning borrow and supply caps for compatibility, nor pause flag\n   * @param asset The address of the underlying asset of the reserve\n   * @return decimals The number of decimals of the reserve\n   * @return ltv The ltv of the reserve\n   * @return liquidationThreshold The liquidationThreshold of the reserve\n   * @return liquidationBonus The liquidationBonus of the reserve\n   * @return reserveFactor The reserveFactor of the reserve\n   * @return usageAsCollateralEnabled True if the usage as collateral is enabled, false otherwise\n   * @return borrowingEnabled True if borrowing is enabled, false otherwise\n   * @return stableBorrowRateEnabled True if stable rate borrowing is enabled, false otherwise\n   * @return isActive True if it is active, false otherwise\n   * @return isFrozen True if it is frozen, false otherwise\n   */\n  function getReserveConfigurationData(\n    address asset\n  )\n    external\n    view\n    returns (\n      uint256 decimals,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus,\n      uint256 reserveFactor,\n      bool usageAsCollateralEnabled,\n      bool borrowingEnabled,\n      bool stableBorrowRateEnabled,\n      bool isActive,\n      bool isFrozen\n    );\n\n  /**\n   * @notice Returns the efficiency mode category of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The eMode id of the reserve\n   */\n  function getReserveEModeCategory(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the caps parameters of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return borrowCap The borrow cap of the reserve\n   * @return supplyCap The supply cap of the reserve\n   */\n  function getReserveCaps(\n    address asset\n  ) external view returns (uint256 borrowCap, uint256 supplyCap);\n\n  /**\n   * @notice Returns if the pool is paused\n   * @param asset The address of the underlying asset of the reserve\n   * @return isPaused True if the pool is paused, false otherwise\n   */\n  function getPaused(address asset) external view returns (bool isPaused);\n\n  /**\n   * @notice Returns the siloed borrowing flag\n   * @param asset The address of the underlying asset of the reserve\n   * @return True if the asset is siloed for borrowing\n   */\n  function getSiloedBorrowing(address asset) external view returns (bool);\n\n  /**\n   * @notice Returns the protocol fee on the liquidation bonus\n   * @param asset The address of the underlying asset of the reserve\n   * @return The protocol fee on liquidation\n   */\n  function getLiquidationProtocolFee(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the unbacked mint cap of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The unbacked mint cap of the reserve\n   */\n  function getUnbackedMintCap(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the debt ceiling of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The debt ceiling of the reserve\n   */\n  function getDebtCeiling(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the debt ceiling decimals\n   * @return The debt ceiling decimals\n   */\n  function getDebtCeilingDecimals() external pure returns (uint256);\n\n  /**\n   * @notice Returns the reserve data\n   * @param asset The address of the underlying asset of the reserve\n   * @return unbacked The amount of unbacked tokens\n   * @return accruedToTreasuryScaled The scaled amount of tokens accrued to treasury that is to be minted\n   * @return totalAToken The total supply of the aToken\n   * @return totalStableDebt The total stable debt of the reserve\n   * @return totalVariableDebt The total variable debt of the reserve\n   * @return liquidityRate The liquidity rate of the reserve\n   * @return variableBorrowRate The variable borrow rate of the reserve\n   * @return stableBorrowRate The stable borrow rate of the reserve\n   * @return averageStableBorrowRate The average stable borrow rate of the reserve\n   * @return liquidityIndex The liquidity index of the reserve\n   * @return variableBorrowIndex The variable borrow index of the reserve\n   * @return lastUpdateTimestamp The timestamp of the last update of the reserve\n   */\n  function getReserveData(\n    address asset\n  )\n    external\n    view\n    returns (\n      uint256 unbacked,\n      uint256 accruedToTreasuryScaled,\n      uint256 totalAToken,\n      uint256 totalStableDebt,\n      uint256 totalVariableDebt,\n      uint256 liquidityRate,\n      uint256 variableBorrowRate,\n      uint256 stableBorrowRate,\n      uint256 averageStableBorrowRate,\n      uint256 liquidityIndex,\n      uint256 variableBorrowIndex,\n      uint40 lastUpdateTimestamp\n    );\n\n  /**\n   * @notice Returns the total supply of aTokens for a given asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The total supply of the aToken\n   */\n  function getATokenTotalSupply(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the total debt for a given asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The total debt for asset\n   */\n  function getTotalDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the user data in a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param user The address of the user\n   * @return currentATokenBalance The current AToken balance of the user\n   * @return currentStableDebt The current stable debt of the user\n   * @return currentVariableDebt The current variable debt of the user\n   * @return principalStableDebt The principal stable debt of the user\n   * @return scaledVariableDebt The scaled variable debt of the user\n   * @return stableBorrowRate The stable borrow rate of the user\n   * @return liquidityRate The liquidity rate of the reserve\n   * @return stableRateLastUpdated The timestamp of the last update of the user stable rate\n   * @return usageAsCollateralEnabled True if the user is using the asset as collateral, false\n   *         otherwise\n   */\n  function getUserReserveData(\n    address asset,\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 currentATokenBalance,\n      uint256 currentStableDebt,\n      uint256 currentVariableDebt,\n      uint256 principalStableDebt,\n      uint256 scaledVariableDebt,\n      uint256 stableBorrowRate,\n      uint256 liquidityRate,\n      uint40 stableRateLastUpdated,\n      bool usageAsCollateralEnabled\n    );\n\n  /**\n   * @notice Returns the token addresses of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return aTokenAddress The AToken address of the reserve\n   * @return stableDebtTokenAddress The StableDebtToken address of the reserve\n   * @return variableDebtTokenAddress The VariableDebtToken address of the reserve\n   */\n  function getReserveTokensAddresses(\n    address asset\n  )\n    external\n    view\n    returns (\n      address aTokenAddress,\n      address stableDebtTokenAddress,\n      address variableDebtTokenAddress\n    );\n\n  /**\n   * @notice Returns the address of the Interest Rate strategy\n   * @param asset The address of the underlying asset of the reserve\n   * @return irStrategyAddress The address of the Interest Rate strategy\n   */\n  function getInterestRateStrategyAddress(\n    address asset\n  ) external view returns (address irStrategyAddress);\n\n  /**\n   * @notice Returns whether the reserve has FlashLoans enabled or disabled\n   * @param asset The address of the underlying asset of the reserve\n   * @return True if FlashLoans are enabled, false otherwise\n   */\n  function getFlashLoanEnabled(address asset) external view returns (bool);\n}\n"
    },
    "aave-v3-core/contracts/interfaces/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPriceOracleGetter\n * @author Aave\n * @notice Interface for the Aave price oracle.\n */\ninterface IPriceOracleGetter {\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   */\n  function BASE_CURRENCY() external view returns (address);\n\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   */\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   */\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "aave-v3-core/contracts/interfaces/IReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IReserveInterestRateStrategy\n * @author Aave\n * @notice Interface for the calculation of the interest rates\n */\ninterface IReserveInterestRateStrategy {\n  /**\n   * @notice Calculates the interest rates depending on the reserve's state and configurations\n   * @param params The parameters needed to calculate interest rates\n   * @return liquidityRate The liquidity rate expressed in rays\n   * @return stableBorrowRate The stable borrow rate expressed in rays\n   * @return variableBorrowRate The variable borrow rate expressed in rays\n   */\n  function calculateInterestRates(\n    DataTypes.CalculateInterestRatesParams memory params\n  ) external view returns (uint256, uint256, uint256);\n}\n"
    },
    "aave-v3-core/contracts/interfaces/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IScaledBalanceToken\n * @author Aave\n * @notice Defines the basic interface for a scaled-balance token.\n */\ninterface IScaledBalanceToken {\n  /**\n   * @dev Emitted after the mint action\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted tokens\n   * @param value The scaled-up amount being minted (based on user entered amount and balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'onBehalfOf'\n   * @param index The next liquidity index of the reserve\n   */\n  event Mint(\n    address indexed caller,\n    address indexed onBehalfOf,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @dev Emitted after the burn action\n   * @dev If the burn function does not involve a transfer of the underlying asset, the target defaults to zero address\n   * @param from The address from which the tokens will be burned\n   * @param target The address that will receive the underlying, if any\n   * @param value The scaled-up amount being burned (user entered amount - balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'from'\n   * @param index The next liquidity index of the reserve\n   */\n  event Burn(\n    address indexed from,\n    address indexed target,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @notice Returns the scaled balance of the user.\n   * @dev The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index\n   * at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   */\n  function scaledBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @notice Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled total supply\n   */\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n  /**\n   * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)\n   * @return The scaled total supply\n   */\n  function scaledTotalSupply() external view returns (uint256);\n\n  /**\n   * @notice Returns last index interest was accrued to the user's balance\n   * @param user The address of the user\n   * @return The last index interest was accrued to the user's balance, expressed in ray\n   */\n  function getPreviousIndex(address user) external view returns (uint256);\n}\n"
    },
    "aave-v3-core/contracts/protocol/libraries/configuration/ReserveConfiguration.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Errors} from '../helpers/Errors.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n  uint256 internal constant LTV_MASK =                       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n  uint256 internal constant LIQUIDATION_THRESHOLD_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n  uint256 internal constant LIQUIDATION_BONUS_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n  uint256 internal constant DECIMALS_MASK =                  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant ACTIVE_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant FROZEN_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROWING_MASK =                 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant STABLE_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant PAUSED_MASK =                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant SILOED_BORROWING_MASK =          0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant FLASHLOAN_ENABLED_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant RESERVE_FACTOR_MASK =            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant BORROW_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant SUPPLY_CAP_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant LIQUIDATION_PROTOCOL_FEE_MASK =  0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant EMODE_CATEGORY_MASK =            0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant UNBACKED_MINT_CAP_MASK =         0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant DEBT_CEILING_MASK =              0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n  uint256 internal constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n  uint256 internal constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n  uint256 internal constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n  uint256 internal constant IS_ACTIVE_START_BIT_POSITION = 56;\n  uint256 internal constant IS_FROZEN_START_BIT_POSITION = 57;\n  uint256 internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n  uint256 internal constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n  uint256 internal constant IS_PAUSED_START_BIT_POSITION = 60;\n  uint256 internal constant BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61;\n  uint256 internal constant SILOED_BORROWING_START_BIT_POSITION = 62;\n  uint256 internal constant FLASHLOAN_ENABLED_START_BIT_POSITION = 63;\n  uint256 internal constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n  uint256 internal constant BORROW_CAP_START_BIT_POSITION = 80;\n  uint256 internal constant SUPPLY_CAP_START_BIT_POSITION = 116;\n  uint256 internal constant LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152;\n  uint256 internal constant EMODE_CATEGORY_START_BIT_POSITION = 168;\n  uint256 internal constant UNBACKED_MINT_CAP_START_BIT_POSITION = 176;\n  uint256 internal constant DEBT_CEILING_START_BIT_POSITION = 212;\n\n  uint256 internal constant MAX_VALID_LTV = 65535;\n  uint256 internal constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\n  uint256 internal constant MAX_VALID_LIQUIDATION_BONUS = 65535;\n  uint256 internal constant MAX_VALID_DECIMALS = 255;\n  uint256 internal constant MAX_VALID_RESERVE_FACTOR = 65535;\n  uint256 internal constant MAX_VALID_BORROW_CAP = 68719476735;\n  uint256 internal constant MAX_VALID_SUPPLY_CAP = 68719476735;\n  uint256 internal constant MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535;\n  uint256 internal constant MAX_VALID_EMODE_CATEGORY = 255;\n  uint256 internal constant MAX_VALID_UNBACKED_MINT_CAP = 68719476735;\n  uint256 internal constant MAX_VALID_DEBT_CEILING = 1099511627775;\n\n  uint256 public constant DEBT_CEILING_DECIMALS = 2;\n  uint16 public constant MAX_RESERVES_COUNT = 128;\n\n  /**\n   * @notice Sets the Loan to Value of the reserve\n   * @param self The reserve configuration\n   * @param ltv The new ltv\n   */\n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\n    require(ltv <= MAX_VALID_LTV, Errors.INVALID_LTV);\n\n    self.data = (self.data & LTV_MASK) | ltv;\n  }\n\n  /**\n   * @notice Gets the Loan to Value of the reserve\n   * @param self The reserve configuration\n   * @return The loan to value\n   */\n  function getLtv(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n    return self.data & ~LTV_MASK;\n  }\n\n  /**\n   * @notice Sets the liquidation threshold of the reserve\n   * @param self The reserve configuration\n   * @param threshold The new liquidation threshold\n   */\n  function setLiquidationThreshold(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 threshold\n  ) internal pure {\n    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.INVALID_LIQ_THRESHOLD);\n\n    self.data =\n      (self.data & LIQUIDATION_THRESHOLD_MASK) |\n      (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the liquidation threshold of the reserve\n   * @param self The reserve configuration\n   * @return The liquidation threshold\n   */\n  function getLiquidationThreshold(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the liquidation bonus of the reserve\n   * @param self The reserve configuration\n   * @param bonus The new liquidation bonus\n   */\n  function setLiquidationBonus(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 bonus\n  ) internal pure {\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.INVALID_LIQ_BONUS);\n\n    self.data =\n      (self.data & LIQUIDATION_BONUS_MASK) |\n      (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the liquidation bonus of the reserve\n   * @param self The reserve configuration\n   * @return The liquidation bonus\n   */\n  function getLiquidationBonus(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the decimals of the underlying asset of the reserve\n   * @param self The reserve configuration\n   * @param decimals The decimals\n   */\n  function setDecimals(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 decimals\n  ) internal pure {\n    require(decimals <= MAX_VALID_DECIMALS, Errors.INVALID_DECIMALS);\n\n    self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the decimals of the underlying asset of the reserve\n   * @param self The reserve configuration\n   * @return The decimals of the asset\n   */\n  function getDecimals(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the active state of the reserve\n   * @param self The reserve configuration\n   * @param active The active state\n   */\n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\n    self.data =\n      (self.data & ACTIVE_MASK) |\n      (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the active state of the reserve\n   * @param self The reserve configuration\n   * @return The active state\n   */\n  function getActive(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n    return (self.data & ~ACTIVE_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the frozen state of the reserve\n   * @param self The reserve configuration\n   * @param frozen The frozen state\n   */\n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\n    self.data =\n      (self.data & FROZEN_MASK) |\n      (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the frozen state of the reserve\n   * @param self The reserve configuration\n   * @return The frozen state\n   */\n  function getFrozen(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n    return (self.data & ~FROZEN_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the paused state of the reserve\n   * @param self The reserve configuration\n   * @param paused The paused state\n   */\n  function setPaused(DataTypes.ReserveConfigurationMap memory self, bool paused) internal pure {\n    self.data =\n      (self.data & PAUSED_MASK) |\n      (uint256(paused ? 1 : 0) << IS_PAUSED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the paused state of the reserve\n   * @param self The reserve configuration\n   * @return The paused state\n   */\n  function getPaused(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n    return (self.data & ~PAUSED_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the borrowable in isolation flag for the reserve.\n   * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the borrowed\n   * amount will be accumulated in the isolated collateral's total debt exposure.\n   * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n   * consistency in the debt ceiling calculations.\n   * @param self The reserve configuration\n   * @param borrowable True if the asset is borrowable\n   */\n  function setBorrowableInIsolation(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool borrowable\n  ) internal pure {\n    self.data =\n      (self.data & BORROWABLE_IN_ISOLATION_MASK) |\n      (uint256(borrowable ? 1 : 0) << BORROWABLE_IN_ISOLATION_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrowable in isolation flag for the reserve.\n   * @dev If the returned flag is true, the asset is borrowable against isolated collateral. Assets borrowed with\n   * isolated collateral is accounted for in the isolated collateral's total debt exposure.\n   * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n   * consistency in the debt ceiling calculations.\n   * @param self The reserve configuration\n   * @return The borrowable in isolation flag\n   */\n  function getBorrowableInIsolation(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~BORROWABLE_IN_ISOLATION_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the siloed borrowing flag for the reserve.\n   * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n   * @param self The reserve configuration\n   * @param siloed True if the asset is siloed\n   */\n  function setSiloedBorrowing(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool siloed\n  ) internal pure {\n    self.data =\n      (self.data & SILOED_BORROWING_MASK) |\n      (uint256(siloed ? 1 : 0) << SILOED_BORROWING_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the siloed borrowing flag for the reserve.\n   * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n   * @param self The reserve configuration\n   * @return The siloed borrowing flag\n   */\n  function getSiloedBorrowing(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~SILOED_BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Enables or disables borrowing on the reserve\n   * @param self The reserve configuration\n   * @param enabled True if the borrowing needs to be enabled, false otherwise\n   */\n  function setBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool enabled\n  ) internal pure {\n    self.data =\n      (self.data & BORROWING_MASK) |\n      (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrowing state of the reserve\n   * @param self The reserve configuration\n   * @return The borrowing state\n   */\n  function getBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Enables or disables stable rate borrowing on the reserve\n   * @param self The reserve configuration\n   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\n   */\n  function setStableRateBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool enabled\n  ) internal pure {\n    self.data =\n      (self.data & STABLE_BORROWING_MASK) |\n      (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the stable rate borrowing state of the reserve\n   * @param self The reserve configuration\n   * @return The stable rate borrowing state\n   */\n  function getStableRateBorrowingEnabled(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~STABLE_BORROWING_MASK) != 0;\n  }\n\n  /**\n   * @notice Sets the reserve factor of the reserve\n   * @param self The reserve configuration\n   * @param reserveFactor The reserve factor\n   */\n  function setReserveFactor(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 reserveFactor\n  ) internal pure {\n    require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.INVALID_RESERVE_FACTOR);\n\n    self.data =\n      (self.data & RESERVE_FACTOR_MASK) |\n      (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the reserve factor of the reserve\n   * @param self The reserve configuration\n   * @return The reserve factor\n   */\n  function getReserveFactor(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the borrow cap of the reserve\n   * @param self The reserve configuration\n   * @param borrowCap The borrow cap\n   */\n  function setBorrowCap(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 borrowCap\n  ) internal pure {\n    require(borrowCap <= MAX_VALID_BORROW_CAP, Errors.INVALID_BORROW_CAP);\n\n    self.data = (self.data & BORROW_CAP_MASK) | (borrowCap << BORROW_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the borrow cap of the reserve\n   * @param self The reserve configuration\n   * @return The borrow cap\n   */\n  function getBorrowCap(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the supply cap of the reserve\n   * @param self The reserve configuration\n   * @param supplyCap The supply cap\n   */\n  function setSupplyCap(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 supplyCap\n  ) internal pure {\n    require(supplyCap <= MAX_VALID_SUPPLY_CAP, Errors.INVALID_SUPPLY_CAP);\n\n    self.data = (self.data & SUPPLY_CAP_MASK) | (supplyCap << SUPPLY_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the supply cap of the reserve\n   * @param self The reserve configuration\n   * @return The supply cap\n   */\n  function getSupplyCap(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the debt ceiling in isolation mode for the asset\n   * @param self The reserve configuration\n   * @param ceiling The maximum debt ceiling for the asset\n   */\n  function setDebtCeiling(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 ceiling\n  ) internal pure {\n    require(ceiling <= MAX_VALID_DEBT_CEILING, Errors.INVALID_DEBT_CEILING);\n\n    self.data = (self.data & DEBT_CEILING_MASK) | (ceiling << DEBT_CEILING_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the debt ceiling for the asset if the asset is in isolation mode\n   * @param self The reserve configuration\n   * @return The debt ceiling (0 = isolation mode disabled)\n   */\n  function getDebtCeiling(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~DEBT_CEILING_MASK) >> DEBT_CEILING_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the liquidation protocol fee of the reserve\n   * @param self The reserve configuration\n   * @param liquidationProtocolFee The liquidation protocol fee\n   */\n  function setLiquidationProtocolFee(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 liquidationProtocolFee\n  ) internal pure {\n    require(\n      liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE,\n      Errors.INVALID_LIQUIDATION_PROTOCOL_FEE\n    );\n\n    self.data =\n      (self.data & LIQUIDATION_PROTOCOL_FEE_MASK) |\n      (liquidationProtocolFee << LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the liquidation protocol fee\n   * @param self The reserve configuration\n   * @return The liquidation protocol fee\n   */\n  function getLiquidationProtocolFee(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return\n      (self.data & ~LIQUIDATION_PROTOCOL_FEE_MASK) >> LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the unbacked mint cap of the reserve\n   * @param self The reserve configuration\n   * @param unbackedMintCap The unbacked mint cap\n   */\n  function setUnbackedMintCap(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 unbackedMintCap\n  ) internal pure {\n    require(unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP, Errors.INVALID_UNBACKED_MINT_CAP);\n\n    self.data =\n      (self.data & UNBACKED_MINT_CAP_MASK) |\n      (unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the unbacked mint cap of the reserve\n   * @param self The reserve configuration\n   * @return The unbacked mint cap\n   */\n  function getUnbackedMintCap(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~UNBACKED_MINT_CAP_MASK) >> UNBACKED_MINT_CAP_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the eMode asset category\n   * @param self The reserve configuration\n   * @param category The asset category when the user selects the eMode\n   */\n  function setEModeCategory(\n    DataTypes.ReserveConfigurationMap memory self,\n    uint256 category\n  ) internal pure {\n    require(category <= MAX_VALID_EMODE_CATEGORY, Errors.INVALID_EMODE_CATEGORY);\n\n    self.data = (self.data & EMODE_CATEGORY_MASK) | (category << EMODE_CATEGORY_START_BIT_POSITION);\n  }\n\n  /**\n   * @dev Gets the eMode asset category\n   * @param self The reserve configuration\n   * @return The eMode category for the asset\n   */\n  function getEModeCategory(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256) {\n    return (self.data & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION;\n  }\n\n  /**\n   * @notice Sets the flashloanable flag for the reserve\n   * @param self The reserve configuration\n   * @param flashLoanEnabled True if the asset is flashloanable, false otherwise\n   */\n  function setFlashLoanEnabled(\n    DataTypes.ReserveConfigurationMap memory self,\n    bool flashLoanEnabled\n  ) internal pure {\n    self.data =\n      (self.data & FLASHLOAN_ENABLED_MASK) |\n      (uint256(flashLoanEnabled ? 1 : 0) << FLASHLOAN_ENABLED_START_BIT_POSITION);\n  }\n\n  /**\n   * @notice Gets the flashloanable flag for the reserve\n   * @param self The reserve configuration\n   * @return The flashloanable flag\n   */\n  function getFlashLoanEnabled(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool) {\n    return (self.data & ~FLASHLOAN_ENABLED_MASK) != 0;\n  }\n\n  /**\n   * @notice Gets the configuration flags of the reserve\n   * @param self The reserve configuration\n   * @return The state flag representing active\n   * @return The state flag representing frozen\n   * @return The state flag representing borrowing enabled\n   * @return The state flag representing stableRateBorrowing enabled\n   * @return The state flag representing paused\n   */\n  function getFlags(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (bool, bool, bool, bool, bool) {\n    uint256 dataLocal = self.data;\n\n    return (\n      (dataLocal & ~ACTIVE_MASK) != 0,\n      (dataLocal & ~FROZEN_MASK) != 0,\n      (dataLocal & ~BORROWING_MASK) != 0,\n      (dataLocal & ~STABLE_BORROWING_MASK) != 0,\n      (dataLocal & ~PAUSED_MASK) != 0\n    );\n  }\n\n  /**\n   * @notice Gets the configuration parameters of the reserve from storage\n   * @param self The reserve configuration\n   * @return The state param representing ltv\n   * @return The state param representing liquidation threshold\n   * @return The state param representing liquidation bonus\n   * @return The state param representing reserve decimals\n   * @return The state param representing reserve factor\n   * @return The state param representing eMode category\n   */\n  function getParams(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n    uint256 dataLocal = self.data;\n\n    return (\n      dataLocal & ~LTV_MASK,\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION,\n      (dataLocal & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION\n    );\n  }\n\n  /**\n   * @notice Gets the caps parameters of the reserve from storage\n   * @param self The reserve configuration\n   * @return The state param representing borrow cap\n   * @return The state param representing supply cap.\n   */\n  function getCaps(\n    DataTypes.ReserveConfigurationMap memory self\n  ) internal pure returns (uint256, uint256) {\n    uint256 dataLocal = self.data;\n\n    return (\n      (dataLocal & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION,\n      (dataLocal & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION\n    );\n  }\n}\n"
    },
    "aave-v3-core/contracts/protocol/libraries/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Errors library\n * @author Aave\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n */\nlibrary Errors {\n  string public constant CALLER_NOT_POOL_ADMIN = '1'; // 'The caller of the function is not a pool admin'\n  string public constant CALLER_NOT_EMERGENCY_ADMIN = '2'; // 'The caller of the function is not an emergency admin'\n  string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = '3'; // 'The caller of the function is not a pool or emergency admin'\n  string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = '4'; // 'The caller of the function is not a risk or pool admin'\n  string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = '5'; // 'The caller of the function is not an asset listing or pool admin'\n  string public constant CALLER_NOT_BRIDGE = '6'; // 'The caller of the function is not a bridge'\n  string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = '7'; // 'Pool addresses provider is not registered'\n  string public constant INVALID_ADDRESSES_PROVIDER_ID = '8'; // 'Invalid id for the pool addresses provider'\n  string public constant NOT_CONTRACT = '9'; // 'Address is not a contract'\n  string public constant CALLER_NOT_POOL_CONFIGURATOR = '10'; // 'The caller of the function is not the pool configurator'\n  string public constant CALLER_NOT_ATOKEN = '11'; // 'The caller of the function is not an AToken'\n  string public constant INVALID_ADDRESSES_PROVIDER = '12'; // 'The address of the pool addresses provider is invalid'\n  string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = '13'; // 'Invalid return value of the flashloan executor function'\n  string public constant RESERVE_ALREADY_ADDED = '14'; // 'Reserve has already been added to reserve list'\n  string public constant NO_MORE_RESERVES_ALLOWED = '15'; // 'Maximum amount of reserves in the pool reached'\n  string public constant EMODE_CATEGORY_RESERVED = '16'; // 'Zero eMode category is reserved for volatile heterogeneous assets'\n  string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = '17'; // 'Invalid eMode category assignment to asset'\n  string public constant RESERVE_LIQUIDITY_NOT_ZERO = '18'; // 'The liquidity of the reserve needs to be 0'\n  string public constant FLASHLOAN_PREMIUM_INVALID = '19'; // 'Invalid flashloan premium'\n  string public constant INVALID_RESERVE_PARAMS = '20'; // 'Invalid risk parameters for the reserve'\n  string public constant INVALID_EMODE_CATEGORY_PARAMS = '21'; // 'Invalid risk parameters for the eMode category'\n  string public constant BRIDGE_PROTOCOL_FEE_INVALID = '22'; // 'Invalid bridge protocol fee'\n  string public constant CALLER_MUST_BE_POOL = '23'; // 'The caller of this function must be a pool'\n  string public constant INVALID_MINT_AMOUNT = '24'; // 'Invalid amount to mint'\n  string public constant INVALID_BURN_AMOUNT = '25'; // 'Invalid amount to burn'\n  string public constant INVALID_AMOUNT = '26'; // 'Amount must be greater than 0'\n  string public constant RESERVE_INACTIVE = '27'; // 'Action requires an active reserve'\n  string public constant RESERVE_FROZEN = '28'; // 'Action cannot be performed because the reserve is frozen'\n  string public constant RESERVE_PAUSED = '29'; // 'Action cannot be performed because the reserve is paused'\n  string public constant BORROWING_NOT_ENABLED = '30'; // 'Borrowing is not enabled'\n  string public constant STABLE_BORROWING_NOT_ENABLED = '31'; // 'Stable borrowing is not enabled'\n  string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = '32'; // 'User cannot withdraw more than the available balance'\n  string public constant INVALID_INTEREST_RATE_MODE_SELECTED = '33'; // 'Invalid interest rate mode selected'\n  string public constant COLLATERAL_BALANCE_IS_ZERO = '34'; // 'The collateral balance is 0'\n  string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '35'; // 'Health factor is lesser than the liquidation threshold'\n  string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = '36'; // 'There is not enough collateral to cover a new borrow'\n  string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = '37'; // 'Collateral is (mostly) the same currency that is being borrowed'\n  string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '38'; // 'The requested amount is greater than the max loan size in stable rate mode'\n  string public constant NO_DEBT_OF_SELECTED_TYPE = '39'; // 'For repayment of a specific type of debt, the user needs to have debt that type'\n  string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '40'; // 'To repay on behalf of a user an explicit amount to repay is needed'\n  string public constant NO_OUTSTANDING_STABLE_DEBT = '41'; // 'User does not have outstanding stable rate debt on this reserve'\n  string public constant NO_OUTSTANDING_VARIABLE_DEBT = '42'; // 'User does not have outstanding variable rate debt on this reserve'\n  string public constant UNDERLYING_BALANCE_ZERO = '43'; // 'The underlying balance needs to be greater than 0'\n  string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '44'; // 'Interest rate rebalance conditions were not met'\n  string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '45'; // 'Health factor is not below the threshold'\n  string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = '46'; // 'The collateral chosen cannot be liquidated'\n  string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '47'; // 'User did not borrow the specified currency'\n  string public constant INCONSISTENT_FLASHLOAN_PARAMS = '49'; // 'Inconsistent flashloan parameters'\n  string public constant BORROW_CAP_EXCEEDED = '50'; // 'Borrow cap is exceeded'\n  string public constant SUPPLY_CAP_EXCEEDED = '51'; // 'Supply cap is exceeded'\n  string public constant UNBACKED_MINT_CAP_EXCEEDED = '52'; // 'Unbacked mint cap is exceeded'\n  string public constant DEBT_CEILING_EXCEEDED = '53'; // 'Debt ceiling is exceeded'\n  string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = '54'; // 'Claimable rights over underlying not zero (aToken supply or accruedToTreasury)'\n  string public constant STABLE_DEBT_NOT_ZERO = '55'; // 'Stable debt supply is not zero'\n  string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = '56'; // 'Variable debt supply is not zero'\n  string public constant LTV_VALIDATION_FAILED = '57'; // 'Ltv validation failed'\n  string public constant INCONSISTENT_EMODE_CATEGORY = '58'; // 'Inconsistent eMode category'\n  string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = '59'; // 'Price oracle sentinel validation failed'\n  string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = '60'; // 'Asset is not borrowable in isolation mode'\n  string public constant RESERVE_ALREADY_INITIALIZED = '61'; // 'Reserve has already been initialized'\n  string public constant USER_IN_ISOLATION_MODE_OR_LTV_ZERO = '62'; // 'User is in isolation mode or ltv is zero'\n  string public constant INVALID_LTV = '63'; // 'Invalid ltv parameter for the reserve'\n  string public constant INVALID_LIQ_THRESHOLD = '64'; // 'Invalid liquidity threshold parameter for the reserve'\n  string public constant INVALID_LIQ_BONUS = '65'; // 'Invalid liquidity bonus parameter for the reserve'\n  string public constant INVALID_DECIMALS = '66'; // 'Invalid decimals parameter of the underlying asset of the reserve'\n  string public constant INVALID_RESERVE_FACTOR = '67'; // 'Invalid reserve factor parameter for the reserve'\n  string public constant INVALID_BORROW_CAP = '68'; // 'Invalid borrow cap for the reserve'\n  string public constant INVALID_SUPPLY_CAP = '69'; // 'Invalid supply cap for the reserve'\n  string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = '70'; // 'Invalid liquidation protocol fee for the reserve'\n  string public constant INVALID_EMODE_CATEGORY = '71'; // 'Invalid eMode category for the reserve'\n  string public constant INVALID_UNBACKED_MINT_CAP = '72'; // 'Invalid unbacked mint cap for the reserve'\n  string public constant INVALID_DEBT_CEILING = '73'; // 'Invalid debt ceiling for the reserve\n  string public constant INVALID_RESERVE_INDEX = '74'; // 'Invalid reserve index'\n  string public constant ACL_ADMIN_CANNOT_BE_ZERO = '75'; // 'ACL admin cannot be set to the zero address'\n  string public constant INCONSISTENT_PARAMS_LENGTH = '76'; // 'Array parameters that should be equal length are not'\n  string public constant ZERO_ADDRESS_NOT_VALID = '77'; // 'Zero address not valid'\n  string public constant INVALID_EXPIRATION = '78'; // 'Invalid expiration'\n  string public constant INVALID_SIGNATURE = '79'; // 'Invalid signature'\n  string public constant OPERATION_NOT_SUPPORTED = '80'; // 'Operation not supported'\n  string public constant DEBT_CEILING_NOT_ZERO = '81'; // 'Debt ceiling is not zero'\n  string public constant ASSET_NOT_LISTED = '82'; // 'Asset is not listed'\n  string public constant INVALID_OPTIMAL_USAGE_RATIO = '83'; // 'Invalid optimal usage ratio'\n  string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = '84'; // 'Invalid optimal stable to total debt ratio'\n  string public constant UNDERLYING_CANNOT_BE_RESCUED = '85'; // 'The underlying asset cannot be rescued'\n  string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = '86'; // 'Reserve has already been added to reserve list'\n  string public constant POOL_ADDRESSES_DO_NOT_MATCH = '87'; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'\n  string public constant STABLE_BORROWING_ENABLED = '88'; // 'Stable borrowing is enabled'\n  string public constant SILOED_BORROWING_VIOLATION = '89'; // 'User is trying to borrow multiple assets including a siloed one'\n  string public constant RESERVE_DEBT_NOT_ZERO = '90'; // the total debt of the reserve needs to be 0\n  string public constant FLASHLOAN_DISABLED = '91'; // FlashLoaning for this asset is disabled\n}\n"
    },
    "aave-v3-core/contracts/protocol/libraries/types/ConfiguratorInputTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary ConfiguratorInputTypes {\n  struct InitReserveInput {\n    address aTokenImpl;\n    address stableDebtTokenImpl;\n    address variableDebtTokenImpl;\n    uint8 underlyingAssetDecimals;\n    address interestRateStrategyAddress;\n    address underlyingAsset;\n    address treasury;\n    address incentivesController;\n    string aTokenName;\n    string aTokenSymbol;\n    string variableDebtTokenName;\n    string variableDebtTokenSymbol;\n    string stableDebtTokenName;\n    string stableDebtTokenSymbol;\n    bytes params;\n  }\n\n  struct UpdateATokenInput {\n    address asset;\n    address treasury;\n    address incentivesController;\n    string name;\n    string symbol;\n    address implementation;\n    bytes params;\n  }\n\n  struct UpdateDebtTokenInput {\n    address asset;\n    address incentivesController;\n    string name;\n    string symbol;\n    address implementation;\n    bytes params;\n  }\n}\n"
    },
    "aave-v3-core/contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62: siloed borrowing enabled\n    //bit 63: flashloaning enabled\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "ds-test/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    }\n\n    function fail() internal virtual {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"      Left\", a);\n            emit log_named_address(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"      Left\", a);\n            emit log_named_bytes32(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"      Left\", a);\n            emit log_named_int(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertNotEq(address a, address b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [address]\");\n            emit log_named_address(\"      Left\", a);\n            emit log_named_address(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(address a, address b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string (\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n\n    function assertNotEq(bytes32 a, bytes32 b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"      Left\", a);\n            emit log_named_bytes32(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string (\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n    function assertNotEq32(bytes32 a, bytes32 b) internal {\n        assertNotEq(a, b);\n    }\n    function assertNotEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertNotEq(a, b, err);\n    }\n\n    function assertNotEq(int a, int b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [int]\");\n            emit log_named_int(\"      Left\", a);\n            emit log_named_int(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(int a, int b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n    function assertNotEq(uint a, uint b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(uint a, uint b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n    function assertNotEqDecimal(int a, int b, uint decimals) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertNotEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEqDecimal(a, b, decimals);\n        }\n    }\n    function assertNotEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertNotEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"      Left\", a);\n            emit log_named_string(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertNotEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a != b not satisfied [string]\");\n            emit log_named_string(\"      Left\", a);\n            emit log_named_string(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"      Left\", a);\n            emit log_named_bytes(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n\n    function assertNotEq0(bytes memory a, bytes memory b) internal {\n        if (checkEq0(a, b)) {\n            emit log(\"Error: a != b not satisfied [bytes]\");\n            emit log_named_bytes(\"      Left\", a);\n            emit log_named_bytes(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq0(a, b);\n        }\n    }\n}\n"
    },
    "forge-std/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n    // console.sol and console2.sol work by executing a staticcall to this address.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\"foundry default caller\"))));\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    // Deterministic deployment address of the Multicall3 contract.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n"
    },
    "forge-std/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "forge-std/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "forge-std/interfaces/IMulticall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n"
    },
    "forge-std/Script.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\n// 💬 ABOUT\n// Standard Library's default Script.\n\n// 🧩 MODULES\nimport {ScriptBase} from \"./Base.sol\";\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheatsSafe} from \"./StdCheats.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorageSafe} from \"./StdStorage.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\n// 📦 BOILERPLATE\nimport {ScriptBase} from \"./Base.sol\";\n\n// ⭐️ SCRIPT\nabstract contract Script is StdChains, StdCheatsSafe, StdUtils, ScriptBase {\n    // Note: IS_SCRIPT() must return true.\n    bool public IS_SCRIPT = true;\n}\n"
    },
    "forge-std/StdAssertions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {DSTest} from \"ds-test/test.sol\";\nimport {stdMath} from \"./StdMath.sol\";\n\nabstract contract StdAssertions is DSTest {\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal virtual {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bool]\");\n            emit log_named_string(\"      Left\", a ? \"true\" : \"false\");\n            emit log_named_string(\"     Right\", b ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal virtual {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal virtual {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    // Legacy helper\n    function assertEqUint(uint256 a, uint256 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"       Left\", a);\n            emit log_named_int(\"      Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"        Left\", a);\n            emit log_named_uint(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"        Left\", a, decimals);\n            emit log_named_decimal_uint(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"        Left\", a);\n            emit log_named_int(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"        Left\", a, decimals);\n            emit log_named_decimal_int(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\n        assertEqCall(target, callDataA, target, callDataB, true);\n    }\n\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\n        internal\n        virtual\n    {\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\n        internal\n        virtual\n    {\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\n    }\n\n    function assertEqCall(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData\n    ) internal virtual {\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\n\n        if (successA && successB) {\n            assertEq(returnDataA, returnDataB, \"Call return data does not match\");\n        }\n\n        if (!successA && !successB && strictRevertData) {\n            assertEq(returnDataA, returnDataB, \"Call revert data does not match\");\n        }\n\n        if (!successA && successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call revert data\", returnDataA);\n            emit log_named_bytes(\" Right call return data\", returnDataB);\n            fail();\n        }\n\n        if (successA && !successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call return data\", returnDataA);\n            emit log_named_bytes(\" Right call revert data\", returnDataB);\n            fail();\n        }\n    }\n}\n"
    },
    "forge-std/StdChains.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve the RPC URL for `mainnet`:\n *   - If you have specified data with `setChain`, it will return that.\n *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it\n *     is valid (e.g. a URL is specified, or an environment variable is given and exists).\n *   - If neither of the above conditions is met, the default data is returned.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private stdChainsInitialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initializeStdChains();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initializeStdChains();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initializeStdChains();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // distinguish 'not found' from 'cannot read'\n                bytes memory notFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initializeStdChains() private {\n        if (stdChainsInitialized) return;\n\n        stdChainsInitialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\n            \"mainnet\", ChainData(\"Mainnet\", 1, \"https://mainnet.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"goerli\", ChainData(\"Goerli\", 5, \"https://goerli.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"optimism_goerli\", ChainData(\"Optimism Goerli\", 420, \"https://goerli.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_goerli\", ChainData(\"Arbitrum One Goerli\", 421613, \"https://goerli-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_mumbai\", ChainData(\"Polygon Mumbai\", 80001, \"https://rpc-mumbai.maticvigil.com\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n"
    },
    "forge-std/StdCheats.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    struct Account {\n        address addr;\n        uint256 key;\n    }\n\n    function assumeNoPrecompiles(address addr) internal virtual {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        assumeNoPrecompiles(addr, chainId);\n    }\n\n    function assumeNoPrecompiles(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These should be present on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0x9));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // creates a struct containing both a labeled address and the corresponding private key\n    function makeAccount(string memory name) internal virtual returns (Account memory account) {\n        (account.addr, account.key) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // a cheat for fuzzing addresses that are payable only\n    // see https://github.com/foundry-rs/foundry/issues/3631\n    function assumePayable(address addr) internal virtual {\n        (bool success,) = payable(addr).call{value: 0}(\"\");\n        vm.assume(success);\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    function changePrank(address msgSender, address txOrigin) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender, txOrigin);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    // Set the balance of an account for any ERC1155 token\n    // Use the alternative signature to update `totalSupply`\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\n        dealERC1155(token, to, id, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x00fdd58e, to, id));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0xbd85b039, id));\n            require(\n                totSupData.length != 0,\n                \"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\"\n            );\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\n        }\n    }\n\n    function dealERC721(address token, address to, uint256 id) internal virtual {\n        // check if token id is already minted and the actual owner.\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n        require(successMinted, \"StdCheats deal(address,address,uint,bool): id not minted.\");\n\n        // get owner current balance\n        (, bytes memory fromBalData) = token.call(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\n\n        // get new user current balance\n        (, bytes memory toBalData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\n\n        // update balances\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\n\n        // update owner\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\n    }\n}\n"
    },
    "forge-std/StdError.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n"
    },
    "forge-std/StdInvariant.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ncontract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzSelector[] private _targetedArtifactSelectors;\n    FuzzSelector[] private _targetedSelectors;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSelectors.push(newTargetedSelector_);\n    }\n\n    function targetSender(address newTargetedSender_) internal {\n        _targetedSenders.push(newTargetedSender_);\n    }\n\n    // Functions for forge:\n    // These are called by forge to run invariant tests and don't need to be called in tests.\n\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n}\n"
    },
    "forge-std/StdJson.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"some_peth\");\n// json.parseUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"deploymentArtifact\";\n// Contract contract = new Contract();\n// json.serialize(\"contractAddress\", address(contract));\n// json = json.serialize(\"deploymentTimes\", uint(1));\n// // store the stringified JSON to the 'json' variable we have been using as a key\n// // as we won't need it any longer\n// string memory json2 = \"finalArtifact\";\n// string memory final = json2.serialize(\"depArtifact\", json);\n// final.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n"
    },
    "forge-std/StdMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "forge-std/StdStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(\n                    false,\n                    \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n                );\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32 * field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm.store(who, reads[i], prev);\n                    break;\n                }\n                vm.store(who, reads[i], prev);\n            }\n        } else {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.find(self);\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n        bytes32 curr = vm.load(who, slot);\n\n        if (fdat != curr) {\n            require(\n                false,\n                \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n            );\n        }\n        vm.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    // Private function so needs to be copied over\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    // Private function so needs to be copied over\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "forge-std/StdStyle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(int256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(address self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(bool self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function yellow(string memory self) internal pure returns (string memory) {\n        return styleConcat(YELLOW, self);\n    }\n\n    function yellow(uint256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(int256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(address self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(bool self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function blue(string memory self) internal pure returns (string memory) {\n        return styleConcat(BLUE, self);\n    }\n\n    function blue(uint256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(int256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(address self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(bool self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function magenta(string memory self) internal pure returns (string memory) {\n        return styleConcat(MAGENTA, self);\n    }\n\n    function magenta(uint256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(int256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(address self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(bool self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function cyan(string memory self) internal pure returns (string memory) {\n        return styleConcat(CYAN, self);\n    }\n\n    function cyan(uint256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(int256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(address self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(bool self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function bold(string memory self) internal pure returns (string memory) {\n        return styleConcat(BOLD, self);\n    }\n\n    function bold(uint256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(int256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(address self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(bool self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function dim(string memory self) internal pure returns (string memory) {\n        return styleConcat(DIM, self);\n    }\n\n    function dim(uint256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(int256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(address self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(bool self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function italic(string memory self) internal pure returns (string memory) {\n        return styleConcat(ITALIC, self);\n    }\n\n    function italic(uint256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(int256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(address self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(bool self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function underline(string memory self) internal pure returns (string memory) {\n        return styleConcat(UNDERLINE, self);\n    }\n\n    function underline(uint256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(int256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(address self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(bool self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function inverse(string memory self) internal pure returns (string memory) {\n        return styleConcat(INVERSE, self);\n    }\n\n    function inverse(uint256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(int256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(address self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(bool self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n}\n"
    },
    "forge-std/StdUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n        console2_log(\"Bound Result\", result);\n    }\n\n    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {\n        result = _bound(x, min, max);\n        console2_log(\"Bound result\", vm.toString(result));\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        // forgefmt: disable-start\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n        // forgefmt: disable-end\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(\n            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))\n        );\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n\n    function console2_log(string memory p0, uint256 p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n        status;\n    }\n\n    function console2_log(string memory p0, string memory p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n        status;\n    }\n}\n"
    },
    "forge-std/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// 💬 ABOUT\n// Standard Library's default Test\n\n// 🧩 MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\n\n// 📦 BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\nimport {DSTest} from \"ds-test/test.sol\";\n\n// ⭐️ TEST\nabstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils, TestBase {\n// Note: IS_TEST() must return true.\n// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.\n}\n"
    },
    "forge-std/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// Cheatcodes are marked as view/pure/none using the following rules:\n// 0. A call's observable behaviour includes its return value, logs, reverts and state writes,\n// 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),\n// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,\n// 3. Otherwise you're `pure`.\n\ninterface VmSafe {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n        address emitter;\n    }\n\n    struct Rpc {\n        string key;\n        string url;\n    }\n\n    struct DirEntry {\n        string errorMessage;\n        string path;\n        uint64 depth;\n        bool isDir;\n        bool isSymlink;\n    }\n\n    struct FsMetadata {\n        bool isDir;\n        bool isSymlink;\n        uint256 length;\n        bool readOnly;\n        uint256 modified;\n        uint256 accessed;\n        uint256 created;\n    }\n\n    // Loads a storage slot from an address\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n    // Signs data\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n    // Gets the address for a given private key\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n    // Gets the nonce of an account\n    function getNonce(address account) external view returns (uint64 nonce);\n    // Performs a foreign function call via the terminal\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n    // Sets environment variables\n    function setEnv(string calldata name, string calldata value) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata name) external view returns (bool value);\n    function envUint(string calldata name) external view returns (uint256 value);\n    function envInt(string calldata name) external view returns (int256 value);\n    function envAddress(string calldata name) external view returns (address value);\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n    function envString(string calldata name) external view returns (string memory value);\n    function envBytes(string calldata name) external view returns (bytes memory value);\n    // Reads environment variables as arrays\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n    // Read environment variables with default value\n    function envOr(string calldata name, bool defaultValue) external returns (bool value);\n    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);\n    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);\n    function envOr(string calldata name, address defaultValue) external returns (address value);\n    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);\n    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);\n    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);\n    // Read environment variables as arrays with default value\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        returns (bool[] memory value);\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        returns (uint256[] memory value);\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        returns (int256[] memory value);\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        returns (address[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        returns (bytes32[] memory value);\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        returns (string[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        returns (bytes[] memory value);\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n    // Labels an address in call traces\n    function label(address account, string calldata newLabel) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address signer) external;\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\n    function broadcast(uint256 privateKey) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\n    function startBroadcast(address signer) external;\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\n    function startBroadcast(uint256 privateKey) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n\n    // Get the path of the current project root.\n    function projectRoot() external view returns (string memory path);\n    // Reads the entire content of file to string. `path` is relative to the project root.\n    function readFile(string calldata path) external view returns (string memory data);\n    // Reads the entire content of file as binary. `path` is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n    // Reads next line of file to string.\n    function readLine(string calldata path) external view returns (string memory line);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // `path` is relative to the project root.\n    function writeFile(string calldata path, string calldata data) external;\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // `path` is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n    // Writes line to file, creating a file if it does not exist.\n    // `path` is relative to the project root.\n    function writeLine(string calldata path, string calldata data) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    // `path` is relative to the project root.\n    function closeFile(string calldata path) external;\n    // Removes a file from the filesystem.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - `path` points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    // `path` is relative to the project root.\n    function removeFile(string calldata path) external;\n    // Creates a new, empty directory at the provided path.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - User lacks permissions to modify `path`.\n    // - A parent of the given path doesn't exist and `recursive` is false.\n    // - `path` already exists and `recursive` is false.\n    // `path` is relative to the project root.\n    function createDir(string calldata path, bool recursive) external;\n    // Removes a directory at the provided path.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - `path` doesn't exist.\n    // - `path` isn't a directory.\n    // - User lacks permissions to modify `path`.\n    // - The directory is not empty and `recursive` is false.\n    // `path` is relative to the project root.\n    function removeDir(string calldata path, bool recursive) external;\n    // Reads the directory at the given path recursively, up to `max_depth`.\n    // `max_depth` defaults to 1, meaning only the direct children of the given directory will be returned.\n    // Follows symbolic links if `follow_links` is true.\n    function readDir(string calldata path) external view returns (DirEntry[] memory entries);\n    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);\n    function readDir(string calldata path, uint64 maxDepth, bool followLinks)\n        external\n        view\n        returns (DirEntry[] memory entries);\n    // Reads a symbolic link, returning the path that the link points to.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - `path` is not a symbolic link.\n    // - `path` does not exist.\n    function readLink(string calldata linkPath) external view returns (string memory targetPath);\n    // Given a path, query the file system to get information about a file, directory, etc.\n    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);\n\n    // Convert values to a string\n    function toString(address value) external pure returns (string memory stringifiedValue);\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n    // Convert values from a string\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs\n    function getRecordedLogs() external returns (Log[] memory logs);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n    // Adds a private key to the local forge wallet and returns the address\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n    //\n    // parseJson\n    //\n    // ----\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\n    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\n    // as tuples, with the attributes in the order in which they are defined.\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\n    // a: uint256\n    // b: address\n    // To decode that json, we need to define a struct or a tuple as follows:\n    // struct json = { uint256 a; address b; }\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\n    // decode the tuple in that order, and thus fail.\n    // ----\n    // Given a string of JSON, return it as ABI-encoded\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    // The following parseJson cheatcodes will do type coercion, for the type that they indicate.\n    // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers '12'\n    // and hex numbers '0xEF'.\n    // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not\n    // a JSON object.\n    function parseJsonUint(string calldata, string calldata) external returns (uint256);\n    function parseJsonUintArray(string calldata, string calldata) external returns (uint256[] memory);\n    function parseJsonInt(string calldata, string calldata) external returns (int256);\n    function parseJsonIntArray(string calldata, string calldata) external returns (int256[] memory);\n    function parseJsonBool(string calldata, string calldata) external returns (bool);\n    function parseJsonBoolArray(string calldata, string calldata) external returns (bool[] memory);\n    function parseJsonAddress(string calldata, string calldata) external returns (address);\n    function parseJsonAddressArray(string calldata, string calldata) external returns (address[] memory);\n    function parseJsonString(string calldata, string calldata) external returns (string memory);\n    function parseJsonStringArray(string calldata, string calldata) external returns (string[] memory);\n    function parseJsonBytes(string calldata, string calldata) external returns (bytes memory);\n    function parseJsonBytesArray(string calldata, string calldata) external returns (bytes[] memory);\n    function parseJsonBytes32(string calldata, string calldata) external returns (bytes32);\n    function parseJsonBytes32Array(string calldata, string calldata) external returns (bytes32[] memory);\n\n    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file\n    // It returns the stringified version of the specific JSON file up to that moment.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    //\n    // writeJson\n    //\n    // ----\n    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    // Let's assume we want to write the following JSON to a file:\n    //\n    // { \"boolean\": true, \"number\": 342, \"object\": { \"title\": \"finally json serialization\" } }\n    //\n    // ```\n    //  string memory json1 = \"some key\";\n    //  vm.serializeBool(json1, \"boolean\", true);\n    //  vm.serializeBool(json1, \"number\", uint256(342));\n    //  json2 = \"some other key\";\n    //  string memory output = vm.serializeString(json2, \"title\", \"finally json serialization\");\n    //  string memory finalJson = vm.serialize(json1, \"object\", output);\n    //  vm.writeJson(finalJson, \"./output/example.json\");\n    // ```\n    // The critical insight is that every invocation of serialization will return the stringified version of the JSON\n    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version\n    // to serialize them as values to another JSON object.\n    //\n    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)\n    // will find the object in-memory that is keyed by \"some key\".\n    function writeJson(string calldata json, string calldata path) external;\n    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>\n    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n    // Returns the RPC url for the given alias\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n    // Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external view returns (string[2][] memory urls);\n    // Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n    // If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n    // Writes a breakpoint to jump to in the debugger\n    function breakpoint(string calldata char) external;\n    // Writes a conditional breakpoint to jump to in the debugger\n    function breakpoint(string calldata char, bool value) external;\n}\n\ninterface Vm is VmSafe {\n    // Sets block.timestamp\n    function warp(uint256 newTimestamp) external;\n    // Sets block.height\n    function roll(uint256 newHeight) external;\n    // Sets block.basefee\n    function fee(uint256 newBasefee) external;\n    // Sets block.difficulty\n    function difficulty(uint256 newDifficulty) external;\n    // Sets block.chainid\n    function chainId(uint256 newChainId) external;\n    // Sets tx.gasprice\n    function txGasPrice(uint256 newGasPrice) external;\n    // Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address account, uint64 newNonce) external;\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address msgSender) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address msgSender) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address msgSender, address txOrigin) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address msgSender, address txOrigin) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance\n    function deal(address account, uint256 newBalance) external;\n    // Sets an address' code\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata revertData) external;\n    function expectRevert(bytes4 revertData) external;\n    function expectRevert() external;\n\n    // Prepare an expected log with all four checks enabled.\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data.\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit() external;\n    function expectEmit(address emitter) external;\n\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n    // Reverts a call to an address with specified revert data.\n    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;\n    // Reverts a call to an address with a specific msg.value, with specified revert data.\n    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)\n        external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address callee, bytes calldata data) external;\n    // Expects given number of calls to an address with the specified calldata.\n    function expectCall(address callee, bytes calldata data, uint64 count) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n    // Expects given number of calls to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;\n    // Expect a call to an address with the specified msg.value, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n    // Expects given number of calls to an address with the specified msg.value, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;\n    // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n    // Expect given number of calls to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)\n        external;\n    // Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the current subcontext. If any other\n    // memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\n    function expectSafeMemory(uint64 min, uint64 max) external;\n    // Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the next created subcontext.\n    // If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\n    // to the set.\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\n    // Sets block.coinbase\n    function coinbase(address newCoinbase) external;\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns (uint256 snapshotId);\n    // Revert the state of the EVM to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,\n    // and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before\n    // the transaction, returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256 blockNumber) external;\n    // Updates the currently active fork to given transaction\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\n    function rollFork(bytes32 txHash) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address account) external;\n    function makePersistent(address account0, address account1) external;\n    function makePersistent(address account0, address account1, address account2) external;\n    function makePersistent(address[] calldata accounts) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address account) external;\n    function revokePersistent(address[] calldata accounts) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address account) external view returns (bool persistent);\n    // In forking mode, explicitly grant the given address cheatcode access\n    function allowCheatcodes(address account) external;\n    // Fetches the given transaction from the active fork and executes it on the current state\n    function transact(bytes32 txHash) external;\n    // Fetches the given transaction from the given fork and executes it on the current state\n    function transact(uint256 forkId, bytes32 txHash) external;\n}\n"
    },
    "solidity-utils/contracts/oz-common/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, 'Address: insufficient balance');\n\n    (bool success, ) = recipient.call{value: amount}('');\n    require(success, 'Address: unable to send value, recipient may have reverted');\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, 'Address: low-level call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, 'Address: insufficient balance for call');\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(address target, bytes memory data)\n    internal\n    view\n    returns (bytes memory)\n  {\n    return functionStaticCall(target, data, 'Address: low-level static call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, 'Address: low-level delegate call failed');\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n   *\n   * _Available since v4.8._\n   */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), 'Address: call to non-contract');\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason or using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "solidity-utils/contracts/oz-common/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n// From commit https://github.com/OpenZeppelin/openzeppelin-contracts/commit/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n  struct AddressSlot {\n    address value;\n  }\n\n  struct BooleanSlot {\n    bool value;\n  }\n\n  struct Bytes32Slot {\n    bytes32 value;\n  }\n\n  struct Uint256Slot {\n    uint256 value;\n  }\n\n  /**\n   * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n   */\n  function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n   */\n  function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n   */\n  function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n   */\n  function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      r.slot := slot\n    }\n  }\n}\n"
    },
    "solidity-utils/contracts/transparent-proxy/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/** @dev OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n * From https://github.com/OpenZeppelin/openzeppelin-contracts/tree/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n *\n * BGD Labs adaptations:\n * - Same exact version as OZ, only linting changes\n */\n\npragma solidity ^0.8.0;\n\nimport './Proxy.sol';\nimport './ERC1967Upgrade.sol';\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n   */\n  constructor(address _logic, bytes memory _data) payable {\n    _upgradeToAndCall(_logic, _data, false);\n  }\n\n  /**\n   * @dev Returns the current implementation address.\n   */\n  function _implementation() internal view virtual override returns (address impl) {\n    return ERC1967Upgrade._getImplementation();\n  }\n}\n"
    },
    "solidity-utils/contracts/transparent-proxy/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/** @dev OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n * From https://github.com/OpenZeppelin/openzeppelin-contracts/tree/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n *\n * BGD Labs adaptations:\n * - This is an opinionated version, to be used on \"classic\" transparent upgradeable proxies (non UUPS/Beacon)\n * - For the sake of simplification and gas savings on deployment, the functions/constants related with UUPS/Beacon have been removed\n * - Moved declaration of `_ADMIN_SLOT` constant and `AdminChanged` event to the top\n * - Linting\n * - Removed imports not used anymore due to not have UUPS/Beacon logic\n */\n\npragma solidity ^0.8.2;\n\nimport '../oz-common/Address.sol';\nimport '../oz-common/StorageSlot.sol';\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _IMPLEMENTATION_SLOT =\n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _ADMIN_SLOT =\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Emitted when the admin account has changed.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Returns the current implementation address.\n   */\n  function _getImplementation() internal view returns (address) {\n    return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    require(Address.isContract(newImplementation), 'ERC1967: new implementation is not a contract');\n    StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      Address.functionDelegateCall(newImplementation, data);\n    }\n  }\n\n  /**\n   * @dev Returns the current admin.\n   */\n  function _getAdmin() internal view returns (address) {\n    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 admin slot.\n   */\n  function _setAdmin(address newAdmin) private {\n    require(newAdmin != address(0), 'ERC1967: new admin is the zero address');\n    StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   *\n   * Emits an {AdminChanged} event.\n   */\n  function _changeAdmin(address newAdmin) internal {\n    emit AdminChanged(_getAdmin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n}\n"
    },
    "solidity-utils/contracts/transparent-proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @dev OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n * From https://github.com/OpenZeppelin/openzeppelin-contracts/tree/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n *\n * BGD Labs adaptations:\n * - Added a constructor disabling initialization for implementation contracts\n * - Linting\n */\n\npragma solidity ^0.8.2;\n\nimport '../oz-common/Address.sol';\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n   * @custom:oz-retyped-from bool\n   */\n  uint8 private _initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private _initializing;\n\n  /**\n   * @dev Triggered when the contract has been initialized or reinitialized.\n   */\n  event Initialized(uint8 version);\n\n  /**\n   * @dev OPINIONATED. Generally is not a good practise to allow initialization of implementations\n   */\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n   * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n   */\n  modifier initializer() {\n    bool isTopLevelCall = !_initializing;\n    require(\n      (isTopLevelCall && _initialized < 1) ||\n        (!Address.isContract(address(this)) && _initialized == 1),\n      'Initializable: contract is already initialized'\n    );\n    _initialized = 1;\n    if (isTopLevelCall) {\n      _initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      _initializing = false;\n      emit Initialized(1);\n    }\n  }\n\n  /**\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n   * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n   * used to initialize parent contracts.\n   *\n   * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n   * initialization step. This is essential to configure modules that are added through upgrades and that require\n   * initialization.\n   *\n   * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n   * a contract, executing them in the right order is up to the developer or operator.\n   */\n  modifier reinitializer(uint8 version) {\n    require(\n      !_initializing && _initialized < version,\n      'Initializable: contract is already initialized'\n    );\n    _initialized = version;\n    _initializing = true;\n    _;\n    _initializing = false;\n    emit Initialized(version);\n  }\n\n  /**\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n   * {initializer} and {reinitializer} modifiers, directly or indirectly.\n   */\n  modifier onlyInitializing() {\n    require(_initializing, 'Initializable: contract is not initializing');\n    _;\n  }\n\n  /**\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n   * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n   * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n   * through proxies.\n   */\n  function _disableInitializers() internal virtual {\n    require(!_initializing, 'Initializable: contract is initializing');\n    if (_initialized < type(uint8).max) {\n      _initialized = type(uint8).max;\n      emit Initialized(type(uint8).max);\n    }\n  }\n}\n"
    },
    "solidity-utils/contracts/transparent-proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @dev OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n * From https://github.com/OpenZeppelin/openzeppelin-contracts/tree/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n *\n * BGD Labs adaptations:\n * - Linting\n */\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n  /**\n   * @dev Delegates the current call to `implementation`.\n   *\n   * This function does not return to its internal call site, it will return directly to the external caller.\n   */\n  function _delegate(address implementation) internal virtual {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates the current call to the address returned by `_implementation()`.\n   *\n   * This function does not return to its internal call site, it will return directly to the external caller.\n   */\n  function _fallback() internal virtual {\n    _beforeFallback();\n    _delegate(_implementation());\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n   * function in the contract matches the call data.\n   */\n  fallback() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n   * is empty.\n   */\n  receive() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n   * call, or as part of the Solidity `fallback` or `receive` functions.\n   *\n   * If overridden should call `super._beforeFallback()`.\n   */\n  function _beforeFallback() internal virtual {}\n}\n"
    },
    "solidity-utils/contracts/transparent-proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * @dev OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n * From https://github.com/OpenZeppelin/openzeppelin-contracts/tree/8b778fa20d6d76340c5fac1ed66c80273f05b95a\n *\n * BGD Labs adaptations:\n * - Linting\n */\n\npragma solidity ^0.8.0;\n\nimport './ERC1967Proxy.sol';\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n  /**\n   * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n   * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n   */\n  constructor(\n    address _logic,\n    address admin_,\n    bytes memory _data\n  ) payable ERC1967Proxy(_logic, _data) {\n    _changeAdmin(admin_);\n  }\n\n  /**\n   * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _getAdmin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @dev Returns the current admin.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n   *\n   * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n   * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n   * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n   */\n  function admin() external ifAdmin returns (address admin_) {\n    admin_ = _getAdmin();\n  }\n\n  /**\n   * @dev Returns the current implementation.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n   *\n   * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n   * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n   * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n   */\n  function implementation() external ifAdmin returns (address implementation_) {\n    implementation_ = _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   *\n   * Emits an {AdminChanged} event.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n   */\n  function changeAdmin(address newAdmin) external virtual ifAdmin {\n    _changeAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the implementation of the proxy.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeToAndCall(newImplementation, bytes(''), false);\n  }\n\n  /**\n   * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n   * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n   * proxied contract.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\n    external\n    payable\n    ifAdmin\n  {\n    _upgradeToAndCall(newImplementation, data, true);\n  }\n\n  /**\n   * @dev Returns the current admin.\n   */\n  function _admin() internal view virtual returns (address) {\n    return _getAdmin();\n  }\n\n  /**\n   * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n   */\n  function _beforeFallback() internal virtual override {\n    require(\n      msg.sender != _getAdmin(),\n      'TransparentUpgradeableProxy: admin cannot fallback to proxy target'\n    );\n    super._beforeFallback();\n  }\n}\n"
    },
    "src/contracts/facilitators/aave/interestStrategy/FixedRateStrategyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IDefaultInterestRateStrategy} from '@aave/core-v3/contracts/interfaces/IDefaultInterestRateStrategy.sol';\nimport {VersionedInitializable} from '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {IFixedRateStrategyFactory} from './interfaces/IFixedRateStrategyFactory.sol';\nimport {GhoInterestRateStrategy} from './GhoInterestRateStrategy.sol';\n\n/**\n * @title FixedRateStrategyFactory\n * @author Aave Labs\n * @notice Factory contract to create and keep record of Aave v3 fixed rate strategy contracts\n * @dev `GhoInterestRateStrategy` is used to provide a fixed interest rate strategy.\n */\ncontract FixedRateStrategyFactory is VersionedInitializable, IFixedRateStrategyFactory {\n  ///@inheritdoc IFixedRateStrategyFactory\n  address public immutable POOL_ADDRESSES_PROVIDER;\n\n  mapping(uint256 => address) internal _strategiesByRate;\n  address[] internal _strategies;\n\n  /**\n   * @dev Constructor\n   * @param addressesProvider The address of the PoolAddressesProvider of Aave V3 Pool\n   */\n  constructor(address addressesProvider) {\n    require(addressesProvider != address(0), 'INVALID_ADDRESSES_PROVIDER');\n    POOL_ADDRESSES_PROVIDER = addressesProvider;\n  }\n\n  /**\n   * @notice FixedRateStrategyFactory initializer\n   * @dev assumes that the addresses provided are fixed rate deployed strategies.\n   * @param fixedRateStrategiesList List of fixed rate strategies\n   */\n  function initialize(address[] memory fixedRateStrategiesList) external initializer {\n    for (uint256 i = 0; i < fixedRateStrategiesList.length; i++) {\n      address fixedRateStrategy = fixedRateStrategiesList[i];\n      uint256 rate = IDefaultInterestRateStrategy(fixedRateStrategy).getBaseVariableBorrowRate();\n\n      _strategiesByRate[rate] = fixedRateStrategy;\n      _strategies.push(fixedRateStrategy);\n\n      emit RateStrategyCreated(fixedRateStrategy, rate);\n    }\n  }\n\n  ///@inheritdoc IFixedRateStrategyFactory\n  function createStrategies(uint256[] memory fixedRateList) public returns (address[] memory) {\n    address[] memory strategies = new address[](fixedRateList.length);\n    for (uint256 i = 0; i < fixedRateList.length; i++) {\n      uint256 rate = fixedRateList[i];\n      address cachedStrategy = _strategiesByRate[rate];\n\n      if (cachedStrategy == address(0)) {\n        cachedStrategy = address(new GhoInterestRateStrategy(POOL_ADDRESSES_PROVIDER, rate));\n        _strategiesByRate[rate] = cachedStrategy;\n        _strategies.push(cachedStrategy);\n\n        emit RateStrategyCreated(cachedStrategy, rate);\n      }\n\n      strategies[i] = cachedStrategy;\n    }\n\n    return strategies;\n  }\n\n  ///@inheritdoc IFixedRateStrategyFactory\n  function getAllStrategies() external view returns (address[] memory) {\n    return _strategies;\n  }\n\n  ///@inheritdoc IFixedRateStrategyFactory\n  function getStrategyByRate(uint256 borrowRate) external view returns (address) {\n    return _strategiesByRate[borrowRate];\n  }\n\n  /// @inheritdoc IFixedRateStrategyFactory\n  function REVISION() public pure virtual override returns (uint256) {\n    return 1;\n  }\n\n  /// @inheritdoc VersionedInitializable\n  function getRevision() internal pure virtual override returns (uint256) {\n    return REVISION();\n  }\n}\n"
    },
    "src/contracts/facilitators/aave/interestStrategy/GhoDiscountRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {WadRayMath} from '@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol';\nimport {IGhoDiscountRateStrategy} from './interfaces/IGhoDiscountRateStrategy.sol';\n\n/**\n * @title GhoDiscountRateStrategy contract\n * @author Aave\n * @notice Implements the calculation of the discount rate depending on the current strategy\n */\ncontract GhoDiscountRateStrategy is IGhoDiscountRateStrategy {\n  using WadRayMath for uint256;\n\n  /**\n   * @dev Amount of debt that is entitled to get a discount per unit of discount token\n   * Expressed with the number of decimals of the discounted token\n   */\n  uint256 public constant GHO_DISCOUNTED_PER_DISCOUNT_TOKEN = 100e18;\n\n  /**\n   * @dev Percentage of discount to apply to the part of the debt that is entitled to get a discount\n   * Expressed in bps, a value of 3000 results in 30.00%\n   */\n  uint256 public constant DISCOUNT_RATE = 0.3e4;\n\n  /**\n   * @dev Minimum balance amount of discount token to be entitled to a discount\n   * Expressed with the number of decimals of the discount token\n   */\n  uint256 public constant MIN_DISCOUNT_TOKEN_BALANCE = 1e15;\n\n  /**\n   * @dev Minimum balance amount of debt token to be entitled to a discount\n   * Expressed with the number of decimals of the debt token\n   */\n  uint256 public constant MIN_DEBT_TOKEN_BALANCE = 1e18;\n\n  /// @inheritdoc IGhoDiscountRateStrategy\n  function calculateDiscountRate(\n    uint256 debtBalance,\n    uint256 discountTokenBalance\n  ) external pure override returns (uint256) {\n    if (discountTokenBalance < MIN_DISCOUNT_TOKEN_BALANCE || debtBalance < MIN_DEBT_TOKEN_BALANCE) {\n      return 0;\n    } else {\n      uint256 discountedBalance = discountTokenBalance.wadMul(GHO_DISCOUNTED_PER_DISCOUNT_TOKEN);\n      if (discountedBalance >= debtBalance) {\n        return DISCOUNT_RATE;\n      } else {\n        return (discountedBalance * DISCOUNT_RATE) / debtBalance;\n      }\n    }\n  }\n}\n"
    },
    "src/contracts/facilitators/aave/interestStrategy/GhoInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {DataTypes} from '@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol';\nimport {IDefaultInterestRateStrategy} from '@aave/core-v3/contracts/interfaces/IDefaultInterestRateStrategy.sol';\nimport {IReserveInterestRateStrategy} from '@aave/core-v3/contracts/interfaces/IReserveInterestRateStrategy.sol';\nimport {IPoolAddressesProvider} from '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\n\n/**\n * @title GhoInterestRateStrategy\n * @author Aave\n * @notice Implements the calculation of GHO interest rates, which defines a fixed variable borrow rate.\n * @dev The variable borrow interest rate is fixed at deployment time. The rest of parameters are zeroed.\n */\ncontract GhoInterestRateStrategy is IDefaultInterestRateStrategy {\n  /// @inheritdoc IDefaultInterestRateStrategy\n  uint256 public constant OPTIMAL_USAGE_RATIO = 0;\n\n  /// @inheritdoc IDefaultInterestRateStrategy\n  uint256 public constant OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = 0;\n\n  /// @inheritdoc IDefaultInterestRateStrategy\n  uint256 public constant MAX_EXCESS_USAGE_RATIO = 0;\n\n  /// @inheritdoc IDefaultInterestRateStrategy\n  uint256 public constant MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO = 0;\n\n  /// @inheritdoc IDefaultInterestRateStrategy\n  IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n  // Base variable borrow rate when usage rate = 0. Expressed in ray\n  uint256 internal immutable _baseVariableBorrowRate;\n\n  /**\n   * @dev Constructor\n   * @param addressesProvider The address of the PoolAddressesProvider\n   * @param borrowRate The variable borrow rate (expressed in ray)\n   */\n  constructor(address addressesProvider, uint256 borrowRate) {\n    ADDRESSES_PROVIDER = IPoolAddressesProvider(addressesProvider);\n    _baseVariableBorrowRate = borrowRate;\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategy\n  function getVariableRateSlope1() external pure returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategy\n  function getVariableRateSlope2() external pure returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategy\n  function getStableRateSlope1() external pure returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategy\n  function getStableRateSlope2() external pure returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategy\n  function getStableRateExcessOffset() external pure returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategy\n  function getBaseStableBorrowRate() public pure returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategy\n  function getBaseVariableBorrowRate() external view override returns (uint256) {\n    return _baseVariableBorrowRate;\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategy\n  function getMaxVariableBorrowRate() external view override returns (uint256) {\n    return _baseVariableBorrowRate;\n  }\n\n  /// @inheritdoc IReserveInterestRateStrategy\n  function calculateInterestRates(\n    DataTypes.CalculateInterestRatesParams memory\n  ) public view override returns (uint256, uint256, uint256) {\n    return (0, 0, _baseVariableBorrowRate);\n  }\n}\n"
    },
    "src/contracts/facilitators/aave/interestStrategy/interfaces/IFixedRateStrategyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IFixedRateStrategyFactory\n * @author Aave Labs\n * @notice Defines the interface of the FixedRateStrategyFactory\n */\ninterface IFixedRateStrategyFactory {\n  /**\n   * @dev Emitted when a new strategy is created\n   * @param strategy The address of the new fixed rate strategy\n   * @param rate The rate of the new strategy, expressed in ray (e.g. 0.0150e27 results in 1.50%)\n   */\n  event RateStrategyCreated(address indexed strategy, uint256 indexed rate);\n\n  /**\n   * @notice Creates new fixed rate strategy contracts from a list of rates.\n   * @dev Returns the address of a cached contract if a strategy with same rate already exists\n   * @param fixedRateList The list of rates for interest rates strategies, expressed in ray (e.g. 0.0150e27 results in 1.50%)\n   * @return The list of fixed interest rate strategy contracts\n   */\n  function createStrategies(uint256[] memory fixedRateList) external returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the Pool Addresses Provider of Aave\n   * @return The address of the PoolAddressesProvider of Aave\n   */\n  function POOL_ADDRESSES_PROVIDER() external view returns (address);\n\n  /**\n   * @notice Returns all the fixed interest rate strategy contracts of the factory\n   * @return The list of fixed interest rate strategy contracts\n   */\n  function getAllStrategies() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the fixed interest rate strategy contract which corresponds to the given rate.\n   * @dev Returns `address(0)` if there is no interest rate strategy for the given rate\n   * @param rate The rate of the fixed interest rate strategy contract\n   * @return The address of the fixed interest rate strategy contract\n   */\n  function getStrategyByRate(uint256 rate) external view returns (address);\n\n  /**\n   * @notice Returns the FixedRateStrategyFactory revision number\n   * @return The revision number\n   */\n  function REVISION() external pure returns (uint256);\n}\n"
    },
    "src/contracts/facilitators/aave/interestStrategy/interfaces/IGhoDiscountRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IGhoDiscountRateStrategy\n * @author Aave\n * @notice Defines the basic interface of the GhoDiscountRateStrategy\n */\ninterface IGhoDiscountRateStrategy {\n  /**\n   * @notice Calculates the discount rate depending on the debt and discount token balances\n   * @param debtBalance The debt balance of the user\n   * @param discountTokenBalance The discount token balance of the user\n   * @return The discount rate, as a percentage - the maximum can be 10000 = 100.00%\n   */\n  function calculateDiscountRate(\n    uint256 debtBalance,\n    uint256 discountTokenBalance\n  ) external view returns (uint256);\n}\n"
    },
    "src/contracts/facilitators/aave/interestStrategy/ZeroDiscountRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IGhoDiscountRateStrategy} from '../interestStrategy/interfaces/IGhoDiscountRateStrategy.sol';\n\n/**\n * @title ZeroDiscountRateStrategy\n * @author Aave\n * @notice Discount Rate Strategy that always return zero discount rate.\n */\ncontract ZeroDiscountRateStrategy is IGhoDiscountRateStrategy {\n  uint256 public constant GHO_DISCOUNTED_PER_DISCOUNT_TOKEN = 0;\n  uint256 public constant DISCOUNT_RATE = 0;\n  uint256 public constant MIN_DISCOUNT_TOKEN_BALANCE = 0;\n  uint256 public constant MIN_DEBT_TOKEN_BALANCE = 0;\n\n  /// @inheritdoc IGhoDiscountRateStrategy\n  function calculateDiscountRate(\n    uint256 debtBalance,\n    uint256 discountTokenBalance\n  ) external view override returns (uint256) {\n    return DISCOUNT_RATE;\n  }\n}\n"
    },
    "src/contracts/facilitators/aave/misc/interfaces/IUiGhoDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/**\n * @title IUiGhoDataProvider\n * @author Aave\n * @notice Defines the basic interface of the UiGhoDataProvider\n */\ninterface IUiGhoDataProvider {\n  struct GhoReserveData {\n    uint256 ghoBaseVariableBorrowRate;\n    uint256 ghoDiscountedPerToken;\n    uint256 ghoDiscountRate;\n    uint256 ghoMinDebtTokenBalanceForDiscount;\n    uint256 ghoMinDiscountTokenBalanceForDiscount;\n    uint40 ghoReserveLastUpdateTimestamp;\n    uint128 ghoCurrentBorrowIndex;\n    uint256 aaveFacilitatorBucketLevel;\n    uint256 aaveFacilitatorBucketMaxCapacity;\n  }\n\n  struct GhoUserData {\n    uint256 userGhoDiscountPercent;\n    uint256 userDiscountTokenBalance;\n    uint256 userPreviousGhoBorrowIndex;\n    uint256 userGhoScaledBorrowBalance;\n  }\n\n  /**\n   * @notice Returns data of the GHO reserve and the Aave Facilitator\n   * @return An object with information related to the GHO reserve and the Aave Facilitator\n   */\n  function getGhoReserveData() external view returns (GhoReserveData memory);\n\n  /**\n   * @notice Returns data of the user's position on GHO\n   * @return An object with information related to the user's position with regard to GHO\n   */\n  function getGhoUserData(address user) external view returns (GhoUserData memory);\n}\n"
    },
    "src/contracts/facilitators/aave/misc/UiGhoDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IERC20} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport {DataTypes} from '@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol';\nimport {IGhoToken} from '../../../gho/interfaces/IGhoToken.sol';\nimport {GhoDiscountRateStrategy} from '../interestStrategy/GhoDiscountRateStrategy.sol';\nimport {IGhoVariableDebtToken} from '../tokens/interfaces/IGhoVariableDebtToken.sol';\nimport {IUiGhoDataProvider} from './interfaces/IUiGhoDataProvider.sol';\n\n/**\n * @title UiGhoDataProvider\n * @author Aave\n * @notice Data provider of GHO token as a reserve within the Aave Protocol\n */\ncontract UiGhoDataProvider is IUiGhoDataProvider {\n  IPool public immutable POOL;\n  IGhoToken public immutable GHO;\n\n  /**\n   * @dev Constructor\n   * @param pool The address of the Pool contract\n   * @param ghoToken The address of the GhoToken contract\n   */\n  constructor(IPool pool, IGhoToken ghoToken) {\n    POOL = pool;\n    GHO = ghoToken;\n  }\n\n  /// @inheritdoc IUiGhoDataProvider\n  function getGhoReserveData() public view override returns (GhoReserveData memory) {\n    DataTypes.ReserveData memory baseData = POOL.getReserveData(address(GHO));\n    IGhoVariableDebtToken debtToken = IGhoVariableDebtToken(baseData.variableDebtTokenAddress);\n    GhoDiscountRateStrategy discountRateStrategy = GhoDiscountRateStrategy(\n      debtToken.getDiscountRateStrategy()\n    );\n\n    (uint256 bucketCapacity, uint256 bucketLevel) = GHO.getFacilitatorBucket(\n      baseData.aTokenAddress\n    );\n\n    return\n      GhoReserveData({\n        ghoBaseVariableBorrowRate: baseData.currentVariableBorrowRate,\n        ghoDiscountedPerToken: discountRateStrategy.GHO_DISCOUNTED_PER_DISCOUNT_TOKEN(),\n        ghoDiscountRate: discountRateStrategy.DISCOUNT_RATE(),\n        ghoMinDebtTokenBalanceForDiscount: discountRateStrategy.MIN_DEBT_TOKEN_BALANCE(),\n        ghoMinDiscountTokenBalanceForDiscount: discountRateStrategy.MIN_DISCOUNT_TOKEN_BALANCE(),\n        ghoReserveLastUpdateTimestamp: baseData.lastUpdateTimestamp,\n        ghoCurrentBorrowIndex: baseData.variableBorrowIndex,\n        aaveFacilitatorBucketLevel: bucketLevel,\n        aaveFacilitatorBucketMaxCapacity: bucketCapacity\n      });\n  }\n\n  /// @inheritdoc IUiGhoDataProvider\n  function getGhoUserData(address user) public view override returns (GhoUserData memory) {\n    DataTypes.ReserveData memory baseData = POOL.getReserveData(address(GHO));\n    IGhoVariableDebtToken debtToken = IGhoVariableDebtToken(baseData.variableDebtTokenAddress);\n    address discountToken = debtToken.getDiscountToken();\n\n    return\n      GhoUserData({\n        userGhoDiscountPercent: debtToken.getDiscountPercent(user),\n        userDiscountTokenBalance: IERC20(discountToken).balanceOf(user),\n        userPreviousGhoBorrowIndex: debtToken.getPreviousIndex(user),\n        userGhoScaledBorrowBalance: debtToken.scaledBalanceOf(user)\n      });\n  }\n}\n"
    },
    "src/contracts/facilitators/aave/oracle/GhoOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/**\n * @title GhoOracle\n * @notice Price feed for GHO (USD denominated)\n * @dev Price fixed at 1 USD, Chainlink format with 8 decimals\n * @author Aave\n */\ncontract GhoOracle {\n  int256 public constant GHO_PRICE = 1e8;\n\n  /**\n   * @notice Returns the price of a unit of GHO (USD denominated)\n   * @dev GHO price is fixed at 1 USD\n   * @return The price of a unit of GHO (with 8 decimals)\n   */\n  function latestAnswer() external pure returns (int256) {\n    return GHO_PRICE;\n  }\n\n  /**\n   * @notice Returns the number of decimals the price is formatted with\n   * @return The number of decimals\n   */\n  function decimals() external pure returns (uint8) {\n    return 8;\n  }\n}\n"
    },
    "src/contracts/facilitators/aave/tokens/base/ScaledBalanceTokenBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {SafeCast} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {Errors} from '@aave/core-v3/contracts/protocol/libraries/helpers/Errors.sol';\nimport {WadRayMath} from '@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol';\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport {IScaledBalanceToken} from '@aave/core-v3/contracts/interfaces/IScaledBalanceToken.sol';\nimport {MintableIncentivizedERC20} from '@aave/core-v3/contracts/protocol/tokenization/base/MintableIncentivizedERC20.sol';\n\n/**\n * @title ScaledBalanceTokenBase\n * @author Aave\n * @notice Basic ERC20 implementation of scaled balance token\n */\nabstract contract ScaledBalanceTokenBase is MintableIncentivizedERC20, IScaledBalanceToken {\n  using WadRayMath for uint256;\n  using SafeCast for uint256;\n\n  /**\n   * @dev Constructor.\n   * @param pool The reference to the main Pool contract\n   * @param name The name of the token\n   * @param symbol The symbol of the token\n   * @param decimals The number of decimals of the token\n   */\n  constructor(\n    IPool pool,\n    string memory name,\n    string memory symbol,\n    uint8 decimals\n  ) MintableIncentivizedERC20(pool, name, symbol, decimals) {\n    // Intentionally left blank\n  }\n\n  /// @inheritdoc IScaledBalanceToken\n  function scaledBalanceOf(address user) external view override returns (uint256) {\n    return super.balanceOf(user);\n  }\n\n  /// @inheritdoc IScaledBalanceToken\n  function getScaledUserBalanceAndSupply(\n    address user\n  ) external view override returns (uint256, uint256) {\n    return (super.balanceOf(user), super.totalSupply());\n  }\n\n  /// @inheritdoc IScaledBalanceToken\n  function scaledTotalSupply() public view virtual override returns (uint256) {\n    return super.totalSupply();\n  }\n\n  /// @inheritdoc IScaledBalanceToken\n  function getPreviousIndex(address user) external view virtual override returns (uint256) {\n    return _userState[user].additionalData;\n  }\n\n  /**\n   * @notice Implements the basic logic to mint a scaled balance token.\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the scaled tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function _mintScaled(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) internal virtual returns (bool) {\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.INVALID_MINT_AMOUNT);\n\n    uint256 scaledBalance = super.balanceOf(onBehalfOf);\n    uint256 balanceIncrease = scaledBalance.rayMul(index) -\n      scaledBalance.rayMul(_userState[onBehalfOf].additionalData);\n\n    _userState[onBehalfOf].additionalData = index.toUint128();\n\n    _mint(onBehalfOf, amountScaled.toUint128());\n\n    uint256 amountToMint = amount + balanceIncrease;\n    emit Transfer(address(0), onBehalfOf, amountToMint);\n    emit Mint(caller, onBehalfOf, amountToMint, balanceIncrease, index);\n\n    return (scaledBalance == 0);\n  }\n\n  /**\n   * @notice Implements the basic logic to burn a scaled balance token.\n   * @dev In some instances, a burn transaction will emit a mint event\n   * if the amount to burn is less than the interest that the user accrued\n   * @param user The user which debt is burnt\n   * @param target The address that will receive the underlying, if any\n   * @param amount The amount getting burned\n   * @param index The variable debt index of the reserve\n   */\n  function _burnScaled(\n    address user,\n    address target,\n    uint256 amount,\n    uint256 index\n  ) internal virtual {\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.INVALID_BURN_AMOUNT);\n\n    uint256 scaledBalance = super.balanceOf(user);\n    uint256 balanceIncrease = scaledBalance.rayMul(index) -\n      scaledBalance.rayMul(_userState[user].additionalData);\n\n    _userState[user].additionalData = index.toUint128();\n\n    _burn(user, amountScaled.toUint128());\n\n    if (balanceIncrease > amount) {\n      uint256 amountToMint = balanceIncrease - amount;\n      emit Transfer(address(0), user, amountToMint);\n      emit Mint(user, user, amountToMint, balanceIncrease, index);\n    } else {\n      uint256 amountToBurn = amount - balanceIncrease;\n      emit Transfer(user, address(0), amountToBurn);\n      emit Burn(user, target, amountToBurn, balanceIncrease, index);\n    }\n  }\n}\n"
    },
    "src/contracts/facilitators/aave/tokens/GhoAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IERC20} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol';\nimport {GPv2SafeERC20} from '@aave/core-v3/contracts/dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {VersionedInitializable} from '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {Errors} from '@aave/core-v3/contracts/protocol/libraries/helpers/Errors.sol';\nimport {WadRayMath} from '@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol';\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport {IAToken} from '@aave/core-v3/contracts/interfaces/IAToken.sol';\nimport {IAaveIncentivesController} from '@aave/core-v3/contracts/interfaces/IAaveIncentivesController.sol';\nimport {IInitializableAToken} from '@aave/core-v3/contracts/interfaces/IInitializableAToken.sol';\nimport {ScaledBalanceTokenBase} from '@aave/core-v3/contracts/protocol/tokenization/base/ScaledBalanceTokenBase.sol';\nimport {IncentivizedERC20} from '@aave/core-v3/contracts/protocol/tokenization/base/IncentivizedERC20.sol';\nimport {EIP712Base} from '@aave/core-v3/contracts/protocol/tokenization/base/EIP712Base.sol';\n\n// Gho Imports\nimport {IGhoToken} from '../../../gho/interfaces/IGhoToken.sol';\nimport {IGhoFacilitator} from '../../../gho/interfaces/IGhoFacilitator.sol';\nimport {IGhoAToken} from './interfaces/IGhoAToken.sol';\nimport {GhoVariableDebtToken} from './GhoVariableDebtToken.sol';\n\n/**\n * @title GhoAToken\n * @author Aave\n * @notice Implementation of the interest bearing token for the Aave protocol\n */\ncontract GhoAToken is VersionedInitializable, ScaledBalanceTokenBase, EIP712Base, IGhoAToken {\n  using WadRayMath for uint256;\n  using GPv2SafeERC20 for IERC20;\n\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  uint256 public constant ATOKEN_REVISION = 0x1;\n\n  address internal _treasury;\n  address internal _underlyingAsset;\n\n  // Gho Storage\n  GhoVariableDebtToken internal _ghoVariableDebtToken;\n  address internal _ghoTreasury;\n\n  /// @inheritdoc VersionedInitializable\n  function getRevision() internal pure virtual override returns (uint256) {\n    return ATOKEN_REVISION;\n  }\n\n  /**\n   * @dev Constructor.\n   * @param pool The address of the Pool contract\n   */\n  constructor(\n    IPool pool\n  ) ScaledBalanceTokenBase(pool, 'GHO_ATOKEN_IMPL', 'GHO_ATOKEN_IMPL', 0) EIP712Base() {\n    // Intentionally left blank\n  }\n\n  /// @inheritdoc IInitializableAToken\n  function initialize(\n    IPool initializingPool,\n    address treasury,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 aTokenDecimals,\n    string calldata aTokenName,\n    string calldata aTokenSymbol,\n    bytes calldata params\n  ) external override initializer {\n    require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);\n    _setName(aTokenName);\n    _setSymbol(aTokenSymbol);\n    _setDecimals(aTokenDecimals);\n\n    _treasury = treasury;\n    _underlyingAsset = underlyingAsset;\n    _incentivesController = incentivesController;\n\n    _domainSeparator = _calculateDomainSeparator();\n\n    emit Initialized(\n      underlyingAsset,\n      address(POOL),\n      treasury,\n      address(incentivesController),\n      aTokenDecimals,\n      aTokenName,\n      aTokenSymbol,\n      params\n    );\n  }\n\n  /// @inheritdoc IAToken\n  function mint(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function burn(\n    address from,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function mintToTreasury(uint256 amount, uint256 index) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function transferOnLiquidation(\n    address from,\n    address to,\n    uint256 value\n  ) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IERC20\n  function balanceOf(\n    address user\n  ) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IERC20\n  function totalSupply() public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IAToken\n  function RESERVE_TREASURY_ADDRESS() external view override returns (address) {\n    return _treasury;\n  }\n\n  /// @inheritdoc IAToken\n  function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @notice Transfers the underlying asset to `target`.\n   * @dev It performs a mint of GHO on behalf of the `target`\n   * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()\n   * @param target The recipient of the underlying\n   * @param amount The amount getting transferred\n   */\n  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {\n    IGhoToken(_underlyingAsset).mint(target, amount);\n  }\n\n  /// @inheritdoc IAToken\n  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external virtual override onlyPool {\n    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);\n    if (amount <= balanceFromInterest) {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);\n    } else {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);\n      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);\n    }\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function distributeFeesToTreasury() external virtual override {\n    uint256 balance = IERC20(_underlyingAsset).balanceOf(address(this));\n    IERC20(_underlyingAsset).transfer(_ghoTreasury, balance);\n    emit FeesDistributedToTreasury(_ghoTreasury, _underlyingAsset, balance);\n  }\n\n  /// @inheritdoc IAToken\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /**\n   * @notice Overrides the parent _transfer to force validated transfer() and transferFrom()\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   */\n  function _transfer(address from, address to, uint128 amount) internal override {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /**\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.DOMAIN_SEPARATOR()` for more detailed documentation\n   */\n  function DOMAIN_SEPARATOR() public view override(IAToken, EIP712Base) returns (bytes32) {\n    return super.DOMAIN_SEPARATOR();\n  }\n\n  /**\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.nonces()` for more detailed documentation\n   */\n  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {\n    return super.nonces(owner);\n  }\n\n  /// @inheritdoc EIP712Base\n  function _EIP712BaseId() internal view override returns (string memory) {\n    return name();\n  }\n\n  /// @inheritdoc IAToken\n  function rescueTokens(address token, address to, uint256 amount) external override onlyPoolAdmin {\n    require(token != _underlyingAsset, Errors.UNDERLYING_CANNOT_BE_RESCUED);\n    IERC20(token).safeTransfer(to, amount);\n  }\n\n  /// @inheritdoc IGhoAToken\n  function setVariableDebtToken(address ghoVariableDebtToken) external override onlyPoolAdmin {\n    require(address(_ghoVariableDebtToken) == address(0), 'VARIABLE_DEBT_TOKEN_ALREADY_SET');\n    require(ghoVariableDebtToken != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    _ghoVariableDebtToken = GhoVariableDebtToken(ghoVariableDebtToken);\n    emit VariableDebtTokenSet(ghoVariableDebtToken);\n  }\n\n  /// @inheritdoc IGhoAToken\n  function getVariableDebtToken() external view override returns (address) {\n    return address(_ghoVariableDebtToken);\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function updateGhoTreasury(address newGhoTreasury) external override onlyPoolAdmin {\n    require(newGhoTreasury != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    address oldGhoTreasury = _ghoTreasury;\n    _ghoTreasury = newGhoTreasury;\n    emit GhoTreasuryUpdated(oldGhoTreasury, newGhoTreasury);\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function getGhoTreasury() external view override returns (address) {\n    return _ghoTreasury;\n  }\n}\n"
    },
    "src/contracts/facilitators/aave/tokens/GhoStableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\nimport {IERC20} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol';\nimport {VersionedInitializable} from '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {MathUtils} from '@aave/core-v3/contracts/protocol/libraries/math/MathUtils.sol';\nimport {WadRayMath} from '@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol';\nimport {Errors} from '@aave/core-v3/contracts/protocol/libraries/helpers/Errors.sol';\nimport {IAaveIncentivesController} from '@aave/core-v3/contracts/interfaces/IAaveIncentivesController.sol';\nimport {IInitializableDebtToken} from '@aave/core-v3/contracts/interfaces/IInitializableDebtToken.sol';\nimport {IStableDebtToken} from '@aave/core-v3/contracts/interfaces/IStableDebtToken.sol';\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport {EIP712Base} from '@aave/core-v3/contracts/protocol/tokenization/base/EIP712Base.sol';\nimport {DebtTokenBase} from '@aave/core-v3/contracts/protocol/tokenization/base/DebtTokenBase.sol';\nimport {IncentivizedERC20} from '@aave/core-v3/contracts/protocol/tokenization/base/IncentivizedERC20.sol';\nimport {SafeCast} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeCast.sol';\n\n/**\n * @title GhoStableDebtToken\n * @author Aave\n * @notice Implements a non-usable and reverting stable debt token, only used for listing configuration purposes.\n * @dev All write operations revert and read functions return 0\n */\ncontract GhoStableDebtToken is DebtTokenBase, IncentivizedERC20, IStableDebtToken {\n  using WadRayMath for uint256;\n  using SafeCast for uint256;\n\n  uint256 public constant DEBT_TOKEN_REVISION = 0x1;\n\n  /**\n   * @dev Constructor.\n   * @param pool The address of the Pool contract\n   */\n  constructor(\n    IPool pool\n  )\n    DebtTokenBase()\n    IncentivizedERC20(pool, 'GHO_STABLE_DEBT_TOKEN_IMPL', 'GHO_STABLE_DEBT_TOKEN_IMPL', 0)\n  {\n    // Intentionally left blank\n  }\n\n  /// @inheritdoc IInitializableDebtToken\n  function initialize(\n    IPool initializingPool,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 debtTokenDecimals,\n    string memory debtTokenName,\n    string memory debtTokenSymbol,\n    bytes calldata params\n  ) external override initializer {\n    require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);\n    _setName(debtTokenName);\n    _setSymbol(debtTokenSymbol);\n    _setDecimals(debtTokenDecimals);\n\n    _underlyingAsset = underlyingAsset;\n    _incentivesController = incentivesController;\n\n    _domainSeparator = _calculateDomainSeparator();\n\n    emit Initialized(\n      underlyingAsset,\n      address(POOL),\n      address(incentivesController),\n      debtTokenDecimals,\n      debtTokenName,\n      debtTokenSymbol,\n      params\n    );\n  }\n\n  /// @inheritdoc VersionedInitializable\n  function getRevision() internal pure virtual override returns (uint256) {\n    return DEBT_TOKEN_REVISION;\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function getAverageStableRate() external pure virtual override returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function getUserLastUpdated(address) external pure virtual override returns (uint40) {\n    return 0;\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function getUserStableRate(address) external pure virtual override returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IERC20\n  function balanceOf(address) public pure virtual override returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function mint(\n    address,\n    address,\n    uint256,\n    uint256\n  ) external virtual override onlyPool returns (bool, uint256, uint256) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function burn(address, uint256) external virtual override onlyPool returns (uint256, uint256) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function getSupplyData() external pure override returns (uint256, uint256, uint256, uint40) {\n    return (0, 0, 0, 0);\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function getTotalSupplyAndAvgRate() external pure override returns (uint256, uint256) {\n    return (0, 0);\n  }\n\n  /// @inheritdoc IERC20\n  function totalSupply() public pure virtual override returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function getTotalSupplyLastUpdated() external pure override returns (uint40) {\n    return 0;\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function principalBalanceOf(address) external pure virtual override returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IStableDebtToken\n  function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /// @inheritdoc EIP712Base\n  function _EIP712BaseId() internal view override returns (string memory) {\n    return name();\n  }\n\n  /**\n   * @dev Being non transferrable, the debt token does not implement any of the\n   * standard ERC20 functions for transfer and allowance.\n   */\n  function transfer(address, uint256) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function allowance(address, address) external view virtual override returns (uint256) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function approve(address, uint256) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function transferFrom(address, address, uint256) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function increaseAllowance(address, uint256) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function decreaseAllowance(address, uint256) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n}\n"
    },
    "src/contracts/facilitators/aave/tokens/GhoVariableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IERC20} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol';\nimport {SafeCast} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {VersionedInitializable} from '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {WadRayMath} from '@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol';\nimport {PercentageMath} from '@aave/core-v3/contracts/protocol/libraries/math/PercentageMath.sol';\nimport {Errors} from '@aave/core-v3/contracts/protocol/libraries/helpers/Errors.sol';\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport {IAaveIncentivesController} from '@aave/core-v3/contracts/interfaces/IAaveIncentivesController.sol';\nimport {IInitializableDebtToken} from '@aave/core-v3/contracts/interfaces/IInitializableDebtToken.sol';\nimport {IVariableDebtToken} from '@aave/core-v3/contracts/interfaces/IVariableDebtToken.sol';\nimport {EIP712Base} from '@aave/core-v3/contracts/protocol/tokenization/base/EIP712Base.sol';\nimport {DebtTokenBase} from '@aave/core-v3/contracts/protocol/tokenization/base/DebtTokenBase.sol';\n\n// Gho Imports\nimport {IGhoDiscountRateStrategy} from '../interestStrategy/interfaces/IGhoDiscountRateStrategy.sol';\nimport {IGhoVariableDebtToken} from './interfaces/IGhoVariableDebtToken.sol';\nimport {ScaledBalanceTokenBase} from './base/ScaledBalanceTokenBase.sol';\n\n/**\n * @title GhoVariableDebtToken\n * @author Aave\n * @notice Implements a variable debt token to track the borrowing positions of users\n * at variable rate mode for GHO\n * @dev Transfer and approve functionalities are disabled since its a non-transferable token\n */\ncontract GhoVariableDebtToken is DebtTokenBase, ScaledBalanceTokenBase, IGhoVariableDebtToken {\n  using WadRayMath for uint256;\n  using SafeCast for uint256;\n  using PercentageMath for uint256;\n\n  uint256 public constant DEBT_TOKEN_REVISION = 0x1;\n\n  // Corresponding AToken to this DebtToken\n  address internal _ghoAToken;\n\n  // Token that grants discounts off the debt interest\n  IERC20 internal _discountToken;\n\n  // Strategy of the discount rate to apply on debt interests\n  IGhoDiscountRateStrategy internal _discountRateStrategy;\n\n  struct GhoUserState {\n    // Accumulated debt interest of the user\n    uint128 accumulatedDebtInterest;\n    // Discount percent of the user (expressed in bps)\n    uint16 discountPercent;\n  }\n\n  // Map of users' address and their gho state data (userAddress => ghoUserState)\n  mapping(address => GhoUserState) internal _ghoUserState;\n\n  /**\n   * @dev Only discount token can call functions marked by this modifier.\n   */\n  modifier onlyDiscountToken() {\n    require(address(_discountToken) == msg.sender, 'CALLER_NOT_DISCOUNT_TOKEN');\n    _;\n  }\n\n  /**\n   * @dev Only AToken can call functions marked by this modifier.\n   */\n  modifier onlyAToken() {\n    require(_ghoAToken == msg.sender, 'CALLER_NOT_A_TOKEN');\n    _;\n  }\n\n  /**\n   * @dev Constructor.\n   * @param pool The address of the Pool contract\n   */\n  constructor(\n    IPool pool\n  )\n    DebtTokenBase()\n    ScaledBalanceTokenBase(pool, 'GHO_VARIABLE_DEBT_TOKEN_IMPL', 'GHO_VARIABLE_DEBT_TOKEN_IMPL', 0)\n  {\n    // Intentionally left blank\n  }\n\n  /// @inheritdoc IInitializableDebtToken\n  function initialize(\n    IPool initializingPool,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 debtTokenDecimals,\n    string memory debtTokenName,\n    string memory debtTokenSymbol,\n    bytes calldata params\n  ) external override initializer {\n    require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);\n    _setName(debtTokenName);\n    _setSymbol(debtTokenSymbol);\n    _setDecimals(debtTokenDecimals);\n\n    _underlyingAsset = underlyingAsset;\n    _incentivesController = incentivesController;\n\n    _domainSeparator = _calculateDomainSeparator();\n\n    emit Initialized(\n      underlyingAsset,\n      address(POOL),\n      address(incentivesController),\n      debtTokenDecimals,\n      debtTokenName,\n      debtTokenSymbol,\n      params\n    );\n  }\n\n  /// @inheritdoc VersionedInitializable\n  function getRevision() internal pure virtual override returns (uint256) {\n    return DEBT_TOKEN_REVISION;\n  }\n\n  /// @inheritdoc IERC20\n  function balanceOf(address user) public view virtual override returns (uint256) {\n    uint256 scaledBalance = super.balanceOf(user);\n\n    if (scaledBalance == 0) {\n      return 0;\n    }\n\n    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);\n    uint256 previousIndex = _userState[user].additionalData;\n    uint256 balance = scaledBalance.rayMul(index);\n    if (index == previousIndex) {\n      return balance;\n    }\n\n    uint256 discountPercent = _ghoUserState[user].discountPercent;\n    if (discountPercent != 0) {\n      uint256 balanceIncrease = balance - scaledBalance.rayMul(previousIndex);\n      balance -= balanceIncrease.percentMul(discountPercent);\n    }\n\n    return balance;\n  }\n\n  /// @inheritdoc IVariableDebtToken\n  function mint(\n    address user,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool returns (bool, uint256) {\n    if (user != onBehalfOf) {\n      _decreaseBorrowAllowance(onBehalfOf, user, amount);\n    }\n    return (_mintScaled(user, onBehalfOf, amount, index), scaledTotalSupply());\n  }\n\n  /// @inheritdoc IVariableDebtToken\n  function burn(\n    address from,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool returns (uint256) {\n    _burnScaled(from, address(0), amount, index);\n    return scaledTotalSupply();\n  }\n\n  /**\n   * @notice Returns the amount of tokens in existence.\n   * @dev It does not account for active discounts of the users. The discount is deducted from the user's debt at\n   * repayment / liquidation time, so this function does always return a greater or equal value than the actual total\n   * supply.\n   * @return The amount of tokens in existence (without accounting for active discounts on debt)\n   */\n  function totalSupply() public view virtual override returns (uint256) {\n    return super.totalSupply().rayMul(POOL.getReserveNormalizedVariableDebt(_underlyingAsset));\n  }\n\n  /// @inheritdoc EIP712Base\n  function _EIP712BaseId() internal view override returns (string memory) {\n    return name();\n  }\n\n  /**\n   * @dev Being non transferrable, the debt token does not implement any of the\n   * standard ERC20 functions for transfer and allowance.\n   */\n  function transfer(address, uint256) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function allowance(address, address) external view virtual override returns (uint256) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function approve(address, uint256) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function transferFrom(address, address, uint256) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function increaseAllowance(address, uint256) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  function decreaseAllowance(address, uint256) external virtual override returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IVariableDebtToken\n  function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /// @inheritdoc IGhoVariableDebtToken\n  function setAToken(address ghoAToken) external override onlyPoolAdmin {\n    require(_ghoAToken == address(0), 'ATOKEN_ALREADY_SET');\n    require(ghoAToken != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    _ghoAToken = ghoAToken;\n    emit ATokenSet(ghoAToken);\n  }\n\n  /// @inheritdoc IGhoVariableDebtToken\n  function getAToken() external view override returns (address) {\n    return _ghoAToken;\n  }\n\n  /// @inheritdoc IGhoVariableDebtToken\n  function updateDiscountRateStrategy(\n    address newDiscountRateStrategy\n  ) external override onlyPoolAdmin {\n    require(newDiscountRateStrategy != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    address oldDiscountRateStrategy = address(_discountRateStrategy);\n    _discountRateStrategy = IGhoDiscountRateStrategy(newDiscountRateStrategy);\n    emit DiscountRateStrategyUpdated(oldDiscountRateStrategy, newDiscountRateStrategy);\n  }\n\n  /// @inheritdoc IGhoVariableDebtToken\n  function getDiscountRateStrategy() external view override returns (address) {\n    return address(_discountRateStrategy);\n  }\n\n  /// @inheritdoc IGhoVariableDebtToken\n  function updateDiscountToken(address newDiscountToken) external override onlyPoolAdmin {\n    require(newDiscountToken != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    address oldDiscountToken = address(_discountToken);\n    _discountToken = IERC20(newDiscountToken);\n    emit DiscountTokenUpdated(oldDiscountToken, newDiscountToken);\n  }\n\n  /// @inheritdoc IGhoVariableDebtToken\n  function getDiscountToken() external view override returns (address) {\n    return address(_discountToken);\n  }\n\n  /// @inheritdoc IGhoVariableDebtToken\n  function updateDiscountDistribution(\n    address sender,\n    address recipient,\n    uint256 senderDiscountTokenBalance,\n    uint256 recipientDiscountTokenBalance,\n    uint256 amount\n  ) external override onlyDiscountToken {\n    // Skipping computation in case of discount token self-transfer\n    if (sender == recipient) {\n      return;\n    }\n\n    uint256 senderPreviousScaledBalance = super.balanceOf(sender);\n    uint256 recipientPreviousScaledBalance = super.balanceOf(recipient);\n\n    // Skipping computation in case users do not have a position\n    if (senderPreviousScaledBalance == 0 && recipientPreviousScaledBalance == 0) {\n      return;\n    }\n\n    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);\n\n    uint256 balanceIncrease;\n    uint256 discountScaled;\n\n    if (senderPreviousScaledBalance > 0) {\n      (balanceIncrease, discountScaled) = _accrueDebtOnAction(\n        sender,\n        senderPreviousScaledBalance,\n        _ghoUserState[sender].discountPercent,\n        index\n      );\n\n      _burn(sender, discountScaled.toUint128());\n\n      _refreshDiscountPercent(\n        sender,\n        super.balanceOf(sender).rayMul(index),\n        senderDiscountTokenBalance - amount,\n        _ghoUserState[sender].discountPercent\n      );\n\n      emit Transfer(address(0), sender, balanceIncrease);\n      emit Mint(address(0), sender, balanceIncrease, balanceIncrease, index);\n    }\n\n    if (recipientPreviousScaledBalance > 0) {\n      (balanceIncrease, discountScaled) = _accrueDebtOnAction(\n        recipient,\n        recipientPreviousScaledBalance,\n        _ghoUserState[recipient].discountPercent,\n        index\n      );\n\n      _burn(recipient, discountScaled.toUint128());\n\n      _refreshDiscountPercent(\n        recipient,\n        super.balanceOf(recipient).rayMul(index),\n        recipientDiscountTokenBalance + amount,\n        _ghoUserState[recipient].discountPercent\n      );\n\n      emit Transfer(address(0), recipient, balanceIncrease);\n      emit Mint(address(0), recipient, balanceIncrease, balanceIncrease, index);\n    }\n  }\n\n  /// @inheritdoc IGhoVariableDebtToken\n  function getDiscountPercent(address user) external view override returns (uint256) {\n    return _ghoUserState[user].discountPercent;\n  }\n\n  /// @inheritdoc IGhoVariableDebtToken\n  function getBalanceFromInterest(address user) external view override returns (uint256) {\n    return _ghoUserState[user].accumulatedDebtInterest;\n  }\n\n  /// @inheritdoc IGhoVariableDebtToken\n  function decreaseBalanceFromInterest(address user, uint256 amount) external override onlyAToken {\n    _ghoUserState[user].accumulatedDebtInterest = (_ghoUserState[user].accumulatedDebtInterest -\n      amount).toUint128();\n  }\n\n  /// @inheritdoc IGhoVariableDebtToken\n  function rebalanceUserDiscountPercent(address user) external override {\n    uint256 index = POOL.getReserveNormalizedVariableDebt(_underlyingAsset);\n    uint256 previousScaledBalance = super.balanceOf(user);\n    uint256 discountPercent = _ghoUserState[user].discountPercent;\n\n    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(\n      user,\n      previousScaledBalance,\n      discountPercent,\n      index\n    );\n\n    _burn(user, discountScaled.toUint128());\n\n    _refreshDiscountPercent(\n      user,\n      super.balanceOf(user).rayMul(index),\n      _discountToken.balanceOf(user),\n      discountPercent\n    );\n\n    emit Transfer(address(0), user, balanceIncrease);\n    emit Mint(address(0), user, balanceIncrease, balanceIncrease, index);\n  }\n\n  /**\n   * @notice Implements the basic logic to mint a scaled balance token.\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the scaled tokens\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function _mintScaled(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) internal override returns (bool) {\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.INVALID_MINT_AMOUNT);\n\n    uint256 previousScaledBalance = super.balanceOf(onBehalfOf);\n    uint256 discountPercent = _ghoUserState[onBehalfOf].discountPercent;\n    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(\n      onBehalfOf,\n      previousScaledBalance,\n      discountPercent,\n      index\n    );\n\n    // confirm the amount being borrowed is greater than the discount\n    if (amountScaled > discountScaled) {\n      _mint(onBehalfOf, (amountScaled - discountScaled).toUint128());\n    } else {\n      _burn(onBehalfOf, (discountScaled - amountScaled).toUint128());\n    }\n\n    _refreshDiscountPercent(\n      onBehalfOf,\n      super.balanceOf(onBehalfOf).rayMul(index),\n      _discountToken.balanceOf(onBehalfOf),\n      discountPercent\n    );\n\n    uint256 amountToMint = amount + balanceIncrease;\n    emit Transfer(address(0), onBehalfOf, amountToMint);\n    emit Mint(caller, onBehalfOf, amountToMint, balanceIncrease, index);\n\n    return true;\n  }\n\n  /**\n   * @notice Implements the basic logic to burn a scaled balance token.\n   * @dev In some instances, a burn transaction will emit a mint event\n   * if the amount to burn is less than the interest that the user accrued\n   * @param user The user which debt is burnt\n   * @param target The address that will receive the underlying, if any\n   * @param amount The amount getting burned\n   * @param index The variable debt index of the reserve\n   */\n  function _burnScaled(\n    address user,\n    address target,\n    uint256 amount,\n    uint256 index\n  ) internal override {\n    uint256 amountScaled = amount.rayDiv(index);\n    require(amountScaled != 0, Errors.INVALID_BURN_AMOUNT);\n\n    uint256 balanceBeforeBurn = balanceOf(user);\n\n    uint256 previousScaledBalance = super.balanceOf(user);\n    uint256 discountPercent = _ghoUserState[user].discountPercent;\n    (uint256 balanceIncrease, uint256 discountScaled) = _accrueDebtOnAction(\n      user,\n      previousScaledBalance,\n      discountPercent,\n      index\n    );\n\n    if (amount == balanceBeforeBurn) {\n      _burn(user, previousScaledBalance.toUint128());\n    } else {\n      _burn(user, (amountScaled + discountScaled).toUint128());\n    }\n\n    _refreshDiscountPercent(\n      user,\n      super.balanceOf(user).rayMul(index),\n      _discountToken.balanceOf(user),\n      discountPercent\n    );\n\n    if (balanceIncrease > amount) {\n      uint256 amountToMint = balanceIncrease - amount;\n      emit Transfer(address(0), user, amountToMint);\n      emit Mint(user, user, amountToMint, balanceIncrease, index);\n    } else {\n      uint256 amountToBurn = amount - balanceIncrease;\n      emit Transfer(user, address(0), amountToBurn);\n      emit Burn(user, target, amountToBurn, balanceIncrease, index);\n    }\n  }\n\n  /**\n   * @dev Accumulates debt of the user since last action.\n   * @dev It skips applying discount in case there is no balance increase or discount percent is zero.\n   * @param user The address of the user\n   * @param previousScaledBalance The previous scaled balance of the user\n   * @param discountPercent The discount percent\n   * @param index The variable debt index of the reserve\n   * @return The increase in scaled balance since the last action of `user`\n   * @return The discounted amount in scaled balance off the balance increase\n   */\n  function _accrueDebtOnAction(\n    address user,\n    uint256 previousScaledBalance,\n    uint256 discountPercent,\n    uint256 index\n  ) internal returns (uint256, uint256) {\n    uint256 balanceIncrease = previousScaledBalance.rayMul(index) -\n      previousScaledBalance.rayMul(_userState[user].additionalData);\n\n    uint256 discountScaled = 0;\n    if (balanceIncrease != 0 && discountPercent != 0) {\n      uint256 discount = balanceIncrease.percentMul(discountPercent);\n      discountScaled = discount.rayDiv(index);\n      balanceIncrease = balanceIncrease - discount;\n    }\n\n    _userState[user].additionalData = index.toUint128();\n\n    _ghoUserState[user].accumulatedDebtInterest = (balanceIncrease +\n      _ghoUserState[user].accumulatedDebtInterest).toUint128();\n\n    return (balanceIncrease, discountScaled);\n  }\n\n  /**\n   * @dev Updates the discount percent of the user according to current discount rate strategy\n   * @param user The address of the user\n   * @param balance The debt balance of the user\n   * @param discountTokenBalance The discount token balance of the user\n   * @param previousDiscountPercent The previous discount percent of the user\n   */\n  function _refreshDiscountPercent(\n    address user,\n    uint256 balance,\n    uint256 discountTokenBalance,\n    uint256 previousDiscountPercent\n  ) internal {\n    uint256 newDiscountPercent = _discountRateStrategy.calculateDiscountRate(\n      balance,\n      discountTokenBalance\n    );\n\n    if (previousDiscountPercent != newDiscountPercent) {\n      _ghoUserState[user].discountPercent = newDiscountPercent.toUint16();\n      emit DiscountPercentUpdated(user, previousDiscountPercent, newDiscountPercent);\n    }\n  }\n}\n"
    },
    "src/contracts/facilitators/aave/tokens/interfaces/IGhoAToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAToken} from '@aave/core-v3/contracts/interfaces/IAToken.sol';\nimport {IGhoFacilitator} from '../../../../gho/interfaces/IGhoFacilitator.sol';\n\n/**\n * @title IGhoAToken\n * @author Aave\n * @notice Defines the basic interface of the GhoAToken\n */\ninterface IGhoAToken is IAToken, IGhoFacilitator {\n  /**\n   * @dev Emitted when variable debt contract is set\n   * @param variableDebtToken The address of the GhoVariableDebtToken contract\n   */\n  event VariableDebtTokenSet(address indexed variableDebtToken);\n\n  /**\n   * @notice Sets a reference to the GHO variable debt token\n   * @param ghoVariableDebtToken The address of the GhoVariableDebtToken contract\n   */\n  function setVariableDebtToken(address ghoVariableDebtToken) external;\n\n  /**\n   * @notice Returns the address of the GHO variable debt token\n   * @return The address of the GhoVariableDebtToken contract\n   */\n  function getVariableDebtToken() external view returns (address);\n}\n"
    },
    "src/contracts/facilitators/aave/tokens/interfaces/IGhoVariableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IVariableDebtToken} from '@aave/core-v3/contracts/interfaces/IVariableDebtToken.sol';\n\n/**\n * @title IGhoVariableDebtToken\n * @author Aave\n * @notice Defines the basic interface of the VariableDebtToken\n */\ninterface IGhoVariableDebtToken is IVariableDebtToken {\n  /**\n   * @dev Emitted when the address of the GHO AToken is set\n   * @param aToken The address of the GhoAToken contract\n   */\n  event ATokenSet(address indexed aToken);\n\n  /**\n   * @dev Emitted when the GhoDiscountRateStrategy is updated\n   * @param oldDiscountRateStrategy The address of the old GhoDiscountRateStrategy\n   * @param newDiscountRateStrategy The address of the new GhoDiscountRateStrategy\n   */\n  event DiscountRateStrategyUpdated(\n    address indexed oldDiscountRateStrategy,\n    address indexed newDiscountRateStrategy\n  );\n\n  /**\n   * @dev Emitted when the Discount Token is updated\n   * @param oldDiscountToken The address of the old discount token\n   * @param newDiscountToken The address of the new discount token\n   */\n  event DiscountTokenUpdated(address indexed oldDiscountToken, address indexed newDiscountToken);\n\n  /**\n   * @dev Emitted when a user's discount is updated\n   * @param user The address of the user\n   * @param oldDiscountPercent The old discount percent of the user\n   * @param newDiscountPercent The new discount percent of the user\n   */\n  event DiscountPercentUpdated(\n    address indexed user,\n    uint256 oldDiscountPercent,\n    uint256 indexed newDiscountPercent\n  );\n\n  /**\n   * @notice Sets a reference to the GHO AToken\n   * @param ghoAToken The address of the GhoAToken contract\n   */\n  function setAToken(address ghoAToken) external;\n\n  /**\n   * @notice Returns the address of the GHO AToken\n   * @return The address of the GhoAToken contract\n   */\n  function getAToken() external view returns (address);\n\n  /**\n   * @notice Updates the Discount Rate Strategy\n   * @param newDiscountRateStrategy The address of DiscountRateStrategy contract\n   */\n  function updateDiscountRateStrategy(address newDiscountRateStrategy) external;\n\n  /**\n   * @notice Returns the address of the Discount Rate Strategy\n   * @return The address of DiscountRateStrategy contract\n   */\n  function getDiscountRateStrategy() external view returns (address);\n\n  /**\n   * @notice Updates the Discount Token\n   * @param newDiscountToken The address of the DiscountToken contract\n   */\n  function updateDiscountToken(address newDiscountToken) external;\n\n  /**\n   * @notice Returns the address of the Discount Token\n   * @return address The address of DiscountToken\n   */\n  function getDiscountToken() external view returns (address);\n\n  /**\n   * @notice Updates the discount percents of the users when a discount token transfer occurs\n   * @dev To be executed before the token transfer happens\n   * @param sender The address of sender\n   * @param recipient The address of recipient\n   * @param senderDiscountTokenBalance The sender discount token balance\n   * @param recipientDiscountTokenBalance The recipient discount token balance\n   * @param amount The amount of discount token being transferred\n   */\n  function updateDiscountDistribution(\n    address sender,\n    address recipient,\n    uint256 senderDiscountTokenBalance,\n    uint256 recipientDiscountTokenBalance,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Returns the discount percent being applied to the debt interest of the user\n   * @param user The address of the user\n   * @return The discount percent (expressed in bps)\n   */\n  function getDiscountPercent(address user) external view returns (uint256);\n\n  /*\n   * @dev Returns the amount of interests accumulated by the user\n   * @param user The address of the user\n   * @return The amount of interests accumulated by the user\n   */\n  function getBalanceFromInterest(address user) external view returns (uint256);\n\n  /**\n   * @dev Decrease the amount of interests accumulated by the user\n   * @param user The address of the user\n   * @param amount The value to be decrease\n   */\n  function decreaseBalanceFromInterest(address user, uint256 amount) external;\n\n  /**\n   * @notice Rebalances the discount percent of a user\n   * @param user The address of the user\n   */\n  function rebalanceUserDiscountPercent(address user) external;\n}\n"
    },
    "src/contracts/facilitators/flashMinter/GhoFlashMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IACLManager} from '@aave/core-v3/contracts/interfaces/IACLManager.sol';\nimport {IPoolAddressesProvider} from '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\nimport {PercentageMath} from '@aave/core-v3/contracts/protocol/libraries/math/PercentageMath.sol';\nimport {IERC3156FlashBorrower} from '@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol';\nimport {IERC3156FlashLender} from '@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol';\nimport {IGhoToken} from '../../gho/interfaces/IGhoToken.sol';\nimport {IGhoFacilitator} from '../../gho/interfaces/IGhoFacilitator.sol';\nimport {IGhoFlashMinter} from './interfaces/IGhoFlashMinter.sol';\n\n/**\n * @title GhoFlashMinter\n * @author Aave\n * @notice Contract that enables FlashMinting of GHO.\n * @dev Based heavily on the EIP3156 reference implementation\n */\ncontract GhoFlashMinter is IGhoFlashMinter {\n  using PercentageMath for uint256;\n\n  // @inheritdoc IGhoFlashMinter\n  bytes32 public constant CALLBACK_SUCCESS = keccak256('ERC3156FlashBorrower.onFlashLoan');\n\n  // @inheritdoc IGhoFlashMinter\n  uint256 public constant MAX_FEE = 1e4;\n\n  // @inheritdoc IGhoFlashMinter\n  IPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\n\n  // @inheritdoc IGhoFlashMinter\n  IGhoToken public immutable GHO_TOKEN;\n\n  // The Access Control List manager contract\n  IACLManager private immutable ACL_MANAGER;\n\n  // The flashmint fee, expressed in bps (a value of 10000 results in 100.00%)\n  uint256 private _fee;\n\n  // The GHO treasury, the recipient of fee distributions\n  address private _ghoTreasury;\n\n  /**\n   * @dev Only pool admin can call functions marked by this modifier.\n   */\n  modifier onlyPoolAdmin() {\n    require(ACL_MANAGER.isPoolAdmin(msg.sender), 'CALLER_NOT_POOL_ADMIN');\n    _;\n  }\n\n  /**\n   * @dev Constructor\n   * @param ghoToken The address of the GHO token contract\n   * @param ghoTreasury The address of the GHO treasury\n   * @param fee The percentage of the flash-mint amount that needs to be repaid, on top of the principal (in bps)\n   * @param addressesProvider The address of the Aave PoolAddressesProvider\n   */\n  constructor(address ghoToken, address ghoTreasury, uint256 fee, address addressesProvider) {\n    require(fee <= MAX_FEE, 'FlashMinter: Fee out of range');\n    GHO_TOKEN = IGhoToken(ghoToken);\n    _updateGhoTreasury(ghoTreasury);\n    _updateFee(fee);\n    ADDRESSES_PROVIDER = IPoolAddressesProvider(addressesProvider);\n    ACL_MANAGER = IACLManager(IPoolAddressesProvider(addressesProvider).getACLManager());\n  }\n\n  /// @inheritdoc IERC3156FlashLender\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override returns (bool) {\n    require(token == address(GHO_TOKEN), 'FlashMinter: Unsupported currency');\n\n    uint256 fee = ACL_MANAGER.isFlashBorrower(msg.sender) ? 0 : _flashFee(amount);\n    GHO_TOKEN.mint(address(receiver), amount);\n\n    require(\n      receiver.onFlashLoan(msg.sender, address(GHO_TOKEN), amount, fee, data) == CALLBACK_SUCCESS,\n      'FlashMinter: Callback failed'\n    );\n\n    GHO_TOKEN.transferFrom(address(receiver), address(this), amount + fee);\n    GHO_TOKEN.burn(amount);\n\n    emit FlashMint(address(receiver), msg.sender, address(GHO_TOKEN), amount, fee);\n\n    return true;\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function distributeFeesToTreasury() external override {\n    uint256 balance = GHO_TOKEN.balanceOf(address(this));\n    GHO_TOKEN.transfer(_ghoTreasury, balance);\n    emit FeesDistributedToTreasury(_ghoTreasury, address(GHO_TOKEN), balance);\n  }\n\n  // @inheritdoc IGhoFlashMinter\n  function updateFee(uint256 newFee) external override onlyPoolAdmin {\n    _updateFee(newFee);\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function updateGhoTreasury(address newGhoTreasury) external override onlyPoolAdmin {\n    _updateGhoTreasury(newGhoTreasury);\n  }\n\n  /// @inheritdoc IERC3156FlashLender\n  function maxFlashLoan(address token) external view override returns (uint256) {\n    if (token != address(GHO_TOKEN)) {\n      return 0;\n    } else {\n      (uint256 capacity, uint256 level) = GHO_TOKEN.getFacilitatorBucket(address(this));\n      return capacity > level ? capacity - level : 0;\n    }\n  }\n\n  /// @inheritdoc IERC3156FlashLender\n  function flashFee(address token, uint256 amount) external view override returns (uint256) {\n    require(token == address(GHO_TOKEN), 'FlashMinter: Unsupported currency');\n    return ACL_MANAGER.isFlashBorrower(msg.sender) ? 0 : _flashFee(amount);\n  }\n\n  /// @inheritdoc IGhoFlashMinter\n  function getFee() external view override returns (uint256) {\n    return _fee;\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function getGhoTreasury() external view override returns (address) {\n    return _ghoTreasury;\n  }\n\n  /**\n   * @notice Returns the fee to charge for a given flashloan.\n   * @dev Internal function with no checks.\n   * @param amount The amount of tokens to be borrowed.\n   * @return The amount of `token` to be charged for the flashloan, on top of the returned principal.\n   */\n  function _flashFee(uint256 amount) internal view returns (uint256) {\n    return amount.percentMul(_fee);\n  }\n\n  function _updateFee(uint256 newFee) internal {\n    require(newFee <= MAX_FEE, 'FlashMinter: Fee out of range');\n    uint256 oldFee = _fee;\n    _fee = newFee;\n    emit FeeUpdated(oldFee, newFee);\n  }\n\n  function _updateGhoTreasury(address newGhoTreasury) internal {\n    address oldGhoTreasury = _ghoTreasury;\n    _ghoTreasury = newGhoTreasury;\n    emit GhoTreasuryUpdated(oldGhoTreasury, newGhoTreasury);\n  }\n}\n"
    },
    "src/contracts/facilitators/flashMinter/interfaces/IGhoFlashMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC3156FlashLender} from '@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol';\nimport {IPoolAddressesProvider} from '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\nimport {IGhoFacilitator} from '../../../gho/interfaces/IGhoFacilitator.sol';\nimport {IGhoToken} from '../../../gho/interfaces/IGhoToken.sol';\n\n/**\n * @title IGhoFlashMinter\n * @author Aave\n * @notice Defines the behavior of the GHO Flash Minter\n */\ninterface IGhoFlashMinter is IERC3156FlashLender, IGhoFacilitator {\n  /**\n   * @dev Emitted when the percentage fee is updated\n   * @param oldFee The old fee (in bps)\n   * @param newFee The new fee (in bps)\n   */\n  event FeeUpdated(uint256 oldFee, uint256 newFee);\n\n  /**\n   * @dev Emitted when a FlashMint occurs\n   * @param receiver The receiver of the FlashMinted tokens (it is also the receiver of the callback)\n   * @param initiator The address initiating the FlashMint\n   * @param asset The asset being FlashMinted. Always GHO.\n   * @param amount The principal being FlashMinted\n   * @param fee The fee returned on top of the principal\n   */\n  event FlashMint(\n    address indexed receiver,\n    address indexed initiator,\n    address asset,\n    uint256 indexed amount,\n    uint256 fee\n  );\n\n  /**\n   * @notice Returns the required return value for a successful flashmint\n   * @return The required callback, the keccak256 hash of 'ERC3156FlashBorrower.onFlashLoan'\n   */\n  function CALLBACK_SUCCESS() external view returns (bytes32);\n\n  /**\n   * @notice Returns the maximum value the fee can be set to\n   * @return The maximum percentage fee of the flash-minted amount that the flashFee can be set to (in bps).\n   */\n  function MAX_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the Aave Pool Addresses Provider contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the address of the GHO token contract\n   * @return The address of the GhoToken\n   */\n  function GHO_TOKEN() external view returns (IGhoToken);\n\n  /**\n   * @notice Updates the percentage fee. It is the percentage of the flash-minted amount that needs to be repaid.\n   * @dev The fee is expressed in bps. A value of 100, results in 1.00%\n   * @param newFee The new percentage fee (in bps)\n   */\n  function updateFee(uint256 newFee) external;\n\n  /**\n   * @notice Returns the percentage of each flash mint taken as a fee\n   * @return The percentage fee of the flash-minted amount that needs to be repaid, on top of the principal (in bps).\n   */\n  function getFee() external view returns (uint256);\n}\n"
    },
    "src/contracts/facilitators/gsm/dependencies/chainlink/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Chainlink Contracts v0.8\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(\n    bytes calldata checkData\n  ) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "src/contracts/facilitators/gsm/feeStrategy/FixedFeeStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\nimport {PercentageMath} from '@aave/core-v3/contracts/protocol/libraries/math/PercentageMath.sol';\nimport {IGsmFeeStrategy} from './interfaces/IGsmFeeStrategy.sol';\n\n/**\n * @title FixedFeeStrategy\n * @author Aave\n * @notice Fee strategy using a fixed rate to calculate buy/sell fees\n */\ncontract FixedFeeStrategy is IGsmFeeStrategy {\n  using Math for uint256;\n\n  uint256 internal constant MAXIMUM_FEE_PERCENT = 5000;\n\n  uint256 internal immutable _buyFee;\n  uint256 internal immutable _sellFee;\n\n  /**\n   * @dev Constructor\n   * @dev Fees must be lower than 5000 bps (e.g. 50.00%)\n   * @param buyFee The fee paid when buying the underlying asset in exchange for GHO, expressed in bps\n   * @param sellFee The fee paid when selling the underlying asset in exchange for GHO, expressed in bps\n   */\n  constructor(uint256 buyFee, uint256 sellFee) {\n    require(buyFee < MAXIMUM_FEE_PERCENT, 'INVALID_BUY_FEE');\n    require(sellFee < MAXIMUM_FEE_PERCENT, 'INVALID_SELL_FEE');\n    require(buyFee > 0 || sellFee > 0, 'MUST_HAVE_ONE_NONZERO_FEE');\n    _buyFee = buyFee;\n    _sellFee = sellFee;\n  }\n\n  /// @inheritdoc IGsmFeeStrategy\n  function getBuyFee(uint256 grossAmount) external view returns (uint256) {\n    return grossAmount.mulDiv(_buyFee, PercentageMath.PERCENTAGE_FACTOR, Math.Rounding.Up);\n  }\n\n  /// @inheritdoc IGsmFeeStrategy\n  function getSellFee(uint256 grossAmount) external view returns (uint256) {\n    return grossAmount.mulDiv(_sellFee, PercentageMath.PERCENTAGE_FACTOR, Math.Rounding.Up);\n  }\n\n  /// @inheritdoc IGsmFeeStrategy\n  function getGrossAmountFromTotalBought(uint256 totalAmount) external view returns (uint256) {\n    if (totalAmount == 0) {\n      return 0;\n    } else if (_buyFee == 0) {\n      return totalAmount;\n    } else {\n      return\n        totalAmount.mulDiv(\n          PercentageMath.PERCENTAGE_FACTOR,\n          PercentageMath.PERCENTAGE_FACTOR + _buyFee,\n          Math.Rounding.Down\n        );\n    }\n  }\n\n  /// @inheritdoc IGsmFeeStrategy\n  function getGrossAmountFromTotalSold(uint256 totalAmount) external view returns (uint256) {\n    if (totalAmount == 0) {\n      return 0;\n    } else if (_sellFee == 0) {\n      return totalAmount;\n    } else {\n      return\n        totalAmount.mulDiv(\n          PercentageMath.PERCENTAGE_FACTOR,\n          PercentageMath.PERCENTAGE_FACTOR - _sellFee,\n          Math.Rounding.Up\n        );\n    }\n  }\n}\n"
    },
    "src/contracts/facilitators/gsm/feeStrategy/FixedFeeStrategyFactory.sol": {
      "content": "/// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {VersionedInitializable} from '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {IFixedFeeStrategyFactory} from './interfaces/IFixedFeeStrategyFactory.sol';\nimport {IGsmFeeStrategy} from './interfaces/IGsmFeeStrategy.sol';\nimport {FixedFeeStrategy} from './FixedFeeStrategy.sol';\n\n/**\n * @title FixedFeeStrategyFactory\n * @author Aave Labs\n * @notice Factory contract to create and keep record of Gsm FixedFeeStrategy contracts\n */\ncontract FixedFeeStrategyFactory is VersionedInitializable, IFixedFeeStrategyFactory {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  // Mapping of fee strategy contracts by buy and sell fees (buyFee => sellFee => feeStrategy)\n  mapping(uint256 => mapping(uint256 => address)) internal _gsmFeeStrategiesByFees;\n  EnumerableSet.AddressSet internal _gsmFeeStrategies;\n\n  /**\n   * @dev Initializer\n   * @param feeStrategiesList List of fee strategies\n   * @dev Assumes that the addresses provided are deployed FixedFeeStrategy contracts\n   */\n  function initialize(address[] memory feeStrategiesList) external initializer {\n    for (uint256 i = 0; i < feeStrategiesList.length; i++) {\n      address feeStrategy = feeStrategiesList[i];\n      uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n      uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n\n      _gsmFeeStrategiesByFees[buyFee][sellFee] = feeStrategy;\n      _gsmFeeStrategies.add(feeStrategy);\n\n      emit FeeStrategyCreated(feeStrategy, buyFee, sellFee);\n    }\n  }\n\n  ///@inheritdoc IFixedFeeStrategyFactory\n  function createStrategies(\n    uint256[] memory buyFeeList,\n    uint256[] memory sellFeeList\n  ) external returns (address[] memory) {\n    require(buyFeeList.length == sellFeeList.length, 'INVALID_FEE_LIST');\n    address[] memory strategies = new address[](buyFeeList.length);\n    for (uint256 i = 0; i < buyFeeList.length; i++) {\n      uint256 buyFee = buyFeeList[i];\n      uint256 sellFee = sellFeeList[i];\n      address cachedStrategy = _gsmFeeStrategiesByFees[buyFee][sellFee];\n\n      if (cachedStrategy == address(0)) {\n        cachedStrategy = address(new FixedFeeStrategy(buyFee, sellFee));\n        _gsmFeeStrategiesByFees[buyFee][sellFee] = cachedStrategy;\n        _gsmFeeStrategies.add(cachedStrategy);\n\n        emit FeeStrategyCreated(cachedStrategy, buyFee, sellFee);\n      }\n\n      strategies[i] = cachedStrategy;\n    }\n\n    return strategies;\n  }\n\n  ///@inheritdoc IFixedFeeStrategyFactory\n  function getFixedFeeStrategies() external view returns (address[] memory) {\n    return _gsmFeeStrategies.values();\n  }\n\n  ///@inheritdoc IFixedFeeStrategyFactory\n  function getFixedFeeStrategy(uint256 buyFee, uint256 sellFee) external view returns (address) {\n    return _gsmFeeStrategiesByFees[buyFee][sellFee];\n  }\n\n  ///@inheritdoc IFixedFeeStrategyFactory\n  function REVISION() public pure virtual override returns (uint256) {\n    return 1;\n  }\n\n  /// @inheritdoc VersionedInitializable\n  function getRevision() internal pure virtual override returns (uint256) {\n    return REVISION();\n  }\n}\n"
    },
    "src/contracts/facilitators/gsm/feeStrategy/interfaces/IFixedFeeStrategyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IFixedFeeStrategyFactory\n * @author Aave Labs\n * @notice Defines the interface of the FixedFeeStrategyFactory\n */\ninterface IFixedFeeStrategyFactory {\n  /**\n   * @dev Emitted when a new strategy is created\n   * @param strategy The address of the new Gsm fee strategy\n   * @param buyFee The buy fee of the new strategy\n   * @param sellFee The sell fee of the new strategy\n   */\n  event FeeStrategyCreated(\n    address indexed strategy,\n    uint256 indexed buyFee,\n    uint256 indexed sellFee\n  );\n\n  /**\n   * @notice Creates new Gsm Fee strategy contracts from lists of buy and sell fees\n   * @dev Returns the address of a cached contract if a strategy with same fees already exists\n   * @param buyFeeList The list of buy fees for Gsm fee strategies\n   * @param sellFeeList The list of sell fees for Gsm fee strategies\n   * @return The list of Gsm fee strategy contracts\n   */\n  function createStrategies(\n    uint256[] memory buyFeeList,\n    uint256[] memory sellFeeList\n  ) external returns (address[] memory);\n\n  /**\n   * @notice Returns all the fee strategy contracts of the factory\n   * @return The list of fee strategy contracts\n   */\n  function getFixedFeeStrategies() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the fee strategy contract which corresponds to the given fees.\n   * @dev Returns `address(0)` if there is no fee strategy for the given fees\n   * @param buyFee The buy fee of the fee strategy contract\n   * @param sellFee The sell fee of the fee strategy contract\n   * @return The address of the fee strategy contract\n   */\n  function getFixedFeeStrategy(uint256 buyFee, uint256 sellFee) external view returns (address);\n\n  /**\n   * @notice Returns the GsmFeeStrategyFactory revision number\n   * @return The revision number\n   */\n  function REVISION() external pure returns (uint256);\n}\n"
    },
    "src/contracts/facilitators/gsm/feeStrategy/interfaces/IGsmFeeStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IGsmFeeStrategy\n * @author Aave\n * @notice Defines the behaviour of Fee Strategies\n * @dev Functions' logic must be invertible, being possible to calculate the fee amount based on the gross amount, and\n * the other way round.\n * @dev All math operations must round up, favoring the protocol.\n */\ninterface IGsmFeeStrategy {\n  /**\n   * @notice Returns the fee to be applied when buying an underlying asset in exchange for GHO\n   * @param grossAmount The amount of GHO being sold for the underlying asset\n   * @return The fee amount of GHO\n   */\n  function getBuyFee(uint256 grossAmount) external view returns (uint256);\n\n  /**\n   * @notice Returns the fee to be applied when buying GHO in exchange for an underlying asset\n   * @param grossAmount The amount of underlying, converted to GHO, being sold\n   * @return The fee amount of GHO\n   */\n  function getSellFee(uint256 grossAmount) external view returns (uint256);\n\n  /**\n   * @notice Returns the gross amount of GHO being bought based on the total bought amount\n   * @param totalAmount The total amount of GHO being bought (gross amount, GHO bought plus fee)\n   * @return The gross amount of GHO being bought (total amount minus fee)\n   */\n  function getGrossAmountFromTotalBought(uint256 totalAmount) external view returns (uint256);\n\n  /**\n   * @notice Returns the amount of GHO being sold based on the total sold amount\n   * @param totalAmount The total amount of GHO being sold (gross amount, GHO sold minus fee)\n   * @return The gross amount of GHO being sold (total amount plus fee)\n   */\n  function getGrossAmountFromTotalSold(uint256 totalAmount) external view returns (uint256);\n}\n"
    },
    "src/contracts/facilitators/gsm/Gsm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {VersionedInitializable} from '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {IERC20} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol';\nimport {GPv2SafeERC20} from '@aave/core-v3/contracts/dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {EIP712} from '@openzeppelin/contracts/utils/cryptography/EIP712.sol';\nimport {SignatureChecker} from '@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/math/SafeCast.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {IGhoFacilitator} from '../../gho/interfaces/IGhoFacilitator.sol';\nimport {IGhoToken} from '../../gho/interfaces/IGhoToken.sol';\nimport {IGsmPriceStrategy} from './priceStrategy/interfaces/IGsmPriceStrategy.sol';\nimport {IGsmFeeStrategy} from './feeStrategy/interfaces/IGsmFeeStrategy.sol';\nimport {IGsm} from './interfaces/IGsm.sol';\n\n/**\n * @title Gsm\n * @author Aave\n * @notice GHO Stability Module. It provides buy/sell facilities to go to/from an underlying asset to/from GHO.\n * @dev To be covered by a proxy contract.\n */\ncontract Gsm is AccessControl, VersionedInitializable, EIP712, IGsm {\n  using GPv2SafeERC20 for IERC20;\n  using SafeCast for uint256;\n\n  /// @inheritdoc IGsm\n  bytes32 public constant CONFIGURATOR_ROLE = keccak256('CONFIGURATOR_ROLE');\n\n  /// @inheritdoc IGsm\n  bytes32 public constant TOKEN_RESCUER_ROLE = keccak256('TOKEN_RESCUER_ROLE');\n\n  /// @inheritdoc IGsm\n  bytes32 public constant SWAP_FREEZER_ROLE = keccak256('SWAP_FREEZER_ROLE');\n\n  /// @inheritdoc IGsm\n  bytes32 public constant LIQUIDATOR_ROLE = keccak256('LIQUIDATOR_ROLE');\n\n  /// @inheritdoc IGsm\n  bytes32 public constant BUY_ASSET_WITH_SIG_TYPEHASH =\n    keccak256(\n      'BuyAssetWithSig(address originator,uint256 minAmount,address receiver,uint256 nonce,uint256 deadline)'\n    );\n\n  /// @inheritdoc IGsm\n  bytes32 public constant SELL_ASSET_WITH_SIG_TYPEHASH =\n    keccak256(\n      'SellAssetWithSig(address originator,uint256 maxAmount,address receiver,uint256 nonce,uint256 deadline)'\n    );\n\n  /// @inheritdoc IGsm\n  address public immutable GHO_TOKEN;\n\n  /// @inheritdoc IGsm\n  address public immutable UNDERLYING_ASSET;\n\n  /// @inheritdoc IGsm\n  address public immutable PRICE_STRATEGY;\n\n  /// @inheritdoc IGsm\n  mapping(address => uint256) public nonces;\n\n  address internal _ghoTreasury;\n  address internal _feeStrategy;\n  bool internal _isFrozen;\n  bool internal _isSeized;\n  uint128 internal _exposureCap;\n  uint128 internal _currentExposure;\n  uint128 internal _accruedFees;\n\n  /**\n   * @dev Require GSM to not be frozen for functions marked by this modifier\n   */\n  modifier notFrozen() {\n    require(!_isFrozen, 'GSM_FROZEN');\n    _;\n  }\n\n  /**\n   * @dev Require GSM to not be seized for functions marked by this modifier\n   */\n  modifier notSeized() {\n    require(!_isSeized, 'GSM_SEIZED');\n    _;\n  }\n\n  /**\n   * @dev Constructor\n   * @param ghoToken The address of the GHO token contract\n   * @param underlyingAsset The address of the collateral asset\n   * @param priceStrategy The address of the price strategy\n   */\n  constructor(address ghoToken, address underlyingAsset, address priceStrategy) EIP712('GSM', '1') {\n    require(ghoToken != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    require(underlyingAsset != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    require(\n      IGsmPriceStrategy(priceStrategy).UNDERLYING_ASSET() == underlyingAsset,\n      'INVALID_PRICE_STRATEGY'\n    );\n    GHO_TOKEN = ghoToken;\n    UNDERLYING_ASSET = underlyingAsset;\n    PRICE_STRATEGY = priceStrategy;\n  }\n\n  /**\n   * @notice GSM initializer\n   * @param admin The address of the default admin role\n   * @param ghoTreasury The address of the GHO treasury\n   * @param exposureCap Maximum amount of user-supplied underlying asset in GSM\n   */\n  function initialize(\n    address admin,\n    address ghoTreasury,\n    uint128 exposureCap\n  ) external initializer {\n    require(admin != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _grantRole(CONFIGURATOR_ROLE, admin);\n    _updateGhoTreasury(ghoTreasury);\n    _updateExposureCap(exposureCap);\n  }\n\n  /// @inheritdoc IGsm\n  function buyAsset(\n    uint256 minAmount,\n    address receiver\n  ) external notFrozen notSeized returns (uint256, uint256) {\n    return _buyAsset(msg.sender, minAmount, receiver);\n  }\n\n  /// @inheritdoc IGsm\n  function buyAssetWithSig(\n    address originator,\n    uint256 minAmount,\n    address receiver,\n    uint256 deadline,\n    bytes calldata signature\n  ) external notFrozen notSeized returns (uint256, uint256) {\n    require(deadline >= block.timestamp, 'SIGNATURE_DEADLINE_EXPIRED');\n    bytes32 digest = keccak256(\n      abi.encode(\n        '\\x19\\x01',\n        _domainSeparatorV4(),\n        BUY_ASSET_WITH_SIG_TYPEHASH,\n        abi.encode(originator, minAmount, receiver, nonces[originator]++, deadline)\n      )\n    );\n    require(\n      SignatureChecker.isValidSignatureNow(originator, digest, signature),\n      'SIGNATURE_INVALID'\n    );\n\n    return _buyAsset(originator, minAmount, receiver);\n  }\n\n  /// @inheritdoc IGsm\n  function sellAsset(\n    uint256 maxAmount,\n    address receiver\n  ) external notFrozen notSeized returns (uint256, uint256) {\n    return _sellAsset(msg.sender, maxAmount, receiver);\n  }\n\n  /// @inheritdoc IGsm\n  function sellAssetWithSig(\n    address originator,\n    uint256 maxAmount,\n    address receiver,\n    uint256 deadline,\n    bytes calldata signature\n  ) external notFrozen notSeized returns (uint256, uint256) {\n    require(deadline >= block.timestamp, 'SIGNATURE_DEADLINE_EXPIRED');\n    bytes32 digest = keccak256(\n      abi.encode(\n        '\\x19\\x01',\n        _domainSeparatorV4(),\n        SELL_ASSET_WITH_SIG_TYPEHASH,\n        abi.encode(originator, maxAmount, receiver, nonces[originator]++, deadline)\n      )\n    );\n    require(\n      SignatureChecker.isValidSignatureNow(originator, digest, signature),\n      'SIGNATURE_INVALID'\n    );\n\n    return _sellAsset(originator, maxAmount, receiver);\n  }\n\n  /// @inheritdoc IGsm\n  function rescueTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external onlyRole(TOKEN_RESCUER_ROLE) {\n    require(amount > 0, 'INVALID_AMOUNT');\n    if (token == GHO_TOKEN) {\n      uint256 rescuableBalance = IERC20(token).balanceOf(address(this)) - _accruedFees;\n      require(rescuableBalance >= amount, 'INSUFFICIENT_GHO_TO_RESCUE');\n    }\n    if (token == UNDERLYING_ASSET) {\n      uint256 rescuableBalance = IERC20(token).balanceOf(address(this)) - _currentExposure;\n      require(rescuableBalance >= amount, 'INSUFFICIENT_EXOGENOUS_ASSET_TO_RESCUE');\n    }\n    IERC20(token).safeTransfer(to, amount);\n    emit TokensRescued(token, to, amount);\n  }\n\n  /// @inheritdoc IGsm\n  function setSwapFreeze(bool enable) external onlyRole(SWAP_FREEZER_ROLE) {\n    if (enable) {\n      require(!_isFrozen, 'GSM_ALREADY_FROZEN');\n    } else {\n      require(_isFrozen, 'GSM_ALREADY_UNFROZEN');\n    }\n    _isFrozen = enable;\n    emit SwapFreeze(msg.sender, enable);\n  }\n\n  /// @inheritdoc IGsm\n  function seize() external notSeized onlyRole(LIQUIDATOR_ROLE) returns (uint256) {\n    _isSeized = true;\n    _currentExposure = 0;\n    _updateExposureCap(0);\n\n    (, uint256 ghoMinted) = IGhoToken(GHO_TOKEN).getFacilitatorBucket(address(this));\n    uint256 underlyingBalance = IERC20(UNDERLYING_ASSET).balanceOf(address(this));\n    if (underlyingBalance > 0) {\n      IERC20(UNDERLYING_ASSET).safeTransfer(_ghoTreasury, underlyingBalance);\n    }\n\n    emit Seized(msg.sender, _ghoTreasury, underlyingBalance, ghoMinted);\n    return underlyingBalance;\n  }\n\n  /// @inheritdoc IGsm\n  function burnAfterSeize(uint256 amount) external onlyRole(LIQUIDATOR_ROLE) returns (uint256) {\n    require(_isSeized, 'GSM_NOT_SEIZED');\n    require(amount > 0, 'INVALID_AMOUNT');\n\n    (, uint256 ghoMinted) = IGhoToken(GHO_TOKEN).getFacilitatorBucket(address(this));\n    if (amount > ghoMinted) {\n      amount = ghoMinted;\n    }\n    IGhoToken(GHO_TOKEN).transferFrom(msg.sender, address(this), amount);\n    IGhoToken(GHO_TOKEN).burn(amount);\n\n    emit BurnAfterSeize(msg.sender, amount, (ghoMinted - amount));\n    return amount;\n  }\n\n  /// @inheritdoc IGsm\n  function updateFeeStrategy(address feeStrategy) external onlyRole(CONFIGURATOR_ROLE) {\n    _updateFeeStrategy(feeStrategy);\n  }\n\n  /// @inheritdoc IGsm\n  function updateExposureCap(uint128 exposureCap) external onlyRole(CONFIGURATOR_ROLE) {\n    _updateExposureCap(exposureCap);\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function distributeFeesToTreasury() public virtual override {\n    uint256 accruedFees = _accruedFees;\n    if (accruedFees > 0) {\n      _accruedFees = 0;\n      IERC20(GHO_TOKEN).transfer(_ghoTreasury, accruedFees);\n      emit FeesDistributedToTreasury(_ghoTreasury, GHO_TOKEN, accruedFees);\n    }\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function updateGhoTreasury(address newGhoTreasury) external override onlyRole(CONFIGURATOR_ROLE) {\n    _updateGhoTreasury(newGhoTreasury);\n  }\n\n  /// @inheritdoc IGsm\n  function DOMAIN_SEPARATOR() external view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  /// @inheritdoc IGsm\n  function getGhoAmountForBuyAsset(\n    uint256 minAssetAmount\n  ) external view returns (uint256, uint256, uint256, uint256) {\n    return _calculateGhoAmountForBuyAsset(minAssetAmount);\n  }\n\n  /// @inheritdoc IGsm\n  function getGhoAmountForSellAsset(\n    uint256 maxAssetAmount\n  ) external view returns (uint256, uint256, uint256, uint256) {\n    return _calculateGhoAmountForSellAsset(maxAssetAmount);\n  }\n\n  /// @inheritdoc IGsm\n  function getAssetAmountForBuyAsset(\n    uint256 maxGhoAmount\n  ) external view returns (uint256, uint256, uint256, uint256) {\n    bool withFee = _feeStrategy != address(0);\n    uint256 grossAmount = withFee\n      ? IGsmFeeStrategy(_feeStrategy).getGrossAmountFromTotalBought(maxGhoAmount)\n      : maxGhoAmount;\n    // round down so maxGhoAmount is guaranteed\n    uint256 assetAmount = IGsmPriceStrategy(PRICE_STRATEGY).getGhoPriceInAsset(grossAmount, false);\n    uint256 finalGrossAmount = IGsmPriceStrategy(PRICE_STRATEGY).getAssetPriceInGho(\n      assetAmount,\n      true\n    );\n    uint256 finalFee = withFee ? IGsmFeeStrategy(_feeStrategy).getBuyFee(finalGrossAmount) : 0;\n    return (assetAmount, finalGrossAmount + finalFee, finalGrossAmount, finalFee);\n  }\n\n  /// @inheritdoc IGsm\n  function getAssetAmountForSellAsset(\n    uint256 minGhoAmount\n  ) external view returns (uint256, uint256, uint256, uint256) {\n    bool withFee = _feeStrategy != address(0);\n    uint256 grossAmount = withFee\n      ? IGsmFeeStrategy(_feeStrategy).getGrossAmountFromTotalSold(minGhoAmount)\n      : minGhoAmount;\n    // round up so minGhoAmount is guaranteed\n    uint256 assetAmount = IGsmPriceStrategy(PRICE_STRATEGY).getGhoPriceInAsset(grossAmount, true);\n    uint256 finalGrossAmount = IGsmPriceStrategy(PRICE_STRATEGY).getAssetPriceInGho(\n      assetAmount,\n      false\n    );\n    uint256 finalFee = withFee ? IGsmFeeStrategy(_feeStrategy).getSellFee(finalGrossAmount) : 0;\n    return (assetAmount, finalGrossAmount - finalFee, finalGrossAmount, finalFee);\n  }\n\n  /// @inheritdoc IGsm\n  function getAvailableUnderlyingExposure() external view returns (uint256) {\n    return _exposureCap > _currentExposure ? _exposureCap - _currentExposure : 0;\n  }\n\n  /// @inheritdoc IGsm\n  function getExposureCap() external view returns (uint128) {\n    return _exposureCap;\n  }\n\n  /// @inheritdoc IGsm\n  function getAvailableLiquidity() external view returns (uint256) {\n    return _currentExposure;\n  }\n\n  /// @inheritdoc IGsm\n  function getFeeStrategy() external view returns (address) {\n    return _feeStrategy;\n  }\n\n  /// @inheritdoc IGsm\n  function getAccruedFees() external view returns (uint256) {\n    return _accruedFees;\n  }\n\n  /// @inheritdoc IGsm\n  function getIsFrozen() external view returns (bool) {\n    return _isFrozen;\n  }\n\n  /// @inheritdoc IGsm\n  function getIsSeized() external view returns (bool) {\n    return _isSeized;\n  }\n\n  /// @inheritdoc IGsm\n  function canSwap() external view returns (bool) {\n    return !_isFrozen && !_isSeized;\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function getGhoTreasury() external view override returns (address) {\n    return _ghoTreasury;\n  }\n\n  /// @inheritdoc IGsm\n  function GSM_REVISION() public pure virtual override returns (uint256) {\n    return 1;\n  }\n\n  /**\n   * @dev Buys an underlying asset with GHO\n   * @param originator The originator of the request\n   * @param minAmount The minimum amount of the underlying asset desired for purchase\n   * @param receiver The recipient address of the underlying asset being purchased\n   * @return The amount of underlying asset bought\n   * @return The amount of GHO sold by the user\n   */\n  function _buyAsset(\n    address originator,\n    uint256 minAmount,\n    address receiver\n  ) internal returns (uint256, uint256) {\n    (\n      uint256 assetAmount,\n      uint256 ghoSold,\n      uint256 grossAmount,\n      uint256 fee\n    ) = _calculateGhoAmountForBuyAsset(minAmount);\n\n    _beforeBuyAsset(originator, assetAmount, receiver);\n\n    require(assetAmount > 0, 'INVALID_AMOUNT');\n    require(_currentExposure >= assetAmount, 'INSUFFICIENT_AVAILABLE_EXOGENOUS_ASSET_LIQUIDITY');\n\n    _currentExposure -= uint128(assetAmount);\n    _accruedFees += fee.toUint128();\n    IGhoToken(GHO_TOKEN).transferFrom(originator, address(this), ghoSold);\n    IGhoToken(GHO_TOKEN).burn(grossAmount);\n    IERC20(UNDERLYING_ASSET).safeTransfer(receiver, assetAmount);\n\n    emit BuyAsset(originator, receiver, assetAmount, ghoSold, fee);\n    return (assetAmount, ghoSold);\n  }\n\n  /**\n   * @dev Hook that is called before `buyAsset`.\n   * @dev This can be used to add custom logic\n   * @param originator Originator of the request\n   * @param amount The amount of the underlying asset desired for purchase\n   * @param receiver Recipient address of the underlying asset being purchased\n   */\n  function _beforeBuyAsset(address originator, uint256 amount, address receiver) internal virtual {}\n\n  /**\n   * @dev Sells an underlying asset for GHO\n   * @param originator The originator of the request\n   * @param maxAmount The maximum amount of the underlying asset desired to sell\n   * @param receiver The recipient address of the GHO being purchased\n   * @return The amount of underlying asset sold\n   * @return The amount of GHO bought by the user\n   */\n  function _sellAsset(\n    address originator,\n    uint256 maxAmount,\n    address receiver\n  ) internal returns (uint256, uint256) {\n    (\n      uint256 assetAmount,\n      uint256 ghoBought,\n      uint256 grossAmount,\n      uint256 fee\n    ) = _calculateGhoAmountForSellAsset(maxAmount);\n\n    _beforeSellAsset(originator, assetAmount, receiver);\n\n    require(assetAmount > 0, 'INVALID_AMOUNT');\n    require(_currentExposure + assetAmount <= _exposureCap, 'EXOGENOUS_ASSET_EXPOSURE_TOO_HIGH');\n\n    _currentExposure += uint128(assetAmount);\n    _accruedFees += fee.toUint128();\n    IERC20(UNDERLYING_ASSET).safeTransferFrom(originator, address(this), assetAmount);\n\n    IGhoToken(GHO_TOKEN).mint(address(this), grossAmount);\n    IGhoToken(GHO_TOKEN).transfer(receiver, ghoBought);\n\n    emit SellAsset(originator, receiver, assetAmount, grossAmount, fee);\n    return (assetAmount, ghoBought);\n  }\n\n  /**\n   * @dev Hook that is called before `sellAsset`.\n   * @dev This can be used to add custom logic\n   * @param originator Originator of the request\n   * @param amount The amount of the underlying asset desired to sell\n   * @param receiver Recipient address of the GHO being purchased\n   */\n  function _beforeSellAsset(\n    address originator,\n    uint256 amount,\n    address receiver\n  ) internal virtual {}\n\n  /**\n   * @dev Returns the amount of GHO sold in exchange of buying underlying asset\n   * @param assetAmount The amount of underlying asset to buy\n   * @return The exact amount of asset the user purchases\n   * @return The total amount of GHO the user sells (gross amount in GHO plus fee)\n   * @return The gross amount of GHO\n   * @return The fee amount in GHO, applied on top of gross amount of GHO\n   */\n  function _calculateGhoAmountForBuyAsset(\n    uint256 assetAmount\n  ) internal view returns (uint256, uint256, uint256, uint256) {\n    bool withFee = _feeStrategy != address(0);\n    // pick the highest GHO amount possible for given asset amount\n    uint256 grossAmount = IGsmPriceStrategy(PRICE_STRATEGY).getAssetPriceInGho(assetAmount, true);\n    uint256 fee = withFee ? IGsmFeeStrategy(_feeStrategy).getBuyFee(grossAmount) : 0;\n    uint256 ghoSold = grossAmount + fee;\n    uint256 finalGrossAmount = withFee\n      ? IGsmFeeStrategy(_feeStrategy).getGrossAmountFromTotalBought(ghoSold)\n      : ghoSold;\n    // pick the lowest asset amount possible for given GHO amount\n    uint256 finalAssetAmount = IGsmPriceStrategy(PRICE_STRATEGY).getGhoPriceInAsset(\n      finalGrossAmount,\n      false\n    );\n    uint256 finalFee = ghoSold - finalGrossAmount;\n    return (finalAssetAmount, finalGrossAmount + finalFee, finalGrossAmount, finalFee);\n  }\n\n  /**\n   * @dev Returns the amount of GHO bought in exchange of a given amount of underlying asset\n   * @param assetAmount The amount of underlying asset to sell\n   * @return The exact amount of asset the user sells\n   * @return The total amount of GHO the user buys (gross amount in GHO minus fee)\n   * @return The gross amount of GHO\n   * @return The fee amount in GHO, applied to the gross amount of GHO\n   */\n  function _calculateGhoAmountForSellAsset(\n    uint256 assetAmount\n  ) internal view returns (uint256, uint256, uint256, uint256) {\n    bool withFee = _feeStrategy != address(0);\n    // pick the lowest GHO amount possible for given asset amount\n    uint256 grossAmount = IGsmPriceStrategy(PRICE_STRATEGY).getAssetPriceInGho(assetAmount, false);\n    uint256 fee = withFee ? IGsmFeeStrategy(_feeStrategy).getSellFee(grossAmount) : 0;\n    uint256 ghoBought = grossAmount - fee;\n    uint256 finalGrossAmount = withFee\n      ? IGsmFeeStrategy(_feeStrategy).getGrossAmountFromTotalSold(ghoBought)\n      : ghoBought;\n    // pick the highest asset amount possible for given GHO amount\n    uint256 finalAssetAmount = IGsmPriceStrategy(PRICE_STRATEGY).getGhoPriceInAsset(\n      finalGrossAmount,\n      true\n    );\n    uint256 finalFee = finalGrossAmount - ghoBought;\n    return (finalAssetAmount, finalGrossAmount - finalFee, finalGrossAmount, finalFee);\n  }\n\n  /**\n   * @dev Updates Fee Strategy\n   * @param feeStrategy The address of the new Fee Strategy\n   */\n  function _updateFeeStrategy(address feeStrategy) internal {\n    address oldFeeStrategy = _feeStrategy;\n    _feeStrategy = feeStrategy;\n    emit FeeStrategyUpdated(oldFeeStrategy, feeStrategy);\n  }\n\n  /**\n   * @dev Updates Exposure Cap\n   * @param exposureCap The value of the new Exposure Cap\n   */\n  function _updateExposureCap(uint128 exposureCap) internal {\n    uint128 oldExposureCap = _exposureCap;\n    _exposureCap = exposureCap;\n    emit ExposureCapUpdated(oldExposureCap, exposureCap);\n  }\n\n  /**\n   * @dev Updates GHO Treasury Address\n   * @param newGhoTreasury The address of the new GHO Treasury\n   */\n  function _updateGhoTreasury(address newGhoTreasury) internal {\n    require(newGhoTreasury != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    address oldGhoTreasury = _ghoTreasury;\n    _ghoTreasury = newGhoTreasury;\n    emit GhoTreasuryUpdated(oldGhoTreasury, newGhoTreasury);\n  }\n\n  /// @inheritdoc VersionedInitializable\n  function getRevision() internal pure virtual override returns (uint256) {\n    return GSM_REVISION();\n  }\n}\n"
    },
    "src/contracts/facilitators/gsm/Gsm4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IERC20} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol';\nimport {GPv2SafeERC20} from '@aave/core-v3/contracts/dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/math/SafeCast.sol';\nimport {IGhoFacilitator} from '../../gho/interfaces/IGhoFacilitator.sol';\nimport {IGhoToken} from '../../gho/interfaces/IGhoToken.sol';\nimport {IGsmPriceStrategy} from './priceStrategy/interfaces/IGsmPriceStrategy.sol';\nimport {IGsm4626} from './interfaces/IGsm4626.sol';\nimport {Gsm} from './Gsm.sol';\n\n/**\n * @title Gsm4626\n * @author Aave\n * @notice GHO Stability Module for ERC4626 vault shares. It provides buy/sell facilities to go to/from an ERC4626\n * vault share to/from GHO.\n * @dev Aimed to be used with ERC4626 vault shares as underlying asset. Users can use the ERC4626 vault share to\n * buy/sell GHO and the generated yield is redirected to the GHO Treasury in form of GHO.\n * @dev To be covered by a proxy contract.\n */\ncontract Gsm4626 is Gsm, IGsm4626 {\n  using GPv2SafeERC20 for IERC20;\n  using SafeCast for uint256;\n\n  /**\n   * @dev Constructor\n   * @param ghoToken The address of the GHO token contract\n   * @param underlyingAsset The address of the ERC4626 vault\n   * @param priceStrategy The address of the price strategy\n   */\n  constructor(\n    address ghoToken,\n    address underlyingAsset,\n    address priceStrategy\n  ) Gsm(ghoToken, underlyingAsset, priceStrategy) {\n    // Intentionally left blank\n  }\n\n  /// @inheritdoc IGsm4626\n  function backWithGho(\n    uint256 amount\n  ) external notSeized onlyRole(CONFIGURATOR_ROLE) returns (uint256) {\n    require(amount > 0, 'INVALID_AMOUNT');\n\n    (, uint256 ghoMinted) = IGhoToken(GHO_TOKEN).getFacilitatorBucket(address(this));\n    (, uint256 deficit) = _getCurrentBacking(ghoMinted);\n    require(deficit > 0, 'NO_CURRENT_DEFICIT_BACKING');\n\n    uint256 ghoToBack = amount > deficit ? deficit : amount;\n\n    IGhoToken(GHO_TOKEN).transferFrom(msg.sender, address(this), ghoToBack);\n    IGhoToken(GHO_TOKEN).burn(ghoToBack);\n\n    emit BackingProvided(msg.sender, GHO_TOKEN, ghoToBack, ghoToBack, deficit - ghoToBack);\n    return ghoToBack;\n  }\n\n  /// @inheritdoc IGsm4626\n  function backWithUnderlying(\n    uint256 amount\n  ) external notSeized onlyRole(CONFIGURATOR_ROLE) returns (uint256) {\n    require(amount > 0, 'INVALID_AMOUNT');\n\n    (, uint256 ghoMinted) = IGhoToken(GHO_TOKEN).getFacilitatorBucket(address(this));\n    (, uint256 deficit) = _getCurrentBacking(ghoMinted);\n    require(deficit > 0, 'NO_CURRENT_DEFICIT_BACKING');\n\n    uint128 deficitInUnderlying = IGsmPriceStrategy(PRICE_STRATEGY)\n      .getGhoPriceInAsset(deficit, false)\n      .toUint128();\n\n    if (amount >= deficitInUnderlying) {\n      _currentExposure += deficitInUnderlying;\n      IERC20(UNDERLYING_ASSET).safeTransferFrom(msg.sender, address(this), deficitInUnderlying);\n\n      emit BackingProvided(msg.sender, UNDERLYING_ASSET, deficitInUnderlying, deficit, 0);\n      return deficitInUnderlying;\n    } else {\n      uint256 amountInGho = IGsmPriceStrategy(PRICE_STRATEGY).getAssetPriceInGho(amount, false);\n\n      _currentExposure += uint128(amount);\n      IERC20(UNDERLYING_ASSET).safeTransferFrom(msg.sender, address(this), amount);\n\n      emit BackingProvided(\n        msg.sender,\n        UNDERLYING_ASSET,\n        amount,\n        amountInGho,\n        deficit - amountInGho\n      );\n      return amount;\n    }\n  }\n\n  /// @inheritdoc IGsm4626\n  function getCurrentBacking() external view returns (uint256, uint256) {\n    (, uint256 ghoMinted) = IGhoToken(GHO_TOKEN).getFacilitatorBucket(address(this));\n    return _getCurrentBacking(ghoMinted);\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function distributeFeesToTreasury() public override(Gsm, IGhoFacilitator) {\n    _cumulateYieldInGho();\n    super.distributeFeesToTreasury();\n  }\n\n  /// @inheritdoc Gsm\n  function _beforeBuyAsset(address, uint256, address) internal override {\n    _cumulateYieldInGho();\n  }\n\n  /// @inheritdoc Gsm\n  function _beforeSellAsset(address, uint256, address) internal override {}\n\n  /**\n   * @dev Cumulates yield in form of GHO, aimed to be redirected to the treasury\n   * @dev It mints GHO backed by the excess of underlying produced by the ERC4626 yield\n   * @dev If the GHO amount exceeds the amount available, it will mint up to the remaining capacity\n   */\n  function _cumulateYieldInGho() internal {\n    (uint256 ghoCapacity, uint256 ghoLevel) = IGhoToken(GHO_TOKEN).getFacilitatorBucket(\n      address(this)\n    );\n    uint256 ghoAvailableToMint = ghoCapacity > ghoLevel ? ghoCapacity - ghoLevel : 0;\n    (uint256 ghoExcess, ) = _getCurrentBacking(ghoLevel);\n    if (ghoExcess > 0 && ghoAvailableToMint > 0) {\n      ghoExcess = ghoExcess > ghoAvailableToMint ? ghoAvailableToMint : ghoExcess;\n      _accruedFees += uint128(ghoExcess);\n      IGhoToken(GHO_TOKEN).mint(address(this), ghoExcess);\n    }\n  }\n\n  /**\n   * @dev Calculates the excess or deficit of GHO minted, reflective of GSM backing\n   * @param ghoMinted The amount of GHO currently minted by the GSM\n   * @return The excess amount of GHO minted, relative to the value of the underlying\n   * @return The deficit of GHO minted, relative to the value of the underlying\n   */\n  function _getCurrentBacking(uint256 ghoMinted) internal view returns (uint256, uint256) {\n    uint256 ghoToBack = IGsmPriceStrategy(PRICE_STRATEGY).getAssetPriceInGho(\n      _currentExposure,\n      false\n    );\n    if (ghoToBack >= ghoMinted) {\n      return (ghoToBack - ghoMinted, 0);\n    } else {\n      return (0, ghoMinted - ghoToBack);\n    }\n  }\n}\n"
    },
    "src/contracts/facilitators/gsm/interfaces/IGsm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAccessControl} from '@openzeppelin/contracts/access/IAccessControl.sol';\nimport {IGhoFacilitator} from '../../../gho/interfaces/IGhoFacilitator.sol';\n\n/**\n * @title IGsm\n * @author Aave\n * @notice Defines the behaviour of a GHO Stability Module\n */\ninterface IGsm is IAccessControl, IGhoFacilitator {\n  /**\n   * @dev Emitted when a user buys an asset (selling GHO) in the GSM\n   * @param originator The address of the buyer originating the request\n   * @param receiver The address of the receiver of the underlying asset\n   * @param underlyingAmount The amount of the underlying asset bought\n   * @param ghoAmount The amount of GHO sold, inclusive of fee\n   * @param fee The fee paid by the buyer, in GHO\n   */\n  event BuyAsset(\n    address indexed originator,\n    address indexed receiver,\n    uint256 underlyingAmount,\n    uint256 ghoAmount,\n    uint256 fee\n  );\n\n  /**\n   * @dev Emitted when a user sells an asset (buying GHO) in the GSM\n   * @param originator The address of the seller originating the request\n   * @param receiver The address of the receiver of GHO\n   * @param underlyingAmount The amount of the underlying asset sold\n   * @param ghoAmount The amount of GHO bought, inclusive of fee\n   * @param fee The fee paid by the buyer, in GHO\n   */\n  event SellAsset(\n    address indexed originator,\n    address indexed receiver,\n    uint256 underlyingAmount,\n    uint256 ghoAmount,\n    uint256 fee\n  );\n\n  /**\n   * @dev Emitted when the Swap Freezer freezes buys/sells\n   * @param freezer The address of the Swap Freezer\n   * @param enabled True if swap functions are frozen, False otherwise\n   */\n  event SwapFreeze(address indexed freezer, bool enabled);\n\n  /**\n   * @dev Emitted when a Liquidator seizes GSM funds\n   * @param seizer The address originating the seizure request\n   * @param recipient The address of the recipient of seized funds\n   * @param underlyingAmount The amount of the underlying asset seized\n   * @param ghoOutstanding The amount of remaining GHO that the GSM had minted\n   */\n  event Seized(\n    address indexed seizer,\n    address indexed recipient,\n    uint256 underlyingAmount,\n    uint256 ghoOutstanding\n  );\n\n  /**\n   * @dev Emitted when burning GHO after a seizure of GSM funds\n   * @param burner The address of the burner\n   * @param amount The amount of GHO burned\n   * @param ghoOutstanding The amount of remaining GHO that the GSM had minted\n   */\n  event BurnAfterSeize(address indexed burner, uint256 amount, uint256 ghoOutstanding);\n\n  /**\n   * @dev Emitted when the Fee Strategy is updated\n   * @param oldFeeStrategy The address of the old Fee Strategy\n   * @param newFeeStrategy The address of the new Fee Strategy\n   */\n  event FeeStrategyUpdated(address indexed oldFeeStrategy, address indexed newFeeStrategy);\n\n  /**\n   * @dev Emitted when the GSM underlying asset Exposure Cap is updated\n   * @param oldExposureCap The amount of the old Exposure Cap\n   * @param newExposureCap The amount of the new Exposure Cap\n   */\n  event ExposureCapUpdated(uint256 oldExposureCap, uint256 newExposureCap);\n\n  /**\n   * @dev Emitted when tokens are rescued from the GSM\n   * @param tokenRescued The address of the rescued token\n   * @param recipient The address that received the rescued tokens\n   * @param amountRescued The amount of token rescued\n   */\n  event TokensRescued(\n    address indexed tokenRescued,\n    address indexed recipient,\n    uint256 amountRescued\n  );\n\n  /**\n   * @notice Buys the GSM underlying asset in exchange for selling GHO\n   * @dev Use `getAssetAmountForBuyAsset` function to calculate the amount based on the GHO amount to sell\n   * @param minAmount The minimum amount of the underlying asset to buy\n   * @param receiver Recipient address of the underlying asset being purchased\n   * @return The amount of underlying asset bought\n   * @return The amount of GHO sold by the user\n   */\n  function buyAsset(uint256 minAmount, address receiver) external returns (uint256, uint256);\n\n  /**\n   * @notice Buys the GSM underlying asset in exchange for selling GHO, using an EIP-712 signature\n   * @dev Use `getAssetAmountForBuyAsset` function to calculate the amount based on the GHO amount to sell\n   * @param originator The signer of the request\n   * @param minAmount The minimum amount of the underlying asset to buy\n   * @param receiver Recipient address of the underlying asset being purchased\n   * @param deadline Signature expiration deadline\n   * @param signature Signature data\n   * @return The amount of underlying asset bought\n   * @return The amount of GHO sold by the user\n   */\n  function buyAssetWithSig(\n    address originator,\n    uint256 minAmount,\n    address receiver,\n    uint256 deadline,\n    bytes calldata signature\n  ) external returns (uint256, uint256);\n\n  /**\n   * @notice Sells the GSM underlying asset in exchange for buying GHO\n   * @dev Use `getAssetAmountForSellAsset` function to calculate the amount based on the GHO amount to buy\n   * @param maxAmount The maximum amount of the underlying asset to sell\n   * @param receiver Recipient address of the GHO being purchased\n   * @return The amount of underlying asset sold\n   * @return The amount of GHO bought by the user\n   */\n  function sellAsset(uint256 maxAmount, address receiver) external returns (uint256, uint256);\n\n  /**\n   * @notice Sells the GSM underlying asset in exchange for buying GHO, using an EIP-712 signature\n   * @dev Use `getAssetAmountForSellAsset` function to calculate the amount based on the GHO amount to buy\n   * @param originator The signer of the request\n   * @param maxAmount The maximum amount of the underlying asset to sell\n   * @param receiver Recipient address of the GHO being purchased\n   * @param deadline Signature expiration deadline\n   * @param signature Signature data\n   * @return The amount of underlying asset sold\n   * @return The amount of GHO bought by the user\n   */\n  function sellAssetWithSig(\n    address originator,\n    uint256 maxAmount,\n    address receiver,\n    uint256 deadline,\n    bytes calldata signature\n  ) external returns (uint256, uint256);\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(address token, address to, uint256 amount) external;\n\n  /**\n   * @notice Enable or disable the swap freeze\n   * @param enable True to freeze swap functions, false otherwise\n   */\n  function setSwapFreeze(bool enable) external;\n\n  /**\n   * @notice Seizes all of the underlying asset from the GSM, sending to the Treasury\n   * @dev Seizing is a last resort mechanism to provide the Treasury with the entire amount of underlying asset\n   * so it can be used to backstop any potential event impacting the functionality of the Gsm.\n   * @dev Seizing disables the swap feature\n   * @return The amount of underlying asset seized and transferred to Treasury\n   */\n  function seize() external returns (uint256);\n\n  /**\n   * @notice Burns an amount of GHO after seizure reducing the facilitator bucket level effectively\n   * @dev Passing an amount higher than the facilitator bucket level will result in burning all minted GHO\n   * @dev Only callable if the GSM has assets seized, helpful to wind down the facilitator\n   * @param amount The amount of GHO to burn\n   * @return The amount of GHO burned\n   */\n  function burnAfterSeize(uint256 amount) external returns (uint256);\n\n  /**\n   * @notice Updates the address of the Fee Strategy\n   * @param feeStrategy The address of the new FeeStrategy\n   */\n  function updateFeeStrategy(address feeStrategy) external;\n\n  /**\n   * @notice Updates the exposure cap of the underlying asset\n   * @param exposureCap The new value for the exposure cap (in underlying asset terms)\n   */\n  function updateExposureCap(uint128 exposureCap) external;\n\n  /**\n   * @notice Returns the EIP712 domain separator\n   * @return The EIP712 domain separator\n   */\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /**\n   * @notice Returns the total amount of GHO, gross amount and fee result of buying assets\n   * @param minAssetAmount The minimum amount of underlying asset to buy\n   * @return The exact amount of underlying asset to be bought\n   * @return The total amount of GHO the user sells (gross amount in GHO plus fee)\n   * @return The gross amount of GHO\n   * @return The fee amount in GHO, applied on top of gross amount of GHO\n   */\n  function getGhoAmountForBuyAsset(\n    uint256 minAssetAmount\n  ) external view returns (uint256, uint256, uint256, uint256);\n\n  /**\n   * @notice Returns the total amount of GHO, gross amount and fee result of selling assets\n   * @param maxAssetAmount The maximum amount of underlying asset to sell\n   * @return The exact amount of underlying asset to sell\n   * @return The total amount of GHO the user buys (gross amount in GHO minus fee)\n   * @return The gross amount of GHO\n   * @return The fee amount in GHO, applied to the gross amount of GHO\n   */\n  function getGhoAmountForSellAsset(\n    uint256 maxAssetAmount\n  ) external view returns (uint256, uint256, uint256, uint256);\n\n  /**\n   * @notice Returns the amount of underlying asset, gross amount of GHO and fee result of buying assets\n   * @param maxGhoAmount The maximum amount of GHO the user provides for buying underlying asset\n   * @return The amount of underlying asset the user buys\n   * @return The exact amount of GHO the user provides\n   * @return The gross amount of GHO corresponding to the given total amount of GHO\n   * @return The fee amount in GHO, charged for buying assets\n   */\n  function getAssetAmountForBuyAsset(\n    uint256 maxGhoAmount\n  ) external view returns (uint256, uint256, uint256, uint256);\n\n  /**\n   * @notice Returns the amount of underlying asset, gross amount of GHO and fee result of selling assets\n   * @param minGhoAmount The minimum amount of GHO the user must receive for selling underlying asset\n   * @return The amount of underlying asset the user sells\n   * @return The exact amount of GHO the user receives in exchange\n   * @return The gross amount of GHO corresponding to the given total amount of GHO\n   * @return The fee amount in GHO, charged for selling assets\n   */\n  function getAssetAmountForSellAsset(\n    uint256 minGhoAmount\n  ) external view returns (uint256, uint256, uint256, uint256);\n\n  /**\n   * @notice Returns the remaining GSM exposure capacity\n   * @return The amount of underlying asset that can be sold to the GSM\n   */\n  function getAvailableUnderlyingExposure() external view returns (uint256);\n\n  /**\n   * @notice Returns the exposure limit to the underlying asset\n   * @return The maximum amount of underlying asset that can be sold to the GSM\n   */\n  function getExposureCap() external view returns (uint128);\n\n  /**\n   * @notice Returns the actual underlying asset balance immediately available in the GSM\n   * @return The amount of underlying asset that can be bought from the GSM\n   */\n  function getAvailableLiquidity() external view returns (uint256);\n\n  /**\n   * @notice Returns the Fee Strategy for the GSM\n   * @dev It returns 0x0 in case of no fee strategy\n   * @return The address of the FeeStrategy\n   */\n  function getFeeStrategy() external view returns (address);\n\n  /**\n   * @notice Returns the amount of current accrued fees\n   * @dev It does not factor in potential fees that can be accrued upon distribution of fees\n   * @return The amount of accrued fees\n   */\n  function getAccruedFees() external view returns (uint256);\n\n  /**\n   * @notice Returns the freeze status of the GSM\n   * @return True if frozen, false if not\n   */\n  function getIsFrozen() external view returns (bool);\n\n  /**\n   * @notice Returns the current seizure status of the GSM\n   * @return True if the GSM has been seized, false if not\n   */\n  function getIsSeized() external view returns (bool);\n\n  /**\n   * @notice Returns whether or not swaps via buyAsset/sellAsset are currently possible\n   * @return True if the GSM has swapping enabled, false otherwise\n   */\n  function canSwap() external view returns (bool);\n\n  /**\n   * @notice Returns the GSM revision number\n   * @return The revision number\n   */\n  function GSM_REVISION() external pure returns (uint256);\n\n  /**\n   * @notice Returns the address of the GHO token\n   * @return The address of GHO token contract\n   */\n  function GHO_TOKEN() external view returns (address);\n\n  /**\n   * @notice Returns the underlying asset of the GSM\n   * @return The address of the underlying asset\n   */\n  function UNDERLYING_ASSET() external view returns (address);\n\n  /**\n   * @notice Returns the price strategy of the GSM\n   * @return The address of the price strategy\n   */\n  function PRICE_STRATEGY() external view returns (address);\n\n  /**\n   * @notice Returns the current nonce (for EIP-712 signature methods) of an address\n   * @param user The address of the user\n   * @return The current nonce of the user\n   */\n  function nonces(address user) external view returns (uint256);\n\n  /**\n   * @notice Returns the identifier of the Configurator Role\n   * @return The bytes32 id hash of the Configurator role\n   */\n  function CONFIGURATOR_ROLE() external pure returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the Token Rescuer Role\n   * @return The bytes32 id hash of the TokenRescuer role\n   */\n  function TOKEN_RESCUER_ROLE() external pure returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the Swap Freezer Role\n   * @return The bytes32 id hash of the SwapFreezer role\n   */\n  function SWAP_FREEZER_ROLE() external pure returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the Liquidator Role\n   * @return The bytes32 id hash of the Liquidator role\n   */\n  function LIQUIDATOR_ROLE() external pure returns (bytes32);\n\n  /**\n   * @notice Returns the EIP-712 signature typehash for buyAssetWithSig\n   * @return The bytes32 signature typehash for buyAssetWithSig\n   */\n  function BUY_ASSET_WITH_SIG_TYPEHASH() external pure returns (bytes32);\n\n  /**\n   * @notice Returns the EIP-712 signature typehash for sellAssetWithSig\n   * @return The bytes32 signature typehash for sellAssetWithSig\n   */\n  function SELL_ASSET_WITH_SIG_TYPEHASH() external pure returns (bytes32);\n}\n"
    },
    "src/contracts/facilitators/gsm/interfaces/IGsm4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IGsm} from './IGsm.sol';\n\n/**\n * @title IGsm4626\n * @author Aave\n * @notice Defines the behaviour of a GHO Stability Module with an ERC-4626 underlying asset\n */\ninterface IGsm4626 is IGsm {\n  /**\n   * @dev Emitted when an asset is provided to the GSM to backstop a loss\n   * @param backer The address of the backer\n   * @param asset The address of the provided asset\n   * @param amount The amount of the asset\n   * @param ghoAmount The amount of the asset, in GHO terms\n   * @param remainingLoss The loss balance that remains after the operation\n   */\n  event BackingProvided(\n    address indexed backer,\n    address indexed asset,\n    uint256 amount,\n    uint256 ghoAmount,\n    uint256 remainingLoss\n  );\n\n  /**\n   * @notice Restores backing of GHO by burning GHO\n   * @dev Useful in the event the underlying value declines relative to GHO minted\n   * @dev Passing an amount higher than the current deficit will result in backing the entire deficit\n   * @param amount The amount of GHO to be burned\n   * @return The amount of GHO used for backing\n   */\n  function backWithGho(uint256 amount) external returns (uint256);\n\n  /**\n   * @notice Restores backing of GHO by providing underlying asset\n   * @dev Useful in the event the underlying value declines relative to GHO minted\n   * @dev Passing an amount higher than the current deficit will result in backing the entire deficit\n   * @param amount The amount of underlying to be used for backing\n   * @return The amount of underlying used for backing\n   */\n  function backWithUnderlying(uint256 amount) external returns (uint256);\n\n  /**\n   * @notice Returns the excess or deficit of GHO, reflecting current GSM backing\n   * @return The excess amount of GHO minted, relative to the value of the underlying\n   * @return The deficit of GHO minted, relative to the value of the underlying\n   */\n  function getCurrentBacking() external view returns (uint256, uint256);\n}\n"
    },
    "src/contracts/facilitators/gsm/misc/GsmRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IGsmRegistry} from './IGsmRegistry.sol';\n\n/**\n * @title GsmRegistry\n * @author Aave\n * @notice Main registry of GSM contracts.\n */\ncontract GsmRegistry is Ownable, IGsmRegistry {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  EnumerableSet.AddressSet internal _gsmList;\n\n  /**\n   * @dev Constructor\n   * @param newOwner The address of the contract owner\n   */\n  constructor(address newOwner) {\n    require(newOwner != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    _transferOwnership(newOwner);\n  }\n\n  /// @inheritdoc IGsmRegistry\n  function addGsm(address gsmAddress) external onlyOwner {\n    require(gsmAddress != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    require(_gsmList.add(gsmAddress), 'GSM_ALREADY_ADDED');\n\n    emit GsmAdded(gsmAddress);\n  }\n\n  /// @inheritdoc IGsmRegistry\n  function removeGsm(address gsmAddress) external onlyOwner {\n    require(gsmAddress != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    require(_gsmList.remove(gsmAddress), 'NONEXISTENT_GSM');\n\n    emit GsmRemoved(gsmAddress);\n  }\n\n  /// @inheritdoc IGsmRegistry\n  function getGsmList() external view returns (address[] memory) {\n    return _gsmList.values();\n  }\n\n  /// @inheritdoc IGsmRegistry\n  function getGsmListLength() external view returns (uint256) {\n    return _gsmList.length();\n  }\n\n  /// @inheritdoc IGsmRegistry\n  function getGsmAtIndex(uint256 index) external view returns (address) {\n    require(index < _gsmList.length(), 'INVALID_INDEX');\n    return _gsmList.at(index);\n  }\n}\n"
    },
    "src/contracts/facilitators/gsm/misc/IGsmRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IGsmRegistry\n * @author Aave\n * @notice Defines the behaviour of the GsmRegistry\n */\ninterface IGsmRegistry {\n  /**\n   * @dev Emitted when a new GSM is added to the registry\n   * @param gsmAddress The address of the GSM contract\n   */\n  event GsmAdded(address indexed gsmAddress);\n\n  /**\n   * @dev Emitted when a new GSM is removed from the registry\n   * @param gsmAddress The address of the GSM contract\n   */\n  event GsmRemoved(address indexed gsmAddress);\n\n  /**\n   * @notice Adds a new GSM to the registry\n   * @param gsmAddress The address of the GSM contract\n   */\n  function addGsm(address gsmAddress) external;\n\n  /**\n   * @notice Removes a GSM from the registry\n   * @param gsmAddress The address of the GSM contract\n   */\n  function removeGsm(address gsmAddress) external;\n\n  /**\n   * @notice Returns a list of GSM addresses to the registry\n   * @return A list of GSM contract addresses\n   */\n  function getGsmList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the length of the list of GSM addresses\n   * @return The size of the GSM list\n   */\n  function getGsmListLength() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the GSM placed in the list at the given index\n   * @param index The index of the GSM within the list\n   * @return The GSM address\n   */\n  function getGsmAtIndex(uint256 index) external view returns (address);\n}\n"
    },
    "src/contracts/facilitators/gsm/misc/SampleLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IERC20} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IGhoToken} from '../../../gho/interfaces/IGhoToken.sol';\nimport {IGsm} from '../interfaces/IGsm.sol';\n\n/**\n * @title SampleLiquidator\n * @author Aave\n * @notice Minimal Liquidator that can serve as sample contract\n */\ncontract SampleLiquidator is Ownable {\n  /**\n   * @notice Triggers seizure of a GSM, sending seized funds to the Treasury\n   * @param gsm Address of the GSM\n   * @return The amount of underlying asset seized and transferred to Treasury\n   */\n  function triggerSeize(address gsm) external onlyOwner returns (uint256) {\n    return IGsm(gsm).seize();\n  }\n\n  /**\n   * @notice Pulls GHO from the sender and burns it via the GSM\n   * @param gsm Address of the GSM\n   * @param amount The maximum amount of GHO to be burned\n   * @return The amount of GHO burned\n   */\n  function triggerBurnAfterSeize(address gsm, uint256 amount) external onlyOwner returns (uint256) {\n    IERC20 ghoToken = IERC20(IGsm(gsm).GHO_TOKEN());\n    (, uint256 ghoMinted) = IGhoToken(address(ghoToken)).getFacilitatorBucket(gsm);\n    if (amount > ghoMinted) {\n      amount = ghoMinted;\n    }\n    ghoToken.transferFrom(msg.sender, address(this), amount);\n    ghoToken.approve(gsm, amount);\n    return IGsm(gsm).burnAfterSeize(amount);\n  }\n}\n"
    },
    "src/contracts/facilitators/gsm/misc/SampleSwapFreezer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IGsm} from '../interfaces/IGsm.sol';\n\n/**\n * @title SampleSwapFreezer\n * @author Aave\n * @notice Minimal Swap Freezer that can serve as sample contract\n */\ncontract SampleSwapFreezer is Ownable {\n  /**\n   * @notice Triggers freezing of a GSM\n   * @param gsm Address of the GSM\n   */\n  function triggerFreeze(address gsm) external onlyOwner {\n    IGsm(gsm).setSwapFreeze(true);\n  }\n\n  /**\n   * @notice Triggers unfreezing of a GSM\n   * @param gsm Address of the GSM\n   */\n  function triggerUnfreeze(address gsm) external onlyOwner {\n    IGsm(gsm).setSwapFreeze(false);\n  }\n}\n"
    },
    "src/contracts/facilitators/gsm/priceStrategy/FixedPriceStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\nimport {IGsmPriceStrategy} from './interfaces/IGsmPriceStrategy.sol';\n\n/**\n * @title FixedPriceStrategy\n * @author Aave\n * @notice Price strategy involving a fixed-rate conversion from an underlying asset to GHO\n */\ncontract FixedPriceStrategy is IGsmPriceStrategy {\n  using Math for uint256;\n\n  /// @inheritdoc IGsmPriceStrategy\n  uint256 public constant GHO_DECIMALS = 18;\n\n  /// @inheritdoc IGsmPriceStrategy\n  address public immutable UNDERLYING_ASSET;\n\n  /// @inheritdoc IGsmPriceStrategy\n  uint256 public immutable UNDERLYING_ASSET_DECIMALS;\n\n  /// @dev The price ratio from underlying asset to GHO (expressed in WAD), e.g. a ratio of 2e18 means 2 GHO per 1 underlying asset\n  uint256 public immutable PRICE_RATIO;\n\n  /// @dev Underlying asset units represent units for the underlying asset\n  uint256 internal immutable _underlyingAssetUnits;\n\n  /**\n   * @dev Constructor\n   * @param priceRatio The price ratio from underlying asset to GHO (expressed in WAD)\n   * @param underlyingAsset The address of the underlying asset\n   * @param underlyingAssetDecimals The number of decimals of the underlying asset\n   */\n  constructor(uint256 priceRatio, address underlyingAsset, uint8 underlyingAssetDecimals) {\n    require(priceRatio > 0, 'INVALID_PRICE_RATIO');\n    PRICE_RATIO = priceRatio;\n    UNDERLYING_ASSET = underlyingAsset;\n    UNDERLYING_ASSET_DECIMALS = underlyingAssetDecimals;\n    _underlyingAssetUnits = 10 ** underlyingAssetDecimals;\n  }\n\n  /// @inheritdoc IGsmPriceStrategy\n  function getAssetPriceInGho(uint256 assetAmount, bool roundUp) external view returns (uint256) {\n    return\n      assetAmount.mulDiv(\n        PRICE_RATIO,\n        _underlyingAssetUnits,\n        roundUp ? Math.Rounding.Up : Math.Rounding.Down\n      );\n  }\n\n  /// @inheritdoc IGsmPriceStrategy\n  function getGhoPriceInAsset(uint256 ghoAmount, bool roundUp) external view returns (uint256) {\n    return\n      ghoAmount.mulDiv(\n        _underlyingAssetUnits,\n        PRICE_RATIO,\n        roundUp ? Math.Rounding.Up : Math.Rounding.Down\n      );\n  }\n}\n"
    },
    "src/contracts/facilitators/gsm/priceStrategy/FixedPriceStrategy4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\nimport {IERC4626} from '@openzeppelin/contracts/interfaces/IERC4626.sol';\nimport {IGsmPriceStrategy} from './interfaces/IGsmPriceStrategy.sol';\n\n/**\n * @title FixedPriceStrategy4626\n * @author Aave\n * @notice Price strategy involving a fixed-rate conversion from an ERC4626 vault to GHO\n * @dev 4626 vault assets represent the underlying asset held by a vault, vault shares are the vault token\n */\ncontract FixedPriceStrategy4626 is IGsmPriceStrategy {\n  using Math for uint256;\n\n  /// @inheritdoc IGsmPriceStrategy\n  uint256 public constant GHO_DECIMALS = 18;\n\n  /// @inheritdoc IGsmPriceStrategy\n  address public immutable UNDERLYING_ASSET;\n\n  /// @dev Underlying asset decimals represent decimals for the 4626 vault asset, not for the vault share\n  uint256 public immutable UNDERLYING_ASSET_DECIMALS;\n\n  /// @dev The price ratio from 4626 vault asset to GHO (expressed in WAD), e.g. a ratio of 2e18 means 2 GHO per 1 vault asset\n  uint256 public immutable PRICE_RATIO;\n\n  /// @dev Underlying asset units represent units for the 4626 vault asset, not for the vault share\n  uint256 internal immutable _underlyingAssetUnits;\n\n  /**\n   * @dev Constructor\n   * @param priceRatio The price ratio from 4626 vault asset to GHO (expressed in WAD)\n   * @param underlyingAsset The address of the 4626 vault (i.e., corresponding to vault shares)\n   * @param underlyingAssetDecimals The number of decimals of the 4626 vault asset\n   */\n  constructor(uint256 priceRatio, address underlyingAsset, uint8 underlyingAssetDecimals) {\n    require(priceRatio > 0, 'INVALID_PRICE_RATIO');\n    PRICE_RATIO = priceRatio;\n    UNDERLYING_ASSET = underlyingAsset;\n    UNDERLYING_ASSET_DECIMALS = underlyingAssetDecimals;\n    _underlyingAssetUnits = 10 ** underlyingAssetDecimals;\n  }\n\n  /// @inheritdoc IGsmPriceStrategy\n  function getAssetPriceInGho(uint256 assetAmount, bool roundUp) external view returns (uint256) {\n    // conversion from 4626 shares to 4626 assets\n    uint256 vaultAssets = roundUp\n      ? IERC4626(UNDERLYING_ASSET).previewMint(assetAmount) // round up\n      : IERC4626(UNDERLYING_ASSET).convertToAssets(assetAmount); // round down\n    return\n      vaultAssets.mulDiv(\n        PRICE_RATIO,\n        _underlyingAssetUnits,\n        roundUp ? Math.Rounding.Up : Math.Rounding.Down\n      );\n  }\n\n  /// @inheritdoc IGsmPriceStrategy\n  function getGhoPriceInAsset(uint256 ghoAmount, bool roundUp) external view returns (uint256) {\n    uint256 vaultAssets = ghoAmount.mulDiv(\n      _underlyingAssetUnits,\n      PRICE_RATIO,\n      roundUp ? Math.Rounding.Up : Math.Rounding.Down\n    );\n    // conversion of 4626 assets to 4626 shares\n    return\n      roundUp\n        ? IERC4626(UNDERLYING_ASSET).previewWithdraw(vaultAssets) // round up\n        : IERC4626(UNDERLYING_ASSET).convertToShares(vaultAssets); // round down\n  }\n}\n"
    },
    "src/contracts/facilitators/gsm/priceStrategy/interfaces/IGsmPriceStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IGsmPriceStrategy\n * @author Aave\n * @notice Defines the behaviour of Price Strategies\n */\ninterface IGsmPriceStrategy {\n  /**\n   * @notice Returns the number of decimals of GHO\n   * @return The number of decimals of GHO\n   */\n  function GHO_DECIMALS() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the underlying asset being priced\n   * @return The address of the underlying asset\n   */\n  function UNDERLYING_ASSET() external view returns (address);\n\n  /**\n   * @notice Returns the decimals of the underlying asset being priced\n   * @return The number of decimals of the underlying asset\n   */\n  function UNDERLYING_ASSET_DECIMALS() external view returns (uint256);\n\n  /**\n   * @notice Returns the price of the underlying asset (GHO denominated)\n   * @param assetAmount The amount of the underlying asset to calculate the price of\n   * @param roundUp True if the price should be rounded up, false if rounded down\n   * @return The price of the underlying asset (expressed in GHO units)\n   */\n  function getAssetPriceInGho(uint256 assetAmount, bool roundUp) external view returns (uint256);\n\n  /**\n   * @notice Returns the price of GHO (denominated in the underlying asset)\n   * @param ghoAmount The amount of GHO to calculate the price of\n   * @param roundUp True if the price should be rounded up, false if rounded down\n   * @return The price of the GHO amount (expressed in underlying asset units)\n   */\n  function getGhoPriceInAsset(uint256 ghoAmount, bool roundUp) external view returns (uint256);\n}\n"
    },
    "src/contracts/facilitators/gsm/swapFreezer/OracleSwapFreezer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IPoolAddressesProvider} from '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\nimport {IPriceOracle} from '@aave/core-v3/contracts/interfaces/IPriceOracle.sol';\nimport {AutomationCompatibleInterface} from '../dependencies/chainlink/AutomationCompatibleInterface.sol';\nimport {IGsm} from '../interfaces/IGsm.sol';\n\n/**\n * @title OracleSwapFreezer\n * @author Aave\n * @notice Swap freezer that enacts the freeze action based on underlying oracle price, GSM's state and predefined price boundaries\n * @dev Chainlink Automation-compatible contract using Aave V3 Price Oracle, where prices are USD denominated with 8-decimal precision\n * @dev Freeze action is executable if GSM is not seized, not frozen and price is outside of the freeze bounds\n * @dev Unfreeze action is executable if GSM is not seized, frozen, unfreezing is allowed and price is inside the unfreeze bounds\n */\ncontract OracleSwapFreezer is AutomationCompatibleInterface {\n  enum Action {\n    NONE,\n    FREEZE,\n    UNFREEZE\n  }\n\n  IGsm public immutable GSM;\n  address public immutable UNDERLYING_ASSET;\n  IPoolAddressesProvider public immutable ADDRESS_PROVIDER;\n  uint128 internal immutable _freezeLowerBound;\n  uint128 internal immutable _freezeUpperBound;\n  uint128 internal immutable _unfreezeLowerBound;\n  uint128 internal immutable _unfreezeUpperBound;\n  bool internal immutable _allowUnfreeze;\n\n  /**\n   * @dev Constructor\n   * @dev Freeze/unfreeze bounds are specified in USD with 8-decimal precision, like Aave v3 Price Oracles\n   * @dev Unfreeze boundaries are \"contained\" in freeze boundaries, where freezeLowerBound < unfreezeLowerBound and unfreezeUpperBound < freezeUpperBound\n   * @dev All bound ranges are inclusive\n   * @param gsm The GSM that this contract will trigger freezes/unfreezes on\n   * @param underlyingAsset The address of the collateral asset\n   * @param addressProvider The Aave Addresses Provider for looking up the Price Oracle\n   * @param freezeLowerBound The lower price bound for freeze operations\n   * @param freezeUpperBound The upper price bound for freeze operations\n   * @param unfreezeLowerBound The lower price bound for unfreeze operations, must be 0 if unfreezing not allowed\n   * @param unfreezeUpperBound The upper price bound for unfreeze operations, must be 0 if unfreezing not allowed\n   * @param allowUnfreeze True if bounds verification should factor in the unfreeze boundary, false otherwise\n   */\n  constructor(\n    IGsm gsm,\n    address underlyingAsset,\n    IPoolAddressesProvider addressProvider,\n    uint128 freezeLowerBound,\n    uint128 freezeUpperBound,\n    uint128 unfreezeLowerBound,\n    uint128 unfreezeUpperBound,\n    bool allowUnfreeze\n  ) {\n    require(underlyingAsset != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    require(\n      _validateBounds(\n        freezeLowerBound,\n        freezeUpperBound,\n        unfreezeLowerBound,\n        unfreezeUpperBound,\n        allowUnfreeze\n      ),\n      'BOUNDS_NOT_VALID'\n    );\n    GSM = gsm;\n    UNDERLYING_ASSET = underlyingAsset;\n    ADDRESS_PROVIDER = addressProvider;\n    _freezeLowerBound = freezeLowerBound;\n    _freezeUpperBound = freezeUpperBound;\n    _unfreezeLowerBound = unfreezeLowerBound;\n    _unfreezeUpperBound = unfreezeUpperBound;\n    _allowUnfreeze = allowUnfreeze;\n  }\n\n  /// @inheritdoc AutomationCompatibleInterface\n  function performUpkeep(bytes calldata) external {\n    Action action = _getAction();\n    if (action == Action.FREEZE) {\n      GSM.setSwapFreeze(true);\n    } else if (action == Action.UNFREEZE) {\n      GSM.setSwapFreeze(false);\n    }\n  }\n\n  /// @inheritdoc AutomationCompatibleInterface\n  function checkUpkeep(bytes calldata) external view returns (bool, bytes memory) {\n    return (_getAction() == Action.NONE ? false : true, '');\n  }\n\n  /**\n   * @notice Returns whether or not the swap freezer can unfreeze a GSM\n   * @return True if the freezer can unfreeze, false otherwise\n   */\n  function getCanUnfreeze() external view returns (bool) {\n    return _allowUnfreeze;\n  }\n\n  /**\n   * @notice Returns the bound used for freeze operations\n   * @return The freeze lower bound (inclusive)\n   * @return The freeze upper bound (inclusive)\n   */\n  function getFreezeBound() external view returns (uint128, uint128) {\n    return (_freezeLowerBound, _freezeUpperBound);\n  }\n\n  /**\n   * @notice Returns the bound used for unfreeze operations, or (0, 0) if unfreezing not allowed\n   * @return The unfreeze lower bound (inclusive), or 0 if unfreezing not allowed\n   * @return The unfreeze upper bound (inclusive), or 0 if unfreezing not allowed\n   */\n  function getUnfreezeBound() external view returns (uint128, uint128) {\n    return (_unfreezeLowerBound, _unfreezeUpperBound);\n  }\n\n  /**\n   * @notice Fetches price oracle data and checks whether a swap freeze or unfreeze action is required\n   * @return The action to take (none, freeze, or unfreeze)\n   */\n  function _getAction() internal view returns (Action) {\n    if (GSM.hasRole(GSM.SWAP_FREEZER_ROLE(), address(this))) {\n      if (GSM.getIsSeized()) {\n        return Action.NONE;\n      } else if (!GSM.getIsFrozen()) {\n        if (_isActionAllowed(Action.FREEZE)) {\n          return Action.FREEZE;\n        }\n      } else if (_allowUnfreeze) {\n        if (_isActionAllowed(Action.UNFREEZE)) {\n          return Action.UNFREEZE;\n        }\n      }\n    }\n    return Action.NONE;\n  }\n\n  /**\n   * @notice Checks whether the action is allowed, based on the action, oracle price and freeze/unfreeze bounds\n   * @dev Freeze action is allowed if price is outside of the freeze bounds\n   * @dev Unfreeze action is allowed if price is inside the unfreeze bounds\n   * @param actionToExecute The requested action type to validate\n   * @return True if conditions to execute the action passed are met, false otherwise\n   */\n  function _isActionAllowed(Action actionToExecute) internal view returns (bool) {\n    uint256 oraclePrice = IPriceOracle(ADDRESS_PROVIDER.getPriceOracle()).getAssetPrice(\n      UNDERLYING_ASSET\n    );\n    // Assume a 0 oracle price is invalid and no action should be taken based on that data\n    if (oraclePrice == 0) {\n      return false;\n    } else if (actionToExecute == Action.FREEZE) {\n      if (oraclePrice <= _freezeLowerBound || oraclePrice >= _freezeUpperBound) {\n        return true;\n      }\n    } else if (actionToExecute == Action.UNFREEZE) {\n      if (oraclePrice >= _unfreezeLowerBound && oraclePrice <= _unfreezeUpperBound) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @notice Verifies that the unfreeze bound and freeze bounds do not conflict, causing unexpected behaviour\n   * @param freezeLowerBound The lower bound for freeze operations\n   * @param freezeUpperBound The upper bound for freeze operations\n   * @param unfreezeLowerBound The lower bound for unfreeze operations, must be 0 if unfreezing not allowed\n   * @param unfreezeUpperBound The upper bound for unfreeze operations, must be 0 if unfreezing not allowed\n   * @param allowUnfreeze True if bounds verification should factor in the unfreeze boundary, false otherwise\n   * @return True if the bounds are valid and conflict-free, false otherwise\n   */\n  function _validateBounds(\n    uint128 freezeLowerBound,\n    uint128 freezeUpperBound,\n    uint128 unfreezeLowerBound,\n    uint128 unfreezeUpperBound,\n    bool allowUnfreeze\n  ) internal pure returns (bool) {\n    if (freezeLowerBound >= freezeUpperBound) {\n      return false;\n    } else if (allowUnfreeze) {\n      if (\n        unfreezeLowerBound >= unfreezeUpperBound ||\n        freezeLowerBound >= unfreezeLowerBound ||\n        freezeUpperBound <= unfreezeUpperBound\n      ) {\n        return false;\n      }\n    } else {\n      if (unfreezeLowerBound != 0 || unfreezeUpperBound != 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
    },
    "src/contracts/gho/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT-only\npragma solidity ^0.8.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/**\n * @title ERC20\n * @notice Gas Efficient ERC20 + EIP-2612 implementation\n * @dev Modified version of Solmate ERC20 (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol),\n * implementing the basic IERC20\n */\nabstract contract ERC20 is IERC20 {\n  /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  string public name;\n\n  string public symbol;\n\n  uint8 public immutable decimals;\n\n  /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  uint256 public totalSupply;\n\n  mapping(address => uint256) public balanceOf;\n\n  mapping(address => mapping(address => uint256)) public allowance;\n\n  /**\n   * @notice Delegated token used for additional allowance checks\n   * @dev When set, this token's allowance is checked in addition to internal allowance\n   */\n  address public delegatedToken;\n\n  /**\n   * @dev Emitted when the delegated token is updated\n   * @param oldDelegatedToken The previous delegated token address\n   * @param newDelegatedToken The new delegated token address\n   */\n  event DelegatedTokenUpdated(\n    address indexed oldDelegatedToken,\n    address indexed newDelegatedToken\n  );\n\n  /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  uint256 internal immutable INITIAL_CHAIN_ID;\n\n  bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n  mapping(address => uint256) public nonces;\n\n  /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n  constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n    name = _name;\n    symbol = _symbol;\n    decimals = _decimals;\n\n    INITIAL_CHAIN_ID = block.chainid;\n    INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  function approve(address spender, uint256 amount) public virtual returns (bool) {\n    allowance[msg.sender][spender] = amount;\n\n    emit Approval(msg.sender, spender, amount);\n\n    return true;\n  }\n\n  function transfer(address to, uint256 amount) public virtual returns (bool) {\n    balanceOf[msg.sender] -= amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(msg.sender, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Sets the delegated token to be used for additional allowance checks\n   * @dev Only the contract that inherits from ERC20 should implement access controls\n   * @param token The address of the token to be used for delegated allowance checks\n   */\n  function _setDelegatedToken(address token) internal virtual {\n    address oldDelegatedToken = delegatedToken;\n    delegatedToken = token;\n    emit DelegatedTokenUpdated(oldDelegatedToken, token);\n  }\n\n  function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n    // If sender is not the owner, check allowances\n    if (from != msg.sender) {\n      // Check if delegated token allows bypassing internal allowance\n      bool hasDelegatedAllowance = false;\n\n      if (delegatedToken != address(0)) {\n        try IERC20(delegatedToken).allowance(from, msg.sender) returns (uint256 delegatedAllowance) {\n          hasDelegatedAllowance = delegatedAllowance > amount;\n        } catch {\n          // Delegated token call failed, use internal allowance\n        }\n      }\n\n      // Update internal allowance only if delegated token doesn't cover it\n      if (!hasDelegatedAllowance) {\n        uint256 currentAllowance = allowance[from][msg.sender];\n        if (currentAllowance != type(uint256).max) {\n          allowance[from][msg.sender] = currentAllowance - amount;\n        }\n      }\n    }\n\n    balanceOf[from] -= amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual {\n    require(deadline >= block.timestamp, 'PERMIT_DEADLINE_EXPIRED');\n\n    // Unchecked because the only math done is incrementing\n    // the owner's nonce which cannot realistically overflow.\n    unchecked {\n      bytes32 digest = keccak256(\n        abi.encodePacked(\n          '\\x19\\x01',\n          DOMAIN_SEPARATOR(),\n          keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n        )\n      );\n\n      address recoveredAddress = ecrecover(digest, v, r, s);\n\n      require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNER');\n\n      allowance[recoveredAddress][spender] = value;\n    }\n\n    emit Approval(owner, spender, value);\n  }\n\n  function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n    return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n  }\n\n  function computeDomainSeparator() internal view virtual returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          keccak256(\n            'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n          ),\n          keccak256(bytes(name)),\n          keccak256('1'),\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  function _mint(address to, uint256 amount) internal virtual {\n    totalSupply += amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _burn(address from, uint256 amount) internal virtual {\n    balanceOf[from] -= amount;\n\n    // Cannot underflow because a user's balance\n    // will never be larger than the total supply.\n    unchecked {\n      totalSupply -= amount;\n    }\n\n    emit Transfer(from, address(0), amount);\n  }\n}\n"
    },
    "src/contracts/gho/GhoToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  /// @inheritdoc IGhoToken\n  bytes32 public constant FACILITATOR_MANAGER_ROLE = keccak256('FACILITATOR_MANAGER_ROLE');\n\n  /// @inheritdoc IGhoToken\n  bytes32 public constant BUCKET_MANAGER_ROLE = keccak256('BUCKET_MANAGER_ROLE');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Hydrated Dollar', 'HOLLAR', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /// @inheritdoc IGhoToken\n  function mint(address account, uint256 amount) external {\n    require(amount > 0, 'INVALID_MINT_AMOUNT');\n    Facilitator storage f = _facilitators[msg.sender];\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(f.bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function burn(uint256 amount) external {\n    require(amount > 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER_ROLE) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(\n    address facilitatorAddress\n  ) external onlyRole(FACILITATOR_MANAGER_ROLE) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER_ROLE) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n\n  function setDelegatedToken(address token) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setDelegatedToken(token);\n  }\n}\n"
    },
    "src/contracts/gho/interfaces/IGhoFacilitator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title IGhoFacilitator\n * @author Aave\n * @notice Defines the behavior of a Gho Facilitator\n */\ninterface IGhoFacilitator {\n  /**\n   * @dev Emitted when fees are distributed to the GhoTreasury\n   * @param ghoTreasury The address of the ghoTreasury\n   * @param asset The address of the asset transferred to the ghoTreasury\n   * @param amount The amount of the asset transferred to the ghoTreasury\n   */\n  event FeesDistributedToTreasury(\n    address indexed ghoTreasury,\n    address indexed asset,\n    uint256 amount\n  );\n\n  /**\n   * @dev Emitted when Gho Treasury address is updated\n   * @param oldGhoTreasury The address of the old GhoTreasury contract\n   * @param newGhoTreasury The address of the new GhoTreasury contract\n   */\n  event GhoTreasuryUpdated(address indexed oldGhoTreasury, address indexed newGhoTreasury);\n\n  /**\n   * @notice Distribute fees to the GhoTreasury\n   */\n  function distributeFeesToTreasury() external;\n\n  /**\n   * @notice Updates the address of the Gho Treasury\n   * @dev WARNING: The GhoTreasury is where revenue fees are sent to. Update carefully\n   * @param newGhoTreasury The address of the GhoTreasury\n   */\n  function updateGhoTreasury(address newGhoTreasury) external;\n\n  /**\n   * @notice Returns the address of the Gho Treasury\n   * @return The address of the GhoTreasury contract\n   */\n  function getGhoTreasury() external view returns (address);\n}\n"
    },
    "src/contracts/gho/interfaces/IGhoToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IAccessControl} from '@openzeppelin/contracts/access/IAccessControl.sol';\n\n/**\n * @title IGhoToken\n * @author Aave\n */\ninterface IGhoToken is IERC20, IAccessControl {\n  struct Facilitator {\n    uint128 bucketCapacity;\n    uint128 bucketLevel;\n    string label;\n  }\n\n  /**\n   * @dev Emitted when a new facilitator is added\n   * @param facilitatorAddress The address of the new facilitator\n   * @param label A hashed human readable identifier for the facilitator\n   * @param bucketCapacity The initial capacity of the facilitator's bucket\n   */\n  event FacilitatorAdded(\n    address indexed facilitatorAddress,\n    bytes32 indexed label,\n    uint256 bucketCapacity\n  );\n\n  /**\n   * @dev Emitted when a facilitator is removed\n   * @param facilitatorAddress The address of the removed facilitator\n   */\n  event FacilitatorRemoved(address indexed facilitatorAddress);\n\n  /**\n   * @dev Emitted when the bucket capacity of a facilitator is updated\n   * @param facilitatorAddress The address of the facilitator whose bucket capacity is being changed\n   * @param oldCapacity The old capacity of the bucket\n   * @param newCapacity The new capacity of the bucket\n   */\n  event FacilitatorBucketCapacityUpdated(\n    address indexed facilitatorAddress,\n    uint256 oldCapacity,\n    uint256 newCapacity\n  );\n\n  /**\n   * @dev Emitted when the bucket level changed\n   * @param facilitatorAddress The address of the facilitator whose bucket level is being changed\n   * @param oldLevel The old level of the bucket\n   * @param newLevel The new level of the bucket\n   */\n  event FacilitatorBucketLevelUpdated(\n    address indexed facilitatorAddress,\n    uint256 oldLevel,\n    uint256 newLevel\n  );\n\n  /**\n   * @notice Returns the identifier of the Facilitator Manager Role\n   * @return The bytes32 id hash of the FacilitatorManager role\n   */\n  function FACILITATOR_MANAGER_ROLE() external pure returns (bytes32);\n\n  /**\n   * @notice Returns the identifier of the Bucket Manager Role\n   * @return The bytes32 id hash of the BucketManager role\n   */\n  function BUCKET_MANAGER_ROLE() external pure returns (bytes32);\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external;\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external;\n\n  /**\n   * @notice Add the facilitator passed with the parameters to the facilitators list.\n   * @dev Only accounts with `FACILITATOR_MANAGER_ROLE` role can call this function\n   * @param facilitatorAddress The address of the facilitator to add\n   * @param facilitatorLabel A human readable identifier for the facilitator\n   * @param bucketCapacity The upward limit of GHO can be minted by the facilitator\n   */\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external;\n\n  /**\n   * @notice Remove the facilitator from the facilitators list.\n   * @dev Only accounts with `FACILITATOR_MANAGER_ROLE` role can call this function\n   * @param facilitatorAddress The address of the facilitator to remove\n   */\n  function removeFacilitator(address facilitatorAddress) external;\n\n  /**\n   * @notice Set the bucket capacity of the facilitator.\n   * @dev Only accounts with `BUCKET_MANAGER_ROLE` role can call this function\n   * @param facilitator The address of the facilitator\n   * @param newCapacity The new capacity of the bucket\n   */\n  function setFacilitatorBucketCapacity(address facilitator, uint128 newCapacity) external;\n\n  /**\n   * @notice Returns the facilitator data\n   * @param facilitator The address of the facilitator\n   * @return The facilitator configuration\n   */\n  function getFacilitator(address facilitator) external view returns (Facilitator memory);\n\n  /**\n   * @notice Returns the bucket configuration of the facilitator\n   * @param facilitator The address of the facilitator\n   * @return The capacity of the facilitator's bucket\n   * @return The level of the facilitator's bucket\n   */\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256);\n\n  /**\n   * @notice Returns the list of the addresses of the active facilitator\n   * @return The list of the facilitators addresses\n   */\n  function getFacilitatorsList() external view returns (address[] memory);\n}\n"
    },
    "src/contracts/gho/UpgradeableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT-only\npragma solidity ^0.8.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/**\n * @title UpgradeableERC20\n * @author Aave Labs\n * @notice Upgradeable version of Solmate ERC20\n * @dev Contract adaptations:\n * - Removal of domain separator optimization\n * - Move of name and symbol definition to initialization stage\n */\nabstract contract UpgradeableERC20 is IERC20 {\n  /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  string public name;\n\n  string public symbol;\n\n  uint8 public immutable decimals;\n\n  /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  uint256 public totalSupply;\n\n  mapping(address => uint256) public balanceOf;\n\n  mapping(address => mapping(address => uint256)) public allowance;\n\n  /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  mapping(address => uint256) public nonces;\n\n  /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n  constructor(uint8 _decimals) {\n    decimals = _decimals;\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                               INITIALIZER\n    //////////////////////////////////////////////////////////////*/\n\n  function _ERC20_init(string memory _name, string memory _symbol) internal {\n    name = _name;\n    symbol = _symbol;\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  function approve(address spender, uint256 amount) public virtual returns (bool) {\n    allowance[msg.sender][spender] = amount;\n\n    emit Approval(msg.sender, spender, amount);\n\n    return true;\n  }\n\n  function transfer(address to, uint256 amount) public virtual returns (bool) {\n    balanceOf[msg.sender] -= amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(msg.sender, to, amount);\n\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\n    uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n    if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n    balanceOf[from] -= amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual {\n    require(deadline >= block.timestamp, 'PERMIT_DEADLINE_EXPIRED');\n\n    // Unchecked because the only math done is incrementing\n    // the owner's nonce which cannot realistically overflow.\n    unchecked {\n      bytes32 digest = keccak256(\n        abi.encodePacked(\n          '\\x19\\x01',\n          DOMAIN_SEPARATOR(),\n          keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n        )\n      );\n\n      address recoveredAddress = ecrecover(digest, v, r, s);\n\n      require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNER');\n\n      allowance[recoveredAddress][spender] = value;\n    }\n\n    emit Approval(owner, spender, value);\n  }\n\n  function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n    return computeDomainSeparator();\n  }\n\n  function computeDomainSeparator() internal view virtual returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          keccak256(\n            'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n          ),\n          keccak256(bytes(name)),\n          keccak256('1'),\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  function _mint(address to, uint256 amount) internal virtual {\n    totalSupply += amount;\n\n    // Cannot overflow because the sum of all user\n    // balances can't exceed the max uint256 value.\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _burn(address from, uint256 amount) internal virtual {\n    balanceOf[from] -= amount;\n\n    // Cannot underflow because a user's balance\n    // will never be larger than the total supply.\n    unchecked {\n      totalSupply -= amount;\n    }\n\n    emit Transfer(from, address(0), amount);\n  }\n}\n"
    },
    "src/contracts/gho/UpgradeableGhoToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {Initializable} from 'solidity-utils/contracts/transparent-proxy/Initializable.sol';\nimport {UpgradeableERC20} from './UpgradeableERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title Upgradeable GHO Token\n * @author Aave Labs\n */\ncontract UpgradeableGhoToken is Initializable, UpgradeableERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  /// @inheritdoc IGhoToken\n  bytes32 public constant FACILITATOR_MANAGER_ROLE = keccak256('FACILITATOR_MANAGER_ROLE');\n\n  /// @inheritdoc IGhoToken\n  bytes32 public constant BUCKET_MANAGER_ROLE = keccak256('BUCKET_MANAGER_ROLE');\n\n  /**\n   * @dev Constructor\n   */\n  constructor() UpgradeableERC20(18) {\n    // Intentionally left bank\n  }\n\n  /**\n   * @dev Initializer\n   * @param admin This is the initial holder of the default admin role\n   */\n  function initialize(address admin) public virtual initializer {\n    _ERC20_init('Gho Token', 'GHO');\n\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /// @inheritdoc IGhoToken\n  function mint(address account, uint256 amount) external {\n    require(amount > 0, 'INVALID_MINT_AMOUNT');\n    Facilitator storage f = _facilitators[msg.sender];\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(f.bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function burn(uint256 amount) external {\n    require(amount > 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER_ROLE) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(\n    address facilitatorAddress\n  ) external onlyRole(FACILITATOR_MANAGER_ROLE) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER_ROLE) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n"
    },
    "src/contracts/misc/dependencies/AaveV3-1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Address} from 'solidity-utils/contracts/oz-common/Address.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/math/SafeCast.sol';\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\nimport {IPoolAddressesProvider} from '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\nimport {ConfiguratorInputTypes} from '@aave/core-v3/contracts/protocol/libraries/types/ConfiguratorInputTypes.sol';\n\nlibrary DataTypes {\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    bool usingVirtualBalance;\n    uint256 virtualUnderlyingBalance;\n  }\n}\n\n/**\n * @title Errors library\n * @author Aave\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n */\nlibrary Errors {\n  string public constant CALLER_NOT_POOL_CONFIGURATOR = '10'; // 'The caller of the function is not the pool configurator'\n  string public constant INVALID_ADDRESSES_PROVIDER = '12'; // 'The address of the pool addresses provider is invalid'\n  string public constant ZERO_ADDRESS_NOT_VALID = '77'; // 'Zero address not valid'\n  string public constant INVALID_OPTIMAL_USAGE_RATIO = '83'; // 'Invalid optimal usage ratio'\n  string public constant INVALID_MAX_RATE = '92'; // The expect maximum borrow rate is invalid\n  string public constant SLOPE_2_MUST_BE_GTE_SLOPE_1 = '95'; // Variable interest rate slope 2 can not be lower than slope 1\n}\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n */\nlibrary PercentageMath {\n  // Maximum percentage factor (100.00%)\n  uint256 internal constant PERCENTAGE_FACTOR = 1e4;\n\n  // Half percentage factor (50.00%)\n  uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\n\n  /**\n   * @notice Executes a percentage multiplication\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return result value percentmul percentage\n   */\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n    // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage\n    assembly {\n      if iszero(\n        or(\n          iszero(percentage),\n          iszero(gt(value, div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage)))\n        )\n      ) {\n        revert(0, 0)\n      }\n\n      result := div(add(mul(value, percentage), HALF_PERCENTAGE_FACTOR), PERCENTAGE_FACTOR)\n    }\n  }\n\n  /**\n   * @notice Executes a percentage division\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return result value percentdiv percentage\n   */\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n    // to avoid overflow, value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR\n    assembly {\n      if or(\n        iszero(percentage),\n        iszero(iszero(gt(value, div(sub(not(0), div(percentage, 2)), PERCENTAGE_FACTOR))))\n      ) {\n        revert(0, 0)\n      }\n\n      result := div(add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)), percentage)\n    }\n  }\n}\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @notice Provides functions to perform calculations with Wad and Ray units\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\n * with 27 digits of precision)\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n */\nlibrary WadRayMath {\n  // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\n  uint256 internal constant WAD = 1e18;\n  uint256 internal constant HALF_WAD = 0.5e18;\n\n  uint256 internal constant RAY = 1e27;\n  uint256 internal constant HALF_RAY = 0.5e27;\n\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n  /**\n   * @dev Multiplies two wad, rounding half up to the nearest wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @param b Wad\n   * @return c = a*b, in wad\n   */\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\n    assembly {\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, b), HALF_WAD), WAD)\n    }\n  }\n\n  /**\n   * @dev Divides two wad, rounding half up to the nearest wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @param b Wad\n   * @return c = a/b, in wad\n   */\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\n    assembly {\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, WAD), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @notice Multiplies two ray, rounding half up to the nearest ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @param b Ray\n   * @return c = a raymul b\n   */\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\n    assembly {\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, b), HALF_RAY), RAY)\n    }\n  }\n\n  /**\n   * @notice Divides two ray, rounding half up to the nearest ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @param b Ray\n   * @return c = a raydiv b\n   */\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n    assembly {\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, RAY), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @dev Casts ray down to wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @return b = a converted to wad, rounded half up to the nearest wad\n   */\n  function rayToWad(uint256 a) internal pure returns (uint256 b) {\n    assembly {\n      b := div(a, WAD_RAY_RATIO)\n      let remainder := mod(a, WAD_RAY_RATIO)\n      if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\n        b := add(b, 1)\n      }\n    }\n  }\n\n  /**\n   * @dev Converts wad up to ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @return b = a converted in ray\n   */\n  function wadToRay(uint256 a) internal pure returns (uint256 b) {\n    // to avoid overflow, b/WAD_RAY_RATIO == a\n    assembly {\n      b := mul(a, WAD_RAY_RATIO)\n\n      if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\n        revert(0, 0)\n      }\n    }\n  }\n}\n\n/// @notice This interface contains the only ARM-related functions that might be used on-chain by other CCIP contracts.\ninterface IARM {\n  /// @notice A Merkle root tagged with the address of the commit store contract it is destined for.\n  struct TaggedRoot {\n    address commitStore;\n    bytes32 root;\n  }\n\n  /// @notice Callers MUST NOT cache the return value as a blessed tagged root could become unblessed.\n  function isBlessed(TaggedRoot calldata taggedRoot) external view returns (bool);\n\n  /// @notice When the ARM is \"cursed\", CCIP pauses until the curse is lifted.\n  function isCursed() external view returns (bool);\n}\n\n/**\n * @title IPoolConfigurator\n * @author Aave\n * @notice Defines the basic interface for a Pool configurator.\n * @dev Reduced interface from https://github.com/aave-dao/aave-v3-origin/blob/main/src/core/contracts/interfaces/IPoolConfigurator.sol\n */\ninterface IPoolConfigurator {\n  /**\n   * @notice Sets interest rate data for a reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateData bytes-encoded rate data. In this format in order to allow the rate strategy contract\n   *  to de-structure custom data\n   */\n  function setReserveInterestRateData(address asset, bytes calldata rateData) external;\n\n  /**\n   * @notice Updates the borrow cap of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newBorrowCap The new borrow cap of the reserve\n   */\n  function setBorrowCap(address asset, uint256 newBorrowCap) external;\n\n  /**\n   * @notice Updates the supply cap of a reserve.\n   * @param asset The address of the underlying asset of the reserve\n   * @param newSupplyCap The new supply cap of the reserve\n   */\n  function setSupplyCap(address asset, uint256 newSupplyCap) external;\n}\n\n/**\n * @title IReserveInterestRateStrategy\n * @author BGD Labs\n * @notice Basic interface for any rate strategy used by the Aave protocol\n */\ninterface IReserveInterestRateStrategy {\n  /**\n   * @notice Sets interest rate data for an Aave rate strategy\n   * @param reserve The reserve to update\n   * @param rateData The abi encoded reserve interest rate data to apply to the given reserve\n   *   Abstracted this way as rate strategies can be custom\n   */\n  function setInterestRateParams(address reserve, bytes calldata rateData) external;\n\n  /**\n   * @notice Calculates the interest rates depending on the reserve's state and configurations\n   * @param params The parameters needed to calculate interest rates\n   * @return liquidityRate The liquidity rate expressed in ray\n   * @return stableBorrowRate The stable borrow rate expressed in ray\n   * @return variableBorrowRate The variable borrow rate expressed in ray\n   */\n  function calculateInterestRates(\n    DataTypes.CalculateInterestRatesParams memory params\n  ) external view returns (uint256, uint256, uint256);\n}\n\n/**\n * @title IDefaultInterestRateStrategyV2\n * @author BGD Labs\n * @notice Interface of the default interest rate strategy used by the Aave protocol\n */\ninterface IDefaultInterestRateStrategyV2 is IReserveInterestRateStrategy {\n  struct CalcInterestRatesLocalVars {\n    uint256 availableLiquidity;\n    uint256 totalDebt;\n    uint256 currentVariableBorrowRate;\n    uint256 currentLiquidityRate;\n    uint256 borrowUsageRatio;\n    uint256 supplyUsageRatio;\n    uint256 availableLiquidityPlusDebt;\n  }\n\n  /**\n   * @notice Holds the interest rate data for a given reserve\n   *\n   * @dev Since values are in bps, they are multiplied by 1e23 in order to become rays with 27 decimals. This\n   * in turn means that the maximum supported interest rate is 4294967295 (2**32-1) bps or 42949672.95%.\n   *\n   * @param optimalUsageRatio The optimal usage ratio, in bps\n   * @param baseVariableBorrowRate The base variable borrow rate, in bps\n   * @param variableRateSlope1 The slope of the variable interest curve, before hitting the optimal ratio, in bps\n   * @param variableRateSlope2 The slope of the variable interest curve, after hitting the optimal ratio, in bps\n   */\n  struct InterestRateData {\n    uint16 optimalUsageRatio;\n    uint32 baseVariableBorrowRate;\n    uint32 variableRateSlope1;\n    uint32 variableRateSlope2;\n  }\n\n  /**\n   * @notice The interest rate data, where all values are in ray (fixed-point 27 decimal numbers) for a given reserve,\n   * used in in-memory calculations.\n   *\n   * @param optimalUsageRatio The optimal usage ratio\n   * @param baseVariableBorrowRate The base variable borrow rate\n   * @param variableRateSlope1 The slope of the variable interest curve, before hitting the optimal ratio\n   * @param variableRateSlope2 The slope of the variable interest curve, after hitting the optimal ratio\n   */\n  struct InterestRateDataRay {\n    uint256 optimalUsageRatio;\n    uint256 baseVariableBorrowRate;\n    uint256 variableRateSlope1;\n    uint256 variableRateSlope2;\n  }\n\n  /**\n   * @notice emitted when new interest rate data is set in a reserve\n   *\n   * @param reserve address of the reserve that has new interest rate data set\n   * @param optimalUsageRatio The optimal usage ratio, in bps\n   * @param baseVariableBorrowRate The base variable borrow rate, in bps\n   * @param variableRateSlope1 The slope of the variable interest curve, before hitting the optimal ratio, in bps\n   * @param variableRateSlope2 The slope of the variable interest curve, after hitting the optimal ratio, in bps\n   */\n  event RateDataUpdate(\n    address indexed reserve,\n    uint256 optimalUsageRatio,\n    uint256 baseVariableBorrowRate,\n    uint256 variableRateSlope1,\n    uint256 variableRateSlope2\n  );\n\n  /**\n   * @notice Returns the address of the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Returns the maximum value achievable for variable borrow rate, in bps\n   * @return The maximum rate\n   */\n  function MAX_BORROW_RATE() external view returns (uint256);\n\n  /**\n   * @notice Returns the minimum optimal point, in bps\n   * @return The optimal point\n   */\n  function MIN_OPTIMAL_POINT() external view returns (uint256);\n\n  /**\n   * @notice Returns the maximum optimal point, in bps\n   * @return The optimal point\n   */\n  function MAX_OPTIMAL_POINT() external view returns (uint256);\n\n  /**\n   * notice Returns the full InterestRateDataRay object for the given reserve, in bps\n   *\n   * @param reserve The reserve to get the data of\n   *\n   * @return The InterestRateData object for the given reserve\n   */\n  function getInterestRateDataBps(address reserve) external view returns (InterestRateData memory);\n\n  /**\n   * @notice Returns the optimal usage rate for the given reserve in ray\n   *\n   * @param reserve The reserve to get the optimal usage rate of\n   *\n   * @return The optimal usage rate is the level of borrow / collateral at which the borrow rate\n   */\n  function getOptimalUsageRatio(address reserve) external view returns (uint256);\n\n  /**\n   * @notice Returns the variable rate slope below optimal usage ratio in ray\n   * @dev It's the variable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO\n   *\n   * @param reserve The reserve to get the variable rate slope 1 of\n   *\n   * @return The variable rate slope\n   */\n  function getVariableRateSlope1(address reserve) external view returns (uint256);\n\n  /**\n   * @notice Returns the variable rate slope above optimal usage ratio in ray\n   * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO\n   *\n   * @param reserve The reserve to get the variable rate slope 2 of\n   *\n   * @return The variable rate slope\n   */\n  function getVariableRateSlope2(address reserve) external view returns (uint256);\n\n  /**\n   * @notice Returns the base variable borrow rate, in ray\n   *\n   * @param reserve The reserve to get the base variable borrow rate of\n   *\n   * @return The base variable borrow rate\n   */\n  function getBaseVariableBorrowRate(address reserve) external view returns (uint256);\n\n  /**\n   * @notice Returns the maximum variable borrow rate, in ray\n   *\n   * @param reserve The reserve to get the maximum variable borrow rate of\n   *\n   * @return The maximum variable borrow rate\n   */\n  function getMaxVariableBorrowRate(address reserve) external view returns (uint256);\n\n  /**\n   * @notice Sets interest rate data for an Aave rate strategy\n   * @param reserve The reserve to update\n   * @param rateData The reserve interest rate data to apply to the given reserve\n   *   Being specific to this custom implementation, with custom struct type,\n   *   overloading the function on the generic interface\n   */\n  function setInterestRateParams(address reserve, InterestRateData calldata rateData) external;\n}\n\n/**\n * @title DefaultReserveInterestRateStrategyV2 contract\n * @author BGD Labs\n * @notice Default interest rate strategy used by the Aave protocol\n * @dev Strategies are pool-specific: each contract CAN'T be used across different Aave pools\n *   due to the caching of the PoolAddressesProvider and the usage of underlying addresses as\n *   index of the _interestRateData\n */\ncontract DefaultReserveInterestRateStrategyV2 is IDefaultInterestRateStrategyV2 {\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n\n  /// @inheritdoc IDefaultInterestRateStrategyV2\n  IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n  /// @inheritdoc IDefaultInterestRateStrategyV2\n  uint256 public constant MAX_BORROW_RATE = 1000_00;\n\n  /// @inheritdoc IDefaultInterestRateStrategyV2\n  uint256 public constant MIN_OPTIMAL_POINT = 1_00;\n\n  /// @inheritdoc IDefaultInterestRateStrategyV2\n  uint256 public constant MAX_OPTIMAL_POINT = 99_00;\n\n  /// @dev Map of reserves address and their interest rate data (reserveAddress => interestRateData)\n  mapping(address => InterestRateData) internal _interestRateData;\n\n  modifier onlyPoolConfigurator() {\n    require(\n      msg.sender == ADDRESSES_PROVIDER.getPoolConfigurator(),\n      Errors.CALLER_NOT_POOL_CONFIGURATOR\n    );\n    _;\n  }\n\n  /**\n   * @dev Constructor.\n   * @param provider The address of the PoolAddressesProvider of the associated Aave pool\n   */\n  constructor(address provider) {\n    require(provider != address(0), Errors.INVALID_ADDRESSES_PROVIDER);\n    ADDRESSES_PROVIDER = IPoolAddressesProvider(provider);\n  }\n\n  /// @inheritdoc IReserveInterestRateStrategy\n  function setInterestRateParams(\n    address reserve,\n    bytes calldata rateData\n  ) external onlyPoolConfigurator {\n    _setInterestRateParams(reserve, abi.decode(rateData, (InterestRateData)));\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategyV2\n  function setInterestRateParams(\n    address reserve,\n    InterestRateData calldata rateData\n  ) external onlyPoolConfigurator {\n    _setInterestRateParams(reserve, rateData);\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategyV2\n  function getInterestRateDataBps(address reserve) external view returns (InterestRateData memory) {\n    return _interestRateData[reserve];\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategyV2\n  function getOptimalUsageRatio(address reserve) external view returns (uint256) {\n    return _bpsToRay(uint256(_interestRateData[reserve].optimalUsageRatio));\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategyV2\n  function getVariableRateSlope1(address reserve) external view returns (uint256) {\n    return _bpsToRay(uint256(_interestRateData[reserve].variableRateSlope1));\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategyV2\n  function getVariableRateSlope2(address reserve) external view returns (uint256) {\n    return _bpsToRay(uint256(_interestRateData[reserve].variableRateSlope2));\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategyV2\n  function getBaseVariableBorrowRate(address reserve) external view override returns (uint256) {\n    return _bpsToRay(uint256(_interestRateData[reserve].baseVariableBorrowRate));\n  }\n\n  /// @inheritdoc IDefaultInterestRateStrategyV2\n  function getMaxVariableBorrowRate(address reserve) external view override returns (uint256) {\n    return\n      _bpsToRay(\n        uint256(\n          _interestRateData[reserve].baseVariableBorrowRate +\n            _interestRateData[reserve].variableRateSlope1 +\n            _interestRateData[reserve].variableRateSlope2\n        )\n      );\n  }\n\n  /// @inheritdoc IReserveInterestRateStrategy\n  function calculateInterestRates(\n    DataTypes.CalculateInterestRatesParams memory params\n  ) external view virtual override returns (uint256, uint256, uint256) {\n    InterestRateDataRay memory rateData = _rayifyRateData(_interestRateData[params.reserve]);\n\n    // @note This is a short circuit to allow mintable assets (ex. GHO), which by definition cannot be supplied\n    // and thus do not use virtual underlying balances.\n    if (!params.usingVirtualBalance) {\n      return (0, 0, rateData.baseVariableBorrowRate);\n    }\n\n    CalcInterestRatesLocalVars memory vars;\n\n    vars.totalDebt = params.totalStableDebt + params.totalVariableDebt;\n\n    vars.currentLiquidityRate = 0;\n    vars.currentVariableBorrowRate = rateData.baseVariableBorrowRate;\n\n    if (vars.totalDebt != 0) {\n      vars.availableLiquidity =\n        params.virtualUnderlyingBalance +\n        params.liquidityAdded -\n        params.liquidityTaken;\n\n      vars.availableLiquidityPlusDebt = vars.availableLiquidity + vars.totalDebt;\n      vars.borrowUsageRatio = vars.totalDebt.rayDiv(vars.availableLiquidityPlusDebt);\n      vars.supplyUsageRatio = vars.totalDebt.rayDiv(\n        vars.availableLiquidityPlusDebt + params.unbacked\n      );\n    } else {\n      return (0, 0, vars.currentVariableBorrowRate);\n    }\n\n    if (vars.borrowUsageRatio > rateData.optimalUsageRatio) {\n      uint256 excessBorrowUsageRatio = (vars.borrowUsageRatio - rateData.optimalUsageRatio).rayDiv(\n        WadRayMath.RAY - rateData.optimalUsageRatio\n      );\n\n      vars.currentVariableBorrowRate +=\n        rateData.variableRateSlope1 +\n        rateData.variableRateSlope2.rayMul(excessBorrowUsageRatio);\n    } else {\n      vars.currentVariableBorrowRate += rateData\n        .variableRateSlope1\n        .rayMul(vars.borrowUsageRatio)\n        .rayDiv(rateData.optimalUsageRatio);\n    }\n\n    vars.currentLiquidityRate = _getOverallBorrowRate(\n      params.totalStableDebt,\n      params.totalVariableDebt,\n      vars.currentVariableBorrowRate,\n      params.averageStableBorrowRate\n    ).rayMul(vars.supplyUsageRatio).percentMul(\n        PercentageMath.PERCENTAGE_FACTOR - params.reserveFactor\n      );\n\n    return (vars.currentLiquidityRate, 0, vars.currentVariableBorrowRate);\n  }\n\n  /**\n   * @dev Calculates the overall borrow rate as the weighted average between the total variable debt and total stable\n   * debt\n   * @param totalStableDebt The total borrowed from the reserve at a stable rate\n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n   * @param currentVariableBorrowRate The current variable borrow rate of the reserve\n   * @param currentAverageStableBorrowRate The current weighted average of all the stable rate loans\n   * @return The weighted averaged borrow rate\n   */\n  function _getOverallBorrowRate(\n    uint256 totalStableDebt,\n    uint256 totalVariableDebt,\n    uint256 currentVariableBorrowRate,\n    uint256 currentAverageStableBorrowRate\n  ) internal pure returns (uint256) {\n    uint256 totalDebt = totalStableDebt + totalVariableDebt;\n\n    uint256 weightedVariableRate = totalVariableDebt.wadToRay().rayMul(currentVariableBorrowRate);\n\n    uint256 weightedStableRate = totalStableDebt.wadToRay().rayMul(currentAverageStableBorrowRate);\n\n    uint256 overallBorrowRate = (weightedVariableRate + weightedStableRate).rayDiv(\n      totalDebt.wadToRay()\n    );\n\n    return overallBorrowRate;\n  }\n\n  /**\n   * @dev Doing validations and data update for an asset\n   * @param reserve address of the underlying asset of the reserve\n   * @param rateData Encoded reserve interest rate data to apply\n   */\n  function _setInterestRateParams(address reserve, InterestRateData memory rateData) internal {\n    require(reserve != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n\n    require(\n      rateData.optimalUsageRatio <= MAX_OPTIMAL_POINT &&\n        rateData.optimalUsageRatio >= MIN_OPTIMAL_POINT,\n      Errors.INVALID_OPTIMAL_USAGE_RATIO\n    );\n\n    require(\n      rateData.variableRateSlope1 <= rateData.variableRateSlope2,\n      Errors.SLOPE_2_MUST_BE_GTE_SLOPE_1\n    );\n\n    // The maximum rate should not be above certain threshold\n    require(\n      uint256(rateData.baseVariableBorrowRate) +\n        uint256(rateData.variableRateSlope1) +\n        uint256(rateData.variableRateSlope2) <=\n        MAX_BORROW_RATE,\n      Errors.INVALID_MAX_RATE\n    );\n\n    _interestRateData[reserve] = rateData;\n    emit RateDataUpdate(\n      reserve,\n      rateData.optimalUsageRatio,\n      rateData.baseVariableBorrowRate,\n      rateData.variableRateSlope1,\n      rateData.variableRateSlope2\n    );\n  }\n\n  /**\n   * @dev Transforms an InterestRateData struct to an InterestRateDataRay struct by multiplying all values\n   * by 1e23, turning them into ray values\n   *\n   * @param data The InterestRateData struct to transform\n   *\n   * @return The resulting InterestRateDataRay struct\n   */\n  function _rayifyRateData(\n    InterestRateData memory data\n  ) internal pure returns (InterestRateDataRay memory) {\n    return\n      InterestRateDataRay({\n        optimalUsageRatio: _bpsToRay(uint256(data.optimalUsageRatio)),\n        baseVariableBorrowRate: _bpsToRay(uint256(data.baseVariableBorrowRate)),\n        variableRateSlope1: _bpsToRay(uint256(data.variableRateSlope1)),\n        variableRateSlope2: _bpsToRay(uint256(data.variableRateSlope2))\n      });\n  }\n\n  // @dev helper function added here, as generally the protocol doesn't use bps\n  function _bpsToRay(uint256 n) internal pure returns (uint256) {\n    return n * 1e23;\n  }\n}\n"
    },
    "src/contracts/misc/dependencies/Ccip.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n\n/// @notice Implements Token Bucket rate limiting.\n/// @dev Reduced library from https://github.com/aave/ccip/blob/ccip-gho/contracts/src/v0.8/ccip/libraries/RateLimiter.sol\n/// @dev uint128 is safe for rate limiter state.\n/// For USD value rate limiting, it can adequately store USD value in 18 decimals.\n/// For ERC20 token amount rate limiting, all tokens that will be listed will have at most\n/// a supply of uint128.max tokens, and it will therefore not overflow the bucket.\n/// In exceptional scenarios where tokens consumed may be larger than uint128,\n/// e.g. compromised issuer, an enabled RateLimiter will check and revert.\nlibrary RateLimiter {\n  error InvalidRatelimitRate(Config rateLimiterConfig);\n  error DisabledNonZeroRateLimit(Config config);\n  error RateLimitMustBeDisabled();\n\n  event ConfigChanged(Config config);\n\n  struct TokenBucket {\n    uint128 tokens; // ──────╮ Current number of tokens that are in the bucket.\n    uint32 lastUpdated; //   │ Timestamp in seconds of the last token refill, good for 100+ years.\n    bool isEnabled; // ──────╯ Indication whether the rate limiting is enabled or not\n    uint128 capacity; // ────╮ Maximum number of tokens that can be in the bucket.\n    uint128 rate; // ────────╯ Number of tokens per second that the bucket is refilled.\n  }\n\n  struct Config {\n    bool isEnabled; // Indication whether the rate limiting should be enabled\n    uint128 capacity; // ────╮ Specifies the capacity of the rate limiter\n    uint128 rate; //  ───────╯ Specifies the rate of the rate limiter\n  }\n\n  /// @notice Gets the token bucket with its values for the block it was requested at.\n  /// @return The token bucket.\n  function _currentTokenBucketState(\n    TokenBucket memory bucket\n  ) internal view returns (TokenBucket memory) {\n    // We update the bucket to reflect the status at the exact time of the\n    // call. This means we might need to refill a part of the bucket based\n    // on the time that has passed since the last update.\n    bucket.tokens = uint128(\n      _calculateRefill(\n        bucket.capacity,\n        bucket.tokens,\n        block.timestamp - bucket.lastUpdated,\n        bucket.rate\n      )\n    );\n    bucket.lastUpdated = uint32(block.timestamp);\n    return bucket;\n  }\n\n  /// @notice Sets the rate limited config.\n  /// @param s_bucket The token bucket\n  /// @param config The new config\n  function _setTokenBucketConfig(TokenBucket storage s_bucket, Config memory config) internal {\n    // First update the bucket to make sure the proper rate is used for all the time\n    // up until the config change.\n    uint256 timeDiff = block.timestamp - s_bucket.lastUpdated;\n    if (timeDiff != 0) {\n      s_bucket.tokens = uint128(\n        _calculateRefill(s_bucket.capacity, s_bucket.tokens, timeDiff, s_bucket.rate)\n      );\n\n      s_bucket.lastUpdated = uint32(block.timestamp);\n    }\n\n    s_bucket.tokens = uint128(_min(config.capacity, s_bucket.tokens));\n    s_bucket.isEnabled = config.isEnabled;\n    s_bucket.capacity = config.capacity;\n    s_bucket.rate = config.rate;\n\n    emit ConfigChanged(config);\n  }\n\n  /// @notice Validates the token bucket config\n  function _validateTokenBucketConfig(Config memory config, bool mustBeDisabled) internal pure {\n    if (config.isEnabled) {\n      if (config.rate >= config.capacity || config.rate == 0) {\n        revert InvalidRatelimitRate(config);\n      }\n      if (mustBeDisabled) {\n        revert RateLimitMustBeDisabled();\n      }\n    } else {\n      if (config.rate != 0 || config.capacity != 0) {\n        revert DisabledNonZeroRateLimit(config);\n      }\n    }\n  }\n\n  /// @notice Calculate refilled tokens\n  /// @param capacity bucket capacity\n  /// @param tokens current bucket tokens\n  /// @param timeDiff block time difference since last refill\n  /// @param rate bucket refill rate\n  /// @return the value of tokens after refill\n  function _calculateRefill(\n    uint256 capacity,\n    uint256 tokens,\n    uint256 timeDiff,\n    uint256 rate\n  ) private pure returns (uint256) {\n    return _min(capacity, tokens + timeDiff * rate);\n  }\n\n  /// @notice Return the smallest of two integers\n  /// @param a first int\n  /// @param b second int\n  /// @return smallest\n  function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n}\n\n/// @dev Reduced interface of CCIP Router contract with needed functions only\n/// @dev Adapted from https://github.com/aave/ccip/blob/ccip-gho/contracts/src/v0.8/ccip/interfaces/IRouter.sol\ninterface IRouter {\n  error OnlyOffRamp();\n\n  /// @notice Route the message to its intended receiver contract.\n  /// @param message Client.Any2EVMMessage struct.\n  /// @param gasForCallExactCheck of params for exec\n  /// @param gasLimit set of params for exec\n  /// @param receiver set of params for exec\n  /// @dev if the receiver is a contracts that signals support for CCIP execution through EIP-165.\n  /// the contract is called. If not, only tokens are transferred.\n  /// @return success A boolean value indicating whether the ccip message was received without errors.\n  /// @return retBytes A bytes array containing return data form CCIP receiver.\n  /// @return gasUsed the gas used by the external customer call. Does not include any overhead.\n  function routeMessage(\n    Client.Any2EVMMessage calldata message,\n    uint16 gasForCallExactCheck,\n    uint256 gasLimit,\n    address receiver\n  ) external returns (bool success, bytes memory retBytes, uint256 gasUsed);\n\n  /// @notice Returns the configured onramp for a specific destination chain.\n  /// @param destChainSelector The destination chain Id to get the onRamp for.\n  /// @return onRampAddress The address of the onRamp.\n  function getOnRamp(uint64 destChainSelector) external view returns (address onRampAddress);\n\n  /// @notice Return true if the given offRamp is a configured offRamp for the given source chain.\n  /// @param sourceChainSelector The source chain selector to check.\n  /// @param offRamp The address of the offRamp to check.\n  function isOffRamp(\n    uint64 sourceChainSelector,\n    address offRamp\n  ) external view returns (bool isOffRamp);\n}\n\n/// @dev Reduced interface of CCIP UpgradeableLockReleaseTokenPool contract with needed functions only\n/// @dev Adapted from https://github.com/aave/ccip/blob/ccip-gho/contracts/src/v0.8/ccip/pools/GHO/UpgradeableLockReleaseTokenPool.sol\ninterface IUpgradeableLockReleaseTokenPool {\n  function setBridgeLimit(uint256 newBridgeLimit) external;\n\n  function setChainRateLimiterConfig(\n    uint64 remoteChainSelector,\n    RateLimiter.Config memory outboundConfig,\n    RateLimiter.Config memory inboundConfig\n  ) external;\n\n  function setRateLimitAdmin(address rateLimitAdmin) external;\n\n  function setBridgeLimitAdmin(address bridgeLimitAdmin) external;\n\n  function getRateLimitAdmin() external view returns (address);\n\n  function getBridgeLimitAdmin() external view returns (address);\n\n  function getBridgeLimit() external view returns (uint256);\n\n  function getCurrentOutboundRateLimiterState(\n    uint64 remoteChainSelector\n  ) external view returns (RateLimiter.TokenBucket memory);\n\n  function getCurrentInboundRateLimiterState(\n    uint64 remoteChainSelector\n  ) external view returns (RateLimiter.TokenBucket memory);\n}\n"
    },
    "src/contracts/misc/GhoAaveSteward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IPoolDataProvider} from '@aave/core-v3/contracts/interfaces/IPoolDataProvider.sol';\nimport {IPoolAddressesProvider} from '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport {DataTypes} from '@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol';\nimport {ReserveConfiguration} from '@aave/core-v3/contracts/protocol/libraries/configuration/ReserveConfiguration.sol';\nimport {IPoolConfigurator, IDefaultInterestRateStrategyV2} from './dependencies/AaveV3-1.sol';\nimport {IGhoAaveSteward} from './interfaces/IGhoAaveSteward.sol';\nimport {RiskCouncilControlled} from './RiskCouncilControlled.sol';\n\n/**\n * @title GhoAaveSteward\n * @author Aave Labs\n * @notice Helper contract for managing parameters of the GHO reserve\n * @dev Only the Risk Council is able to action contract's functions, based on specific conditions that have been agreed upon with the community.\n * @dev Requires role RiskAdmin on the Aave V3 Ethereum Pool\n */\ncontract GhoAaveSteward is Ownable, RiskCouncilControlled, IGhoAaveSteward {\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  uint256 internal constant BPS_MAX = 100_00;\n\n  /// @inheritdoc IGhoAaveSteward\n  address public immutable POOL_DATA_PROVIDER;\n\n  /// @inheritdoc IGhoAaveSteward\n  uint256 public constant MINIMUM_DELAY = 1 days;\n\n  /// @inheritdoc IGhoAaveSteward\n  address public immutable POOL_ADDRESSES_PROVIDER;\n\n  /// @inheritdoc IGhoAaveSteward\n  address public immutable GHO_TOKEN;\n\n  BorrowRateConfig internal _borrowRateConfig;\n\n  GhoDebounce internal _ghoTimelocks;\n\n  /**\n   * @dev Only methods that are not timelocked can be called if marked by this modifier.\n   */\n  modifier notTimelocked(uint40 timelock) {\n    require(block.timestamp - timelock > MINIMUM_DELAY, 'DEBOUNCE_NOT_RESPECTED');\n    _;\n  }\n\n  /**\n   * @dev Constructor\n   * @param owner The address of the contract's owner\n   * @param addressesProvider The address of the PoolAddressesProvider of Aave V3 Ethereum Pool\n   * @param poolDataProvider The pool data provider of the pool to be controlled by the steward\n   * @param ghoToken The address of the GhoToken\n   * @param riskCouncil The address of the risk council\n   * @param borrowRateConfig The configuration conditions for GHO borrow rate changes\n   */\n  constructor(\n    address owner,\n    address addressesProvider,\n    address poolDataProvider,\n    address ghoToken,\n    address riskCouncil,\n    BorrowRateConfig memory borrowRateConfig\n  ) RiskCouncilControlled(riskCouncil) {\n    require(owner != address(0), 'INVALID_OWNER');\n    require(addressesProvider != address(0), 'INVALID_ADDRESSES_PROVIDER');\n    require(poolDataProvider != address(0), 'INVALID_DATA_PROVIDER');\n    require(ghoToken != address(0), 'INVALID_GHO_TOKEN');\n\n    POOL_ADDRESSES_PROVIDER = addressesProvider;\n    POOL_DATA_PROVIDER = poolDataProvider;\n    GHO_TOKEN = ghoToken;\n    _borrowRateConfig = borrowRateConfig;\n\n    _transferOwnership(owner);\n  }\n\n  /// @inheritdoc IGhoAaveSteward\n  function updateGhoBorrowRate(\n    uint16 optimalUsageRatio,\n    uint32 baseVariableBorrowRate,\n    uint32 variableRateSlope1,\n    uint32 variableRateSlope2\n  ) external onlyRiskCouncil notTimelocked(_ghoTimelocks.ghoBorrowRateLastUpdate) {\n    IDefaultInterestRateStrategyV2.InterestRateData\n      memory rateParams = IDefaultInterestRateStrategyV2.InterestRateData({\n        optimalUsageRatio: optimalUsageRatio,\n        baseVariableBorrowRate: baseVariableBorrowRate,\n        variableRateSlope1: variableRateSlope1,\n        variableRateSlope2: variableRateSlope2\n      });\n    _validateRatesUpdate(rateParams);\n\n    _ghoTimelocks.ghoBorrowRateLastUpdate = uint40(block.timestamp);\n\n    IPoolConfigurator(IPoolAddressesProvider(POOL_ADDRESSES_PROVIDER).getPoolConfigurator())\n      .setReserveInterestRateData(GHO_TOKEN, abi.encode(rateParams));\n  }\n\n  /// @inheritdoc IGhoAaveSteward\n  function updateGhoBorrowCap(\n    uint256 newBorrowCap\n  ) external onlyRiskCouncil notTimelocked(_ghoTimelocks.ghoBorrowCapLastUpdate) {\n    DataTypes.ReserveConfigurationMap memory configuration = IPool(\n      IPoolAddressesProvider(POOL_ADDRESSES_PROVIDER).getPool()\n    ).getConfiguration(GHO_TOKEN);\n    uint256 currentBorrowCap = configuration.getBorrowCap();\n    require(newBorrowCap != currentBorrowCap, 'NO_CHANGE_IN_BORROW_CAP');\n    require(\n      _isDifferenceLowerThanMax(currentBorrowCap, newBorrowCap, currentBorrowCap),\n      'INVALID_BORROW_CAP_UPDATE'\n    );\n\n    _ghoTimelocks.ghoBorrowCapLastUpdate = uint40(block.timestamp);\n\n    IPoolConfigurator(IPoolAddressesProvider(POOL_ADDRESSES_PROVIDER).getPoolConfigurator())\n      .setBorrowCap(GHO_TOKEN, newBorrowCap);\n  }\n\n  /// @inheritdoc IGhoAaveSteward\n  function updateGhoSupplyCap(\n    uint256 newSupplyCap\n  ) external onlyRiskCouncil notTimelocked(_ghoTimelocks.ghoSupplyCapLastUpdate) {\n    DataTypes.ReserveConfigurationMap memory configuration = IPool(\n      IPoolAddressesProvider(POOL_ADDRESSES_PROVIDER).getPool()\n    ).getConfiguration(GHO_TOKEN);\n    uint256 currentSupplyCap = configuration.getSupplyCap();\n    require(newSupplyCap != currentSupplyCap, 'NO_CHANGE_IN_SUPPLY_CAP');\n    require(\n      _isDifferenceLowerThanMax(currentSupplyCap, newSupplyCap, currentSupplyCap),\n      'INVALID_SUPPLY_CAP_UPDATE'\n    );\n\n    _ghoTimelocks.ghoSupplyCapLastUpdate = uint40(block.timestamp);\n\n    IPoolConfigurator(IPoolAddressesProvider(POOL_ADDRESSES_PROVIDER).getPoolConfigurator())\n      .setSupplyCap(GHO_TOKEN, newSupplyCap);\n  }\n\n  /// @inheritdoc IGhoAaveSteward\n  function setBorrowRateConfig(\n    uint16 optimalUsageRatioMaxChange,\n    uint32 baseVariableBorrowRateMaxChange,\n    uint32 variableRateSlope1MaxChange,\n    uint32 variableRateSlope2MaxChange\n  ) external onlyOwner {\n    _borrowRateConfig.optimalUsageRatioMaxChange = optimalUsageRatioMaxChange;\n    _borrowRateConfig.baseVariableBorrowRateMaxChange = baseVariableBorrowRateMaxChange;\n    _borrowRateConfig.variableRateSlope1MaxChange = variableRateSlope1MaxChange;\n    _borrowRateConfig.variableRateSlope2MaxChange = variableRateSlope2MaxChange;\n  }\n\n  /// @inheritdoc IGhoAaveSteward\n  function getBorrowRateConfig() external view returns (BorrowRateConfig memory) {\n    return _borrowRateConfig;\n  }\n\n  /// @inheritdoc IGhoAaveSteward\n  function getGhoTimelocks() external view returns (GhoDebounce memory) {\n    return _ghoTimelocks;\n  }\n\n  /// @inheritdoc IGhoAaveSteward\n  function RISK_COUNCIL() public view override returns (address) {\n    return _riskCouncil;\n  }\n\n  /**\n   * @dev Validates the interest rates update\n   * @param newRates The new interest rate data\n   */\n  function _validateRatesUpdate(\n    IDefaultInterestRateStrategyV2.InterestRateData memory newRates\n  ) internal view {\n    address rateStrategyAddress = IPoolDataProvider(POOL_DATA_PROVIDER)\n      .getInterestRateStrategyAddress(GHO_TOKEN);\n    IDefaultInterestRateStrategyV2.InterestRateData\n      memory currentRates = IDefaultInterestRateStrategyV2(rateStrategyAddress)\n        .getInterestRateDataBps(GHO_TOKEN);\n\n    require(\n      newRates.optimalUsageRatio != currentRates.optimalUsageRatio ||\n        newRates.baseVariableBorrowRate != currentRates.baseVariableBorrowRate ||\n        newRates.variableRateSlope1 != currentRates.variableRateSlope1 ||\n        newRates.variableRateSlope2 != currentRates.variableRateSlope2,\n      'NO_CHANGE_IN_RATES'\n    );\n\n    require(\n      _updateWithinAllowedRange(\n        currentRates.optimalUsageRatio,\n        newRates.optimalUsageRatio,\n        _borrowRateConfig.optimalUsageRatioMaxChange,\n        false\n      ),\n      'INVALID_OPTIMAL_USAGE_RATIO'\n    );\n    require(\n      _updateWithinAllowedRange(\n        currentRates.baseVariableBorrowRate,\n        newRates.baseVariableBorrowRate,\n        _borrowRateConfig.baseVariableBorrowRateMaxChange,\n        false\n      ),\n      'INVALID_BORROW_RATE_UPDATE'\n    );\n    require(\n      _updateWithinAllowedRange(\n        currentRates.variableRateSlope1,\n        newRates.variableRateSlope1,\n        _borrowRateConfig.variableRateSlope1MaxChange,\n        false\n      ),\n      'INVALID_VARIABLE_RATE_SLOPE1'\n    );\n    require(\n      _updateWithinAllowedRange(\n        currentRates.variableRateSlope2,\n        newRates.variableRateSlope2,\n        _borrowRateConfig.variableRateSlope2MaxChange,\n        false\n      ),\n      'INVALID_VARIABLE_RATE_SLOPE2'\n    );\n  }\n\n  /**\n   * @dev Ensures that the change difference is lower than max.\n   * @param from current value\n   * @param to new value\n   * @param max maximum difference between from and to\n   * @return bool true if difference between values lower than max, false otherwise\n   */\n  function _isDifferenceLowerThanMax(\n    uint256 from,\n    uint256 to,\n    uint256 max\n  ) internal pure returns (bool) {\n    return from < to ? to - from <= max : from - to <= max;\n  }\n\n  /**\n   * @notice Ensures the risk param update is within the allowed range\n   * @param from current risk param value\n   * @param to new updated risk param value\n   * @param maxPercentChange the max percent change allowed\n   * @param isChangeRelative true, if maxPercentChange is relative in value, false if maxPercentChange\n   *        is absolute in value.\n   * @return bool true, if difference is within the maxPercentChange\n   */\n  function _updateWithinAllowedRange(\n    uint256 from,\n    uint256 to,\n    uint256 maxPercentChange,\n    bool isChangeRelative\n  ) internal pure returns (bool) {\n    // diff denotes the difference between the from and to values, ensuring it is a positive value always\n    uint256 diff = from > to ? from - to : to - from;\n\n    // maxDiff denotes the max permitted difference on both the upper and lower bounds, if the maxPercentChange is relative in value\n    // we calculate the max permitted difference using the maxPercentChange and the from value, otherwise if the maxPercentChange is absolute in value\n    // the max permitted difference is the maxPercentChange itself\n    uint256 maxDiff = isChangeRelative ? (maxPercentChange * from) / BPS_MAX : maxPercentChange;\n\n    if (diff > maxDiff) return false;\n    return true;\n  }\n}\n"
    },
    "src/contracts/misc/GhoBucketSteward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {IGhoToken} from '../gho/interfaces/IGhoToken.sol';\nimport {RiskCouncilControlled} from './RiskCouncilControlled.sol';\nimport {IGhoBucketSteward} from './interfaces/IGhoBucketSteward.sol';\n\n/**\n * @title GhoBucketSteward\n * @author Aave Labs\n * @notice Helper contract for managing bucket capacities of controlled facilitators\n * @dev Only the Risk Council is able to action contract's functions, based on specific conditions that have been agreed upon with the community.\n * @dev Requires role GHO_TOKEN_BUCKET_MANAGER_ROLE on GhoToken\n */\ncontract GhoBucketSteward is Ownable, RiskCouncilControlled, IGhoBucketSteward {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @inheritdoc IGhoBucketSteward\n  uint256 public constant MINIMUM_DELAY = 1 days;\n\n  /// @inheritdoc IGhoBucketSteward\n  address public immutable GHO_TOKEN;\n\n  mapping(address => uint40) internal _facilitatorsBucketCapacityTimelocks;\n\n  mapping(address => bool) internal _controlledFacilitatorsByAddress;\n  EnumerableSet.AddressSet internal _controlledFacilitators;\n\n  /**\n   * @dev Only methods that are not timelocked can be called if marked by this modifier.\n   */\n  modifier notTimelocked(uint40 timelock) {\n    require(block.timestamp - timelock > MINIMUM_DELAY, 'DEBOUNCE_NOT_RESPECTED');\n    _;\n  }\n\n  /**\n   * @dev Constructor\n   * @param owner The address of the contract's owner\n   * @param ghoToken The address of the GhoToken\n   * @param riskCouncil The address of the risk council\n   */\n  constructor(\n    address owner,\n    address ghoToken,\n    address riskCouncil\n  ) RiskCouncilControlled(riskCouncil) {\n    require(owner != address(0), 'INVALID_OWNER');\n    require(ghoToken != address(0), 'INVALID_GHO_TOKEN');\n\n    GHO_TOKEN = ghoToken;\n\n    _transferOwnership(owner);\n  }\n\n  /// @inheritdoc IGhoBucketSteward\n  function updateFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newBucketCapacity\n  ) external onlyRiskCouncil notTimelocked(_facilitatorsBucketCapacityTimelocks[facilitator]) {\n    require(_controlledFacilitatorsByAddress[facilitator], 'FACILITATOR_NOT_CONTROLLED');\n    (uint256 currentBucketCapacity, ) = IGhoToken(GHO_TOKEN).getFacilitatorBucket(facilitator);\n    require(newBucketCapacity != currentBucketCapacity, 'NO_CHANGE_IN_BUCKET_CAPACITY');\n    require(\n      _isIncreaseLowerThanMax(currentBucketCapacity, newBucketCapacity, currentBucketCapacity),\n      'INVALID_BUCKET_CAPACITY_UPDATE'\n    );\n\n    _facilitatorsBucketCapacityTimelocks[facilitator] = uint40(block.timestamp);\n\n    IGhoToken(GHO_TOKEN).setFacilitatorBucketCapacity(facilitator, newBucketCapacity);\n  }\n\n  /// @inheritdoc IGhoBucketSteward\n  function setControlledFacilitator(\n    address[] memory facilitatorList,\n    bool approve\n  ) external onlyOwner {\n    for (uint256 i = 0; i < facilitatorList.length; i++) {\n      _controlledFacilitatorsByAddress[facilitatorList[i]] = approve;\n      if (approve) {\n        _controlledFacilitators.add(facilitatorList[i]);\n      } else {\n        _controlledFacilitators.remove(facilitatorList[i]);\n      }\n    }\n  }\n\n  /// @inheritdoc IGhoBucketSteward\n  function getControlledFacilitators() external view returns (address[] memory) {\n    return _controlledFacilitators.values();\n  }\n\n  /// @inheritdoc IGhoBucketSteward\n  function isControlledFacilitator(address facilitator) external view returns (bool) {\n    return _controlledFacilitatorsByAddress[facilitator];\n  }\n\n  /// @inheritdoc IGhoBucketSteward\n  function getFacilitatorBucketCapacityTimelock(\n    address facilitator\n  ) external view returns (uint40) {\n    return _facilitatorsBucketCapacityTimelocks[facilitator];\n  }\n\n  /// @inheritdoc IGhoBucketSteward\n  function RISK_COUNCIL() public view override returns (address) {\n    return _riskCouncil;\n  }\n\n  /**\n   * @dev Ensures that the change is positive and the difference is lower than max.\n   * @param from current value\n   * @param to new value\n   * @param max maximum difference between from and to\n   * @return bool true if difference between values is positive and lower than max, false otherwise\n   */\n  function _isIncreaseLowerThanMax(\n    uint256 from,\n    uint256 to,\n    uint256 max\n  ) internal pure returns (bool) {\n    return to >= from && to - from <= max;\n  }\n}\n"
    },
    "src/contracts/misc/GhoCcipSteward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IUpgradeableLockReleaseTokenPool, RateLimiter} from './dependencies/Ccip.sol';\nimport {IGhoCcipSteward} from './interfaces/IGhoCcipSteward.sol';\nimport {RiskCouncilControlled} from './RiskCouncilControlled.sol';\n\n/**\n * @title GhoCcipSteward\n * @author Aave Labs\n * @notice Helper contract for managing parameters of the CCIP token pools\n * @dev Only the Risk Council is able to action contract's functions, based on specific conditions that have been agreed upon with the community.\n * @dev Requires roles RateLimitAdmin and BridgeLimitAdmin (if on Ethereum) on GhoTokenPool\n */\ncontract GhoCcipSteward is RiskCouncilControlled, IGhoCcipSteward {\n  /// @inheritdoc IGhoCcipSteward\n  uint256 public constant MINIMUM_DELAY = 1 days;\n\n  /// @inheritdoc IGhoCcipSteward\n  address public immutable GHO_TOKEN;\n\n  /// @inheritdoc IGhoCcipSteward\n  address public immutable GHO_TOKEN_POOL;\n\n  /// @inheritdoc IGhoCcipSteward\n  bool public immutable BRIDGE_LIMIT_ENABLED;\n\n  CcipDebounce internal _ccipTimelocks;\n\n  /**\n   * @dev Only methods that are not timelocked can be called if marked by this modifier.\n   */\n  modifier notTimelocked(uint40 timelock) {\n    require(block.timestamp - timelock > MINIMUM_DELAY, 'DEBOUNCE_NOT_RESPECTED');\n    _;\n  }\n\n  /**\n   * @dev Constructor\n   * @param ghoToken The address of the GhoToken\n   * @param ghoTokenPool The address of the Gho CCIP Token Pool\n   * @param riskCouncil The address of the risk council\n   * @param bridgeLimitEnabled Whether the bridge limit feature is supported in the GhoTokenPool\n   */\n  constructor(\n    address ghoToken,\n    address ghoTokenPool,\n    address riskCouncil,\n    bool bridgeLimitEnabled\n  ) RiskCouncilControlled(riskCouncil) {\n    require(ghoToken != address(0), 'INVALID_GHO_TOKEN');\n    require(ghoTokenPool != address(0), 'INVALID_GHO_TOKEN_POOL');\n\n    GHO_TOKEN = ghoToken;\n    GHO_TOKEN_POOL = ghoTokenPool;\n    BRIDGE_LIMIT_ENABLED = bridgeLimitEnabled;\n  }\n\n  /// @inheritdoc IGhoCcipSteward\n  function updateBridgeLimit(\n    uint256 newBridgeLimit\n  ) external onlyRiskCouncil notTimelocked(_ccipTimelocks.bridgeLimitLastUpdate) {\n    require(BRIDGE_LIMIT_ENABLED, 'BRIDGE_LIMIT_DISABLED');\n\n    uint256 currentBridgeLimit = IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL).getBridgeLimit();\n    require(newBridgeLimit != currentBridgeLimit, 'NO_CHANGE_IN_BRIDGE_LIMIT');\n    require(\n      _isDifferenceLowerThanMax(currentBridgeLimit, newBridgeLimit, currentBridgeLimit),\n      'INVALID_BRIDGE_LIMIT_UPDATE'\n    );\n\n    _ccipTimelocks.bridgeLimitLastUpdate = uint40(block.timestamp);\n\n    IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL).setBridgeLimit(newBridgeLimit);\n  }\n\n  /// @inheritdoc IGhoCcipSteward\n  function updateRateLimit(\n    uint64 remoteChainSelector,\n    bool outboundEnabled,\n    uint128 outboundCapacity,\n    uint128 outboundRate,\n    bool inboundEnabled,\n    uint128 inboundCapacity,\n    uint128 inboundRate\n  ) external onlyRiskCouncil notTimelocked(_ccipTimelocks.rateLimitLastUpdate) {\n    RateLimiter.TokenBucket memory outboundConfig = IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL)\n      .getCurrentOutboundRateLimiterState(remoteChainSelector);\n    RateLimiter.TokenBucket memory inboundConfig = IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL)\n      .getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    require(\n      outboundEnabled != outboundConfig.isEnabled ||\n        outboundCapacity != outboundConfig.capacity ||\n        outboundRate != outboundConfig.rate ||\n        inboundEnabled != inboundConfig.isEnabled ||\n        inboundCapacity != inboundConfig.capacity ||\n        inboundRate != inboundConfig.rate,\n      'NO_CHANGE_IN_RATE_LIMIT'\n    );\n\n    require(\n      _isDifferenceLowerThanMax(outboundConfig.capacity, outboundCapacity, outboundConfig.capacity),\n      'INVALID_RATE_LIMIT_UPDATE'\n    );\n    require(\n      _isDifferenceLowerThanMax(outboundConfig.rate, outboundRate, outboundConfig.rate),\n      'INVALID_RATE_LIMIT_UPDATE'\n    );\n    require(\n      _isDifferenceLowerThanMax(inboundConfig.capacity, inboundCapacity, inboundConfig.capacity),\n      'INVALID_RATE_LIMIT_UPDATE'\n    );\n    require(\n      _isDifferenceLowerThanMax(inboundConfig.rate, inboundRate, inboundConfig.rate),\n      'INVALID_RATE_LIMIT_UPDATE'\n    );\n\n    _ccipTimelocks.rateLimitLastUpdate = uint40(block.timestamp);\n\n    IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL).setChainRateLimiterConfig(\n      remoteChainSelector,\n      RateLimiter.Config({\n        isEnabled: outboundEnabled,\n        capacity: outboundCapacity,\n        rate: outboundRate\n      }),\n      RateLimiter.Config({isEnabled: inboundEnabled, capacity: inboundCapacity, rate: inboundRate})\n    );\n  }\n\n  /// @inheritdoc IGhoCcipSteward\n  function getCcipTimelocks() external view override returns (CcipDebounce memory) {\n    return _ccipTimelocks;\n  }\n\n  /// @inheritdoc IGhoCcipSteward\n  function RISK_COUNCIL() external view override returns (address) {\n    return _riskCouncil;\n  }\n\n  /**\n   * @dev Ensures that the change difference is lower than max.\n   * @param from current value\n   * @param to new value\n   * @param max maximum difference between from and to\n   * @return bool true if difference between values lower than max, false otherwise\n   */\n  function _isDifferenceLowerThanMax(\n    uint256 from,\n    uint256 to,\n    uint256 max\n  ) internal pure returns (bool) {\n    return from < to ? to - from <= max : from - to <= max;\n  }\n}\n"
    },
    "src/contracts/misc/GhoGsmSteward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IGsm} from '../facilitators/gsm/interfaces/IGsm.sol';\nimport {IGsmFeeStrategy} from '../facilitators/gsm/feeStrategy/interfaces/IGsmFeeStrategy.sol';\nimport {IFixedFeeStrategyFactory} from '../facilitators/gsm/feeStrategy/interfaces/IFixedFeeStrategyFactory.sol';\nimport {IGhoGsmSteward} from './interfaces/IGhoGsmSteward.sol';\nimport {RiskCouncilControlled} from './RiskCouncilControlled.sol';\n\n/**\n * @title GhoGsmSteward\n * @author Aave Labs\n * @notice Helper contract for managing parameters of the GSM\n * @dev Only the Risk Council is able to action contract's functions, based on specific conditions that have been agreed upon with the community.\n * @dev Requires role GSM_CONFIGURATOR_ROLE on every GSM contract to be managed\n */\ncontract GhoGsmSteward is RiskCouncilControlled, IGhoGsmSteward {\n  /// @inheritdoc IGhoGsmSteward\n  uint256 public constant GSM_FEE_RATE_CHANGE_MAX = 0.0050e4; // 0.50%\n\n  /// @inheritdoc IGhoGsmSteward\n  uint256 public constant MINIMUM_DELAY = 1 days;\n\n  /// @inheritdoc IGhoGsmSteward\n  address public immutable FIXED_FEE_STRATEGY_FACTORY;\n\n  mapping(address => GsmDebounce) internal _gsmTimelocksByAddress;\n\n  /**\n   * @dev Only methods that are not timelocked can be called if marked by this modifier.\n   */\n  modifier notTimelocked(uint40 timelock) {\n    require(block.timestamp - timelock > MINIMUM_DELAY, 'DEBOUNCE_NOT_RESPECTED');\n    _;\n  }\n\n  /**\n   * @dev Constructor\n   * @param fixedFeeStrategyFactory The address of the Fixed Fee Strategy Factory\n   * @param riskCouncil The address of the risk council\n   */\n  constructor(\n    address fixedFeeStrategyFactory,\n    address riskCouncil\n  ) RiskCouncilControlled(riskCouncil) {\n    require(fixedFeeStrategyFactory != address(0), 'INVALID_FIXED_FEE_STRATEGY_FACTORY');\n\n    FIXED_FEE_STRATEGY_FACTORY = fixedFeeStrategyFactory;\n  }\n\n  /// @inheritdoc IGhoGsmSteward\n  function updateGsmExposureCap(\n    address gsm,\n    uint128 newExposureCap\n  ) external onlyRiskCouncil notTimelocked(_gsmTimelocksByAddress[gsm].gsmExposureCapLastUpdated) {\n    uint128 currentExposureCap = IGsm(gsm).getExposureCap();\n    require(newExposureCap != currentExposureCap, 'NO_CHANGE_IN_EXPOSURE_CAP');\n    require(\n      _isDifferenceLowerThanMax(currentExposureCap, newExposureCap, currentExposureCap),\n      'INVALID_EXPOSURE_CAP_UPDATE'\n    );\n\n    _gsmTimelocksByAddress[gsm].gsmExposureCapLastUpdated = uint40(block.timestamp);\n\n    IGsm(gsm).updateExposureCap(newExposureCap);\n  }\n\n  /// @inheritdoc IGhoGsmSteward\n  function updateGsmBuySellFees(\n    address gsm,\n    uint256 buyFee,\n    uint256 sellFee\n  ) external onlyRiskCouncil notTimelocked(_gsmTimelocksByAddress[gsm].gsmFeeStrategyLastUpdated) {\n    address currentFeeStrategy = IGsm(gsm).getFeeStrategy();\n    require(currentFeeStrategy != address(0), 'FIXED_FEE_STRATEGY_NOT_FOUND');\n\n    uint256 currentBuyFee = IGsmFeeStrategy(currentFeeStrategy).getBuyFee(1e4);\n    uint256 currentSellFee = IGsmFeeStrategy(currentFeeStrategy).getSellFee(1e4);\n    require(buyFee != currentBuyFee || sellFee != currentSellFee, 'NO_CHANGE_IN_FEES');\n    require(\n      _isDifferenceLowerThanMax(currentBuyFee, buyFee, GSM_FEE_RATE_CHANGE_MAX),\n      'INVALID_BUY_FEE_UPDATE'\n    );\n    require(\n      _isDifferenceLowerThanMax(currentSellFee, sellFee, GSM_FEE_RATE_CHANGE_MAX),\n      'INVALID_SELL_FEE_UPDATE'\n    );\n\n    IFixedFeeStrategyFactory strategyFactory = IFixedFeeStrategyFactory(FIXED_FEE_STRATEGY_FACTORY);\n    uint256[] memory buyFeeList = new uint256[](1);\n    uint256[] memory sellFeeList = new uint256[](1);\n    buyFeeList[0] = buyFee;\n    sellFeeList[0] = sellFee;\n    address strategy = strategyFactory.createStrategies(buyFeeList, sellFeeList)[0];\n\n    _gsmTimelocksByAddress[gsm].gsmFeeStrategyLastUpdated = uint40(block.timestamp);\n\n    IGsm(gsm).updateFeeStrategy(strategy);\n  }\n\n  /// @inheritdoc IGhoGsmSteward\n  function getGsmTimelocks(address gsm) external view returns (GsmDebounce memory) {\n    return _gsmTimelocksByAddress[gsm];\n  }\n\n  /// @inheritdoc IGhoGsmSteward\n  function RISK_COUNCIL() public view override returns (address) {\n    return _riskCouncil;\n  }\n\n  /**\n   * @dev Ensures that the change difference is lower than max.\n   * @param from current value\n   * @param to new value\n   * @param max maximum difference between from and to\n   * @return bool true if difference between values lower than max, false otherwise\n   */\n  function _isDifferenceLowerThanMax(\n    uint256 from,\n    uint256 to,\n    uint256 max\n  ) internal pure returns (bool) {\n    return from < to ? to - from <= max : from - to <= max;\n  }\n}\n"
    },
    "src/contracts/misc/interfaces/IGhoAaveSteward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/**\n * @title IGhoAaveSteward\n * @author Aave Labs\n * @notice Defines the basic interface of the GhoAaveSteward\n */\ninterface IGhoAaveSteward {\n  /**\n   * @notice Struct storing the last update by the steward of each borrow rate param\n   */\n  struct GhoDebounce {\n    uint40 ghoBorrowCapLastUpdate;\n    uint40 ghoSupplyCapLastUpdate;\n    uint40 ghoBorrowRateLastUpdate;\n  }\n\n  /**\n   * @notice Struct storing the configuration for the borrow rate params\n   */\n  struct BorrowRateConfig {\n    uint16 optimalUsageRatioMaxChange;\n    uint32 baseVariableBorrowRateMaxChange;\n    uint32 variableRateSlope1MaxChange;\n    uint32 variableRateSlope2MaxChange;\n  }\n\n  /**\n   * @notice Updates the borrow rate of GHO, only if:\n   * - respects `MINIMUM_DELAY`, the minimum time delay between updates\n   * - the update changes parameters up to the maximum allowed change according to risk config\n   * @dev Only callable by Risk Council\n   * @dev Values are all expressed in BPS\n   * @param optimalUsageRatio The new optimal usage ratio\n   * @param baseVariableBorrowRate The new base variable borrow rate\n   * @param variableRateSlope1 The new variable rate slope 1\n   * @param variableRateSlope2 The new variable rate slope 2\n   */\n  function updateGhoBorrowRate(\n    uint16 optimalUsageRatio,\n    uint32 baseVariableBorrowRate,\n    uint32 variableRateSlope1,\n    uint32 variableRateSlope2\n  ) external;\n\n  /**\n   * @notice Updates the GHO borrow cap, only if:\n   * - respects `MINIMUM_DELAY`, the minimum time delay between updates\n   * - the update changes up to 100% upwards or downwards\n   * @dev Only callable by Risk Council\n   * @param newBorrowCap The new borrow cap (in whole tokens)\n   */\n  function updateGhoBorrowCap(uint256 newBorrowCap) external;\n\n  /**\n   * @notice Updates the GHO supply cap, only if:\n   * - respects `MINIMUM_DELAY`, the minimum time delay between updates\n   * - the update changes up to 100% upwards or downwards\n   * @dev Only callable by Risk Council\n   * @param newSupplyCap The new supply cap (in whole tokens)\n   */\n  function updateGhoSupplyCap(uint256 newSupplyCap) external;\n\n  /**\n   * @notice Updates the configuration conditions for borrow rate changes\n   * @dev Values are all expressed in BPS\n   * @param optimalUsageRatioMaxChange The new allowed max percentage change for optimal usage ratio\n   * @param baseVariableBorrowRateMaxChange The new allowed max percentage change for base variable borrow rate\n   * @param variableRateSlope1MaxChange The new allowed max percentage change for variable rate slope 1\n   * @param variableRateSlope2MaxChange The new allowed max percentage change for variable rate slope 2\n   */\n  function setBorrowRateConfig(\n    uint16 optimalUsageRatioMaxChange,\n    uint32 baseVariableBorrowRateMaxChange,\n    uint32 variableRateSlope1MaxChange,\n    uint32 variableRateSlope2MaxChange\n  ) external;\n\n  /**\n   * @notice Returns the configuration conditions for a GHO borrow rate change\n   * @return struct containing the borrow rate configuration\n   */\n  function getBorrowRateConfig() external view returns (BorrowRateConfig memory);\n\n  /**\n   * @notice Returns timestamp of the last update of GHO parameters\n   * @return The GhoDebounce struct describing the last update of GHO parameters\n   */\n  function getGhoTimelocks() external view returns (GhoDebounce memory);\n\n  /**\n   * @notice The address of pool data provider of the POOL the steward controls\n   */\n  function POOL_DATA_PROVIDER() external view returns (address);\n\n  /**\n   * @notice Returns the minimum delay that must be respected between parameters update.\n   * @return The minimum delay between parameter updates (in seconds)\n   */\n  function MINIMUM_DELAY() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the Pool Addresses Provider of the Aave V3 Ethereum Pool\n   * @return The address of the PoolAddressesProvider of Aave V3 Ethereum Pool\n   */\n  function POOL_ADDRESSES_PROVIDER() external view returns (address);\n\n  /**\n   * @notice Returns the address of the Gho Token\n   * @return The address of the GhoToken\n   */\n  function GHO_TOKEN() external view returns (address);\n\n  /**\n   * @notice Returns the address of the risk council\n   * @return The address of the RiskCouncil\n   */\n  function RISK_COUNCIL() external view returns (address);\n}\n"
    },
    "src/contracts/misc/interfaces/IGhoBucketSteward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/**\n * @title IGhoBucketSteward\n * @author Aave Labs\n * @notice Defines the basic interface of the GhoBucketSteward\n */\ninterface IGhoBucketSteward {\n  /**\n   * @notice Updates the bucket capacity of facilitator, only if:\n   * - respects `MINIMUM_DELAY`, the minimum time delay between updates\n   * - the update changes up to 100% upwards\n   * - the facilitator is controlled\n   * @dev Only callable by Risk Council\n   * @param facilitator The facilitator address\n   * @param newBucketCapacity The new facilitator bucket capacity\n   */\n  function updateFacilitatorBucketCapacity(address facilitator, uint128 newBucketCapacity) external;\n\n  /**\n   * @notice Adds/Removes controlled facilitators\n   * @dev Only callable by owner\n   * @param facilitatorList A list of facilitators addresses to add to control\n   * @param approve True to add as controlled facilitators, false to remove\n   */\n  function setControlledFacilitator(address[] memory facilitatorList, bool approve) external;\n\n  /**\n   * @notice Returns the list of controlled facilitators by this steward.\n   * @return An array of facilitator addresses\n   */\n  function getControlledFacilitators() external view returns (address[] memory);\n\n  /**\n   * @notice Checks if a facilitator is controlled by this steward\n   * @param facilitator The facilitator address to check\n   * @return True if the facilitator is controlled by this steward\n   */\n  function isControlledFacilitator(address facilitator) external view returns (bool);\n\n  /**\n   * @notice Returns timestamp of the facilitators last bucket capacity update\n   * @param facilitator The facilitator address\n   * @return The unix time of the last bucket capacity (in seconds).\n   */\n  function getFacilitatorBucketCapacityTimelock(address facilitator) external view returns (uint40);\n\n  /**\n   * @notice Returns the minimum delay that must be respected between parameters update.\n   * @return The minimum delay between parameter updates (in seconds)\n   */\n  function MINIMUM_DELAY() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the Gho Token\n   * @return The address of the GhoToken\n   */\n  function GHO_TOKEN() external view returns (address);\n\n  /**\n   * @notice Returns the address of the risk council\n   * @return The address of the RiskCouncil\n   */\n  function RISK_COUNCIL() external view returns (address);\n}\n"
    },
    "src/contracts/misc/interfaces/IGhoCcipSteward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/**\n * @title IGhoCcipSteward\n * @author Aave Labs\n * @notice Defines the basic interface of the GhoCcipSteward\n */\ninterface IGhoCcipSteward {\n  /**\n   * @notice Struct storing the last update by the steward of the bridge and rate limit param.\n   */\n  struct CcipDebounce {\n    uint40 bridgeLimitLastUpdate;\n    uint40 rateLimitLastUpdate;\n  }\n\n  /**\n   * @notice Updates the CCIP bridge limit\n   * @dev Only callable by Risk Council\n   * @param newBridgeLimit The new desired bridge limit\n   */\n  function updateBridgeLimit(uint256 newBridgeLimit) external;\n\n  /**\n   * @notice Updates the CCIP rate limit config\n   * @dev Only callable by Risk Council\n   * @dev Rate limit update must be consistent with other pools' rate limit\n   * @param remoteChainSelector The remote chain selector for which the rate limits apply.\n   * @param outboundEnabled True if the outbound rate limiter is enabled.\n   * @param outboundCapacity The outbound rate limiter capacity.\n   * @param outboundRate The outbound rate limiter rate.\n   * @param inboundEnabled True if the inbound rate limiter is enabled.\n   * @param inboundCapacity The inbound rate limiter capacity.\n   * @param inboundRate The inbound rate limiter rate.\n   */\n  function updateRateLimit(\n    uint64 remoteChainSelector,\n    bool outboundEnabled,\n    uint128 outboundCapacity,\n    uint128 outboundRate,\n    bool inboundEnabled,\n    uint128 inboundCapacity,\n    uint128 inboundRate\n  ) external;\n\n  /**\n   * @notice Returns timestamp of the last update of Ccip parameters.\n   * @return The CcipDebounce struct describing the last update of Ccip parameters.\n   */\n  function getCcipTimelocks() external view returns (CcipDebounce memory);\n\n  /**\n   * @notice Returns the minimum delay that must be respected between parameters update.\n   * @return The minimum delay between parameter updates (in seconds)\n   */\n  function MINIMUM_DELAY() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the Gho Token\n   * @return The address of the GhoToken\n   */\n  function GHO_TOKEN() external view returns (address);\n\n  /**\n   * @notice Returns the address of the Gho CCIP Token Pool\n   * @return The address of the Gho CCIP Token Pool\n   */\n  function GHO_TOKEN_POOL() external view returns (address);\n\n  /**\n   * @notice Returns whether the bridge limit feature is supported in the GhoTokenPool\n   * @return True if bridge limit is enabled in the CCIP GhoTokenPool, false otherwise\n   */\n  function BRIDGE_LIMIT_ENABLED() external view returns (bool);\n\n  /**\n   * @notice Returns the address of the risk council\n   * @return The address of the RiskCouncil\n   */\n  function RISK_COUNCIL() external view returns (address);\n}\n"
    },
    "src/contracts/misc/interfaces/IGhoGsmSteward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/**\n * @title IGhoGsmSteward\n * @author Aave Labs\n * @notice Defines the basic interface of the GhoGsmSteward\n */\ninterface IGhoGsmSteward {\n  struct GsmDebounce {\n    uint40 gsmExposureCapLastUpdated;\n    uint40 gsmFeeStrategyLastUpdated;\n  }\n\n  /**\n   * @notice Updates the exposure cap of the GSM, only if:\n   * - respects `MINIMUM_DELAY`, the minimum time delay between updates\n   * - the update changes up to 100% upwards or downwards\n   * @dev Only callable by Risk Council\n   * @param gsm The gsm address to update\n   * @param newExposureCap The new exposure cap (in underlying asset terms)\n   */\n  function updateGsmExposureCap(address gsm, uint128 newExposureCap) external;\n\n  /**\n   * @notice Updates the fixed percent fees of the GSM, only if:\n   * - respects `MINIMUM_DELAY`, the minimum time delay between updates\n   * - the update changes up to `GSM_FEE_RATE_CHANGE_MAX` upwards or downwards (for both buy and sell individually)\n   * @dev Only callable by Risk Council\n   * @dev Reverts if fee strategy is not set, or zero fees. Must be updated via AIP in this case\n   * @param gsm The gsm address to update\n   * @param buyFee The new buy fee (expressed in bps) (e.g. 0.0150e4 results in 1.50%)\n   * @param sellFee The new sell fee (expressed in bps) (e.g. 0.0150e4 results in 1.50%)\n   */\n  function updateGsmBuySellFees(address gsm, uint256 buyFee, uint256 sellFee) external;\n\n  /**\n   * @notice Returns timestamp of the last update of Gsm parameters\n   * @param gsm The GSM address\n   * @return The GsmDebounce struct describing the last update of GSM parameters\n   */\n  function getGsmTimelocks(address gsm) external view returns (GsmDebounce memory);\n\n  /**\n   * @notice Returns the maximum increase for GSM fee rates (buy or sell).\n   * @return The maximum increase change for GSM fee rates updates in bps (e.g. 0.010e4 results in 1.00%)\n   */\n  function GSM_FEE_RATE_CHANGE_MAX() external view returns (uint256);\n\n  /**\n   * @notice Returns the minimum delay that must be respected between parameters update.\n   * @return The minimum delay between parameter updates (in seconds)\n   */\n  function MINIMUM_DELAY() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the GSM Fee Strategy Factory\n   * @return The address of the GSM Fee Strategy Factory\n   */\n  function FIXED_FEE_STRATEGY_FACTORY() external view returns (address);\n\n  /**\n   * @notice Returns the address of the risk council\n   * @return The address of the RiskCouncil\n   */\n  function RISK_COUNCIL() external view returns (address);\n}\n"
    },
    "src/contracts/misc/RiskCouncilControlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/**\n * @title RiskCouncilControlled\n * @author Aave Labs\n * @notice Helper contract for controlling access to Steward and other functions restricted to Risk Council\n */\nabstract contract RiskCouncilControlled {\n  address internal immutable _riskCouncil;\n\n  /**\n   * @dev Constructor\n   * @param riskCouncil The address of the risk council\n   */\n  constructor(address riskCouncil) {\n    require(riskCouncil != address(0), 'INVALID_RISK_COUNCIL');\n    _riskCouncil = riskCouncil;\n  }\n\n  /**\n   * @dev Only Risk Council can call functions marked by this modifier.\n   */\n  modifier onlyRiskCouncil() {\n    require(_riskCouncil == msg.sender, 'INVALID_CALLER');\n    _;\n  }\n}\n"
    },
    "src/script/DeployGsmLaunch.s.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Script, console2} from 'forge-std/Script.sol';\nimport {AaveV3Ethereum, AaveV3EthereumAssets} from 'aave-address-book/AaveV3Ethereum.sol';\nimport {GovernanceV3Ethereum} from 'aave-address-book/GovernanceV3Ethereum.sol';\nimport {MiscEthereum} from 'aave-address-book/MiscEthereum.sol';\nimport {TransparentUpgradeableProxy} from 'solidity-utils/contracts/transparent-proxy/TransparentUpgradeableProxy.sol';\nimport {IPoolAddressesProvider} from '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\nimport {Gsm} from '../contracts/facilitators/gsm/Gsm.sol';\nimport {IGsm} from '../contracts/facilitators/gsm/interfaces/IGsm.sol';\nimport {FixedPriceStrategy} from '../contracts/facilitators/gsm/priceStrategy/FixedPriceStrategy.sol';\nimport {FixedFeeStrategy} from '../contracts/facilitators/gsm/feeStrategy/FixedFeeStrategy.sol';\nimport {GsmRegistry} from '../contracts/facilitators/gsm/misc/GsmRegistry.sol';\nimport {OracleSwapFreezer} from '../contracts/facilitators/gsm/swapFreezer/OracleSwapFreezer.sol';\n\n// GSM USDC\nuint8 constant USDC_DECIMALS = 6;\nuint128 constant USDC_EXPOSURE_CAP = 500_000e6;\nstring constant GSM_USDC_FACILITATOR_LABEL = 'GSM USDC';\nuint128 constant GSM_USDC_BUCKET_CAPACITY = 500_000e18;\n\n// GSM USDT\nuint8 constant USDT_DECIMALS = 6;\nuint128 constant USDT_EXPOSURE_CAP = 500_000e6;\nstring constant GSM_USDT_FACILITATOR_LABEL = 'GSM USDT';\nuint128 constant GSM_USDT_BUCKET_CAPACITY = 500_000e18;\n\nuint256 constant GSM_PRICE_RATIO = 1e18;\nuint256 constant GSM_BUY_FEE_BPS = 0.002e4; // 0.2%, 0.5e4 is 50%\nuint256 constant GSM_SELL_FEE_BPS = 0.002e4; // 0.2%\n\nuint128 constant SWAP_FREEZE_LOWER_BOUND = 0.99e8;\nuint128 constant SWAP_FREEZE_UPPER_BOUND = 1.01e8;\nuint128 constant SWAP_UNFREEZE_LOWER_BOUND = 0.995e8;\nuint128 constant SWAP_UNFREEZE_UPPER_BOUND = 1.005e8;\nbool constant SWAP_UNFREEZE_ALLOWED = true;\n\ncontract DeployGsmLaunch is Script {\n  function run() external {\n    uint256 deployerPrivateKey = vm.envUint('PRIVATE_KEY');\n    address deployerAddress = vm.addr(deployerPrivateKey);\n    console2.log('Deployer Address: ', deployerAddress);\n    console2.log('Deployer Balance: ', address(deployerAddress).balance);\n    console2.log('Block Number: ', block.number);\n    vm.startBroadcast(deployerPrivateKey);\n    _deploy();\n    vm.stopBroadcast();\n  }\n\n  function _deploy() internal {\n    // ------------------------------------------------\n    // 1. FixedPriceStrategy\n    // ------------------------------------------------\n    FixedPriceStrategy gsmUsdcPriceStrategy = new FixedPriceStrategy(\n      GSM_PRICE_RATIO,\n      AaveV3EthereumAssets.USDC_UNDERLYING,\n      USDC_DECIMALS\n    );\n    console2.log('GSM USDC FixedPriceStrategy: ', address(gsmUsdcPriceStrategy));\n\n    FixedPriceStrategy gsmUsdtPriceStrategy = new FixedPriceStrategy(\n      GSM_PRICE_RATIO,\n      AaveV3EthereumAssets.USDT_UNDERLYING,\n      USDT_DECIMALS\n    );\n    console2.log('GSM USDT FixedPriceStrategy: ', address(gsmUsdtPriceStrategy));\n\n    // ------------------------------------------------\n    // 2. GSM implementations\n    // ------------------------------------------------\n    Gsm gsmUsdcImpl = new Gsm(\n      AaveV3EthereumAssets.GHO_UNDERLYING,\n      AaveV3EthereumAssets.USDC_UNDERLYING,\n      address(gsmUsdcPriceStrategy)\n    );\n    console2.log('GSM USDC Implementation: ', address(gsmUsdcImpl));\n\n    Gsm gsmUsdtImpl = new Gsm(\n      AaveV3EthereumAssets.GHO_UNDERLYING,\n      AaveV3EthereumAssets.USDT_UNDERLYING,\n      address(gsmUsdtPriceStrategy)\n    );\n    console2.log('GSM USDT Implementation: ', address(gsmUsdtImpl));\n\n    gsmUsdcImpl.initialize(\n      GovernanceV3Ethereum.EXECUTOR_LVL_1,\n      address(AaveV3Ethereum.COLLECTOR),\n      USDC_EXPOSURE_CAP\n    );\n    gsmUsdtImpl.initialize(\n      GovernanceV3Ethereum.EXECUTOR_LVL_1,\n      address(AaveV3Ethereum.COLLECTOR),\n      USDT_EXPOSURE_CAP\n    );\n\n    // ------------------------------------------------\n    // 3. GSM proxy deployment and initialization\n    // ------------------------------------------------\n    bytes memory gsmUsdcInitParams = abi.encodeWithSignature(\n      'initialize(address,address,uint128)',\n      GovernanceV3Ethereum.EXECUTOR_LVL_1,\n      address(AaveV3Ethereum.COLLECTOR),\n      USDC_EXPOSURE_CAP\n    );\n    TransparentUpgradeableProxy gsmUsdcProxy = new TransparentUpgradeableProxy(\n      address(gsmUsdcImpl),\n      MiscEthereum.PROXY_ADMIN,\n      gsmUsdcInitParams\n    );\n    Gsm gsmUsdc = Gsm(address(gsmUsdcProxy));\n    console2.log('GSM USDC Proxy: ', address(gsmUsdcProxy));\n\n    bytes memory gsmUsdtInitParams = abi.encodeWithSignature(\n      'initialize(address,address,uint128)',\n      GovernanceV3Ethereum.EXECUTOR_LVL_1,\n      address(AaveV3Ethereum.COLLECTOR),\n      USDT_EXPOSURE_CAP\n    );\n    TransparentUpgradeableProxy gsmUsdtProxy = new TransparentUpgradeableProxy(\n      address(gsmUsdtImpl),\n      MiscEthereum.PROXY_ADMIN,\n      gsmUsdtInitParams\n    );\n    Gsm gsmUsdt = Gsm(address(gsmUsdtProxy));\n    console2.log('GSM USDT Proxy: ', address(gsmUsdtProxy));\n\n    // ------------------------------------------------\n    // 4. FixedFeeStrategy\n    // ------------------------------------------------\n    FixedFeeStrategy fixedFeeStrategy = new FixedFeeStrategy(GSM_BUY_FEE_BPS, GSM_SELL_FEE_BPS);\n    console2.log('GSM FixedFeeStrategy: ', address(fixedFeeStrategy));\n\n    // ------------------------------------------------\n    // 5. OracleSwapFreezers\n    // ------------------------------------------------\n    OracleSwapFreezer gsmUsdcOracleSwapFreezer = new OracleSwapFreezer(\n      IGsm(address(gsmUsdc)),\n      AaveV3EthereumAssets.USDC_UNDERLYING,\n      IPoolAddressesProvider(address(AaveV3Ethereum.POOL_ADDRESSES_PROVIDER)),\n      SWAP_FREEZE_LOWER_BOUND,\n      SWAP_FREEZE_UPPER_BOUND,\n      SWAP_UNFREEZE_LOWER_BOUND,\n      SWAP_UNFREEZE_UPPER_BOUND,\n      SWAP_UNFREEZE_ALLOWED\n    );\n    console2.log('GSM USDC OracleSwapFreezer: ', address(gsmUsdcOracleSwapFreezer));\n\n    OracleSwapFreezer gsmUsdtOracleSwapFreezer = new OracleSwapFreezer(\n      IGsm(address(gsmUsdt)),\n      AaveV3EthereumAssets.USDT_UNDERLYING,\n      IPoolAddressesProvider(address(AaveV3Ethereum.POOL_ADDRESSES_PROVIDER)),\n      SWAP_FREEZE_LOWER_BOUND,\n      SWAP_FREEZE_UPPER_BOUND,\n      SWAP_UNFREEZE_LOWER_BOUND,\n      SWAP_UNFREEZE_UPPER_BOUND,\n      SWAP_UNFREEZE_ALLOWED\n    );\n    console2.log('GSM USDT OracleSwapFreezer: ', address(gsmUsdtOracleSwapFreezer));\n\n    // ------------------------------------------------\n    // 6. Deploy GsmRegistry\n    // ------------------------------------------------\n    GsmRegistry gsmRegistry = new GsmRegistry(GovernanceV3Ethereum.EXECUTOR_LVL_1);\n    console2.log('GsmRegistry: ', address(gsmRegistry));\n  }\n}\n"
    },
    "src/script/ExternalDependencyCompiler.s.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n// Importing contracts from dependencies libraries so it can be used by Hardhat scripts\nimport 'aave-stk-v1-5/src/contracts/StakedAaveV3.sol';\n"
    },
    "src/test/helpers/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Constants {\n  // ERC1967 slots\n  bytes32 internal constant ERC1967_IMPLEMENTATION_SLOT =\n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n  bytes32 internal constant ERC1967_ADMIN_SLOT =\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  // addresses expected for BGD stkAave\n  address constant SHORT_EXECUTOR = 0xEE56e2B3D491590B5b31738cC34d5232F378a8D5;\n  address constant STKAAVE_PROXY_ADMIN = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;\n\n  // default admin role\n  bytes32 public constant DEFAULT_ADMIN_ROLE = bytes32(0);\n\n  // admin roles for GhoToken\n  bytes32 public constant GHO_TOKEN_FACILITATOR_MANAGER_ROLE =\n    keccak256('FACILITATOR_MANAGER_ROLE');\n  bytes32 public constant GHO_TOKEN_BUCKET_MANAGER_ROLE = keccak256('BUCKET_MANAGER_ROLE');\n\n  // admin role for GSM\n  bytes32 public constant GSM_CONFIGURATOR_ROLE = keccak256('CONFIGURATOR_ROLE');\n  bytes32 public constant GSM_TOKEN_RESCUER_ROLE = keccak256('TOKEN_RESCUER_ROLE');\n  bytes32 public constant GSM_SWAP_FREEZER_ROLE = keccak256('SWAP_FREEZER_ROLE');\n  bytes32 public constant GSM_LIQUIDATOR_ROLE = keccak256('LIQUIDATOR_ROLE');\n\n  // signature typehash for GSM\n  bytes32 public constant GSM_BUY_ASSET_WITH_SIG_TYPEHASH =\n    keccak256(\n      'BuyAssetWithSig(address originator,uint256 minAmount,address receiver,uint256 nonce,uint256 deadline)'\n    );\n  bytes32 public constant GSM_SELL_ASSET_WITH_SIG_TYPEHASH =\n    keccak256(\n      'SellAssetWithSig(address originator,uint256 maxAmount,address receiver,uint256 nonce,uint256 deadline)'\n    );\n\n  // defaults used in test environment\n  uint256 constant DEFAULT_FLASH_FEE = 0.0009e4; // 0.09%\n  uint128 constant DEFAULT_CAPACITY = 100_000_000e18;\n  uint256 constant DEFAULT_BORROW_AMOUNT = 200e18;\n  int256 constant DEFAULT_GHO_PRICE = 1e8;\n  uint8 constant DEFAULT_ORACLE_DECIMALS = 8;\n  uint256 constant DEFAULT_FIXED_PRICE = 1e18;\n  uint256 constant DEFAULT_GSM_BUY_FEE = 0.1e4; // 10%\n  uint256 constant DEFAULT_GSM_SELL_FEE = 0.1e4; // 10%\n  uint128 constant DEFAULT_GSM_USDC_EXPOSURE = 100_000_000e6; // 6 decimals for USDC\n  uint128 constant DEFAULT_GSM_USDC_AMOUNT = 100e6; // 6 decimals for USDC\n  uint128 constant DEFAULT_GSM_GHO_AMOUNT = 100e18;\n\n  // Gho Stewards\n  uint32 constant GHO_BORROW_RATE_CHANGE_MAX = 0.05e4;\n  uint256 constant GSM_FEE_RATE_CHANGE_MAX = 0.0050e4;\n  uint256 constant MINIMUM_DELAY_V2 = 1 days;\n  uint256 constant FIXED_RATE_STRATEGY_FACTORY_REVISION = 1;\n\n  // sample users used across unit tests\n  address constant ALICE = address(0x1111);\n  address constant BOB = address(0x1112);\n  address constant CHARLES = address(0x1113);\n\n  address constant FAUCET = address(0x10001);\n  address constant TREASURY = address(0x10002);\n  address constant RISK_COUNCIL = address(0x10003);\n}\n"
    },
    "src/test/helpers/DebtUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeCast} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {WadRayMath} from '@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol';\nimport {PercentageMath} from '@aave/core-v3/contracts/protocol/libraries/math/PercentageMath.sol';\n\nlibrary DebtUtils {\n  using WadRayMath for uint256;\n  using SafeCast for uint256;\n  using PercentageMath for uint256;\n\n  function test_coverage_ignore() public {\n    // Intentionally left blank.\n    // Excludes contract from coverage.\n  }\n\n  function computeDebt(\n    uint256 userPreviousIndex,\n    uint256 index,\n    uint256 previousScaledBalance,\n    uint256 accumulatedDebtInterest,\n    uint256 discountPercent\n  ) external pure returns (uint256, uint256, uint128) {\n    uint256 balanceIncrease = previousScaledBalance.rayMul(index) -\n      previousScaledBalance.rayMul(userPreviousIndex);\n\n    uint256 discountScaled = 0;\n    if (balanceIncrease != 0 && discountPercent != 0) {\n      uint256 discount = balanceIncrease.percentMul(discountPercent);\n      discountScaled = discount.rayDiv(index);\n      balanceIncrease = balanceIncrease - discount;\n    }\n\n    uint128 accumulatedDebt = (balanceIncrease + accumulatedDebtInterest).toUint128();\n\n    return (balanceIncrease, discountScaled, accumulatedDebt);\n  }\n}\n"
    },
    "src/test/helpers/ErrorsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/Strings.sol';\n\nlibrary AccessControlErrorsLib {\n  function MISSING_ROLE(bytes32 role, address account) external pure returns (bytes memory) {\n    return\n      abi.encodePacked(\n        'AccessControl: account ',\n        Strings.toHexString(account),\n        ' is missing role ',\n        Strings.toHexString(uint256(role), 32)\n      );\n  }\n\n  function test_coverage_ignore() public {\n    // Intentionally left blank.\n    // Excludes contract from coverage.\n  }\n}\n\nlibrary OwnableErrorsLib {\n  function CALLER_NOT_OWNER() external pure returns (bytes memory) {\n    return abi.encodePacked('Ownable: caller is not the owner');\n  }\n\n  function test_coverage_ignore() public {\n    // Intentionally left blank.\n    // Excludes contract from coverage.\n  }\n}\n"
    },
    "src/test/helpers/Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface Events {\n  // core token events\n  event Mint(\n    address indexed caller,\n    address indexed onBehalfOf,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n  event Burn(\n    address indexed from,\n    address indexed target,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  // setter/updater methods\n  event ATokenSet(address indexed);\n  event VariableDebtTokenSet(address indexed variableDebtToken);\n  event GhoTreasuryUpdated(address indexed oldGhoTreasury, address indexed newGhoTreasury);\n  event DiscountPercentUpdated(\n    address indexed user,\n    uint256 oldDiscountPercent,\n    uint256 indexed newDiscountPercent\n  );\n  event DiscountRateStrategyUpdated(\n    address indexed oldDiscountRateStrategy,\n    address indexed newDiscountRateStrategy\n  );\n  event ReserveInterestRateStrategyChanged(\n    address indexed asset,\n    address oldStrategy,\n    address newStrategy\n  );\n\n  // flashmint-related events\n  event FlashMint(\n    address indexed receiver,\n    address indexed initiator,\n    address asset,\n    uint256 indexed amount,\n    uint256 fee\n  );\n  event FeeUpdated(uint256 oldFee, uint256 newFee);\n\n  // facilitator-related events\n  event FacilitatorAdded(\n    address indexed facilitatorAddress,\n    bytes32 indexed label,\n    uint256 bucketCapacity\n  );\n  event FacilitatorRemoved(address indexed facilitatorAddress);\n  event FacilitatorBucketCapacityUpdated(\n    address indexed facilitatorAddress,\n    uint256 oldCapacity,\n    uint256 newCapacity\n  );\n  event FacilitatorBucketLevelUpdated(\n    address indexed facilitatorAddress,\n    uint256 oldLevel,\n    uint256 newLevel\n  );\n\n  // GSM events\n  event BuyAsset(\n    address indexed originator,\n    address indexed receiver,\n    uint256 underlyingAmount,\n    uint256 ghoAmount,\n    uint256 fee\n  );\n  event SellAsset(\n    address indexed originator,\n    address indexed receiver,\n    uint256 underlyingAmount,\n    uint256 ghoAmount,\n    uint256 fee\n  );\n  event SwapFreeze(address indexed freezer, bool enabled);\n  event Seized(\n    address indexed seizer,\n    address indexed recipient,\n    uint256 underlyingAmount,\n    uint256 ghoOutstanding\n  );\n  event BurnAfterSeize(address indexed burner, uint256 amount, uint256 ghoOutstanding);\n  event BackingProvided(\n    address indexed backer,\n    address indexed asset,\n    uint256 amount,\n    uint256 ghoAmount,\n    uint256 remainingLoss\n  );\n  event FeeStrategyUpdated(address indexed oldFeeStrategy, address indexed newFeeStrategy);\n  event ExposureCapUpdated(uint256 oldExposureCap, uint256 newExposureCap);\n  event TokensRescued(\n    address indexed tokenRescued,\n    address indexed recipient,\n    uint256 amountRescued\n  );\n\n  // IGhoFacilitator events\n  event FeesDistributedToTreasury(\n    address indexed ghoTreasury,\n    address indexed asset,\n    uint256 amount\n  );\n\n  // FixedRateStrategyFactory\n  event RateStrategyCreated(address indexed strategy, uint256 indexed rate);\n\n  // IGsmRegistry events\n  event GsmAdded(address indexed gsmAddress);\n  event GsmRemoved(address indexed gsmAddress);\n\n  // AccessControl\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n  // Ownable\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  // Upgrades\n  event Upgraded(address indexed implementation);\n}\n"
    },
    "src/test/mocks/MockAclManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MockAclManager {\n  bool state;\n\n  constructor() {\n    state = true;\n  }\n\n  function test_coverage_ignore() public virtual {\n    // Intentionally left blank.\n    // Excludes contract from coverage.\n  }\n\n  function setState(bool value) public {\n    state = value;\n  }\n\n  function isPoolAdmin(address) public view returns (bool) {\n    return state;\n  }\n\n  function isFlashBorrower(address) public view returns (bool) {\n    return state;\n  }\n}\n"
    },
    "src/test/mocks/MockAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MockAddressesProvider {\n  address immutable ACL_MANAGER;\n  address POOL;\n  address POOL_CONFIGURATOR;\n  address PRICE_ORACLE;\n\n  constructor(address aclManager) {\n    ACL_MANAGER = aclManager;\n  }\n\n  function test_coverage_ignore() public virtual {\n    // Intentionally left blank.\n    // Excludes contract from coverage.\n  }\n\n  function setPool(address pool) public {\n    POOL = pool;\n  }\n\n  function setConfigurator(address configurator) public {\n    POOL_CONFIGURATOR = configurator;\n  }\n\n  function setPriceOracle(address priceOracle) public {\n    PRICE_ORACLE = priceOracle;\n  }\n\n  function getACLManager() public view returns (address) {\n    return ACL_MANAGER;\n  }\n\n  function getPool() public view returns (address) {\n    return POOL;\n  }\n\n  function getPoolConfigurator() public view returns (address) {\n    return POOL_CONFIGURATOR;\n  }\n\n  function getPriceOracle() public view returns (address) {\n    return PRICE_ORACLE;\n  }\n}\n"
    },
    "src/test/mocks/MockConfigurator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport {DataTypes} from '@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol';\nimport {ReserveConfiguration} from '@aave/core-v3/contracts/protocol/libraries/configuration/ReserveConfiguration.sol';\nimport {DefaultReserveInterestRateStrategyV2} from '../../contracts/misc/dependencies/AaveV3-1.sol';\nimport {IDefaultInterestRateStrategyV2} from '../../contracts/misc/dependencies/AaveV3-1.sol';\n\ncontract MockConfigurator {\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  IPool internal _pool;\n\n  event ReserveInterestRateStrategyChanged(\n    address indexed asset,\n    address oldStrategy,\n    address newStrategy\n  );\n\n  event BorrowCapChanged(address indexed asset, uint256 oldBorrowCap, uint256 newBorrowCap);\n\n  event SupplyCapChanged(address indexed asset, uint256 oldSupplyCap, uint256 newSupplyCap);\n\n  constructor(IPool pool) {\n    _pool = pool;\n  }\n\n  function test_coverage_ignore() public virtual {\n    // Intentionally left blank.\n    // Excludes contract from coverage.\n  }\n\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address newRateStrategyAddress\n  ) external {\n    DataTypes.ReserveData memory reserve = _pool.getReserveData(asset);\n    address oldRateStrategyAddress = reserve.interestRateStrategyAddress;\n    _pool.setReserveInterestRateStrategyAddress(asset, newRateStrategyAddress);\n    emit ReserveInterestRateStrategyChanged(asset, oldRateStrategyAddress, newRateStrategyAddress);\n  }\n\n  function setReserveInterestRateParams(\n    address asset,\n    IDefaultInterestRateStrategyV2.InterestRateData calldata rateParams\n  ) external {\n    DataTypes.ReserveData memory reserve = _pool.getReserveData(asset);\n    address rateStrategyAddress = reserve.interestRateStrategyAddress;\n    DefaultReserveInterestRateStrategyV2(rateStrategyAddress).setInterestRateParams(\n      asset,\n      rateParams\n    );\n  }\n\n  function setReserveInterestRateData(address asset, bytes calldata rateData) external {\n    this.setReserveInterestRateParams(\n      asset,\n      abi.decode(rateData, (IDefaultInterestRateStrategyV2.InterestRateData))\n    );\n  }\n\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress,\n    bytes calldata rateData\n  ) external {\n    this.setReserveInterestRateStrategyAddress(asset, rateStrategyAddress);\n    this.setReserveInterestRateParams(\n      asset,\n      abi.decode(rateData, (IDefaultInterestRateStrategyV2.InterestRateData))\n    );\n  }\n\n  function setBorrowCap(address asset, uint256 newBorrowCap) external {\n    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n    uint256 oldBorrowCap = currentConfig.getBorrowCap();\n    currentConfig.setBorrowCap(newBorrowCap);\n    _pool.setConfiguration(asset, currentConfig);\n    emit BorrowCapChanged(asset, oldBorrowCap, newBorrowCap);\n  }\n\n  function setSupplyCap(address asset, uint256 newSupplyCap) external {\n    DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);\n    uint256 oldSupplyCap = currentConfig.getSupplyCap();\n    currentConfig.setSupplyCap(newSupplyCap);\n    _pool.setConfiguration(asset, currentConfig);\n    emit SupplyCapChanged(asset, oldSupplyCap, newSupplyCap);\n  }\n}\n"
    },
    "src/test/mocks/MockERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC4626} from '@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ncontract MockERC4626 is ERC4626 {\n  constructor(\n    string memory name,\n    string memory symbol,\n    address asset\n  ) ERC4626(IERC20(asset)) ERC20(name, symbol) {}\n}\n"
    },
    "src/test/mocks/MockFlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IERC3156FlashBorrower} from '@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol';\nimport {IERC3156FlashLender} from '@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol';\nimport {IGhoToken} from '../../contracts/gho/interfaces/IGhoToken.sol';\n\n/**\n * @title MockFlashBorrower\n * @author Aave\n * @dev This is purely an unsafe mock testing contract. Do not use in production.\n */\ncontract MockFlashBorrower is IERC3156FlashBorrower {\n  enum Action {\n    NORMAL,\n    OTHER\n  }\n\n  IERC3156FlashLender private _lender;\n\n  bool private _allowRepayment;\n  bool private _allowCallback;\n\n  constructor(IERC3156FlashLender lender) {\n    _lender = lender;\n    _allowRepayment = true;\n    _allowCallback = true;\n  }\n\n  function test_coverage_ignore() public virtual {\n    // Intentionally left blank.\n    // Excludes contract from coverage.\n  }\n\n  /// @dev ERC-3156 Flash loan callback\n  function onFlashLoan(\n    address initiator,\n    address token,\n    uint256 amount,\n    uint256 fee,\n    bytes calldata data\n  ) external override returns (bytes32) {\n    require(msg.sender == address(_lender), 'FlashBorrower: Untrusted lender');\n    require(initiator == address(this), 'FlashBorrower: Untrusted loan initiator');\n\n    Action action = abi.decode(data, (Action));\n\n    if (action == Action.NORMAL) {\n      // Intentionally left blank.\n    } else if (action == Action.OTHER) {\n      // Tests capacity change mid-flashmint.\n      require(\n        _lender.flashFee(token, type(uint128).max) == 0,\n        'FlashBorrower: Non-zero flashfee during capacity change test'\n      );\n\n      (uint256 capacityBefore, ) = IGhoToken(token).getFacilitatorBucket(address(_lender));\n      require(capacityBefore != 0, 'FlashBorrower: Zero bucket capacity before setting');\n\n      IGhoToken(token).setFacilitatorBucketCapacity(address(_lender), 0);\n\n      (uint256 capacityAfter, ) = IGhoToken(token).getFacilitatorBucket(address(_lender));\n      require(capacityAfter == 0, 'FlashBorrower: Non-zero bucket capacity after setting');\n\n      require(\n        _lender.maxFlashLoan(token) == 0,\n        'FlashBorrower: Non-zero max flashloan at capacity < level'\n      );\n    }\n\n    // Repayment\n    if (_allowRepayment) {\n      IERC20(token).approve(address(_lender), amount + fee);\n    }\n    return _allowCallback ? keccak256('ERC3156FlashBorrower.onFlashLoan') : keccak256('arbitrary');\n  }\n\n  /// @dev Initiate a flash loan\n  function flashBorrow(address token, uint256 amount) public {\n    bytes memory data = abi.encode(Action.NORMAL);\n\n    _lender.flashLoan(this, token, amount, data);\n  }\n\n  function flashBorrowOtherActionMax(address token) public {\n    bytes memory data = abi.encode(Action.OTHER);\n    uint256 amount = _lender.maxFlashLoan(token);\n\n    _lender.flashLoan(this, token, amount, data);\n  }\n\n  function setAllowRepayment(bool active) public {\n    _allowRepayment = active;\n  }\n\n  function setAllowCallback(bool active) public {\n    _allowCallback = active;\n  }\n}\n"
    },
    "src/test/mocks/MockGsmV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Gsm} from '../../contracts/facilitators/gsm/Gsm.sol';\n\n/**\n * @dev Mock contract to test GSM upgrades, not to be used in production.\n */\ncontract MockGsmV2 is Gsm {\n  /**\n   * @dev Constructor\n   * @param ghoToken The address of the GHO token contract\n   * @param underlyingAsset The address of the collateral asset\n   * @param priceStrategy The address of the price strategy\n   */\n  constructor(\n    address ghoToken,\n    address underlyingAsset,\n    address priceStrategy\n  ) Gsm(ghoToken, underlyingAsset, priceStrategy) {\n    // Intentionally left blank\n  }\n\n  function test_coverage_ignore() public virtual {\n    // Intentionally left blank.\n    // Excludes contract from coverage.\n  }\n\n  function initialize() external initializer {\n    // Intentionally left blank\n  }\n\n  function GSM_REVISION() public pure virtual override returns (uint256) {\n    return 2;\n  }\n}\n"
    },
    "src/test/mocks/MockPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {GhoVariableDebtToken} from '../../contracts/facilitators/aave/tokens/GhoVariableDebtToken.sol';\nimport {GhoAToken} from '../../contracts/facilitators/aave/tokens/GhoAToken.sol';\nimport {IGhoToken} from '../../contracts/gho/interfaces/IGhoToken.sol';\nimport {GhoDiscountRateStrategy} from '../../contracts/facilitators/aave/interestStrategy/GhoDiscountRateStrategy.sol';\nimport {GhoInterestRateStrategy} from '../../contracts/facilitators/aave/interestStrategy/GhoInterestRateStrategy.sol';\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport {IPoolAddressesProvider} from '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\nimport {IAaveIncentivesController} from '@aave/core-v3/contracts/interfaces/IAaveIncentivesController.sol';\nimport {Pool} from '@aave/core-v3/contracts/protocol/pool/Pool.sol';\nimport {UserConfiguration} from '@aave/core-v3/contracts/protocol/libraries/configuration/UserConfiguration.sol';\nimport {ReserveConfiguration} from '@aave/core-v3/contracts/protocol/libraries/configuration/ReserveConfiguration.sol';\nimport {ReserveLogic} from '@aave/core-v3/contracts/protocol/libraries/logic/ReserveLogic.sol';\nimport {Helpers} from '@aave/core-v3/contracts/protocol/libraries/helpers/Helpers.sol';\nimport {DataTypes} from '@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol';\nimport {StableDebtToken} from '@aave/core-v3/contracts/protocol/tokenization/StableDebtToken.sol';\nimport {IERC20} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/ERC20.sol';\nimport {Errors} from '@aave/core-v3/contracts/protocol/libraries/helpers/Errors.sol';\n\n/**\n * @dev MockPool removes assets and users validations from Pool contract.\n */\ncontract MockPool is Pool {\n  using ReserveLogic for DataTypes.ReserveCache;\n  using ReserveLogic for DataTypes.ReserveData;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  GhoVariableDebtToken public DEBT_TOKEN;\n  GhoAToken public ATOKEN;\n  address public GHO;\n\n  constructor(IPoolAddressesProvider provider) Pool(provider) {}\n\n  function test_coverage_ignore() public virtual {\n    // Intentionally left blank.\n    // Excludes contract from coverage.\n  }\n\n  function setGhoTokens(GhoVariableDebtToken ghoDebtToken, GhoAToken ghoAToken) external {\n    DEBT_TOKEN = ghoDebtToken;\n    ATOKEN = ghoAToken;\n    GHO = ghoAToken.UNDERLYING_ASSET_ADDRESS();\n    _reserves[GHO].init(\n      address(ATOKEN),\n      address(new StableDebtToken(IPool(address(this)))),\n      address(DEBT_TOKEN),\n      address(new GhoInterestRateStrategy(address(0), 2e25))\n    );\n  }\n\n  function supply(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) public override(Pool) {}\n\n  function borrow(\n    address, // asset\n    uint256 amount,\n    uint256, // interestRateMode\n    uint16, // referralCode\n    address onBehalfOf\n  ) public override(Pool) {\n    DataTypes.ReserveData storage reserve = _reserves[GHO];\n    DataTypes.ReserveCache memory reserveCache = reserve.cache();\n    reserve.updateState(reserveCache);\n\n    DEBT_TOKEN.mint(msg.sender, onBehalfOf, amount, reserveCache.nextVariableBorrowIndex);\n\n    reserve.updateInterestRates(reserveCache, GHO, 0, amount);\n\n    ATOKEN.transferUnderlyingTo(onBehalfOf, amount);\n  }\n\n  function repay(\n    address, // asset\n    uint256 amount,\n    uint256, // interestRateMode\n    address onBehalfOf\n  ) public override(Pool) returns (uint256) {\n    DataTypes.ReserveData storage reserve = _reserves[GHO];\n    DataTypes.ReserveCache memory reserveCache = reserve.cache();\n    reserve.updateState(reserveCache);\n\n    uint256 paybackAmount = DEBT_TOKEN.balanceOf(onBehalfOf);\n\n    if (amount < paybackAmount) {\n      paybackAmount = amount;\n    }\n\n    DEBT_TOKEN.burn(onBehalfOf, paybackAmount, reserveCache.nextVariableBorrowIndex);\n\n    reserve.updateInterestRates(reserveCache, GHO, 0, amount);\n\n    IERC20(GHO).transferFrom(msg.sender, reserveCache.aTokenAddress, paybackAmount);\n\n    ATOKEN.handleRepayment(msg.sender, onBehalfOf, paybackAmount);\n\n    return paybackAmount;\n  }\n\n  function setReserveInterestRateStrategyAddress(\n    address asset,\n    address rateStrategyAddress\n  ) external override {\n    require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n    _reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\n  }\n\n  function getReserveInterestRateStrategyAddress(address asset) public view returns (address) {\n    return _reserves[asset].interestRateStrategyAddress;\n  }\n\n  function setConfiguration(\n    address asset,\n    DataTypes.ReserveConfigurationMap calldata configuration\n  ) external override {\n    require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n    _reserves[asset].configuration = configuration;\n  }\n}\n"
    },
    "src/test/mocks/MockPoolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolDataProvider} from '@aave/core-v3/contracts/interfaces/IPoolDataProvider.sol';\nimport {IPoolAddressesProvider} from '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\nimport {DataTypes} from '@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol';\nimport {ReserveConfiguration} from '@aave/core-v3/contracts/protocol/libraries/configuration/ReserveConfiguration.sol';\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\n\ncontract MockPoolDataProvider is IPoolDataProvider {\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  IPoolAddressesProvider public immutable POOL_ADDRESSES_PROVIDER;\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider) {\n    return POOL_ADDRESSES_PROVIDER;\n  }\n\n  constructor(address addressesProvider) {\n    POOL_ADDRESSES_PROVIDER = IPoolAddressesProvider(addressesProvider);\n  }\n\n  function getInterestRateStrategyAddress(address asset) external view returns (address) {\n    DataTypes.ReserveData memory reserveData = IPool(\n      IPoolAddressesProvider(POOL_ADDRESSES_PROVIDER).getPool()\n    ).getReserveData(asset);\n    return reserveData.interestRateStrategyAddress;\n  }\n\n  function getATokenTotalSupply(address asset) external view returns (uint256) {\n    return 0;\n  }\n\n  function getAllATokens() external view returns (TokenData[] memory) {\n    return new TokenData[](0);\n  }\n\n  function getAllReservesTokens() external view returns (TokenData[] memory) {\n    return new TokenData[](0);\n  }\n\n  function getDebtCeiling(address asset) external view returns (uint256) {\n    return 0;\n  }\n\n  function getDebtCeilingDecimals() external pure returns (uint256) {\n    return 0;\n  }\n\n  function getFlashLoanEnabled(address asset) external view returns (bool) {\n    return false;\n  }\n\n  function getLiquidationProtocolFee(address asset) external view returns (uint256) {\n    return 0;\n  }\n\n  function getPaused(address asset) external view returns (bool isPaused) {\n    return false;\n  }\n  function getReserveCaps(\n    address asset\n  ) external view returns (uint256 borrowCap, uint256 supplyCap) {\n    return (0, 0);\n  }\n\n  function getReserveConfigurationData(\n    address asset\n  )\n    external\n    view\n    returns (\n      uint256 decimals,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus,\n      uint256 reserveFactor,\n      bool usageAsCollateralEnabled,\n      bool borrowingEnabled,\n      bool stableBorrowRateEnabled,\n      bool isActive,\n      bool isFrozen\n    )\n  {\n    return (0, 0, 0, 0, 0, false, false, false, false, false);\n  }\n\n  function getReserveData(\n    address asset\n  )\n    external\n    view\n    returns (\n      uint256 unbacked,\n      uint256 accruedToTreasuryScaled,\n      uint256 totalAToken,\n      uint256 totalStableDebt,\n      uint256 totalVariableDebt,\n      uint256 liquidityRate,\n      uint256 variableBorrowRate,\n      uint256 stableBorrowRate,\n      uint256 averageStableBorrowRate,\n      uint256 liquidityIndex,\n      uint256 variableBorrowIndex,\n      uint40 lastUpdateTimestamp\n    )\n  {\n    return (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n\n  function getReserveEModeCategory(address asset) external view returns (uint256) {\n    return 0;\n  }\n\n  function getReserveTokensAddresses(\n    address asset\n  )\n    external\n    view\n    returns (\n      address aTokenAddress,\n      address stableDebtTokenAddress,\n      address variableDebtTokenAddress\n    )\n  {\n    return (address(0), address(0), address(0));\n  }\n\n  function getSiloedBorrowing(address asset) external view returns (bool) {\n    return false;\n  }\n\n  function getTotalDebt(address asset) external view returns (uint256) {\n    return 0;\n  }\n\n  function getUnbackedMintCap(address asset) external view returns (uint256) {\n    return 0;\n  }\n\n  function getUserReserveData(\n    address asset,\n    address user\n  )\n    external\n    view\n    returns (\n      uint256 currentATokenBalance,\n      uint256 currentStableDebt,\n      uint256 currentVariableDebt,\n      uint256 principalStableDebt,\n      uint256 scaledVariableDebt,\n      uint256 stableBorrowRate,\n      uint256 liquidityRate,\n      uint40 stableRateLastUpdated,\n      bool usageAsCollateralEnabled\n    )\n  {\n    return (0, 0, 0, 0, 0, 0, 0, 0, false);\n  }\n}\n"
    },
    "src/test/mocks/MockUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Initializable} from 'solidity-utils/contracts/transparent-proxy/Initializable.sol';\n\n/**\n * @dev Mock contract to test upgrades, not to be used in production.\n */\ncontract MockUpgradeable is Initializable {\n  /**\n   * @dev Constructor\n   */\n  constructor() {\n    // Intentionally left bank\n  }\n\n  /**\n   * @dev Initializer\n   */\n  function initialize() public reinitializer(2) {\n    // Intentionally left bank\n  }\n}\n"
    },
    "src/test/mocks/MockUpgradeableBurnMintTokenPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Initializable} from 'solidity-utils/contracts/transparent-proxy/Initializable.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {RateLimiter} from 'src/contracts/misc/dependencies/Ccip.sol';\nimport {IRouter} from 'src/contracts/misc/dependencies/Ccip.sol';\nimport {IARM} from 'src/contracts/misc/dependencies/AaveV3-1.sol';\n\ncontract MockUpgradeableBurnMintTokenPool is Initializable {\n  using SafeERC20 for IERC20;\n  using RateLimiter for RateLimiter.TokenBucket;\n\n  error Unauthorized(address caller);\n  error ZeroAddressNotAllowed();\n\n  event ChainConfigured(\n    uint64 remoteChainSelector,\n    RateLimiter.Config outboundRateLimiterConfig,\n    RateLimiter.Config inboundRateLimiterConfig\n  );\n\n  struct ChainUpdate {\n    uint64 remoteChainSelector;\n    bool allowed;\n    RateLimiter.Config outboundRateLimiterConfig;\n    RateLimiter.Config inboundRateLimiterConfig;\n  }\n\n  address internal _owner;\n  bool internal immutable i_acceptLiquidity;\n  address internal s_rateLimitAdmin;\n  uint256 private s_bridgeLimit;\n  address internal s_bridgeLimitAdmin;\n  IERC20 internal immutable i_token;\n  address internal immutable i_armProxy;\n  bool internal immutable i_allowlistEnabled;\n  EnumerableSet.AddressSet internal s_allowList;\n  IRouter internal s_router;\n  EnumerableSet.UintSet internal s_remoteChainSelectors;\n  mapping(uint64 => RateLimiter.TokenBucket) internal s_outboundRateLimits;\n  mapping(uint64 => RateLimiter.TokenBucket) internal s_inboundRateLimits;\n\n  constructor(address token, address armProxy, bool allowlistEnabled, bool acceptLiquidity) {\n    i_acceptLiquidity = acceptLiquidity;\n    if (address(token) == address(0)) revert ZeroAddressNotAllowed();\n    i_token = IERC20(token);\n    i_armProxy = armProxy;\n    i_allowlistEnabled = allowlistEnabled;\n  }\n\n  function initialize(\n    address owner,\n    address[] memory allowlist,\n    address router,\n    uint256 bridgeLimit\n  ) public virtual initializer {\n    allowlist;\n    if (owner == address(0)) revert ZeroAddressNotAllowed();\n    if (router == address(0)) revert ZeroAddressNotAllowed();\n    _transferOwnership(owner);\n\n    s_router = IRouter(router);\n    s_bridgeLimit = bridgeLimit;\n  }\n\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  function acceptOwnership() external {}\n\n  function setRateLimitAdmin(address rateLimitAdmin) external {\n    s_rateLimitAdmin = rateLimitAdmin;\n  }\n\n  function setBridgeLimit(uint256 newBridgeLimit) external {\n    if (msg.sender != s_bridgeLimitAdmin && msg.sender != owner()) revert Unauthorized(msg.sender);\n    s_bridgeLimit = newBridgeLimit;\n  }\n\n  function setBridgeLimitAdmin(address bridgeLimitAdmin) external {\n    s_bridgeLimitAdmin = bridgeLimitAdmin;\n  }\n\n  function getBridgeLimit() external view virtual returns (uint256) {\n    return s_bridgeLimit;\n  }\n\n  function getRateLimitAdmin() external view returns (address) {\n    return s_rateLimitAdmin;\n  }\n\n  function getBridgeLimitAdmin() external view returns (address) {\n    return s_bridgeLimitAdmin;\n  }\n\n  function setChainRateLimiterConfig(\n    uint64 remoteChainSelector,\n    RateLimiter.Config memory outboundConfig,\n    RateLimiter.Config memory inboundConfig\n  ) external {\n    if (msg.sender != s_rateLimitAdmin && msg.sender != owner()) revert Unauthorized(msg.sender);\n\n    _setRateLimitConfig(remoteChainSelector, outboundConfig, inboundConfig);\n  }\n\n  function _setRateLimitConfig(\n    uint64 remoteChainSelector,\n    RateLimiter.Config memory outboundConfig,\n    RateLimiter.Config memory inboundConfig\n  ) internal {\n    RateLimiter._validateTokenBucketConfig(outboundConfig, false);\n    s_outboundRateLimits[remoteChainSelector]._setTokenBucketConfig(outboundConfig);\n    RateLimiter._validateTokenBucketConfig(inboundConfig, false);\n    s_inboundRateLimits[remoteChainSelector]._setTokenBucketConfig(inboundConfig);\n    emit ChainConfigured(remoteChainSelector, outboundConfig, inboundConfig);\n  }\n\n  function getCurrentOutboundRateLimiterState(\n    uint64 remoteChainSelector\n  ) external view returns (RateLimiter.TokenBucket memory) {\n    return s_outboundRateLimits[remoteChainSelector]._currentTokenBucketState();\n  }\n\n  function getCurrentInboundRateLimiterState(\n    uint64 remoteChainSelector\n  ) external view returns (RateLimiter.TokenBucket memory) {\n    return s_inboundRateLimits[remoteChainSelector]._currentTokenBucketState();\n  }\n\n  function applyChainUpdates(ChainUpdate[] calldata chains) external virtual {\n    for (uint256 i = 0; i < chains.length; ++i) {\n      ChainUpdate memory update = chains[i];\n      s_outboundRateLimits[update.remoteChainSelector] = RateLimiter.TokenBucket({\n        rate: update.outboundRateLimiterConfig.rate,\n        capacity: update.outboundRateLimiterConfig.capacity,\n        tokens: update.outboundRateLimiterConfig.capacity,\n        lastUpdated: uint32(block.timestamp),\n        isEnabled: update.outboundRateLimiterConfig.isEnabled\n      });\n\n      s_inboundRateLimits[update.remoteChainSelector] = RateLimiter.TokenBucket({\n        rate: update.inboundRateLimiterConfig.rate,\n        capacity: update.inboundRateLimiterConfig.capacity,\n        tokens: update.inboundRateLimiterConfig.capacity,\n        lastUpdated: uint32(block.timestamp),\n        isEnabled: update.inboundRateLimiterConfig.isEnabled\n      });\n    }\n  }\n\n  function _transferOwnership(address newOwner) internal {\n    _owner = newOwner;\n  }\n}\n"
    },
    "src/test/mocks/MockUpgradeableLockReleaseTokenPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Initializable} from 'solidity-utils/contracts/transparent-proxy/Initializable.sol';\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {RateLimiter} from 'src/contracts/misc/dependencies/Ccip.sol';\nimport {IRouter} from 'src/contracts/misc/dependencies/Ccip.sol';\nimport {IARM} from 'src/contracts/misc/dependencies/AaveV3-1.sol';\n\ncontract MockUpgradeableLockReleaseTokenPool is Initializable {\n  using SafeERC20 for IERC20;\n  using RateLimiter for RateLimiter.TokenBucket;\n\n  error Unauthorized(address caller);\n  error ZeroAddressNotAllowed();\n\n  event ChainConfigured(\n    uint64 remoteChainSelector,\n    RateLimiter.Config outboundRateLimiterConfig,\n    RateLimiter.Config inboundRateLimiterConfig\n  );\n\n  struct ChainUpdate {\n    uint64 remoteChainSelector;\n    bool allowed;\n    RateLimiter.Config outboundRateLimiterConfig;\n    RateLimiter.Config inboundRateLimiterConfig;\n  }\n\n  address internal _owner;\n  bool internal immutable i_acceptLiquidity;\n  address internal s_rateLimitAdmin;\n  uint256 private s_bridgeLimit;\n  address internal s_bridgeLimitAdmin;\n  IERC20 internal immutable i_token;\n  address internal immutable i_armProxy;\n  bool internal immutable i_allowlistEnabled;\n  EnumerableSet.AddressSet internal s_allowList;\n  IRouter internal s_router;\n  EnumerableSet.UintSet internal s_remoteChainSelectors;\n  mapping(uint64 => RateLimiter.TokenBucket) internal s_outboundRateLimits;\n  mapping(uint64 => RateLimiter.TokenBucket) internal s_inboundRateLimits;\n\n  constructor(address token, address armProxy, bool allowlistEnabled, bool acceptLiquidity) {\n    i_acceptLiquidity = acceptLiquidity;\n    if (address(token) == address(0)) revert ZeroAddressNotAllowed();\n    i_token = IERC20(token);\n    i_armProxy = armProxy;\n    i_allowlistEnabled = allowlistEnabled;\n  }\n\n  function initialize(\n    address owner,\n    address[] memory allowlist,\n    address router,\n    uint256 bridgeLimit\n  ) public virtual initializer {\n    allowlist;\n    if (owner == address(0)) revert ZeroAddressNotAllowed();\n    if (router == address(0)) revert ZeroAddressNotAllowed();\n    _transferOwnership(owner);\n\n    s_router = IRouter(router);\n    s_bridgeLimit = bridgeLimit;\n  }\n\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  function acceptOwnership() external {}\n\n  function setRateLimitAdmin(address rateLimitAdmin) external {\n    s_rateLimitAdmin = rateLimitAdmin;\n  }\n\n  function setBridgeLimit(uint256 newBridgeLimit) external {\n    if (msg.sender != s_bridgeLimitAdmin && msg.sender != owner()) revert Unauthorized(msg.sender);\n    s_bridgeLimit = newBridgeLimit;\n  }\n\n  function setBridgeLimitAdmin(address bridgeLimitAdmin) external {\n    s_bridgeLimitAdmin = bridgeLimitAdmin;\n  }\n\n  function getBridgeLimit() external view virtual returns (uint256) {\n    return s_bridgeLimit;\n  }\n\n  function getRateLimitAdmin() external view returns (address) {\n    return s_rateLimitAdmin;\n  }\n\n  function getBridgeLimitAdmin() external view returns (address) {\n    return s_bridgeLimitAdmin;\n  }\n\n  function setChainRateLimiterConfig(\n    uint64 remoteChainSelector,\n    RateLimiter.Config memory outboundConfig,\n    RateLimiter.Config memory inboundConfig\n  ) external {\n    if (msg.sender != s_rateLimitAdmin && msg.sender != owner()) revert Unauthorized(msg.sender);\n\n    _setRateLimitConfig(remoteChainSelector, outboundConfig, inboundConfig);\n  }\n\n  function _setRateLimitConfig(\n    uint64 remoteChainSelector,\n    RateLimiter.Config memory outboundConfig,\n    RateLimiter.Config memory inboundConfig\n  ) internal {\n    RateLimiter._validateTokenBucketConfig(outboundConfig, false);\n    s_outboundRateLimits[remoteChainSelector]._setTokenBucketConfig(outboundConfig);\n    RateLimiter._validateTokenBucketConfig(inboundConfig, false);\n    s_inboundRateLimits[remoteChainSelector]._setTokenBucketConfig(inboundConfig);\n    emit ChainConfigured(remoteChainSelector, outboundConfig, inboundConfig);\n  }\n\n  function getCurrentOutboundRateLimiterState(\n    uint64 remoteChainSelector\n  ) external view returns (RateLimiter.TokenBucket memory) {\n    return s_outboundRateLimits[remoteChainSelector]._currentTokenBucketState();\n  }\n\n  function getCurrentInboundRateLimiterState(\n    uint64 remoteChainSelector\n  ) external view returns (RateLimiter.TokenBucket memory) {\n    return s_inboundRateLimits[remoteChainSelector]._currentTokenBucketState();\n  }\n\n  function applyChainUpdates(ChainUpdate[] calldata chains) external virtual {\n    for (uint256 i = 0; i < chains.length; ++i) {\n      ChainUpdate memory update = chains[i];\n      s_outboundRateLimits[update.remoteChainSelector] = RateLimiter.TokenBucket({\n        rate: update.outboundRateLimiterConfig.rate,\n        capacity: update.outboundRateLimiterConfig.capacity,\n        tokens: update.outboundRateLimiterConfig.capacity,\n        lastUpdated: uint32(block.timestamp),\n        isEnabled: update.outboundRateLimiterConfig.isEnabled\n      });\n\n      s_inboundRateLimits[update.remoteChainSelector] = RateLimiter.TokenBucket({\n        rate: update.inboundRateLimiterConfig.rate,\n        capacity: update.inboundRateLimiterConfig.capacity,\n        tokens: update.inboundRateLimiterConfig.capacity,\n        lastUpdated: uint32(block.timestamp),\n        isEnabled: update.inboundRateLimiterConfig.isEnabled\n      });\n    }\n  }\n\n  function _transferOwnership(address newOwner) internal {\n    _owner = newOwner;\n  }\n}\n"
    },
    "src/test/TestFixedRateStrategyFactory.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestFixedRateStrategyFactory is TestGhoBase {\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  function testConstructor() public {\n    assertEq(FIXED_RATE_STRATEGY_FACTORY.POOL_ADDRESSES_PROVIDER(), address(PROVIDER));\n    address[] memory strategies = FIXED_RATE_STRATEGY_FACTORY.getAllStrategies();\n\n    assertEq(strategies.length, 0);\n  }\n\n  function testRevertConstructorInvalidExecutor() public {\n    vm.expectRevert('INVALID_ADDRESSES_PROVIDER');\n    new FixedRateStrategyFactory(address(0));\n  }\n\n  function testInitialize() public {\n    address[] memory strategies = new address[](1);\n    strategies[0] = address(new GhoInterestRateStrategy(address(PROVIDER), 100));\n\n    vm.expectEmit(true, true, false, false, address(FIXED_RATE_STRATEGY_FACTORY));\n    emit RateStrategyCreated(strategies[0], 100);\n\n    FIXED_RATE_STRATEGY_FACTORY.initialize(strategies);\n    address[] memory strategiesCall = FIXED_RATE_STRATEGY_FACTORY.getAllStrategies();\n\n    assertEq(strategiesCall.length, 1);\n    assertEq(strategiesCall[0], strategies[0]);\n  }\n\n  function testInitializeMultiple() public {\n    address[] memory strategies = new address[](3);\n    strategies[0] = address(new GhoInterestRateStrategy(address(PROVIDER), 100));\n    strategies[1] = address(new GhoInterestRateStrategy(address(PROVIDER), 200));\n    strategies[2] = address(new GhoInterestRateStrategy(address(PROVIDER), 300));\n\n    vm.expectEmit(true, true, false, false, address(FIXED_RATE_STRATEGY_FACTORY));\n    emit RateStrategyCreated(strategies[0], 100);\n    vm.expectEmit(true, true, false, false, address(FIXED_RATE_STRATEGY_FACTORY));\n    emit RateStrategyCreated(strategies[1], 200);\n    vm.expectEmit(true, true, false, false, address(FIXED_RATE_STRATEGY_FACTORY));\n    emit RateStrategyCreated(strategies[2], 300);\n\n    FIXED_RATE_STRATEGY_FACTORY.initialize(strategies);\n    address[] memory strategiesCall = FIXED_RATE_STRATEGY_FACTORY.getAllStrategies();\n\n    assertEq(strategiesCall.length, 3);\n    assertEq(strategiesCall[0], strategies[0]);\n    assertEq(strategiesCall[1], strategies[1]);\n    assertEq(strategiesCall[2], strategies[2]);\n  }\n\n  function testRevertInitializeTwice() public {\n    address[] memory strategies = new address[](1);\n    strategies[0] = address(new GhoInterestRateStrategy(address(PROVIDER), 100));\n\n    FIXED_RATE_STRATEGY_FACTORY.initialize(strategies);\n    vm.expectRevert('Contract instance has already been initialized');\n    FIXED_RATE_STRATEGY_FACTORY.initialize(strategies);\n  }\n\n  function testCreateStrategies() public {\n    uint256[] memory rates = new uint256[](1);\n    rates[0] = 100;\n\n    uint256 nonce = vm.getNonce(address(FIXED_RATE_STRATEGY_FACTORY));\n    address deployedStrategy = computeCreateAddress(address(FIXED_RATE_STRATEGY_FACTORY), nonce);\n    vm.expectEmit(true, true, false, false, address(FIXED_RATE_STRATEGY_FACTORY));\n    emit RateStrategyCreated(deployedStrategy, 100);\n\n    address[] memory strategies = FIXED_RATE_STRATEGY_FACTORY.createStrategies(rates);\n\n    assertEq(strategies.length, 1);\n    assertEq(GhoInterestRateStrategy(strategies[0]).getBaseVariableBorrowRate(), rates[0]);\n  }\n\n  function testCreateStrategiesMultiple() public {\n    uint256[] memory rates = new uint256[](3);\n    rates[0] = 100;\n    rates[1] = 200;\n    rates[2] = 300;\n\n    uint256 nonce = vm.getNonce(address(FIXED_RATE_STRATEGY_FACTORY));\n\n    address deployedStrategy1 = computeCreateAddress(address(FIXED_RATE_STRATEGY_FACTORY), nonce);\n    vm.expectEmit(true, true, false, false, address(FIXED_RATE_STRATEGY_FACTORY));\n    emit RateStrategyCreated(deployedStrategy1, 100);\n\n    address deployedStrategy2 = computeCreateAddress(\n      address(FIXED_RATE_STRATEGY_FACTORY),\n      nonce + 1\n    );\n    vm.expectEmit(true, true, false, false, address(FIXED_RATE_STRATEGY_FACTORY));\n    emit RateStrategyCreated(deployedStrategy2, 200);\n\n    address deployedStrategy3 = computeCreateAddress(\n      address(FIXED_RATE_STRATEGY_FACTORY),\n      nonce + 2\n    );\n    vm.expectEmit(true, true, false, false, address(FIXED_RATE_STRATEGY_FACTORY));\n    emit RateStrategyCreated(deployedStrategy3, 300);\n\n    address[] memory strategies = FIXED_RATE_STRATEGY_FACTORY.createStrategies(rates);\n\n    assertEq(strategies.length, 3);\n    assertEq(GhoInterestRateStrategy(strategies[0]).getBaseVariableBorrowRate(), rates[0]);\n    assertEq(GhoInterestRateStrategy(strategies[1]).getBaseVariableBorrowRate(), rates[1]);\n    assertEq(GhoInterestRateStrategy(strategies[2]).getBaseVariableBorrowRate(), rates[2]);\n  }\n\n  function testCreateStrategiesCached() public {\n    uint256[] memory rates = new uint256[](2);\n    rates[0] = 100;\n    rates[1] = 100;\n    address[] memory strategies = FIXED_RATE_STRATEGY_FACTORY.createStrategies(rates);\n\n    assertEq(strategies.length, 2);\n    assertEq(strategies[0], strategies[1]);\n  }\n\n  function testCreatedStrategiesCachedDifferentCalls() public {\n    uint256[] memory rates = new uint256[](1);\n    rates[0] = 100;\n    address[] memory strategies = FIXED_RATE_STRATEGY_FACTORY.createStrategies(rates);\n    address[] memory strategies2 = FIXED_RATE_STRATEGY_FACTORY.createStrategies(rates);\n    assertEq(strategies[0], strategies2[0]);\n  }\n\n  function testGetAllStrategies() public {\n    uint256[] memory rates = new uint256[](3);\n    rates[0] = 100;\n    rates[1] = 200;\n    rates[2] = 300;\n\n    address[] memory strategies = FIXED_RATE_STRATEGY_FACTORY.createStrategies(rates);\n    address[] memory strategiesCall = FIXED_RATE_STRATEGY_FACTORY.getAllStrategies();\n\n    assertEq(strategies.length, strategiesCall.length);\n    assertEq(strategies[0], strategiesCall[0]);\n    assertEq(strategies[1], strategiesCall[1]);\n    assertEq(strategies[2], strategiesCall[2]);\n  }\n\n  function testGetAllStrategiesCached() public {\n    uint256[] memory rates = new uint256[](2);\n    rates[0] = 100;\n    rates[1] = 100;\n\n    FIXED_RATE_STRATEGY_FACTORY.createStrategies(rates);\n    address[] memory strategies = FIXED_RATE_STRATEGY_FACTORY.getAllStrategies();\n    assertEq(strategies.length, 1);\n  }\n\n  function testGetStrategyByRate() public {\n    uint256[] memory rates = new uint256[](3);\n    rates[0] = 100;\n    rates[1] = 200;\n    rates[2] = 300;\n\n    address[] memory strategies = FIXED_RATE_STRATEGY_FACTORY.createStrategies(rates);\n\n    assertEq(FIXED_RATE_STRATEGY_FACTORY.getStrategyByRate(rates[0]), strategies[0]);\n    assertEq(FIXED_RATE_STRATEGY_FACTORY.getStrategyByRate(rates[1]), strategies[1]);\n    assertEq(FIXED_RATE_STRATEGY_FACTORY.getStrategyByRate(rates[2]), strategies[2]);\n  }\n\n  function testGetFixedRateStrategyRevision() public {\n    assertEq(FIXED_RATE_STRATEGY_FACTORY.REVISION(), FIXED_RATE_STRATEGY_FACTORY_REVISION);\n  }\n}\n"
    },
    "src/test/TestGhoAaveSteward.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\nimport {Constants} from './helpers/Constants.sol';\nimport {IGhoAaveSteward} from '../contracts/misc/interfaces/IGhoAaveSteward.sol';\nimport {IDefaultInterestRateStrategyV2, DefaultReserveInterestRateStrategyV2} from '../contracts/misc/dependencies/AaveV3-1.sol';\n\ncontract TestGhoAaveSteward is TestGhoBase {\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  IGhoAaveSteward.BorrowRateConfig public defaultBorrowRateConfig =\n    IGhoAaveSteward.BorrowRateConfig({\n      optimalUsageRatioMaxChange: 5_00,\n      baseVariableBorrowRateMaxChange: 5_00,\n      variableRateSlope1MaxChange: 5_00,\n      variableRateSlope2MaxChange: 5_00\n    });\n  IDefaultInterestRateStrategyV2.InterestRateData public defaultRateParams =\n    IDefaultInterestRateStrategyV2.InterestRateData({\n      optimalUsageRatio: 1_00,\n      baseVariableBorrowRate: 0.20e4,\n      variableRateSlope1: 0,\n      variableRateSlope2: 0\n    });\n\n  function setUp() public {\n    // Deploy Gho Aave Steward\n    GHO_AAVE_STEWARD = new GhoAaveSteward(\n      SHORT_EXECUTOR,\n      address(PROVIDER),\n      address(MOCK_POOL_DATA_PROVIDER),\n      address(GHO_TOKEN),\n      RISK_COUNCIL,\n      defaultBorrowRateConfig\n    );\n\n    // Set a new strategy because the default is old strategy type\n    DefaultReserveInterestRateStrategyV2 newRateStrategy = new DefaultReserveInterestRateStrategyV2(\n      address(PROVIDER)\n    );\n    CONFIGURATOR.setReserveInterestRateStrategyAddress(\n      address(GHO_TOKEN),\n      address(newRateStrategy),\n      abi.encode(defaultRateParams)\n    );\n\n    /// @dev Since block.timestamp starts at 0 this is a necessary condition (block.timestamp > `MINIMUM_DELAY`) for the timelocked contract methods to work.\n    vm.warp(GHO_AAVE_STEWARD.MINIMUM_DELAY() + 1);\n  }\n\n  function testConstructor() public {\n    assertEq(GHO_AAVE_STEWARD.owner(), SHORT_EXECUTOR);\n    assertEq(GHO_AAVE_STEWARD.MINIMUM_DELAY(), MINIMUM_DELAY_V2);\n\n    assertEq(GHO_AAVE_STEWARD.POOL_ADDRESSES_PROVIDER(), address(PROVIDER));\n    assertEq(GHO_AAVE_STEWARD.POOL_DATA_PROVIDER(), address(MOCK_POOL_DATA_PROVIDER));\n    assertEq(GHO_AAVE_STEWARD.GHO_TOKEN(), address(GHO_TOKEN));\n    assertEq(GHO_AAVE_STEWARD.RISK_COUNCIL(), RISK_COUNCIL);\n\n    IGhoAaveSteward.GhoDebounce memory ghoTimelocks = GHO_AAVE_STEWARD.getGhoTimelocks();\n    assertEq(ghoTimelocks.ghoBorrowCapLastUpdate, 0);\n  }\n\n  function testRevertConstructorInvalidOwner() public {\n    vm.expectRevert('INVALID_OWNER');\n    new GhoAaveSteward(\n      address(0),\n      address(0x002),\n      address(0x003),\n      address(0x004),\n      address(0x005),\n      defaultBorrowRateConfig\n    );\n  }\n\n  function testRevertConstructorInvalidAddressesProvider() public {\n    vm.expectRevert('INVALID_ADDRESSES_PROVIDER');\n    new GhoAaveSteward(\n      address(0x001),\n      address(0),\n      address(0x003),\n      address(0x004),\n      address(0x005),\n      defaultBorrowRateConfig\n    );\n  }\n\n  function testRevertConstructorInvalidDataProvider() public {\n    vm.expectRevert('INVALID_DATA_PROVIDER');\n    new GhoAaveSteward(\n      address(0x001),\n      address(0x002),\n      address(0),\n      address(0x004),\n      address(0x005),\n      defaultBorrowRateConfig\n    );\n  }\n\n  function testRevertConstructorInvalidGhoToken() public {\n    vm.expectRevert('INVALID_GHO_TOKEN');\n    new GhoAaveSteward(\n      address(0x001),\n      address(0x002),\n      address(0x003),\n      address(0),\n      address(0x005),\n      defaultBorrowRateConfig\n    );\n  }\n\n  function testRevertConstructorInvalidRiskCouncil() public {\n    vm.expectRevert('INVALID_RISK_COUNCIL');\n    new GhoAaveSteward(\n      address(0x001),\n      address(0x002),\n      address(0x003),\n      address(0x004),\n      address(0),\n      defaultBorrowRateConfig\n    );\n  }\n\n  function testChangeOwnership() public {\n    address newOwner = makeAddr('newOwner');\n    assertEq(GHO_AAVE_STEWARD.owner(), SHORT_EXECUTOR);\n    vm.prank(SHORT_EXECUTOR);\n    GHO_AAVE_STEWARD.transferOwnership(newOwner);\n    assertEq(GHO_AAVE_STEWARD.owner(), newOwner);\n  }\n\n  function testChangeOwnershipRevert() public {\n    vm.expectRevert('Ownable: new owner is the zero address');\n    vm.prank(SHORT_EXECUTOR);\n    GHO_AAVE_STEWARD.transferOwnership(address(0));\n  }\n\n  function testUpdateGhoBorrowCap() public {\n    uint256 oldBorrowCap = 1e6;\n    _setGhoBorrowCapViaConfigurator(oldBorrowCap);\n    uint256 newBorrowCap = oldBorrowCap + 1;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowCap(newBorrowCap);\n    uint256 currentBorrowCap = _getGhoBorrowCap();\n    assertEq(newBorrowCap, currentBorrowCap);\n  }\n\n  function testUpdateGhoBorrowCapMaxIncrease() public {\n    uint256 oldBorrowCap = 1e6;\n    _setGhoBorrowCapViaConfigurator(oldBorrowCap);\n    uint256 newBorrowCap = oldBorrowCap * 2;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowCap(newBorrowCap);\n    uint256 currentBorrowCap = _getGhoBorrowCap();\n    assertEq(newBorrowCap, currentBorrowCap);\n  }\n\n  function testUpdateGhoBorrowCapMaxDecrease() public {\n    uint256 oldBorrowCap = 1e6;\n    _setGhoBorrowCapViaConfigurator(oldBorrowCap);\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowCap(0);\n    uint256 currentBorrowCap = _getGhoBorrowCap();\n    assertEq(currentBorrowCap, 0);\n  }\n\n  function testUpdateGhoBorrowCapTimelock() public {\n    uint256 oldBorrowCap = 1e6;\n    _setGhoBorrowCapViaConfigurator(oldBorrowCap);\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowCap(oldBorrowCap + 1);\n    IGhoAaveSteward.GhoDebounce memory ghoTimelocks = GHO_AAVE_STEWARD.getGhoTimelocks();\n    assertEq(ghoTimelocks.ghoBorrowCapLastUpdate, block.timestamp);\n  }\n\n  function testUpdateGhoBorrowCapAfterTimelock() public {\n    uint256 oldBorrowCap = 1e6;\n    _setGhoBorrowCapViaConfigurator(oldBorrowCap);\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowCap(oldBorrowCap + 1);\n    skip(GHO_AAVE_STEWARD.MINIMUM_DELAY() + 1);\n    uint256 newBorrowCap = oldBorrowCap + 2;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowCap(newBorrowCap);\n    uint256 currentBorrowCap = _getGhoBorrowCap();\n    assertEq(newBorrowCap, currentBorrowCap);\n  }\n\n  function testRevertUpdateGhoBorrowCapIfUnauthorized() public {\n    vm.prank(ALICE);\n    vm.expectRevert('INVALID_CALLER');\n    GHO_AAVE_STEWARD.updateGhoBorrowCap(50e6);\n  }\n\n  function testRevertUpdateGhoBorrowCapIfUpdatedTooSoon() public {\n    uint256 oldBorrowCap = 1e6;\n    _setGhoBorrowCapViaConfigurator(oldBorrowCap);\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowCap(oldBorrowCap + 1);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('DEBOUNCE_NOT_RESPECTED');\n    GHO_AAVE_STEWARD.updateGhoBorrowCap(oldBorrowCap + 2);\n  }\n\n  function testRevertUpdateGhoBorrowCapNoChange() public {\n    uint256 oldBorrowCap = 1e6;\n    _setGhoBorrowCapViaConfigurator(oldBorrowCap);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('NO_CHANGE_IN_BORROW_CAP');\n    GHO_AAVE_STEWARD.updateGhoBorrowCap(oldBorrowCap);\n  }\n\n  function testRevertUpdateGhoBorrowCapIfValueMoreThanDouble() public {\n    uint256 oldBorrowCap = 1e6;\n    _setGhoBorrowCapViaConfigurator(oldBorrowCap);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_BORROW_CAP_UPDATE');\n    GHO_AAVE_STEWARD.updateGhoBorrowCap(oldBorrowCap * 2 + 1);\n  }\n\n  function testUpdateGhoSupplyCap() public {\n    uint256 oldSupplyCap = 1e6;\n    _setGhoSupplyCapViaConfigurator(oldSupplyCap);\n    uint256 newSupplyCap = oldSupplyCap + 1;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoSupplyCap(newSupplyCap);\n    uint256 currentSupplyCap = _getGhoSupplyCap();\n    assertEq(newSupplyCap, currentSupplyCap);\n  }\n\n  function testUpdateGhoSupplyCapMaxIncrease() public {\n    uint256 oldSupplyCap = 1e6;\n    _setGhoSupplyCapViaConfigurator(oldSupplyCap);\n    uint256 newSupplyCap = oldSupplyCap * 2;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoSupplyCap(newSupplyCap);\n    uint256 currentSupplyCap = _getGhoSupplyCap();\n    assertEq(newSupplyCap, currentSupplyCap);\n  }\n\n  function testUpdateGhoSupplyCapMaxDecrease() public {\n    uint256 oldSupplyCap = 1e6;\n    _setGhoSupplyCapViaConfigurator(oldSupplyCap);\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoSupplyCap(0);\n    uint256 currentSupplyCap = _getGhoSupplyCap();\n    assertEq(currentSupplyCap, 0);\n  }\n\n  function testUpdateGhoSupplyCapTimelock() public {\n    uint256 oldSupplyCap = 1e6;\n    _setGhoSupplyCapViaConfigurator(oldSupplyCap);\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoSupplyCap(oldSupplyCap + 1);\n    IGhoAaveSteward.GhoDebounce memory ghoTimelocks = GHO_AAVE_STEWARD.getGhoTimelocks();\n    assertEq(ghoTimelocks.ghoSupplyCapLastUpdate, block.timestamp);\n  }\n\n  function testUpdateGhoSupplyCapAfterTimelock() public {\n    uint256 oldSupplyCap = 1e6;\n    _setGhoSupplyCapViaConfigurator(oldSupplyCap);\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoSupplyCap(oldSupplyCap + 1);\n    skip(GHO_AAVE_STEWARD.MINIMUM_DELAY() + 1);\n    uint256 newSupplyCap = oldSupplyCap + 2;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoSupplyCap(newSupplyCap);\n    uint256 currentSupplyCap = _getGhoSupplyCap();\n    assertEq(newSupplyCap, currentSupplyCap);\n  }\n\n  function testRevertUpdateGhoSupplyCapIfUnauthorized() public {\n    vm.prank(ALICE);\n    vm.expectRevert('INVALID_CALLER');\n    GHO_AAVE_STEWARD.updateGhoSupplyCap(50e6);\n  }\n\n  function testRevertUpdateGhoSupplyCapIfUpdatedTooSoon() public {\n    uint256 oldSupplyCap = 1e6;\n    _setGhoSupplyCapViaConfigurator(oldSupplyCap);\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoSupplyCap(oldSupplyCap + 1);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('DEBOUNCE_NOT_RESPECTED');\n    GHO_AAVE_STEWARD.updateGhoSupplyCap(oldSupplyCap + 2);\n  }\n\n  function testRevertUpdateGhoSupplyCapNoChange() public {\n    uint256 oldSupplyCap = 1e6;\n    _setGhoSupplyCapViaConfigurator(oldSupplyCap);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('NO_CHANGE_IN_SUPPLY_CAP');\n    GHO_AAVE_STEWARD.updateGhoSupplyCap(oldSupplyCap);\n  }\n\n  function testRevertUpdateGhoSupplyCapIfValueMoreThanDouble() public {\n    uint256 oldSupplyCap = 1e6;\n    _setGhoSupplyCapViaConfigurator(oldSupplyCap);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_SUPPLY_CAP_UPDATE');\n    GHO_AAVE_STEWARD.updateGhoSupplyCap(oldSupplyCap * 2 + 1);\n  }\n\n  function testUpdateGhoBorrowRate() public {\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      0.21e4,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    assertEq(_getGhoBorrowRate(), 0.21e4);\n  }\n\n  function testUpdateGhoBorrowRateUpwards() public {\n    uint32 oldBorrowRate = _getGhoBorrowRate();\n    uint32 newBorrowRate = oldBorrowRate + 1;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      newBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    uint32 currentBorrowRate = _getGhoBorrowRate();\n    assertEq(currentBorrowRate, newBorrowRate);\n  }\n\n  function testUpdateGhoBorrowRateUpwardsFromHigh() public {\n    // set a very high borrow rate of 80%\n    uint32 highBaseBorrowRate = 0.80e4;\n    _setGhoBorrowRateViaConfigurator(highBaseBorrowRate);\n    highBaseBorrowRate += 0.04e4;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      highBaseBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    assertEq(highBaseBorrowRate, _getGhoBorrowRate());\n  }\n\n  function testUpdateGhoBorrowRateDownwards() public {\n    uint32 oldBorrowRate = _getGhoBorrowRate();\n    uint32 newBorrowRate = oldBorrowRate - 1;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      newBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    uint32 currentBorrowRate = _getGhoBorrowRate();\n    assertEq(currentBorrowRate, newBorrowRate);\n  }\n\n  function testUpdateGhoBorrowRateDownwardsFromHigh() public {\n    // set a very high borrow rate of 80%\n    uint32 highBaseBorrowRate = 0.80e4;\n    _setGhoBorrowRateViaConfigurator(highBaseBorrowRate);\n    highBaseBorrowRate -= 0.04e4;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      highBaseBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    assertEq(highBaseBorrowRate, _getGhoBorrowRate());\n  }\n\n  function testUpdateGhoBorrowRateMaxIncrement() public {\n    uint32 oldBorrowRate = _getGhoBorrowRate();\n    uint32 newBorrowRate = oldBorrowRate + GHO_BORROW_RATE_CHANGE_MAX;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      newBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    uint32 currentBorrowRate = _getGhoBorrowRate();\n    assertEq(currentBorrowRate, newBorrowRate);\n  }\n\n  function testUpdateGhoBorrowRateDecrement() public {\n    uint32 oldBorrowRate = _getGhoBorrowRate();\n    uint32 newBorrowRate = oldBorrowRate - 1;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      newBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    uint32 currentBorrowRate = _getGhoBorrowRate();\n    assertEq(currentBorrowRate, newBorrowRate);\n  }\n\n  function testUpdateGhoBorrowRateMaxDecrement() public {\n    vm.startPrank(RISK_COUNCIL);\n\n    // set a high borrow rate\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      _getGhoBorrowRate() + GHO_BORROW_RATE_CHANGE_MAX,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    vm.warp(block.timestamp + GHO_AAVE_STEWARD.MINIMUM_DELAY() + 1);\n\n    uint32 oldBorrowRate = _getGhoBorrowRate();\n    uint32 newBorrowRate = oldBorrowRate - GHO_BORROW_RATE_CHANGE_MAX;\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      newBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    uint32 currentBorrowRate = _getGhoBorrowRate();\n    assertEq(currentBorrowRate, newBorrowRate);\n\n    vm.stopPrank();\n  }\n\n  function testUpdateGhoBorrowRateTimelock() public {\n    uint32 oldBorrowRate = _getGhoBorrowRate();\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      oldBorrowRate + 1,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    IGhoAaveSteward.GhoDebounce memory ghoTimelocks = GHO_AAVE_STEWARD.getGhoTimelocks();\n    assertEq(ghoTimelocks.ghoBorrowRateLastUpdate, block.timestamp);\n  }\n\n  function testUpdateGhoBorrowRateAfterTimelock() public {\n    uint32 oldBorrowRate = _getGhoBorrowRate();\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      oldBorrowRate + 1,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    skip(GHO_AAVE_STEWARD.MINIMUM_DELAY() + 1);\n    uint32 newBorrowRate = oldBorrowRate + 2;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      newBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    uint32 currentBorrowRate = _getGhoBorrowRate();\n    assertEq(currentBorrowRate, newBorrowRate);\n  }\n\n  function testUpdateGhoBorrowRateOptimalUsageRatio() public {\n    uint16 oldOptimalUsageRatio = _getOptimalUsageRatio();\n    uint16 newOptimalUsageRatio = oldOptimalUsageRatio + 1;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      newOptimalUsageRatio,\n      defaultRateParams.baseVariableBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    uint16 currentOptimalUsageRatio = _getOptimalUsageRatio();\n    assertEq(currentOptimalUsageRatio, newOptimalUsageRatio);\n  }\n\n  function testRevertUpdateGhoBorrowRateOptimalUsageRatioIfMaxExceededUpwards() public {\n    uint16 oldOptimalUsageRatio = _getOptimalUsageRatio();\n    uint16 newOptimalUsageRatio = oldOptimalUsageRatio +\n      defaultBorrowRateConfig.optimalUsageRatioMaxChange +\n      1;\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_OPTIMAL_USAGE_RATIO');\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      newOptimalUsageRatio,\n      defaultRateParams.baseVariableBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n  }\n\n  function testRevertUpdateGhoBorrowRateOptimalUsageRatioIfMaxExceededDownwards() public {\n    uint16 oldOptimalUsageRatio = _getOptimalUsageRatio();\n    uint16 newOptimalUsageRatio = oldOptimalUsageRatio +\n      defaultBorrowRateConfig.optimalUsageRatioMaxChange;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      newOptimalUsageRatio,\n      defaultRateParams.baseVariableBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    vm.warp(block.timestamp + GHO_AAVE_STEWARD.MINIMUM_DELAY() + 1);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_OPTIMAL_USAGE_RATIO');\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      newOptimalUsageRatio - defaultBorrowRateConfig.optimalUsageRatioMaxChange - 1,\n      defaultRateParams.baseVariableBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n  }\n\n  function testUpdateGhoBorrowRateVariableRateSlope1() public {\n    uint32 oldVariableRateSlope1 = _getVariableRateSlope1();\n    uint32 newVariableRateSlope1 = oldVariableRateSlope1 + 1;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      defaultRateParams.baseVariableBorrowRate,\n      newVariableRateSlope1,\n      newVariableRateSlope1 + 1 // variableRateSlope2 has to be gte variableRateSlope1\n    );\n    uint32 currentVariableRateSlope1 = _getVariableRateSlope1();\n    assertEq(currentVariableRateSlope1, newVariableRateSlope1);\n  }\n\n  function testRevertUpdateGhoBorrowRateVariableRateSlope1IfMaxExceededUpwards() public {\n    uint32 oldVariableRateSlope1 = _getVariableRateSlope1();\n    uint32 newVariableRateSlope1 = oldVariableRateSlope1 +\n      defaultBorrowRateConfig.variableRateSlope1MaxChange +\n      1;\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_VARIABLE_RATE_SLOPE1');\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      defaultRateParams.baseVariableBorrowRate,\n      newVariableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n  }\n\n  function testRevertUpdateGhoBorrowRateVariableRateSlope1IfMaxExceededDownwards() public {\n    uint32 oldVariableRateSlope1 = _getVariableRateSlope1();\n    uint32 newVariableRateSlope1 = oldVariableRateSlope1 +\n      defaultBorrowRateConfig.variableRateSlope1MaxChange;\n    _setGhoBorrowRateViaConfigurator(1); // Change Gho borrow rate to not exceed max\n    uint32 ghoBorrowRate = _getGhoBorrowRate();\n    vm.startPrank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      ghoBorrowRate,\n      newVariableRateSlope1,\n      newVariableRateSlope1 // variableRateSlope2 has to be gte variableRateSlope1\n    );\n    newVariableRateSlope1 += 1; // Set higher than max allowed\n    vm.warp(block.timestamp + GHO_AAVE_STEWARD.MINIMUM_DELAY() + 1);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      ghoBorrowRate,\n      newVariableRateSlope1,\n      newVariableRateSlope1\n    );\n    vm.warp(block.timestamp + GHO_AAVE_STEWARD.MINIMUM_DELAY() + 1);\n    vm.expectRevert('INVALID_VARIABLE_RATE_SLOPE1');\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      ghoBorrowRate,\n      newVariableRateSlope1 - defaultBorrowRateConfig.variableRateSlope1MaxChange - 1,\n      newVariableRateSlope1\n    );\n    vm.stopPrank();\n  }\n\n  function testUpdateGhoBorrowRateVariableRateSlope2() public {\n    uint32 oldVariableRateSlope2 = _getVariableRateSlope2();\n    uint32 newVariableRateSlope2 = oldVariableRateSlope2 + 1;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      defaultRateParams.baseVariableBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      newVariableRateSlope2\n    );\n    uint32 currentVariableRateSlope2 = _getVariableRateSlope2();\n    assertEq(currentVariableRateSlope2, newVariableRateSlope2);\n  }\n\n  function testRevertUpdateGhoBorrowRateVariableRateSlope2IfMaxExceededUpwards() public {\n    uint32 oldVariableRateSlope2 = _getVariableRateSlope2();\n    uint32 newVariableRateSlope2 = oldVariableRateSlope2 +\n      defaultBorrowRateConfig.variableRateSlope2MaxChange +\n      1;\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_VARIABLE_RATE_SLOPE2');\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      defaultRateParams.baseVariableBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      newVariableRateSlope2\n    );\n  }\n\n  function testRevertUpdateGhoBorrowRateVariableRateSlope2IfMaxExceededDownwards() public {\n    uint32 oldVariableRateSlope2 = _getVariableRateSlope2();\n    uint32 newVariableRateSlope2 = oldVariableRateSlope2 +\n      defaultBorrowRateConfig.variableRateSlope2MaxChange;\n    _setGhoBorrowRateViaConfigurator(1);\n    uint32 ghoBorrowRate = _getGhoBorrowRate();\n    vm.startPrank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      ghoBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      newVariableRateSlope2\n    );\n    newVariableRateSlope2 += 1; // Set higher than max allowed\n    vm.warp(block.timestamp + GHO_AAVE_STEWARD.MINIMUM_DELAY() + 1);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      ghoBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      newVariableRateSlope2\n    );\n    vm.warp(block.timestamp + GHO_AAVE_STEWARD.MINIMUM_DELAY() + 1);\n    vm.expectRevert('INVALID_VARIABLE_RATE_SLOPE2');\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      ghoBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      newVariableRateSlope2 - defaultBorrowRateConfig.variableRateSlope2MaxChange - 1\n    );\n    vm.stopPrank();\n  }\n\n  function testRevertUpdateGhoBorrowRateIfUnauthorized() public {\n    vm.expectRevert('INVALID_CALLER');\n    vm.prank(ALICE);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      0.07e4,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n  }\n\n  function testRevertUpdateGhoBorrowRateIfUpdatedTooSoon() public {\n    uint32 oldBorrowRate = _getGhoBorrowRate();\n    vm.prank(RISK_COUNCIL);\n    uint32 newBorrowRate = oldBorrowRate + 1;\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      newBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('DEBOUNCE_NOT_RESPECTED');\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      newBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n  }\n\n  function testRevertUpdateGhoBorrowRateNoChange() public {\n    uint32 oldBorrowRate = _getGhoBorrowRate();\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('NO_CHANGE_IN_RATES');\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      oldBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n  }\n\n  function testRevertUpdateGhoBorrowRateIfMaxExceededUpwards() public {\n    uint32 oldBorrowRate = _getGhoBorrowRate();\n    uint32 newBorrowRate = oldBorrowRate + GHO_BORROW_RATE_CHANGE_MAX + 1;\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_BORROW_RATE_UPDATE');\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      newBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n  }\n\n  function testRevertUpdateGhoBorrowRateIfMaxExceededDownwards() public {\n    vm.startPrank(RISK_COUNCIL);\n\n    // set a high borrow rate\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      _getGhoBorrowRate() + GHO_BORROW_RATE_CHANGE_MAX,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n    vm.warp(block.timestamp + GHO_AAVE_STEWARD.MINIMUM_DELAY() + 1);\n\n    uint32 oldBorrowRate = _getGhoBorrowRate();\n    uint32 newBorrowRate = oldBorrowRate - GHO_BORROW_RATE_CHANGE_MAX - 1;\n    vm.expectRevert('INVALID_BORROW_RATE_UPDATE');\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      defaultRateParams.optimalUsageRatio,\n      newBorrowRate,\n      defaultRateParams.variableRateSlope1,\n      defaultRateParams.variableRateSlope2\n    );\n\n    vm.stopPrank();\n  }\n\n  function testSetRiskConfig() public {\n    defaultBorrowRateConfig.optimalUsageRatioMaxChange += 1;\n    vm.prank(SHORT_EXECUTOR);\n    GHO_AAVE_STEWARD.setBorrowRateConfig(\n      defaultBorrowRateConfig.optimalUsageRatioMaxChange,\n      defaultBorrowRateConfig.baseVariableBorrowRateMaxChange,\n      defaultBorrowRateConfig.variableRateSlope1MaxChange,\n      defaultBorrowRateConfig.variableRateSlope2MaxChange\n    );\n    IGhoAaveSteward.BorrowRateConfig memory currentBorrowRateConfig = GHO_AAVE_STEWARD\n      .getBorrowRateConfig();\n    assertEq(\n      currentBorrowRateConfig.optimalUsageRatioMaxChange,\n      defaultBorrowRateConfig.optimalUsageRatioMaxChange\n    );\n  }\n\n  function _setGhoBorrowCapViaConfigurator(uint256 newBorrowCap) internal {\n    CONFIGURATOR.setBorrowCap(address(GHO_TOKEN), newBorrowCap);\n  }\n\n  function _getGhoBorrowCap() internal view returns (uint256) {\n    DataTypes.ReserveConfigurationMap memory configuration = POOL.getConfiguration(\n      address(GHO_TOKEN)\n    );\n    return configuration.getBorrowCap();\n  }\n\n  function _setGhoSupplyCapViaConfigurator(uint256 newSupplyCap) internal {\n    CONFIGURATOR.setSupplyCap(address(GHO_TOKEN), newSupplyCap);\n  }\n\n  function _getGhoSupplyCap() internal view returns (uint256) {\n    DataTypes.ReserveConfigurationMap memory configuration = POOL.getConfiguration(\n      address(GHO_TOKEN)\n    );\n    return configuration.getSupplyCap();\n  }\n\n  function _setGhoBorrowRateViaConfigurator(uint32 newBorrowRate) internal {\n    IDefaultInterestRateStrategyV2.InterestRateData\n      memory rateParams = IDefaultInterestRateStrategyV2.InterestRateData({\n        optimalUsageRatio: 1_00,\n        baseVariableBorrowRate: newBorrowRate,\n        variableRateSlope1: 0,\n        variableRateSlope2: 0\n      });\n    CONFIGURATOR.setReserveInterestRateData(address(GHO_TOKEN), abi.encode(rateParams));\n    uint256 currentBorrowRate = _getGhoBorrowRate();\n    assertEq(currentBorrowRate, newBorrowRate);\n  }\n\n  function _getGhoBorrowRate() internal view returns (uint32) {\n    address currentInterestRateStrategy = POOL.getReserveInterestRateStrategyAddress(\n      address(GHO_TOKEN)\n    );\n    return\n      uint32(\n        IDefaultInterestRateStrategyV2(currentInterestRateStrategy).getBaseVariableBorrowRate(\n          address(GHO_TOKEN)\n        ) / 1e23\n      ); // Convert to bps\n  }\n\n  function _getOptimalUsageRatio() internal view returns (uint16) {\n    address currentInterestRateStrategy = POOL.getReserveInterestRateStrategyAddress(\n      address(GHO_TOKEN)\n    );\n    return\n      uint16(\n        IDefaultInterestRateStrategyV2(currentInterestRateStrategy).getOptimalUsageRatio(\n          address(GHO_TOKEN)\n        ) / 1e23\n      ); // Convert to bps\n  }\n\n  function _getVariableRateSlope1() internal view returns (uint32) {\n    address currentInterestRateStrategy = POOL.getReserveInterestRateStrategyAddress(\n      address(GHO_TOKEN)\n    );\n    return\n      uint32(\n        IDefaultInterestRateStrategyV2(currentInterestRateStrategy).getVariableRateSlope1(\n          address(GHO_TOKEN)\n        ) / 1e23\n      ); // Convert to bps\n  }\n\n  function _getVariableRateSlope2() internal view returns (uint32) {\n    address currentInterestRateStrategy = POOL.getReserveInterestRateStrategyAddress(\n      address(GHO_TOKEN)\n    );\n    return\n      uint32(\n        IDefaultInterestRateStrategyV2(currentInterestRateStrategy).getVariableRateSlope2(\n          address(GHO_TOKEN)\n        ) / 1e23\n      ); // Convert to bps\n  }\n}\n"
    },
    "src/test/TestGhoAToken.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGhoAToken is TestGhoBase {\n  function testConstructor() public {\n    GhoAToken aToken = new GhoAToken(IPool(address(POOL)));\n    assertEq(aToken.name(), 'GHO_ATOKEN_IMPL', 'Wrong default ERC20 name');\n    assertEq(aToken.symbol(), 'GHO_ATOKEN_IMPL', 'Wrong default ERC20 symbol');\n    assertEq(aToken.decimals(), 0, 'Wrong default ERC20 decimals');\n  }\n\n  function testInitialize() public {\n    GhoAToken aToken = new GhoAToken(IPool(address(POOL)));\n    string memory tokenName = 'Aave GHO';\n    string memory tokenSymbol = 'aGHO';\n    bytes memory empty;\n    aToken.initialize(\n      IPool(address(POOL)),\n      TREASURY,\n      address(GHO_TOKEN),\n      IAaveIncentivesController(address(0)),\n      18,\n      tokenName,\n      tokenSymbol,\n      empty\n    );\n\n    assertEq(aToken.name(), tokenName, 'Wrong initialized name');\n    assertEq(aToken.symbol(), tokenSymbol, 'Wrong initialized symbol');\n    assertEq(aToken.decimals(), 18, 'Wrong ERC20 decimals');\n  }\n\n  function testInitializePoolRevert() public {\n    string memory tokenName = 'Aave GHO';\n    string memory tokenSymbol = 'aGHO';\n    bytes memory empty;\n\n    GhoAToken aToken = new GhoAToken(IPool(address(POOL)));\n    vm.expectRevert(bytes(Errors.POOL_ADDRESSES_DO_NOT_MATCH));\n    aToken.initialize(\n      IPool(address(0)),\n      TREASURY,\n      address(GHO_TOKEN),\n      IAaveIncentivesController(address(0)),\n      18,\n      tokenName,\n      tokenSymbol,\n      empty\n    );\n  }\n\n  function testReInitRevert() public {\n    string memory tokenName = 'Aave GHO';\n    string memory tokenSymbol = 'aGHO';\n    bytes memory empty;\n\n    vm.expectRevert(bytes('Contract instance has already been initialized'));\n    GHO_ATOKEN.initialize(\n      IPool(address(POOL)),\n      TREASURY,\n      address(GHO_TOKEN),\n      IAaveIncentivesController(address(0)),\n      18,\n      tokenName,\n      tokenSymbol,\n      empty\n    );\n  }\n\n  function testUnderlying() public {\n    assertEq(\n      GHO_ATOKEN.UNDERLYING_ASSET_ADDRESS(),\n      address(GHO_TOKEN),\n      'Underlying should match token'\n    );\n  }\n\n  function testGetVariableDebtToken() public {\n    assertEq(\n      GHO_ATOKEN.getVariableDebtToken(),\n      address(GHO_DEBT_TOKEN),\n      'Variable debt token getter should match Gho Variable Debt Token'\n    );\n  }\n\n  function testUnauthorizedMint() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.CALLER_MUST_BE_POOL));\n    GHO_ATOKEN.mint(ALICE, ALICE, 0, 0);\n  }\n\n  function testUnauthorizedBurn() public {\n    vm.startPrank(ALICE);\n\n    vm.expectRevert(bytes(Errors.CALLER_MUST_BE_POOL));\n    GHO_ATOKEN.burn(ALICE, ALICE, 0, 0);\n  }\n\n  function testUnauthorizedSetVariableDebtToken() public {\n    GhoAToken aToken = new GhoAToken(IPool(address(POOL)));\n\n    vm.startPrank(ALICE);\n    ACL_MANAGER.setState(false);\n\n    vm.expectRevert(bytes(Errors.CALLER_NOT_POOL_ADMIN));\n    aToken.setVariableDebtToken(ALICE);\n  }\n\n  function testSetVariableDebtToken() public {\n    GhoAToken aToken = new GhoAToken(IPool(address(POOL)));\n\n    vm.expectEmit(true, true, true, true, address(aToken));\n    emit VariableDebtTokenSet(address(GHO_DEBT_TOKEN));\n\n    aToken.setVariableDebtToken(address(GHO_DEBT_TOKEN));\n  }\n\n  function testUpdateVariableDebtToken() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes('VARIABLE_DEBT_TOKEN_ALREADY_SET'));\n    GHO_ATOKEN.setVariableDebtToken(ALICE);\n  }\n\n  function testZeroVariableDebtToken() public {\n    GhoAToken aToken = new GhoAToken(IPool(address(POOL)));\n\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes('ZERO_ADDRESS_NOT_VALID'));\n    aToken.setVariableDebtToken(address(0));\n  }\n\n  function testMintRevert() public {\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    vm.prank(address(POOL));\n    GHO_ATOKEN.mint(CHARLES, CHARLES, 1, 1);\n  }\n\n  function testPermitRevert() public {\n    bytes32 empty;\n\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    vm.prank(address(POOL));\n    GHO_ATOKEN.permit(CHARLES, CHARLES, 1, 1, 1, empty, empty);\n  }\n\n  function testBurnRevert() public {\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    vm.prank(address(POOL));\n    GHO_ATOKEN.burn(CHARLES, CHARLES, 1, 1);\n  }\n\n  function testMintToTreasuryRevert() public {\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    vm.prank(address(POOL));\n    GHO_ATOKEN.mintToTreasury(1, 1);\n  }\n\n  function testTransferOnLiquidationRevert() public {\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    vm.prank(address(POOL));\n    GHO_ATOKEN.transferOnLiquidation(CHARLES, CHARLES, 1);\n  }\n\n  function testStandardTransferRevert() public {\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    vm.prank(CHARLES);\n    GHO_ATOKEN.transfer(ALICE, 0);\n  }\n\n  function testBalanceOfAlwaysZero() public {\n    uint256 balance = GHO_ATOKEN.balanceOf(CHARLES);\n    assertEq(balance, 0, 'AToken balance should always be zero');\n  }\n\n  function testTotalSupplyAlwaysZero() public {\n    uint256 supply = GHO_ATOKEN.totalSupply();\n    assertEq(supply, 0, 'AToken total supply should always be zero');\n  }\n\n  function testReserveTreasuryAddress() public {\n    assertEq(\n      GHO_ATOKEN.RESERVE_TREASURY_ADDRESS(),\n      TREASURY,\n      'AToken treasury address should match the initialized address'\n    );\n  }\n\n  function testDistributeFees() public {\n    borrowAction(CHARLES, 1000e18);\n    vm.warp(block.timestamp + 640000);\n\n    ghoFaucet(CHARLES, 5e18);\n\n    repayAction(CHARLES, GHO_DEBT_TOKEN.balanceOf(CHARLES));\n\n    vm.expectEmit(true, true, true, true, address(GHO_ATOKEN));\n    emit FeesDistributedToTreasury(\n      TREASURY,\n      address(GHO_TOKEN),\n      GHO_TOKEN.balanceOf(address(GHO_ATOKEN))\n    );\n    GHO_ATOKEN.distributeFeesToTreasury();\n  }\n\n  function testRescueToken() public {\n    vm.prank(FAUCET);\n    AAVE_TOKEN.mint(address(GHO_ATOKEN), 1);\n\n    GHO_ATOKEN.rescueTokens(address(AAVE_TOKEN), CHARLES, 1);\n\n    assertEq(AAVE_TOKEN.balanceOf(CHARLES), 1, 'Token rescue should transfer 1 wei');\n  }\n\n  function testRescueTokenRevertIfUnderlying() public {\n    vm.expectRevert(bytes(Errors.UNDERLYING_CANNOT_BE_RESCUED));\n    vm.prank(FAUCET);\n    GHO_ATOKEN.rescueTokens(address(GHO_TOKEN), CHARLES, 1);\n  }\n\n  function testUpdateGhoTreasuryRevertIfZero() public {\n    vm.expectRevert(bytes('ZERO_ADDRESS_NOT_VALID'));\n    GHO_ATOKEN.updateGhoTreasury(address(0));\n  }\n\n  function testUpdateGhoTreasury() public {\n    vm.expectEmit(true, true, true, true, address(GHO_ATOKEN));\n    emit GhoTreasuryUpdated(TREASURY, ALICE);\n    GHO_ATOKEN.updateGhoTreasury(ALICE);\n\n    assertEq(GHO_ATOKEN.getGhoTreasury(), ALICE);\n  }\n\n  function testUnauthorizedUpdateGhoTreasuryRevert() public {\n    ACL_MANAGER.setState(false);\n\n    vm.prank(ALICE);\n\n    vm.expectRevert(bytes(Errors.CALLER_NOT_POOL_ADMIN));\n    GHO_ATOKEN.updateGhoTreasury(ALICE);\n  }\n\n  function testDomainSeparator() public {\n    bytes32 EIP712_DOMAIN = keccak256(\n      'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n    );\n    bytes memory EIP712_REVISION = bytes('1');\n    bytes32 expected = keccak256(\n      abi.encode(\n        EIP712_DOMAIN,\n        keccak256(bytes(GHO_ATOKEN.name())),\n        keccak256(EIP712_REVISION),\n        block.chainid,\n        address(GHO_ATOKEN)\n      )\n    );\n    bytes32 result = GHO_ATOKEN.DOMAIN_SEPARATOR();\n    assertEq(result, expected, 'Unexpected domain separator');\n  }\n\n  function testNonces() public {\n    assertEq(GHO_ATOKEN.nonces(ALICE), 0, 'Unexpected non-zero nonce');\n    assertEq(GHO_ATOKEN.nonces(BOB), 0, 'Unexpected non-zero nonce');\n    assertEq(GHO_ATOKEN.nonces(CHARLES), 0, 'Unexpected non-zero nonce');\n  }\n}\n"
    },
    "src/test/TestGhoBase.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport 'forge-std/Test.sol';\nimport 'forge-std/console2.sol';\n\n// helpers\nimport {Constants} from './helpers/Constants.sol';\nimport {DebtUtils} from './helpers/DebtUtils.sol';\nimport {Events} from './helpers/Events.sol';\nimport {AccessControlErrorsLib, OwnableErrorsLib} from './helpers/ErrorsLib.sol';\n\n// generic libs\nimport {DataTypes} from '@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol';\nimport {Errors} from '@aave/core-v3/contracts/protocol/libraries/helpers/Errors.sol';\nimport {PercentageMath} from '@aave/core-v3/contracts/protocol/libraries/math/PercentageMath.sol';\nimport {SafeCast} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/SafeCast.sol';\nimport {WadRayMath} from '@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol';\n\n// mocks\nimport {MockAclManager} from './mocks/MockAclManager.sol';\nimport {MockConfigurator} from './mocks/MockConfigurator.sol';\nimport {MockFlashBorrower} from './mocks/MockFlashBorrower.sol';\nimport {MockGsmV2} from './mocks/MockGsmV2.sol';\nimport {MockPool} from './mocks/MockPool.sol';\nimport {MockAddressesProvider} from './mocks/MockAddressesProvider.sol';\nimport {MockERC4626} from './mocks/MockERC4626.sol';\nimport {MockUpgradeable} from './mocks/MockUpgradeable.sol';\nimport {PriceOracle} from '@aave/core-v3/contracts/mocks/oracle/PriceOracle.sol';\nimport {TestnetERC20} from '@aave/periphery-v3/contracts/mocks/testnet-helpers/TestnetERC20.sol';\nimport {WETH9Mock} from '@aave/periphery-v3/contracts/mocks/WETH9Mock.sol';\nimport {MockPoolDataProvider} from './mocks/MockPoolDataProvider.sol';\n\n// interfaces\nimport {IAaveIncentivesController} from '@aave/core-v3/contracts/interfaces/IAaveIncentivesController.sol';\nimport {IAToken} from '@aave/core-v3/contracts/interfaces/IAToken.sol';\nimport {IERC20} from 'aave-stk-v1-5/src/interfaces/IERC20.sol';\nimport {IERC3156FlashBorrower} from '@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol';\nimport {IERC3156FlashLender} from '@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol';\nimport {IERC4626} from '@openzeppelin/contracts/interfaces/IERC4626.sol';\nimport {IGhoToken} from '../contracts/gho/interfaces/IGhoToken.sol';\nimport {IGhoVariableDebtTokenTransferHook} from 'aave-stk-v1-5/src/interfaces/IGhoVariableDebtTokenTransferHook.sol';\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport {IPoolAddressesProvider} from '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\nimport {IStakedAaveV3} from 'aave-stk-v1-5/src/interfaces/IStakedAaveV3.sol';\n\n// non-GHO contracts\nimport {AdminUpgradeabilityProxy} from '@aave/core-v3/contracts/dependencies/openzeppelin/upgradeability/AdminUpgradeabilityProxy.sol';\nimport {ERC20} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/ERC20.sol';\nimport {StakedAaveV3} from 'aave-stk-v1-5/src/contracts/StakedAaveV3.sol';\nimport {ReserveConfiguration} from '@aave/core-v3/contracts/protocol/libraries/configuration/ReserveConfiguration.sol';\nimport {TransparentUpgradeableProxy} from 'solidity-utils/contracts/transparent-proxy/TransparentUpgradeableProxy.sol';\n\n// GHO contracts\nimport {GhoAToken} from '../contracts/facilitators/aave/tokens/GhoAToken.sol';\nimport {GhoDiscountRateStrategy} from '../contracts/facilitators/aave/interestStrategy/GhoDiscountRateStrategy.sol';\nimport {GhoFlashMinter} from '../contracts/facilitators/flashMinter/GhoFlashMinter.sol';\nimport {GhoInterestRateStrategy} from '../contracts/facilitators/aave/interestStrategy/GhoInterestRateStrategy.sol';\nimport {IGhoAaveSteward} from '../contracts/misc/interfaces/IGhoAaveSteward.sol';\nimport {GhoAaveSteward} from '../contracts/misc/GhoAaveSteward.sol';\nimport {GhoOracle} from '../contracts/facilitators/aave/oracle/GhoOracle.sol';\nimport {GhoStableDebtToken} from '../contracts/facilitators/aave/tokens/GhoStableDebtToken.sol';\nimport {GhoToken} from '../contracts/gho/GhoToken.sol';\nimport {UpgradeableGhoToken} from '../contracts/gho/UpgradeableGhoToken.sol';\nimport {GhoVariableDebtToken} from '../contracts/facilitators/aave/tokens/GhoVariableDebtToken.sol';\nimport {FixedRateStrategyFactory} from '../contracts/facilitators/aave/interestStrategy/FixedRateStrategyFactory.sol';\n\n// GSM contracts\nimport {IGsm} from '../contracts/facilitators/gsm/interfaces/IGsm.sol';\nimport {Gsm} from '../contracts/facilitators/gsm/Gsm.sol';\nimport {Gsm4626} from '../contracts/facilitators/gsm/Gsm4626.sol';\nimport {FixedPriceStrategy} from '../contracts/facilitators/gsm/priceStrategy/FixedPriceStrategy.sol';\nimport {FixedPriceStrategy4626} from '../contracts/facilitators/gsm/priceStrategy/FixedPriceStrategy4626.sol';\nimport {IGsmFeeStrategy} from '../contracts/facilitators/gsm/feeStrategy/interfaces/IGsmFeeStrategy.sol';\nimport {FixedFeeStrategy} from '../contracts/facilitators/gsm/feeStrategy/FixedFeeStrategy.sol';\nimport {SampleLiquidator} from '../contracts/facilitators/gsm/misc/SampleLiquidator.sol';\nimport {SampleSwapFreezer} from '../contracts/facilitators/gsm/misc/SampleSwapFreezer.sol';\nimport {GsmRegistry} from '../contracts/facilitators/gsm/misc/GsmRegistry.sol';\nimport {IGhoGsmSteward} from '../contracts/misc/interfaces/IGhoGsmSteward.sol';\nimport {GhoGsmSteward} from '../contracts/misc/GhoGsmSteward.sol';\nimport {FixedFeeStrategyFactory} from '../contracts/facilitators/gsm/feeStrategy/FixedFeeStrategyFactory.sol';\n\n// CCIP contracts\nimport {MockUpgradeableLockReleaseTokenPool} from './mocks/MockUpgradeableLockReleaseTokenPool.sol';\nimport {RateLimiter} from '../contracts/misc/dependencies/Ccip.sol';\nimport {IGhoCcipSteward} from '../contracts/misc/interfaces/IGhoCcipSteward.sol';\nimport {GhoCcipSteward} from '../contracts/misc/GhoCcipSteward.sol';\nimport {GhoBucketSteward} from '../contracts/misc/GhoBucketSteward.sol';\n\ncontract TestGhoBase is Test, Constants, Events {\n  using WadRayMath for uint256;\n  using SafeCast for uint256;\n  using PercentageMath for uint256;\n\n  // helper for state tracking\n  struct BorrowState {\n    uint256 supplyBeforeAction;\n    uint256 debtSupplyBeforeAction;\n    uint256 debtScaledSupplyBeforeAction;\n    uint256 balanceBeforeAction;\n    uint256 debtScaledBalanceBeforeAction;\n    uint256 debtBalanceBeforeAction;\n    uint256 userIndexBeforeAction;\n    uint256 userInterestsBeforeAction;\n    uint256 assetIndexBefore;\n    uint256 discountPercent;\n  }\n\n  GhoToken GHO_TOKEN;\n  TestnetERC20 AAVE_TOKEN;\n  IStakedAaveV3 STK_TOKEN;\n  TestnetERC20 USDC_TOKEN;\n  MockERC4626 USDC_4626_TOKEN;\n  MockPool POOL;\n  MockAclManager ACL_MANAGER;\n  MockAddressesProvider PROVIDER;\n  MockConfigurator CONFIGURATOR;\n  PriceOracle PRICE_ORACLE;\n  WETH9Mock WETH;\n  GhoVariableDebtToken GHO_DEBT_TOKEN;\n  GhoStableDebtToken GHO_STABLE_DEBT_TOKEN;\n  GhoAToken GHO_ATOKEN;\n  GhoFlashMinter GHO_FLASH_MINTER;\n  GhoDiscountRateStrategy GHO_DISCOUNT_STRATEGY;\n  MockFlashBorrower FLASH_BORROWER;\n  Gsm GHO_GSM;\n  Gsm4626 GHO_GSM_4626;\n  FixedPriceStrategy GHO_GSM_FIXED_PRICE_STRATEGY;\n  FixedPriceStrategy4626 GHO_GSM_4626_FIXED_PRICE_STRATEGY;\n  FixedFeeStrategy GHO_GSM_FIXED_FEE_STRATEGY;\n  SampleLiquidator GHO_GSM_LAST_RESORT_LIQUIDATOR;\n  SampleSwapFreezer GHO_GSM_SWAP_FREEZER;\n  GsmRegistry GHO_GSM_REGISTRY;\n  GhoOracle GHO_ORACLE;\n  GhoAaveSteward GHO_AAVE_STEWARD;\n  GhoCcipSteward GHO_CCIP_STEWARD;\n  GhoGsmSteward GHO_GSM_STEWARD;\n  GhoBucketSteward GHO_BUCKET_STEWARD;\n  MockPoolDataProvider MOCK_POOL_DATA_PROVIDER;\n\n  FixedRateStrategyFactory FIXED_RATE_STRATEGY_FACTORY;\n  FixedFeeStrategyFactory FIXED_FEE_STRATEGY_FACTORY;\n  MockUpgradeableLockReleaseTokenPool GHO_TOKEN_POOL;\n\n  constructor() {\n    setupGho();\n  }\n\n  function test_coverage_ignore() public virtual {\n    // Intentionally left blank.\n    // Excludes contract from coverage.\n  }\n\n  function setupGho() public {\n    bytes memory empty;\n    ACL_MANAGER = new MockAclManager();\n    PROVIDER = new MockAddressesProvider(address(ACL_MANAGER));\n    MOCK_POOL_DATA_PROVIDER = new MockPoolDataProvider(address(PROVIDER));\n    POOL = new MockPool(IPoolAddressesProvider(address(PROVIDER)));\n    CONFIGURATOR = new MockConfigurator(IPool(POOL));\n    PRICE_ORACLE = new PriceOracle();\n    PROVIDER.setPool(address(POOL));\n    PROVIDER.setConfigurator(address(CONFIGURATOR));\n    PROVIDER.setPriceOracle(address(PRICE_ORACLE));\n    GHO_ORACLE = new GhoOracle();\n    GHO_TOKEN = new GhoToken(address(this));\n    GHO_TOKEN.grantRole(GHO_TOKEN_FACILITATOR_MANAGER_ROLE, address(this));\n    GHO_TOKEN.grantRole(GHO_TOKEN_BUCKET_MANAGER_ROLE, address(this));\n    AAVE_TOKEN = new TestnetERC20('AAVE', 'AAVE', 18, FAUCET);\n    StakedAaveV3 stkAave = new StakedAaveV3(\n      IERC20(address(AAVE_TOKEN)),\n      IERC20(address(AAVE_TOKEN)),\n      1,\n      address(0),\n      address(0),\n      1\n    );\n    AdminUpgradeabilityProxy stkAaveProxy = new AdminUpgradeabilityProxy(\n      address(stkAave),\n      STKAAVE_PROXY_ADMIN,\n      ''\n    );\n    StakedAaveV3(address(stkAaveProxy)).initialize(\n      STKAAVE_PROXY_ADMIN,\n      STKAAVE_PROXY_ADMIN,\n      STKAAVE_PROXY_ADMIN,\n      0,\n      1\n    );\n    STK_TOKEN = IStakedAaveV3(address(stkAaveProxy));\n    USDC_TOKEN = new TestnetERC20('USD Coin', 'USDC', 6, FAUCET);\n    USDC_4626_TOKEN = new MockERC4626('USD Coin 4626', '4626', address(USDC_TOKEN));\n    IPool iPool = IPool(address(POOL));\n    WETH = new WETH9Mock('Wrapped Ether', 'WETH', FAUCET);\n    GHO_DEBT_TOKEN = new GhoVariableDebtToken(iPool);\n    GHO_STABLE_DEBT_TOKEN = new GhoStableDebtToken(iPool);\n    GHO_ATOKEN = new GhoAToken(iPool);\n    GHO_DEBT_TOKEN.initialize(\n      iPool,\n      address(GHO_TOKEN),\n      IAaveIncentivesController(address(0)),\n      18,\n      'Aave Variable Debt GHO',\n      'variableDebtGHO',\n      empty\n    );\n    GHO_STABLE_DEBT_TOKEN.initialize(\n      iPool,\n      address(GHO_TOKEN),\n      IAaveIncentivesController(address(0)),\n      18,\n      'Aave Stable Debt GHO',\n      'stableDebtGHO',\n      empty\n    );\n    GHO_ATOKEN.initialize(\n      iPool,\n      TREASURY,\n      address(GHO_TOKEN),\n      IAaveIncentivesController(address(0)),\n      18,\n      'Aave GHO',\n      'aGHO',\n      empty\n    );\n    GHO_ATOKEN.updateGhoTreasury(TREASURY);\n    GHO_DEBT_TOKEN.updateDiscountToken(address(STK_TOKEN));\n    GHO_DISCOUNT_STRATEGY = new GhoDiscountRateStrategy();\n    GHO_DEBT_TOKEN.updateDiscountRateStrategy(address(GHO_DISCOUNT_STRATEGY));\n    GHO_DEBT_TOKEN.setAToken(address(GHO_ATOKEN));\n    GHO_ATOKEN.setVariableDebtToken(address(GHO_DEBT_TOKEN));\n    vm.prank(SHORT_EXECUTOR);\n    STK_TOKEN.setGHODebtToken(IGhoVariableDebtTokenTransferHook(address(GHO_DEBT_TOKEN)));\n    GHO_TOKEN.addFacilitator(address(GHO_ATOKEN), 'Aave V3 Pool', DEFAULT_CAPACITY);\n    POOL.setGhoTokens(GHO_DEBT_TOKEN, GHO_ATOKEN);\n\n    GHO_FLASH_MINTER = new GhoFlashMinter(\n      address(GHO_TOKEN),\n      TREASURY,\n      DEFAULT_FLASH_FEE,\n      address(PROVIDER)\n    );\n    FLASH_BORROWER = new MockFlashBorrower(IERC3156FlashLender(GHO_FLASH_MINTER));\n\n    GHO_TOKEN.addFacilitator(\n      address(GHO_FLASH_MINTER),\n      'FlashMinter Facilitator',\n      DEFAULT_CAPACITY\n    );\n    GHO_TOKEN.addFacilitator(address(FLASH_BORROWER), 'Gho Flash Borrower', DEFAULT_CAPACITY);\n\n    GHO_GSM_FIXED_PRICE_STRATEGY = new FixedPriceStrategy(\n      DEFAULT_FIXED_PRICE,\n      address(USDC_TOKEN),\n      6\n    );\n    GHO_GSM_4626_FIXED_PRICE_STRATEGY = new FixedPriceStrategy4626(\n      DEFAULT_FIXED_PRICE,\n      address(USDC_4626_TOKEN),\n      6\n    );\n    GHO_GSM_LAST_RESORT_LIQUIDATOR = new SampleLiquidator();\n    GHO_GSM_SWAP_FREEZER = new SampleSwapFreezer();\n    Gsm gsm = new Gsm(\n      address(GHO_TOKEN),\n      address(USDC_TOKEN),\n      address(GHO_GSM_FIXED_PRICE_STRATEGY)\n    );\n    AdminUpgradeabilityProxy gsmProxy = new AdminUpgradeabilityProxy(\n      address(gsm),\n      SHORT_EXECUTOR,\n      ''\n    );\n    GHO_GSM = Gsm(address(gsmProxy));\n\n    GHO_GSM.initialize(address(this), TREASURY, DEFAULT_GSM_USDC_EXPOSURE);\n    GHO_GSM_4626 = new Gsm4626(\n      address(GHO_TOKEN),\n      address(USDC_4626_TOKEN),\n      address(GHO_GSM_4626_FIXED_PRICE_STRATEGY)\n    );\n    GHO_GSM_4626.initialize(address(this), TREASURY, DEFAULT_GSM_USDC_EXPOSURE);\n\n    GHO_GSM_FIXED_FEE_STRATEGY = new FixedFeeStrategy(DEFAULT_GSM_BUY_FEE, DEFAULT_GSM_SELL_FEE);\n    GHO_GSM.updateFeeStrategy(address(GHO_GSM_FIXED_FEE_STRATEGY));\n    GHO_GSM_4626.updateFeeStrategy(address(GHO_GSM_FIXED_FEE_STRATEGY));\n\n    GHO_GSM.grantRole(GSM_LIQUIDATOR_ROLE, address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    GHO_GSM.grantRole(GSM_SWAP_FREEZER_ROLE, address(GHO_GSM_SWAP_FREEZER));\n    GHO_GSM_4626.grantRole(GSM_LIQUIDATOR_ROLE, address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    GHO_GSM_4626.grantRole(GSM_SWAP_FREEZER_ROLE, address(GHO_GSM_SWAP_FREEZER));\n\n    GHO_TOKEN.addFacilitator(address(GHO_GSM), 'GSM Facilitator', DEFAULT_CAPACITY);\n    GHO_TOKEN.addFacilitator(address(GHO_GSM_4626), 'GSM 4626 Facilitator', DEFAULT_CAPACITY);\n\n    GHO_TOKEN.addFacilitator(FAUCET, 'Faucet Facilitator', type(uint128).max);\n\n    GHO_GSM_REGISTRY = new GsmRegistry(address(this));\n    FIXED_RATE_STRATEGY_FACTORY = new FixedRateStrategyFactory(address(PROVIDER));\n\n    // Deploy Gho Token Pool\n    address ARM_PROXY = makeAddr('ARM_PROXY');\n    address OWNER = makeAddr('OWNER');\n    address ROUTER = makeAddr('ROUTER');\n    address PROXY_ADMIN = makeAddr('PROXY_ADMIN');\n    uint256 INITIAL_BRIDGE_LIMIT = 100e6 * 1e18;\n    MockUpgradeableLockReleaseTokenPool tokenPoolImpl = new MockUpgradeableLockReleaseTokenPool(\n      address(GHO_TOKEN),\n      ARM_PROXY,\n      false,\n      true\n    );\n    // proxy deploy and init\n    address[] memory emptyArray = new address[](0);\n    bytes memory tokenPoolInitParams = abi.encodeWithSignature(\n      'initialize(address,address[],address,uint256)',\n      OWNER,\n      emptyArray,\n      ROUTER,\n      INITIAL_BRIDGE_LIMIT\n    );\n    TransparentUpgradeableProxy tokenPoolProxy = new TransparentUpgradeableProxy(\n      address(tokenPoolImpl),\n      PROXY_ADMIN,\n      tokenPoolInitParams\n    );\n\n    // Manage ownership\n    vm.prank(OWNER);\n    MockUpgradeableLockReleaseTokenPool(address(tokenPoolProxy)).acceptOwnership();\n    GHO_TOKEN_POOL = MockUpgradeableLockReleaseTokenPool(address(tokenPoolProxy));\n\n    // Setup GHO Token Pool\n    uint64 SOURCE_CHAIN_SELECTOR = 1;\n    uint64 DEST_CHAIN_SELECTOR = 2;\n    RateLimiter.Config memory initialOutboundRateLimit = RateLimiter.Config({\n      isEnabled: true,\n      capacity: 100e28,\n      rate: 1e15\n    });\n    RateLimiter.Config memory initialInboundRateLimit = RateLimiter.Config({\n      isEnabled: true,\n      capacity: 222e30,\n      rate: 1e18\n    });\n    MockUpgradeableLockReleaseTokenPool.ChainUpdate[]\n      memory chainUpdate = new MockUpgradeableLockReleaseTokenPool.ChainUpdate[](1);\n    chainUpdate[0] = MockUpgradeableLockReleaseTokenPool.ChainUpdate({\n      remoteChainSelector: DEST_CHAIN_SELECTOR,\n      allowed: true,\n      outboundRateLimiterConfig: initialOutboundRateLimit,\n      inboundRateLimiterConfig: initialInboundRateLimit\n    });\n    vm.prank(OWNER);\n    GHO_TOKEN_POOL.applyChainUpdates(chainUpdate);\n  }\n\n  function ghoFaucet(address to, uint256 amount) public {\n    vm.prank(FAUCET);\n    GHO_TOKEN.mint(to, amount);\n  }\n\n  function borrowAction(address user, uint256 amount) public {\n    borrowActionOnBehalf(user, user, amount);\n  }\n\n  function borrowActionOnBehalf(address caller, address onBehalfOf, uint256 amount) public {\n    BorrowState memory bs;\n    bs.supplyBeforeAction = GHO_TOKEN.totalSupply();\n    bs.debtSupplyBeforeAction = GHO_DEBT_TOKEN.totalSupply();\n    bs.debtScaledSupplyBeforeAction = GHO_DEBT_TOKEN.scaledTotalSupply();\n    bs.balanceBeforeAction = GHO_TOKEN.balanceOf(onBehalfOf);\n    bs.debtScaledBalanceBeforeAction = GHO_DEBT_TOKEN.scaledBalanceOf(onBehalfOf);\n    bs.debtBalanceBeforeAction = GHO_DEBT_TOKEN.balanceOf(onBehalfOf);\n    bs.userIndexBeforeAction = GHO_DEBT_TOKEN.getPreviousIndex(onBehalfOf);\n    bs.userInterestsBeforeAction = GHO_DEBT_TOKEN.getBalanceFromInterest(onBehalfOf);\n    bs.assetIndexBefore = POOL.getReserveNormalizedVariableDebt(address(GHO_TOKEN));\n    bs.discountPercent = GHO_DEBT_TOKEN.getDiscountPercent(onBehalfOf);\n\n    if (bs.userIndexBeforeAction == 0) {\n      bs.userIndexBeforeAction = 1e27;\n    }\n\n    (uint256 computedInterest, uint256 discountScaled, ) = DebtUtils.computeDebt(\n      bs.userIndexBeforeAction,\n      bs.assetIndexBefore,\n      bs.debtScaledBalanceBeforeAction,\n      bs.userInterestsBeforeAction,\n      bs.discountPercent\n    );\n    uint256 newDiscountRate = GHO_DISCOUNT_STRATEGY.calculateDiscountRate(\n      (bs.debtScaledBalanceBeforeAction - discountScaled).rayMul(bs.assetIndexBefore) + amount,\n      IERC20(address(STK_TOKEN)).balanceOf(onBehalfOf)\n    );\n\n    if (newDiscountRate != bs.discountPercent) {\n      vm.expectEmit(true, true, true, true, address(GHO_DEBT_TOKEN));\n      emit DiscountPercentUpdated(onBehalfOf, bs.discountPercent, newDiscountRate);\n    }\n\n    vm.expectEmit(true, true, true, true, address(GHO_DEBT_TOKEN));\n    emit Transfer(address(0), onBehalfOf, amount + computedInterest);\n    vm.expectEmit(true, true, true, true, address(GHO_DEBT_TOKEN));\n    emit Mint(caller, onBehalfOf, amount + computedInterest, computedInterest, bs.assetIndexBefore);\n\n    // Action\n    vm.prank(caller);\n    POOL.borrow(address(GHO_TOKEN), amount, 2, 0, onBehalfOf);\n\n    // Checks\n    assertEq(\n      GHO_TOKEN.balanceOf(onBehalfOf),\n      bs.balanceBeforeAction + amount,\n      'Gho amount does not match borrow'\n    );\n    assertEq(GHO_DEBT_TOKEN.getDiscountPercent(onBehalfOf), newDiscountRate);\n    assertEq(\n      GHO_TOKEN.totalSupply(),\n      bs.supplyBeforeAction + amount,\n      'Gho total supply does not match borrow'\n    );\n\n    assertEq(\n      GHO_DEBT_TOKEN.scaledBalanceOf(onBehalfOf),\n      bs.debtScaledBalanceBeforeAction + amount.rayDiv(bs.assetIndexBefore) - discountScaled,\n      'Gho debt token balance does not match borrow'\n    );\n    assertEq(\n      GHO_DEBT_TOKEN.scaledTotalSupply(),\n      bs.debtScaledSupplyBeforeAction + amount.rayDiv(bs.assetIndexBefore) - discountScaled,\n      'Gho debt token Supply does not match borrow'\n    );\n    assertEq(\n      GHO_DEBT_TOKEN.getBalanceFromInterest(onBehalfOf),\n      bs.userInterestsBeforeAction + computedInterest,\n      'Gho debt interests does not match borrow'\n    );\n  }\n\n  function repayAction(address user, uint256 amount) public {\n    BorrowState memory bs;\n    bs.supplyBeforeAction = GHO_TOKEN.totalSupply();\n    bs.debtSupplyBeforeAction = GHO_DEBT_TOKEN.totalSupply();\n    bs.debtScaledSupplyBeforeAction = GHO_DEBT_TOKEN.scaledTotalSupply();\n    bs.balanceBeforeAction = GHO_TOKEN.balanceOf(user);\n    bs.debtScaledBalanceBeforeAction = GHO_DEBT_TOKEN.scaledBalanceOf(user);\n    bs.debtBalanceBeforeAction = GHO_DEBT_TOKEN.balanceOf(user);\n    bs.userIndexBeforeAction = GHO_DEBT_TOKEN.getPreviousIndex(user);\n    bs.userInterestsBeforeAction = GHO_DEBT_TOKEN.getBalanceFromInterest(user);\n    bs.assetIndexBefore = POOL.getReserveNormalizedVariableDebt(address(GHO_TOKEN));\n    bs.discountPercent = GHO_DEBT_TOKEN.getDiscountPercent(user);\n    uint256 expectedDebt = 0;\n    uint256 expectedBurnOffset = 0;\n\n    if (bs.userIndexBeforeAction == 0) {\n      bs.userIndexBeforeAction = 1e27;\n    }\n\n    (uint256 computedInterest, uint256 discountScaled, ) = DebtUtils.computeDebt(\n      bs.userIndexBeforeAction,\n      bs.assetIndexBefore,\n      bs.debtScaledBalanceBeforeAction,\n      bs.userInterestsBeforeAction,\n      bs.discountPercent\n    );\n    uint256 newDiscountRate = GHO_DISCOUNT_STRATEGY.calculateDiscountRate(\n      (bs.debtScaledBalanceBeforeAction - discountScaled).rayMul(bs.assetIndexBefore) - amount,\n      IERC20(address(STK_TOKEN)).balanceOf(user)\n    );\n\n    if (amount <= (bs.userInterestsBeforeAction + computedInterest)) {\n      expectedDebt = bs.userInterestsBeforeAction + computedInterest - amount;\n    } else {\n      expectedBurnOffset = amount - bs.userInterestsBeforeAction + computedInterest;\n    }\n\n    // Action\n    vm.startPrank(user);\n    GHO_TOKEN.approve(address(POOL), amount);\n\n    if (newDiscountRate != bs.discountPercent) {\n      vm.expectEmit(true, true, true, true, address(GHO_DEBT_TOKEN));\n      emit DiscountPercentUpdated(user, bs.discountPercent, newDiscountRate);\n    }\n\n    if (computedInterest > amount) {\n      vm.expectEmit(true, true, true, true, address(GHO_DEBT_TOKEN));\n      emit Transfer(address(0), user, computedInterest - amount);\n    } else {\n      vm.expectEmit(true, true, true, true, address(GHO_DEBT_TOKEN));\n      emit Transfer(user, address(0), amount - computedInterest);\n    }\n\n    POOL.repay(address(GHO_TOKEN), amount, 2, user);\n    vm.stopPrank();\n\n    // Checks\n    assertEq(\n      GHO_TOKEN.balanceOf(user),\n      bs.balanceBeforeAction - amount,\n      'Gho amount does not match repay'\n    );\n    assertEq(GHO_DEBT_TOKEN.getDiscountPercent(user), newDiscountRate);\n    if (expectedBurnOffset != 0) {\n      assertEq(\n        GHO_TOKEN.totalSupply(),\n        bs.supplyBeforeAction - amount + computedInterest + bs.userInterestsBeforeAction,\n        'Gho total supply does not match repay b'\n      );\n    } else {\n      assertEq(\n        GHO_TOKEN.totalSupply(),\n        bs.supplyBeforeAction,\n        'Gho total supply does not match repay a'\n      );\n    }\n\n    assertEq(\n      GHO_DEBT_TOKEN.scaledBalanceOf(user),\n      bs.debtScaledBalanceBeforeAction - amount.rayDiv(bs.assetIndexBefore) - discountScaled,\n      'Gho debt token balance does not match repay'\n    );\n    assertEq(\n      GHO_DEBT_TOKEN.scaledTotalSupply(),\n      bs.debtScaledSupplyBeforeAction - amount.rayDiv(bs.assetIndexBefore) - discountScaled,\n      'Gho debt token Supply does not match repay'\n    );\n    assertEq(\n      GHO_DEBT_TOKEN.getBalanceFromInterest(user),\n      expectedDebt,\n      'Gho debt interests does not match repay'\n    );\n  }\n\n  function mintAndStakeDiscountToken(address user, uint256 amount) public {\n    vm.prank(FAUCET);\n    AAVE_TOKEN.mint(user, amount);\n\n    vm.startPrank(user);\n    AAVE_TOKEN.approve(address(STK_TOKEN), amount);\n    STK_TOKEN.stake(user, amount);\n    vm.stopPrank();\n  }\n\n  function rebalanceDiscountAction(address user) public {\n    BorrowState memory bs;\n    bs.supplyBeforeAction = GHO_TOKEN.totalSupply();\n    bs.debtSupplyBeforeAction = GHO_DEBT_TOKEN.totalSupply();\n    bs.debtScaledSupplyBeforeAction = GHO_DEBT_TOKEN.scaledTotalSupply();\n    bs.balanceBeforeAction = GHO_TOKEN.balanceOf(user);\n    bs.debtScaledBalanceBeforeAction = GHO_DEBT_TOKEN.scaledBalanceOf(user);\n    bs.debtBalanceBeforeAction = GHO_DEBT_TOKEN.balanceOf(user);\n    bs.userIndexBeforeAction = GHO_DEBT_TOKEN.getPreviousIndex(user);\n    bs.userInterestsBeforeAction = GHO_DEBT_TOKEN.getBalanceFromInterest(user);\n    bs.assetIndexBefore = POOL.getReserveNormalizedVariableDebt(address(GHO_TOKEN));\n    bs.discountPercent = GHO_DEBT_TOKEN.getDiscountPercent(user);\n\n    if (bs.userIndexBeforeAction == 0) {\n      bs.userIndexBeforeAction = 1e27;\n    }\n\n    (uint256 computedInterest, uint256 discountScaled, ) = DebtUtils.computeDebt(\n      bs.userIndexBeforeAction,\n      bs.assetIndexBefore,\n      bs.debtScaledBalanceBeforeAction,\n      bs.userInterestsBeforeAction,\n      bs.discountPercent\n    );\n    uint256 newDiscountRate = GHO_DISCOUNT_STRATEGY.calculateDiscountRate(\n      (bs.debtScaledBalanceBeforeAction - discountScaled).rayMul(bs.assetIndexBefore),\n      IERC20(address(STK_TOKEN)).balanceOf(user)\n    );\n\n    if (newDiscountRate != bs.discountPercent) {\n      vm.expectEmit(true, true, true, true, address(GHO_DEBT_TOKEN));\n      emit DiscountPercentUpdated(user, bs.discountPercent, newDiscountRate);\n    }\n\n    vm.expectEmit(true, true, true, true, address(GHO_DEBT_TOKEN));\n    emit Transfer(address(0), user, computedInterest);\n    vm.expectEmit(true, true, true, true, address(GHO_DEBT_TOKEN));\n    emit Mint(address(0), user, computedInterest, computedInterest, bs.assetIndexBefore);\n\n    // Action\n    vm.prank(user);\n    GHO_DEBT_TOKEN.rebalanceUserDiscountPercent(user);\n\n    // Checks\n    assertEq(\n      GHO_TOKEN.balanceOf(user),\n      bs.balanceBeforeAction,\n      'Gho amount does not match rebalance'\n    );\n    assertEq(GHO_DEBT_TOKEN.getDiscountPercent(user), newDiscountRate);\n    assertEq(\n      GHO_TOKEN.totalSupply(),\n      bs.supplyBeforeAction,\n      'Gho total supply does not match rebalance'\n    );\n\n    assertEq(\n      GHO_DEBT_TOKEN.scaledBalanceOf(user),\n      bs.debtScaledBalanceBeforeAction - discountScaled,\n      'Gho debt token balance does not match rebalance'\n    );\n    assertEq(\n      GHO_DEBT_TOKEN.scaledTotalSupply(),\n      bs.debtScaledSupplyBeforeAction - discountScaled,\n      'Gho debt token Supply does not match borrow'\n    );\n    assertEq(\n      GHO_DEBT_TOKEN.getBalanceFromInterest(user),\n      bs.userInterestsBeforeAction + computedInterest,\n      'Gho debt interests does not match borrow'\n    );\n  }\n\n  /// Helper function to sell asset in the GSM\n  function _sellAsset(\n    Gsm gsm,\n    TestnetERC20 token,\n    address receiver,\n    uint256 amount\n  ) internal returns (uint256) {\n    vm.startPrank(FAUCET);\n    token.mint(FAUCET, amount);\n    token.approve(address(gsm), amount);\n    (, uint256 ghoBought) = gsm.sellAsset(amount, receiver);\n    vm.stopPrank();\n    return ghoBought;\n  }\n\n  /// Helper function to mint an amount of assets of an ERC4626 token\n  function _mintVaultAssets(\n    MockERC4626 vault,\n    TestnetERC20 token,\n    address receiver,\n    uint256 amount\n  ) internal {\n    vm.startPrank(FAUCET);\n    token.mint(FAUCET, amount);\n    token.approve(address(vault), amount);\n    vault.deposit(amount, receiver);\n    vm.stopPrank();\n  }\n\n  /// Helper function to mint an amount of shares of an ERC4626 token\n  function _mintVaultShares(\n    MockERC4626 vault,\n    TestnetERC20 token,\n    address receiver,\n    uint256 sharesAmount\n  ) internal {\n    uint256 assets = vault.previewMint(sharesAmount);\n    vm.startPrank(FAUCET);\n    token.mint(FAUCET, assets);\n    token.approve(address(vault), assets);\n    vault.deposit(assets, receiver);\n    vm.stopPrank();\n  }\n\n  /// Helper function to sell shares of an ERC4626 token in the GSM\n  function _sellAsset(\n    Gsm4626 gsm,\n    MockERC4626 vault,\n    TestnetERC20 token,\n    address receiver,\n    uint256 amount\n  ) internal returns (uint256) {\n    uint256 assetsToMint = vault.previewRedeem(amount);\n    _mintVaultAssets(vault, token, address(this), assetsToMint);\n    vault.approve(address(gsm), amount);\n    (, uint256 ghoBought) = gsm.sellAsset(amount, receiver);\n    return ghoBought;\n  }\n\n  /// Helper function to alter the exchange rate between shares and assets in a ERC4626 vault\n  function _changeExchangeRate(\n    MockERC4626 vault,\n    TestnetERC20 token,\n    uint256 amount,\n    bool inflate\n  ) internal {\n    if (inflate) {\n      // Inflate\n      vm.prank(FAUCET);\n      token.mint(address(vault), amount);\n    } else {\n      // Deflate\n      vm.prank(address(vault));\n      token.transfer(address(1), amount);\n    }\n  }\n\n  function _contains(address[] memory list, address item) internal pure returns (bool) {\n    for (uint256 i = 0; i < list.length; i++) {\n      if (list[i] == item) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function getProxyAdminAddress(address proxy) internal view returns (address) {\n    bytes32 adminSlot = vm.load(proxy, ERC1967_ADMIN_SLOT);\n    return address(uint160(uint256(adminSlot)));\n  }\n\n  function getProxyImplementationAddress(address proxy) internal view returns (address) {\n    bytes32 implSlot = vm.load(proxy, ERC1967_IMPLEMENTATION_SLOT);\n    return address(uint160(uint256(implSlot)));\n  }\n}\n"
    },
    "src/test/TestGhoBucketSteward.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGhoBucketSteward is TestGhoBase {\n  function setUp() public {\n    // Deploy Gho Bucket Steward\n    GHO_BUCKET_STEWARD = new GhoBucketSteward(SHORT_EXECUTOR, address(GHO_TOKEN), RISK_COUNCIL);\n    address[] memory controlledFacilitators = new address[](2);\n    controlledFacilitators[0] = address(GHO_ATOKEN);\n    controlledFacilitators[1] = address(GHO_GSM);\n    vm.prank(SHORT_EXECUTOR);\n    GHO_BUCKET_STEWARD.setControlledFacilitator(controlledFacilitators, true);\n\n    /// @dev Since block.timestamp starts at 0 this is a necessary condition (block.timestamp > `MINIMUM_DELAY`) for the timelocked contract methods to work.\n    vm.warp(GHO_BUCKET_STEWARD.MINIMUM_DELAY() + 1);\n\n    // Grant roles\n    GHO_TOKEN.grantRole(GHO_TOKEN_BUCKET_MANAGER_ROLE, address(GHO_BUCKET_STEWARD));\n  }\n\n  function testConstructor() public {\n    assertEq(GHO_BUCKET_STEWARD.owner(), SHORT_EXECUTOR);\n    assertEq(GHO_BUCKET_STEWARD.GHO_TOKEN(), address(GHO_TOKEN));\n    assertEq(GHO_BUCKET_STEWARD.RISK_COUNCIL(), RISK_COUNCIL);\n\n    address[] memory controlledFacilitators = GHO_BUCKET_STEWARD.getControlledFacilitators();\n    assertEq(controlledFacilitators.length, 2);\n\n    uint40 facilitatorTimelock = GHO_BUCKET_STEWARD.getFacilitatorBucketCapacityTimelock(\n      controlledFacilitators[0]\n    );\n    assertEq(facilitatorTimelock, 0);\n  }\n\n  function testRevertConstructorInvalidOwner() public {\n    vm.expectRevert('INVALID_OWNER');\n    new GhoBucketSteward(address(0), address(0x002), address(0x003));\n  }\n\n  function testRevertConstructorInvalidGhoToken() public {\n    vm.expectRevert('INVALID_GHO_TOKEN');\n    new GhoBucketSteward(address(0x001), address(0), address(0x003));\n  }\n\n  function testRevertConstructorInvalidRiskCouncil() public {\n    vm.expectRevert('INVALID_RISK_COUNCIL');\n    new GhoBucketSteward(address(0x001), address(0x002), address(0));\n  }\n\n  function testChangeOwnership() public {\n    address newOwner = makeAddr('newOwner');\n    assertEq(GHO_BUCKET_STEWARD.owner(), SHORT_EXECUTOR);\n    vm.prank(SHORT_EXECUTOR);\n    GHO_BUCKET_STEWARD.transferOwnership(newOwner);\n    assertEq(GHO_BUCKET_STEWARD.owner(), newOwner);\n  }\n\n  function testChangeOwnershipRevert() public {\n    vm.expectRevert('Ownable: new owner is the zero address');\n    vm.prank(SHORT_EXECUTOR);\n    GHO_BUCKET_STEWARD.transferOwnership(address(0));\n  }\n\n  function testUpdateFacilitatorBucketCapacity() public {\n    (uint256 currentBucketCapacity, ) = GHO_TOKEN.getFacilitatorBucket(address(GHO_ATOKEN));\n    vm.prank(RISK_COUNCIL);\n    uint128 newBucketCapacity = uint128(currentBucketCapacity) + 1;\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(address(GHO_ATOKEN), newBucketCapacity);\n    (uint256 capacity, ) = GHO_TOKEN.getFacilitatorBucket(address(GHO_ATOKEN));\n    assertEq(newBucketCapacity, capacity);\n  }\n\n  function testUpdateFacilitatorBucketCapacityMaxValue() public {\n    (uint256 currentBucketCapacity, ) = GHO_TOKEN.getFacilitatorBucket(address(GHO_ATOKEN));\n    uint128 newBucketCapacity = uint128(currentBucketCapacity * 2);\n    vm.prank(RISK_COUNCIL);\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(address(GHO_ATOKEN), newBucketCapacity);\n    (uint256 capacity, ) = GHO_TOKEN.getFacilitatorBucket(address(GHO_ATOKEN));\n    assertEq(capacity, newBucketCapacity);\n  }\n\n  function testUpdateFacilitatorBucketCapacityTimelock() public {\n    (uint256 currentBucketCapacity, ) = GHO_TOKEN.getFacilitatorBucket(address(GHO_ATOKEN));\n    vm.prank(RISK_COUNCIL);\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(\n      address(GHO_ATOKEN),\n      uint128(currentBucketCapacity) + 1\n    );\n    uint40 timelock = GHO_BUCKET_STEWARD.getFacilitatorBucketCapacityTimelock(address(GHO_ATOKEN));\n    assertEq(timelock, block.timestamp);\n  }\n\n  function testUpdateFacilitatorBucketCapacityAfterTimelock() public {\n    (uint256 currentBucketCapacity, ) = GHO_TOKEN.getFacilitatorBucket(address(GHO_ATOKEN));\n    vm.prank(RISK_COUNCIL);\n    uint128 newBucketCapacity = uint128(currentBucketCapacity) + 1;\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(address(GHO_ATOKEN), newBucketCapacity);\n    skip(GHO_BUCKET_STEWARD.MINIMUM_DELAY() + 1);\n    uint128 newBucketCapacityAfterTimelock = newBucketCapacity + 1;\n    vm.prank(RISK_COUNCIL);\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(\n      address(GHO_ATOKEN),\n      newBucketCapacityAfterTimelock\n    );\n    (uint256 capacity, ) = GHO_TOKEN.getFacilitatorBucket(address(GHO_ATOKEN));\n    assertEq(capacity, newBucketCapacityAfterTimelock);\n  }\n\n  function testRevertUpdateFacilitatorBucketCapacityIfUnauthorized() public {\n    vm.expectRevert('INVALID_CALLER');\n    vm.prank(ALICE);\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(address(GHO_ATOKEN), 123);\n  }\n\n  function testRevertUpdateFacilitatorBucketCapacityIfUpdatedTooSoon() public {\n    (uint256 currentBucketCapacity, ) = GHO_TOKEN.getFacilitatorBucket(address(GHO_ATOKEN));\n    vm.prank(RISK_COUNCIL);\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(\n      address(GHO_ATOKEN),\n      uint128(currentBucketCapacity) + 1\n    );\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('DEBOUNCE_NOT_RESPECTED');\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(\n      address(GHO_ATOKEN),\n      uint128(currentBucketCapacity) + 2\n    );\n  }\n\n  function testRevertUpdateFacilitatorBucketCapacityNoChange() public {\n    (uint256 currentBucketCapacity, ) = GHO_TOKEN.getFacilitatorBucket(address(GHO_ATOKEN));\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('NO_CHANGE_IN_BUCKET_CAPACITY');\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(\n      address(GHO_ATOKEN),\n      uint128(currentBucketCapacity)\n    );\n  }\n\n  function testRevertUpdateFacilitatorBucketCapacityIfFacilitatorNotInControl() public {\n    (uint256 currentBucketCapacity, ) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('FACILITATOR_NOT_CONTROLLED');\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(\n      address(GHO_GSM_4626),\n      uint128(currentBucketCapacity) + 1\n    );\n  }\n\n  function testRevertUpdateFacilitatorBucketCapacityIfStewardLostBucketManagerRole() public {\n    (uint256 currentBucketCapacity, ) = GHO_TOKEN.getFacilitatorBucket(address(GHO_ATOKEN));\n    GHO_TOKEN.revokeRole(GHO_TOKEN_BUCKET_MANAGER_ROLE, address(GHO_BUCKET_STEWARD));\n    vm.expectRevert(\n      AccessControlErrorsLib.MISSING_ROLE(\n        GHO_TOKEN_BUCKET_MANAGER_ROLE,\n        address(GHO_BUCKET_STEWARD)\n      )\n    );\n    vm.prank(RISK_COUNCIL);\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(\n      address(GHO_ATOKEN),\n      uint128(currentBucketCapacity) + 1\n    );\n  }\n\n  function testRevertUpdateFacilitatorBucketCapacityIfMoreThanDouble() public {\n    (uint256 currentBucketCapacity, ) = GHO_TOKEN.getFacilitatorBucket(address(GHO_ATOKEN));\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_BUCKET_CAPACITY_UPDATE');\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(\n      address(GHO_ATOKEN),\n      uint128(currentBucketCapacity * 2) + 1\n    );\n  }\n\n  function testRevertUpdateFacilitatorBucketCapacityDecrement() public {\n    (uint256 currentBucketCapacity, ) = GHO_TOKEN.getFacilitatorBucket(address(GHO_ATOKEN));\n    vm.prank(RISK_COUNCIL);\n    uint128 newBucketCapacity = uint128(currentBucketCapacity) - 1;\n    vm.expectRevert('INVALID_BUCKET_CAPACITY_UPDATE');\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(address(GHO_ATOKEN), newBucketCapacity);\n  }\n\n  function testSetControlledFacilitatorAdd() public {\n    address[] memory oldControlledFacilitators = GHO_BUCKET_STEWARD.getControlledFacilitators();\n    address[] memory newGsmList = new address[](1);\n    newGsmList[0] = address(GHO_GSM_4626);\n    vm.prank(SHORT_EXECUTOR);\n    GHO_BUCKET_STEWARD.setControlledFacilitator(newGsmList, true);\n    address[] memory newControlledFacilitators = GHO_BUCKET_STEWARD.getControlledFacilitators();\n    assertEq(newControlledFacilitators.length, oldControlledFacilitators.length + 1);\n    assertTrue(_contains(newControlledFacilitators, address(GHO_GSM_4626)));\n  }\n\n  function testSetControlledFacilitatorsRemove() public {\n    address[] memory oldControlledFacilitators = GHO_BUCKET_STEWARD.getControlledFacilitators();\n    address[] memory disableGsmList = new address[](1);\n    disableGsmList[0] = address(GHO_GSM);\n    vm.prank(SHORT_EXECUTOR);\n    GHO_BUCKET_STEWARD.setControlledFacilitator(disableGsmList, false);\n    address[] memory newControlledFacilitators = GHO_BUCKET_STEWARD.getControlledFacilitators();\n    assertEq(newControlledFacilitators.length, oldControlledFacilitators.length - 1);\n    assertFalse(_contains(newControlledFacilitators, address(GHO_GSM)));\n  }\n\n  function testRevertSetControlledFacilitatorIfUnauthorized() public {\n    vm.expectRevert(OwnableErrorsLib.CALLER_NOT_OWNER());\n    vm.prank(RISK_COUNCIL);\n    address[] memory newGsmList = new address[](1);\n    newGsmList[0] = address(GHO_GSM_4626);\n    GHO_BUCKET_STEWARD.setControlledFacilitator(newGsmList, true);\n  }\n\n  function testIsControlledFacilitator() public {\n    address facilitator = makeAddr('FACILITATOR');\n    address[] memory controlledFacilitators = new address[](1);\n    controlledFacilitators[0] = facilitator;\n    vm.prank(SHORT_EXECUTOR);\n    GHO_BUCKET_STEWARD.setControlledFacilitator(controlledFacilitators, true);\n    assertTrue(GHO_BUCKET_STEWARD.isControlledFacilitator(facilitator));\n    address nonFacilitator = makeAddr('NON_FACILITATOR');\n    assertFalse(GHO_BUCKET_STEWARD.isControlledFacilitator(nonFacilitator));\n  }\n}\n"
    },
    "src/test/TestGhoCcipSteward.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\nimport {RateLimiter} from '../contracts/misc/dependencies/Ccip.sol';\n\ncontract TestGhoCcipSteward is TestGhoBase {\n  RateLimiter.Config rateLimitConfig =\n    RateLimiter.Config({isEnabled: true, capacity: type(uint128).max, rate: 1e15});\n  uint64 remoteChainSelector = 2;\n\n  event ChainConfigured(\n    uint64 remoteChainSelector,\n    RateLimiter.Config outboundRateLimiterConfig,\n    RateLimiter.Config inboundRateLimiterConfig\n  );\n\n  function setUp() public {\n    // Deploy Gho CCIP Steward\n    GHO_CCIP_STEWARD = new GhoCcipSteward(\n      address(GHO_TOKEN),\n      address(GHO_TOKEN_POOL),\n      RISK_COUNCIL,\n      true\n    );\n\n    /// @dev Since block.timestamp starts at 0 this is a necessary condition (block.timestamp > `MINIMUM_DELAY`) for the timelocked contract methods to work.\n    vm.warp(GHO_CCIP_STEWARD.MINIMUM_DELAY() + 1);\n\n    // Grant accesses to the Steward\n    vm.startPrank(GHO_TOKEN_POOL.owner());\n    GHO_TOKEN_POOL.setRateLimitAdmin(address(GHO_CCIP_STEWARD));\n    GHO_TOKEN_POOL.setBridgeLimitAdmin(address(GHO_CCIP_STEWARD));\n    vm.stopPrank();\n  }\n\n  function testConstructor() public {\n    assertEq(GHO_CCIP_STEWARD.MINIMUM_DELAY(), MINIMUM_DELAY_V2);\n\n    assertEq(GHO_CCIP_STEWARD.GHO_TOKEN(), address(GHO_TOKEN));\n    assertEq(GHO_CCIP_STEWARD.GHO_TOKEN_POOL(), address(GHO_TOKEN_POOL));\n    assertEq(GHO_CCIP_STEWARD.RISK_COUNCIL(), RISK_COUNCIL);\n  }\n\n  function testRevertConstructorInvalidGhoToken() public {\n    vm.expectRevert('INVALID_GHO_TOKEN');\n    new GhoCcipSteward(address(0), address(0x002), address(0x003), true);\n  }\n\n  function testRevertConstructorInvalidGhoTokenPool() public {\n    vm.expectRevert('INVALID_GHO_TOKEN_POOL');\n    new GhoCcipSteward(address(0x001), address(0), address(0x003), true);\n  }\n\n  function testRevertConstructorInvalidRiskCouncil() public {\n    vm.expectRevert('INVALID_RISK_COUNCIL');\n    new GhoCcipSteward(address(0x001), address(0x002), address(0), true);\n  }\n\n  function testUpdateBridgeLimit() public {\n    uint256 oldBridgeLimit = GHO_TOKEN_POOL.getBridgeLimit();\n    uint256 newBridgeLimit = oldBridgeLimit + 1;\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateBridgeLimit(newBridgeLimit);\n    uint256 currentBridgeLimit = GHO_TOKEN_POOL.getBridgeLimit();\n    assertEq(currentBridgeLimit, newBridgeLimit);\n  }\n\n  function testRevertUpdateBridgeLimitIfUnauthorized() public {\n    uint256 oldBridgeLimit = GHO_TOKEN_POOL.getBridgeLimit();\n    uint256 newBridgeLimit = oldBridgeLimit + 1;\n    vm.prank(ALICE);\n    vm.expectRevert('INVALID_CALLER');\n    GHO_CCIP_STEWARD.updateBridgeLimit(newBridgeLimit);\n  }\n\n  function testRevertUpdateBridgeLimitIfUpdatedTooSoon() public {\n    uint256 oldBridgeLimit = GHO_TOKEN_POOL.getBridgeLimit();\n    uint256 newBridgeLimit = oldBridgeLimit + 1;\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateBridgeLimit(newBridgeLimit);\n    vm.expectRevert('DEBOUNCE_NOT_RESPECTED');\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateBridgeLimit(newBridgeLimit);\n  }\n\n  function testRevertUpdateBridgeLimitNoChange() public {\n    uint256 oldBridgeLimit = GHO_TOKEN_POOL.getBridgeLimit();\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('NO_CHANGE_IN_BRIDGE_LIMIT');\n    GHO_CCIP_STEWARD.updateBridgeLimit(oldBridgeLimit);\n  }\n\n  function testRevertUpdateBridgeLimitIfDisabled() public {\n    // Deploy new Gho CCIP Steward with bridge limit disabled\n    GHO_CCIP_STEWARD = new GhoCcipSteward(\n      address(GHO_TOKEN),\n      address(GHO_TOKEN_POOL),\n      RISK_COUNCIL,\n      false\n    );\n\n    /// @dev Since block.timestamp starts at 0 this is a necessary condition (block.timestamp > `MINIMUM_DELAY`) for the timelocked contract methods to work.\n    vm.warp(GHO_CCIP_STEWARD.MINIMUM_DELAY() + 1);\n\n    // Grant accesses to the Steward\n    vm.startPrank(GHO_TOKEN_POOL.owner());\n    GHO_TOKEN_POOL.setRateLimitAdmin(address(GHO_CCIP_STEWARD));\n    GHO_TOKEN_POOL.setBridgeLimitAdmin(address(GHO_CCIP_STEWARD));\n    vm.stopPrank();\n\n    uint256 oldBridgeLimit = GHO_TOKEN_POOL.getBridgeLimit();\n    uint256 newBridgeLimit = oldBridgeLimit + 1;\n    vm.expectRevert('BRIDGE_LIMIT_DISABLED');\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateBridgeLimit(newBridgeLimit);\n  }\n\n  function testUpdateBridgeLimitTooHigh() public {\n    uint256 oldBridgeLimit = GHO_TOKEN_POOL.getBridgeLimit();\n    uint256 newBridgeLimit = (oldBridgeLimit + 1) * 2;\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_BRIDGE_LIMIT_UPDATE');\n    GHO_CCIP_STEWARD.updateBridgeLimit(newBridgeLimit);\n  }\n\n  function testUpdateBridgeLimitFuzz(uint256 newBridgeLimit) public {\n    uint256 oldBridgeLimit = GHO_TOKEN_POOL.getBridgeLimit();\n    newBridgeLimit = bound(newBridgeLimit, 0, oldBridgeLimit * 2);\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateBridgeLimit(newBridgeLimit);\n    uint256 currentBridgeLimit = GHO_TOKEN_POOL.getBridgeLimit();\n    assertEq(currentBridgeLimit, newBridgeLimit);\n  }\n\n  function testUpdateRateLimit() public {\n    RateLimiter.TokenBucket memory outboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentOutboundRateLimiterState(remoteChainSelector);\n    RateLimiter.TokenBucket memory inboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    RateLimiter.Config memory newOutboundConfig = RateLimiter.Config({\n      isEnabled: true,\n      capacity: outboundConfig.capacity + 1,\n      rate: outboundConfig.rate + 1\n    });\n\n    RateLimiter.Config memory newInboundConfig = RateLimiter.Config({\n      isEnabled: true,\n      capacity: inboundConfig.capacity + 1,\n      rate: inboundConfig.rate + 1\n    });\n\n    vm.expectEmit(false, false, false, true);\n    emit ChainConfigured(remoteChainSelector, newOutboundConfig, newInboundConfig);\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      newOutboundConfig.isEnabled,\n      newOutboundConfig.capacity,\n      newOutboundConfig.rate,\n      newInboundConfig.isEnabled,\n      newInboundConfig.capacity,\n      newInboundConfig.rate\n    );\n  }\n\n  function testRevertUpdateRateLimitIfUnauthorized() public {\n    vm.prank(ALICE);\n    vm.expectRevert('INVALID_CALLER');\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      rateLimitConfig.isEnabled,\n      rateLimitConfig.capacity,\n      rateLimitConfig.rate,\n      rateLimitConfig.isEnabled,\n      rateLimitConfig.capacity,\n      rateLimitConfig.rate\n    );\n  }\n\n  function testRevertUpdateRateLimitIfUpdatedTooSoon() public {\n    RateLimiter.TokenBucket memory outboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentOutboundRateLimiterState(remoteChainSelector);\n    RateLimiter.TokenBucket memory inboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      outboundConfig.isEnabled,\n      outboundConfig.capacity + 1,\n      outboundConfig.rate,\n      inboundConfig.isEnabled,\n      inboundConfig.capacity,\n      inboundConfig.rate\n    );\n    vm.expectRevert('DEBOUNCE_NOT_RESPECTED');\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      outboundConfig.isEnabled,\n      outboundConfig.capacity + 2,\n      outboundConfig.rate,\n      inboundConfig.isEnabled,\n      inboundConfig.capacity,\n      inboundConfig.rate\n    );\n  }\n\n  function testRevertUpdateRateLimitNoChange() public {\n    RateLimiter.TokenBucket memory outboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentOutboundRateLimiterState(remoteChainSelector);\n    RateLimiter.TokenBucket memory inboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('NO_CHANGE_IN_RATE_LIMIT');\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      outboundConfig.isEnabled,\n      outboundConfig.capacity,\n      outboundConfig.rate,\n      inboundConfig.isEnabled,\n      inboundConfig.capacity,\n      inboundConfig.rate\n    );\n  }\n\n  function testRevertUpdateRateLimitToZero() public {\n    RateLimiter.Config memory invalidConfig = RateLimiter.Config({\n      isEnabled: true,\n      capacity: 0,\n      rate: 0\n    });\n\n    // reverts because capacity or rate cannot be set to 0 when rate limit is enabled\n    // this check is enforced on the token pool (see RateLimiter._validateTokenBucketConfig)\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert(\n      abi.encodeWithSelector(RateLimiter.InvalidRatelimitRate.selector, invalidConfig)\n    );\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      invalidConfig.isEnabled,\n      invalidConfig.capacity,\n      invalidConfig.rate,\n      invalidConfig.isEnabled,\n      invalidConfig.capacity,\n      invalidConfig.rate\n    );\n\n    invalidConfig.rate = 10;\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert(\n      abi.encodeWithSelector(RateLimiter.InvalidRatelimitRate.selector, invalidConfig)\n    );\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      invalidConfig.isEnabled,\n      invalidConfig.capacity,\n      invalidConfig.rate,\n      invalidConfig.isEnabled,\n      invalidConfig.capacity,\n      invalidConfig.rate\n    );\n  }\n\n  function testRevertUpdateRateLimitToZeroWhenDisabled() public {\n    RateLimiter.Config memory invalidConfig = RateLimiter.Config({\n      isEnabled: false,\n      capacity: 10,\n      rate: 0\n    });\n\n    // reverts because capacity and rate both have be set to 0 when rate limit is disabled\n    // this check is enforced on the token pool (see RateLimiter._validateTokenBucketConfig)\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert(\n      abi.encodeWithSelector(RateLimiter.DisabledNonZeroRateLimit.selector, invalidConfig)\n    );\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      invalidConfig.isEnabled,\n      invalidConfig.capacity,\n      invalidConfig.rate,\n      invalidConfig.isEnabled,\n      invalidConfig.capacity,\n      invalidConfig.rate\n    );\n  }\n\n  function testDisableRateLimit() public {\n    RateLimiter.TokenBucket memory outboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentOutboundRateLimiterState(remoteChainSelector);\n    RateLimiter.TokenBucket memory inboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    // assert both inbound & outbound rate limiters are enabled\n    assertTrue(outboundConfig.isEnabled);\n    assertGt(outboundConfig.capacity, 0);\n    assertGt(outboundConfig.rate, 0);\n\n    assertTrue(inboundConfig.isEnabled);\n    assertGt(inboundConfig.capacity, 0);\n    assertGt(inboundConfig.rate, 0);\n\n    // capacity and rate both have be set to 0 when rate limit is disabled, enforced by token pool\n    RateLimiter.Config memory disableLimitConfig = RateLimiter.Config({\n      isEnabled: false,\n      capacity: 0,\n      rate: 0\n    });\n\n    // disable both inbound & outbound config\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      disableLimitConfig.isEnabled,\n      disableLimitConfig.capacity,\n      disableLimitConfig.rate,\n      disableLimitConfig.isEnabled,\n      disableLimitConfig.capacity,\n      disableLimitConfig.rate\n    );\n\n    outboundConfig = MockUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL)\n      .getCurrentOutboundRateLimiterState(remoteChainSelector);\n    inboundConfig = MockUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL)\n      .getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    assertFalse(outboundConfig.isEnabled);\n    assertEq(outboundConfig.capacity, 0);\n    assertEq(outboundConfig.rate, 0);\n\n    assertFalse(inboundConfig.isEnabled);\n    assertEq(inboundConfig.capacity, 0);\n    assertEq(inboundConfig.rate, 0);\n  }\n\n  function testChangeEnabledRateLimit() public {\n    RateLimiter.TokenBucket memory outboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentOutboundRateLimiterState(remoteChainSelector);\n    RateLimiter.TokenBucket memory inboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    RateLimiter.Config memory disableLimitConfig = RateLimiter.Config({\n      isEnabled: false,\n      capacity: 0,\n      rate: 0\n    });\n\n    // disable both inbound & outbound config\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      disableLimitConfig.isEnabled,\n      disableLimitConfig.capacity,\n      disableLimitConfig.rate,\n      disableLimitConfig.isEnabled,\n      disableLimitConfig.capacity,\n      disableLimitConfig.rate\n    );\n\n    skip(GHO_CCIP_STEWARD.MINIMUM_DELAY() + 1);\n\n    // steward is not allowed to re-enable rate limit\n    vm.expectRevert('INVALID_RATE_LIMIT_UPDATE');\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      outboundConfig.isEnabled,\n      outboundConfig.capacity,\n      outboundConfig.rate,\n      inboundConfig.isEnabled,\n      inboundConfig.capacity,\n      inboundConfig.rate\n    );\n\n    // risk admin/DAO can re-enable rate limit on token pool\n    vm.prank(GHO_TOKEN_POOL.owner());\n    GHO_TOKEN_POOL.setChainRateLimiterConfig(\n      remoteChainSelector,\n      _castTokenBucketToConfig(outboundConfig),\n      _castTokenBucketToConfig(inboundConfig)\n    );\n\n    RateLimiter.TokenBucket memory outboundConfigNew = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentOutboundRateLimiterState(remoteChainSelector);\n    RateLimiter.TokenBucket memory inboundConfigNew = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    assertTrue(outboundConfigNew.isEnabled);\n    assertEq(outboundConfigNew.capacity, outboundConfig.capacity);\n    assertEq(outboundConfigNew.rate, outboundConfig.rate);\n\n    assertTrue(inboundConfigNew.isEnabled);\n    assertEq(inboundConfigNew.capacity, inboundConfig.capacity);\n    assertEq(inboundConfigNew.rate, inboundConfig.rate);\n  }\n\n  function testChangeEnabledRateLimitOnlyOneSide() public {\n    RateLimiter.TokenBucket memory outboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentOutboundRateLimiterState(remoteChainSelector);\n    RateLimiter.TokenBucket memory inboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    assertTrue(outboundConfig.isEnabled);\n    assertGt(outboundConfig.capacity, 0);\n    assertGt(outboundConfig.rate, 0);\n\n    assertTrue(inboundConfig.isEnabled);\n    assertGt(inboundConfig.capacity, 0);\n    assertGt(inboundConfig.rate, 0);\n\n    RateLimiter.Config memory disableLimitConfig = RateLimiter.Config({\n      isEnabled: false,\n      capacity: 0,\n      rate: 0\n    });\n\n    // disable only outbound config\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      disableLimitConfig.isEnabled,\n      disableLimitConfig.capacity,\n      disableLimitConfig.rate,\n      // preserve inboundConfig\n      inboundConfig.isEnabled,\n      inboundConfig.capacity,\n      inboundConfig.rate\n    );\n\n    RateLimiter.TokenBucket memory outboundConfigNew = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentOutboundRateLimiterState(remoteChainSelector);\n    RateLimiter.TokenBucket memory inboundConfigNew = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    assertFalse(outboundConfigNew.isEnabled);\n    assertEq(outboundConfigNew.capacity, 0);\n    assertEq(outboundConfigNew.rate, 0);\n\n    assertTrue(inboundConfigNew.isEnabled);\n    assertEq(inboundConfigNew.capacity, inboundConfig.capacity);\n    assertEq(inboundConfigNew.rate, inboundConfig.rate);\n  }\n\n  function testRevertUpdateRateLimitRateGreaterThanCapacity() public {\n    RateLimiter.Config memory invalidConfig = RateLimiter.Config({\n      isEnabled: true,\n      capacity: 10,\n      rate: 100\n    });\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert();\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      invalidConfig.isEnabled,\n      invalidConfig.capacity,\n      invalidConfig.rate,\n      rateLimitConfig.isEnabled,\n      rateLimitConfig.capacity,\n      rateLimitConfig.rate\n    );\n  }\n\n  function testUpdateRateLimitFuzz(\n    uint128 outboundCapacity,\n    uint128 outboundRate,\n    uint128 inboundCapacity,\n    uint128 inboundRate\n  ) public {\n    RateLimiter.TokenBucket memory currentOutboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentOutboundRateLimiterState(remoteChainSelector);\n    RateLimiter.TokenBucket memory currentInboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    // Capacity must be strictly greater than rate and nothing can change more than 100%\n    outboundRate = uint128(bound(outboundRate, 1, currentOutboundConfig.rate * 2));\n    outboundCapacity = uint128(\n      bound(outboundCapacity, outboundRate + 1, currentOutboundConfig.capacity * 2)\n    );\n    inboundRate = uint128(bound(inboundRate, 1, currentInboundConfig.rate * 2));\n    inboundCapacity = uint128(\n      bound(inboundCapacity, inboundRate + 1, currentInboundConfig.capacity * 2)\n    );\n\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      rateLimitConfig.isEnabled,\n      outboundCapacity,\n      outboundRate,\n      rateLimitConfig.isEnabled,\n      inboundCapacity,\n      inboundRate\n    );\n  }\n\n  function _castTokenBucketToConfig(\n    RateLimiter.TokenBucket memory arg\n  ) private view returns (RateLimiter.Config memory) {\n    return RateLimiter.Config({isEnabled: arg.isEnabled, capacity: arg.capacity, rate: arg.rate});\n  }\n}\n"
    },
    "src/test/TestGhoDiscountRateStrategy.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGhoDiscountRateStrategy is TestGhoBase {\n  using WadRayMath for uint256;\n\n  uint256 maxDiscountBalance;\n\n  function setUp() public {\n    // Calculate actual maximum value for discountTokenBalance based on wadMul usage\n    maxDiscountBalance =\n      (UINT256_MAX / GHO_DISCOUNT_STRATEGY.GHO_DISCOUNTED_PER_DISCOUNT_TOKEN()) -\n      WadRayMath.HALF_WAD;\n  }\n\n  function testDebtBalanceBelowThreshold() public {\n    uint256 result = GHO_DISCOUNT_STRATEGY.calculateDiscountRate(\n      0,\n      GHO_DISCOUNT_STRATEGY.MIN_DISCOUNT_TOKEN_BALANCE()\n    );\n    assertEq(result, 0, 'Unexpected discount rate');\n  }\n\n  function testDiscountBalanceBelowThreshold() public {\n    uint256 result = GHO_DISCOUNT_STRATEGY.calculateDiscountRate(\n      GHO_DISCOUNT_STRATEGY.MIN_DEBT_TOKEN_BALANCE(),\n      0\n    );\n    assertEq(result, 0, 'Unexpected discount rate');\n  }\n\n  function testEqualDiscountedTokenThanDebtBalance() public {\n    assertGe(\n      GHO_DISCOUNT_STRATEGY.GHO_DISCOUNTED_PER_DISCOUNT_TOKEN(),\n      1e18,\n      'Unexpected low value for discount token conversion'\n    );\n\n    uint256 ratio = GHO_DISCOUNT_STRATEGY.MIN_DEBT_TOKEN_BALANCE() >\n      GHO_DISCOUNT_STRATEGY.MIN_DISCOUNT_TOKEN_BALANCE()\n      ? GHO_DISCOUNT_STRATEGY.MIN_DEBT_TOKEN_BALANCE().wadDiv(\n        GHO_DISCOUNT_STRATEGY.MIN_DISCOUNT_TOKEN_BALANCE()\n      )\n      : GHO_DISCOUNT_STRATEGY.MIN_DISCOUNT_TOKEN_BALANCE().wadDiv(\n        GHO_DISCOUNT_STRATEGY.MIN_DEBT_TOKEN_BALANCE()\n      );\n\n    uint256 minimumDiscountTokenBalance = (GHO_DISCOUNT_STRATEGY.MIN_DISCOUNT_TOKEN_BALANCE() *\n      ratio) / GHO_DISCOUNT_STRATEGY.GHO_DISCOUNTED_PER_DISCOUNT_TOKEN();\n\n    uint256 result = GHO_DISCOUNT_STRATEGY.calculateDiscountRate(\n      GHO_DISCOUNT_STRATEGY.MIN_DEBT_TOKEN_BALANCE(),\n      minimumDiscountTokenBalance\n    );\n    assertEq(result, GHO_DISCOUNT_STRATEGY.DISCOUNT_RATE(), 'Unexpected discount rate');\n  }\n\n  function testMoreDiscountedTokenThanDebtBalance() public {\n    assertGe(\n      GHO_DISCOUNT_STRATEGY.GHO_DISCOUNTED_PER_DISCOUNT_TOKEN(),\n      1e18,\n      'Unexpected low value for discount token conversion'\n    );\n\n    uint256 ratio = GHO_DISCOUNT_STRATEGY.MIN_DEBT_TOKEN_BALANCE() >\n      GHO_DISCOUNT_STRATEGY.MIN_DISCOUNT_TOKEN_BALANCE()\n      ? GHO_DISCOUNT_STRATEGY.MIN_DEBT_TOKEN_BALANCE().wadDiv(\n        GHO_DISCOUNT_STRATEGY.MIN_DISCOUNT_TOKEN_BALANCE()\n      )\n      : GHO_DISCOUNT_STRATEGY.MIN_DISCOUNT_TOKEN_BALANCE().wadDiv(\n        GHO_DISCOUNT_STRATEGY.MIN_DEBT_TOKEN_BALANCE()\n      );\n\n    uint256 minimumDiscountTokenBalance = (GHO_DISCOUNT_STRATEGY.MIN_DISCOUNT_TOKEN_BALANCE() *\n      ratio) / GHO_DISCOUNT_STRATEGY.GHO_DISCOUNTED_PER_DISCOUNT_TOKEN();\n\n    uint256 result = GHO_DISCOUNT_STRATEGY.calculateDiscountRate(\n      GHO_DISCOUNT_STRATEGY.MIN_DEBT_TOKEN_BALANCE(),\n      minimumDiscountTokenBalance + 1\n    );\n    assertEq(result, GHO_DISCOUNT_STRATEGY.DISCOUNT_RATE(), 'Unexpected discount rate');\n  }\n\n  function testFuzzMinBalance(uint256 debtBalance, uint256 discountTokenBalance) public {\n    vm.assume(\n      debtBalance < GHO_DISCOUNT_STRATEGY.MIN_DEBT_TOKEN_BALANCE() ||\n        discountTokenBalance < GHO_DISCOUNT_STRATEGY.MIN_DISCOUNT_TOKEN_BALANCE()\n    );\n    uint256 result = GHO_DISCOUNT_STRATEGY.calculateDiscountRate(debtBalance, discountTokenBalance);\n    assertEq(result, 0, 'Minimum balance not zero');\n  }\n\n  function testFuzzNeverExceedHundredDiscount(\n    uint256 debtBalance,\n    uint256 discountTokenBalance\n  ) public {\n    vm.assume(\n      (debtBalance >= GHO_DISCOUNT_STRATEGY.MIN_DEBT_TOKEN_BALANCE() ||\n        discountTokenBalance >= GHO_DISCOUNT_STRATEGY.MIN_DISCOUNT_TOKEN_BALANCE()) &&\n        discountTokenBalance < maxDiscountBalance\n    );\n    uint256 result = GHO_DISCOUNT_STRATEGY.calculateDiscountRate(debtBalance, discountTokenBalance);\n    assertLe(result, 10000, 'Discount rate higher than 100%');\n  }\n\n  function testFuzzNeverExceedDiscountRate(\n    uint256 debtBalance,\n    uint256 discountTokenBalance\n  ) public {\n    vm.assume(\n      (debtBalance >= GHO_DISCOUNT_STRATEGY.MIN_DEBT_TOKEN_BALANCE() ||\n        discountTokenBalance >= GHO_DISCOUNT_STRATEGY.MIN_DISCOUNT_TOKEN_BALANCE()) &&\n        discountTokenBalance < maxDiscountBalance\n    );\n    uint256 result = GHO_DISCOUNT_STRATEGY.calculateDiscountRate(debtBalance, discountTokenBalance);\n    assertLe(result, GHO_DISCOUNT_STRATEGY.DISCOUNT_RATE(), 'Discount rate higher than 100%');\n  }\n}\n"
    },
    "src/test/TestGhoFlashMinter.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGhoFlashMinter is TestGhoBase {\n  function testConstructor() public {\n    vm.expectEmit(true, true, false, false);\n    emit GhoTreasuryUpdated(address(0), TREASURY);\n    vm.expectEmit(false, false, false, true);\n    emit FeeUpdated(0, DEFAULT_FLASH_FEE);\n    GhoFlashMinter flashMinter = new GhoFlashMinter(\n      address(GHO_TOKEN),\n      TREASURY,\n      DEFAULT_FLASH_FEE,\n      address(PROVIDER)\n    );\n    assertEq(address(flashMinter.GHO_TOKEN()), address(GHO_TOKEN), 'Wrong GHO token address');\n    assertEq(flashMinter.getFee(), DEFAULT_FLASH_FEE, 'Wrong fee');\n    assertEq(flashMinter.getGhoTreasury(), TREASURY, 'Wrong TREASURY address');\n    assertEq(\n      address(flashMinter.ADDRESSES_PROVIDER()),\n      address(PROVIDER),\n      'Wrong addresses provider address'\n    );\n  }\n\n  function testRevertConstructorFeeOutOfRange() public {\n    vm.expectRevert('FlashMinter: Fee out of range');\n    new GhoFlashMinter(address(GHO_TOKEN), TREASURY, 10001, address(PROVIDER));\n  }\n\n  function testRevertFlashloanNonRecipient() public {\n    vm.expectRevert();\n    GHO_FLASH_MINTER.flashLoan(\n      IERC3156FlashBorrower(address(this)),\n      address(GHO_TOKEN),\n      DEFAULT_BORROW_AMOUNT,\n      ''\n    );\n  }\n\n  function testRevertFlashloanWrongToken() public {\n    vm.expectRevert('FlashMinter: Unsupported currency');\n    GHO_FLASH_MINTER.flashLoan(\n      IERC3156FlashBorrower(address(FLASH_BORROWER)),\n      address(0),\n      DEFAULT_BORROW_AMOUNT,\n      ''\n    );\n  }\n\n  function testRevertFlashloanMoreThanCapacity() public {\n    vm.expectRevert('FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    GHO_FLASH_MINTER.flashLoan(\n      IERC3156FlashBorrower(address(FLASH_BORROWER)),\n      address(GHO_TOKEN),\n      DEFAULT_CAPACITY + 1,\n      ''\n    );\n  }\n\n  function testRevertFlashloanInsufficientReturned() public {\n    ACL_MANAGER.setState(false);\n    assertEq(\n      ACL_MANAGER.isFlashBorrower(address(FLASH_BORROWER)),\n      false,\n      'Flash borrower should not be a whitelisted borrower'\n    );\n    vm.expectRevert(stdError.arithmeticError);\n    FLASH_BORROWER.flashBorrow(address(GHO_TOKEN), DEFAULT_BORROW_AMOUNT);\n  }\n\n  function testRevertFlashloanWrongCallback() public {\n    FLASH_BORROWER.setAllowCallback(false);\n    vm.expectRevert('FlashMinter: Callback failed');\n    FLASH_BORROWER.flashBorrow(address(GHO_TOKEN), DEFAULT_BORROW_AMOUNT);\n  }\n\n  function testRevertUpdateFeeNotPoolAdmin() public {\n    ACL_MANAGER.setState(false);\n    assertEq(\n      ACL_MANAGER.isPoolAdmin(address(GHO_FLASH_MINTER)),\n      false,\n      'GhoFlashMinter should not be a pool admin'\n    );\n\n    vm.expectRevert('CALLER_NOT_POOL_ADMIN');\n    GHO_FLASH_MINTER.updateFee(100);\n  }\n\n  function testRevertUpdateFeeOutOfRange() public {\n    vm.expectRevert('FlashMinter: Fee out of range');\n    GHO_FLASH_MINTER.updateFee(10001);\n  }\n\n  function testRevertUpdateTreasuryNotPoolAdmin() public {\n    ACL_MANAGER.setState(false);\n    assertEq(\n      ACL_MANAGER.isPoolAdmin(address(GHO_FLASH_MINTER)),\n      false,\n      'GhoFlashMinter should not be a pool admin'\n    );\n\n    vm.expectRevert('CALLER_NOT_POOL_ADMIN');\n    GHO_FLASH_MINTER.updateGhoTreasury(address(0));\n  }\n\n  function testRevertFlashfeeNotGho() public {\n    vm.expectRevert('FlashMinter: Unsupported currency');\n    GHO_FLASH_MINTER.flashFee(address(0), DEFAULT_BORROW_AMOUNT);\n  }\n\n  // Positives\n\n  function testFlashloan() public {\n    ACL_MANAGER.setState(false);\n    assertEq(\n      ACL_MANAGER.isFlashBorrower(address(FLASH_BORROWER)),\n      false,\n      'Flash borrower should not be a whitelisted borrower'\n    );\n\n    uint256 feeAmount = (DEFAULT_FLASH_FEE * DEFAULT_BORROW_AMOUNT) / 100e2;\n    ghoFaucet(address(FLASH_BORROWER), feeAmount);\n\n    vm.expectEmit(true, true, true, true, address(GHO_FLASH_MINTER));\n    emit FlashMint(\n      address(FLASH_BORROWER),\n      address(FLASH_BORROWER),\n      address(GHO_TOKEN),\n      DEFAULT_BORROW_AMOUNT,\n      feeAmount\n    );\n    FLASH_BORROWER.flashBorrow(address(GHO_TOKEN), DEFAULT_BORROW_AMOUNT);\n  }\n\n  function testDistributeFeesToTreasury() public {\n    uint256 treasuryBalanceBefore = GHO_TOKEN.balanceOf(TREASURY);\n\n    ghoFaucet(address(GHO_FLASH_MINTER), 100e18);\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_FLASH_MINTER)),\n      100e18,\n      'GhoFlashMinter should have 100 GHO'\n    );\n\n    vm.expectEmit(true, true, false, true, address(GHO_FLASH_MINTER));\n    emit FeesDistributedToTreasury(TREASURY, address(GHO_TOKEN), 100e18);\n    GHO_FLASH_MINTER.distributeFeesToTreasury();\n\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_FLASH_MINTER)),\n      0,\n      'GhoFlashMinter should have no GHO left after fee distribution'\n    );\n    assertEq(\n      GHO_TOKEN.balanceOf(TREASURY),\n      treasuryBalanceBefore + 100e18,\n      'Treasury should have 100 more GHO'\n    );\n  }\n\n  function testUpdateFee() public {\n    assertEq(GHO_FLASH_MINTER.getFee(), DEFAULT_FLASH_FEE, 'Flashminter non-default fee');\n    assertTrue(DEFAULT_FLASH_FEE != 100);\n    vm.expectEmit(false, false, false, true, address(GHO_FLASH_MINTER));\n    emit FeeUpdated(DEFAULT_FLASH_FEE, 100);\n    GHO_FLASH_MINTER.updateFee(100);\n  }\n\n  function testUpdateGhoTreasury() public {\n    assertEq(GHO_FLASH_MINTER.getGhoTreasury(), TREASURY, 'Flashminter non-default TREASURY');\n    assertTrue(TREASURY != address(this));\n    vm.expectEmit(true, true, false, false, address(GHO_FLASH_MINTER));\n    emit GhoTreasuryUpdated(TREASURY, address(this));\n    GHO_FLASH_MINTER.updateGhoTreasury(address(this));\n  }\n\n  function testMaxFlashloanNotGho() public {\n    assertEq(\n      GHO_FLASH_MINTER.maxFlashLoan(address(0)),\n      0,\n      'Max flash loan should be 0 for non-GHO token'\n    );\n  }\n\n  function testMaxFlashloanGho() public {\n    assertEq(\n      GHO_FLASH_MINTER.maxFlashLoan(address(GHO_TOKEN)),\n      DEFAULT_CAPACITY,\n      'Max flash loan should be DEFAULT_CAPACITY for GHO token'\n    );\n  }\n\n  function testWhitelistedFlashFee() public {\n    assertEq(\n      GHO_FLASH_MINTER.flashFee(address(GHO_TOKEN), DEFAULT_BORROW_AMOUNT),\n      0,\n      'Flash fee should be 0 for whitelisted borrowers'\n    );\n  }\n\n  function testNotWhitelistedFlashFee() public {\n    ACL_MANAGER.setState(false);\n    assertEq(\n      ACL_MANAGER.isFlashBorrower(address(this)),\n      false,\n      'Flash borrower should not be a whitelisted borrower'\n    );\n    uint256 fee = GHO_FLASH_MINTER.flashFee(address(GHO_TOKEN), DEFAULT_BORROW_AMOUNT);\n    uint256 expectedFee = (DEFAULT_FLASH_FEE * DEFAULT_BORROW_AMOUNT) / 100e2;\n    assertEq(fee, expectedFee, 'Flash fee should be correct');\n  }\n\n  // Fuzzing\n  function testFuzzFlashFee(uint256 feeToSet, uint256 amount) public {\n    vm.assume(feeToSet <= 10000);\n    vm.assume(amount <= DEFAULT_CAPACITY);\n    GHO_FLASH_MINTER.updateFee(feeToSet);\n    ACL_MANAGER.setState(false); // Set ACL manager to return false so there are no whitelisted borrowers.\n\n    uint256 fee = GHO_FLASH_MINTER.flashFee(address(GHO_TOKEN), amount);\n    uint256 expectedFee = (feeToSet * amount) / 100e2;\n\n    // We account for +/- 1 wei of rounding error.\n    assertTrue(\n      fee >= (expectedFee == 0 ? 0 : expectedFee - 1),\n      'Flash fee should be greater than or equal to expected fee - 1'\n    );\n    assertTrue(\n      fee <= expectedFee + 1,\n      'Flash fee should be less than or equal to expected fee + 1'\n    );\n  }\n}\n"
    },
    "src/test/TestGhoGsmSteward.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\nimport {IGhoGsmSteward} from '../contracts/misc/interfaces/IGhoGsmSteward.sol';\n\ncontract TestGhoGsmSteward is TestGhoBase {\n  function setUp() public {\n    // Deploy Gho GSM Steward\n    FIXED_FEE_STRATEGY_FACTORY = new FixedFeeStrategyFactory();\n    GHO_GSM_STEWARD = new GhoGsmSteward(address(FIXED_FEE_STRATEGY_FACTORY), RISK_COUNCIL);\n\n    /// @dev Since block.timestamp starts at 0 this is a necessary condition (block.timestamp > `MINIMUM_DELAY`) for the timelocked contract methods to work.\n    vm.warp(GHO_GSM_STEWARD.MINIMUM_DELAY() + 1);\n\n    // Grant required roles\n    GHO_GSM.grantRole(GSM_CONFIGURATOR_ROLE, address(GHO_GSM_STEWARD));\n  }\n\n  function testConstructor() public {\n    assertEq(GHO_GSM_STEWARD.GSM_FEE_RATE_CHANGE_MAX(), GSM_FEE_RATE_CHANGE_MAX);\n    assertEq(GHO_GSM_STEWARD.MINIMUM_DELAY(), MINIMUM_DELAY_V2);\n\n    assertEq(GHO_GSM_STEWARD.FIXED_FEE_STRATEGY_FACTORY(), address(FIXED_FEE_STRATEGY_FACTORY));\n    assertEq(GHO_GSM_STEWARD.RISK_COUNCIL(), RISK_COUNCIL);\n\n    address[] memory gsmFeeStrategies = FIXED_FEE_STRATEGY_FACTORY.getFixedFeeStrategies();\n    assertEq(gsmFeeStrategies.length, 0);\n  }\n\n  function testRevertConstructorInvalidGsmFeeStrategyFactory() public {\n    vm.expectRevert('INVALID_FIXED_FEE_STRATEGY_FACTORY');\n    new GhoGsmSteward(address(0), address(0x002));\n  }\n\n  function testRevertConstructorInvalidRiskCouncil() public {\n    vm.expectRevert('INVALID_RISK_COUNCIL');\n    new GhoGsmSteward(address(0x001), address(0));\n  }\n\n  function testUpdateGsmExposureCapUpwards() public {\n    uint128 oldExposureCap = GHO_GSM.getExposureCap();\n    vm.prank(RISK_COUNCIL);\n    uint128 newExposureCap = oldExposureCap + 1;\n    GHO_GSM_STEWARD.updateGsmExposureCap(address(GHO_GSM), newExposureCap);\n    uint128 currentExposureCap = GHO_GSM.getExposureCap();\n    assertEq(currentExposureCap, newExposureCap);\n  }\n\n  function testUpdateGsmExposureCapDownwards() public {\n    uint128 oldExposureCap = GHO_GSM.getExposureCap();\n    vm.prank(RISK_COUNCIL);\n    uint128 newExposureCap = oldExposureCap - 1;\n    GHO_GSM_STEWARD.updateGsmExposureCap(address(GHO_GSM), newExposureCap);\n    uint128 currentExposureCap = GHO_GSM.getExposureCap();\n    assertEq(currentExposureCap, newExposureCap);\n  }\n\n  function testUpdateGsmExposureCapMaxIncrease() public {\n    uint128 oldExposureCap = GHO_GSM.getExposureCap();\n    uint128 newExposureCap = oldExposureCap * 2;\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmExposureCap(address(GHO_GSM), newExposureCap);\n    uint128 currentExposureCap = GHO_GSM.getExposureCap();\n    assertEq(currentExposureCap, newExposureCap);\n  }\n\n  function testUpdateGsmExposureCapMaxDecrease() public {\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmExposureCap(address(GHO_GSM), 0);\n    uint128 currentExposureCap = GHO_GSM.getExposureCap();\n    assertEq(currentExposureCap, 0);\n  }\n\n  function testUpdateGsmExposureCapTimelock() public {\n    uint128 oldExposureCap = GHO_GSM.getExposureCap();\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmExposureCap(address(GHO_GSM), oldExposureCap + 1);\n    IGhoGsmSteward.GsmDebounce memory timelocks = GHO_GSM_STEWARD.getGsmTimelocks(address(GHO_GSM));\n    assertEq(timelocks.gsmExposureCapLastUpdated, block.timestamp);\n  }\n\n  function testUpdateGsmExposureCapAfterTimelock() public {\n    uint128 oldExposureCap = GHO_GSM.getExposureCap();\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmExposureCap(address(GHO_GSM), oldExposureCap + 1);\n    skip(GHO_GSM_STEWARD.MINIMUM_DELAY() + 1);\n    uint128 newExposureCap = oldExposureCap + 2;\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmExposureCap(address(GHO_GSM), newExposureCap);\n    uint128 currentExposureCap = GHO_GSM.getExposureCap();\n    assertEq(currentExposureCap, newExposureCap);\n  }\n\n  function testRevertUpdateGsmExposureCapIfUnauthorized() public {\n    vm.expectRevert('INVALID_CALLER');\n    vm.prank(ALICE);\n    GHO_GSM_STEWARD.updateGsmExposureCap(address(GHO_GSM), 50_000_000e18);\n  }\n\n  function testRevertUpdateGsmExposureCapIfTooSoon() public {\n    uint128 oldExposureCap = GHO_GSM.getExposureCap();\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmExposureCap(address(GHO_GSM), oldExposureCap + 1);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('DEBOUNCE_NOT_RESPECTED');\n    GHO_GSM_STEWARD.updateGsmExposureCap(address(GHO_GSM), oldExposureCap + 2);\n  }\n\n  function testRevertUpdateGsmExposureCapNoChange() public {\n    uint128 oldExposureCap = GHO_GSM.getExposureCap();\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('NO_CHANGE_IN_EXPOSURE_CAP');\n    GHO_GSM_STEWARD.updateGsmExposureCap(address(GHO_GSM), oldExposureCap);\n  }\n\n  function testRevertUpdateGsmExposureCapIfValueMoreThanDouble() public {\n    uint128 oldExposureCap = GHO_GSM.getExposureCap();\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_EXPOSURE_CAP_UPDATE');\n    GHO_GSM_STEWARD.updateGsmExposureCap(address(GHO_GSM), oldExposureCap * 2 + 1);\n  }\n\n  function testRevertUpdateGsmExposureCapIfStewardLostConfiguratorRole() public {\n    uint128 oldExposureCap = GHO_GSM.getExposureCap();\n    GHO_GSM.revokeRole(GSM_CONFIGURATOR_ROLE, address(GHO_GSM_STEWARD));\n    vm.expectRevert(\n      AccessControlErrorsLib.MISSING_ROLE(GSM_CONFIGURATOR_ROLE, address(GHO_GSM_STEWARD))\n    );\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmExposureCap(address(GHO_GSM), oldExposureCap + 1);\n  }\n\n  function testUpdateGsmBuySellFeesBuyFeeUpwards() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee + 1, sellFee);\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    uint256 newBuyFee = IGsmFeeStrategy(newStrategy).getBuyFee(1e4);\n    assertEq(newBuyFee, buyFee + 1);\n  }\n\n  function testUpdateGsmBuySellFeesBuyFeeDownwards() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee - 1, sellFee);\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    uint256 newBuyFee = IGsmFeeStrategy(newStrategy).getBuyFee(1e4);\n    assertEq(newBuyFee, buyFee - 1);\n  }\n\n  function testUpdateGsmBuySellFeesBuyFeeMax() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    uint256 maxFeeUpdate = GHO_GSM_STEWARD.GSM_FEE_RATE_CHANGE_MAX();\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee + maxFeeUpdate, sellFee);\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    uint256 newBuyFee = IGsmFeeStrategy(newStrategy).getBuyFee(1e4);\n    assertEq(newBuyFee, buyFee + maxFeeUpdate);\n  }\n\n  function testUpdateGsmBuySellFeesBuyFeeMin() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    uint256 maxFeeUpdate = GHO_GSM_STEWARD.GSM_FEE_RATE_CHANGE_MAX();\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee - maxFeeUpdate, sellFee);\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    uint256 newBuyFee = IGsmFeeStrategy(newStrategy).getBuyFee(1e4);\n    assertEq(newBuyFee, buyFee - maxFeeUpdate);\n  }\n\n  function testUpdateGsmBuySellFeesSellFeeUpwards() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee, sellFee + 1);\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    uint256 newSellFee = IGsmFeeStrategy(newStrategy).getSellFee(1e4);\n    assertEq(newSellFee, sellFee + 1);\n  }\n\n  function testUpdateGsmBuySellFeesSellFeeDownwards() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee, sellFee - 1);\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    uint256 newSellFee = IGsmFeeStrategy(newStrategy).getSellFee(1e4);\n    assertEq(newSellFee, sellFee - 1);\n  }\n\n  function testUpdateGsmBuySellFeesSellFeeMax() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    uint256 maxFeeUpdate = GHO_GSM_STEWARD.GSM_FEE_RATE_CHANGE_MAX();\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee, sellFee + maxFeeUpdate);\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    uint256 newSellFee = IGsmFeeStrategy(newStrategy).getSellFee(1e4);\n    assertEq(newSellFee, sellFee + maxFeeUpdate);\n  }\n\n  function testUpdateGsmBuySellFeesSellFeeMin() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    uint256 maxFeeUpdate = GHO_GSM_STEWARD.GSM_FEE_RATE_CHANGE_MAX();\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee, sellFee - maxFeeUpdate);\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    uint256 newSellFee = IGsmFeeStrategy(newStrategy).getSellFee(1e4);\n    assertEq(newSellFee, sellFee - maxFeeUpdate);\n  }\n\n  function testUpdateGsmBuySellFeesBothFeesUpwards() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee + 1, sellFee + 1);\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    uint256 newBuyFee = IGsmFeeStrategy(newStrategy).getBuyFee(1e4);\n    uint256 newSellFee = IGsmFeeStrategy(newStrategy).getSellFee(1e4);\n    assertEq(newBuyFee, buyFee + 1);\n    assertEq(newSellFee, sellFee + 1);\n  }\n\n  function testUpdateGsmBuySellFeesBothFeesDownwards() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee - 1, sellFee - 1);\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    uint256 newBuyFee = IGsmFeeStrategy(newStrategy).getBuyFee(1e4);\n    uint256 newSellFee = IGsmFeeStrategy(newStrategy).getSellFee(1e4);\n    assertEq(newBuyFee, buyFee - 1);\n    assertEq(newSellFee, sellFee - 1);\n  }\n\n  function testUpdateGsmBuySellFeesBothFeesMax() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    uint256 maxFeeUpdate = GHO_GSM_STEWARD.GSM_FEE_RATE_CHANGE_MAX();\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(\n      address(GHO_GSM),\n      buyFee + maxFeeUpdate,\n      sellFee + maxFeeUpdate\n    );\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    uint256 newBuyFee = IGsmFeeStrategy(newStrategy).getBuyFee(1e4);\n    uint256 newSellFee = IGsmFeeStrategy(newStrategy).getSellFee(1e4);\n    assertEq(newBuyFee, buyFee + maxFeeUpdate);\n    assertEq(newSellFee, sellFee + maxFeeUpdate);\n  }\n\n  function testUpdateGsmBuySellFeesBothFeesMin() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    uint256 maxFeeUpdate = GHO_GSM_STEWARD.GSM_FEE_RATE_CHANGE_MAX();\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(\n      address(GHO_GSM),\n      buyFee - maxFeeUpdate,\n      sellFee - maxFeeUpdate\n    );\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    uint256 newBuyFee = IGsmFeeStrategy(newStrategy).getBuyFee(1e4);\n    uint256 newSellFee = IGsmFeeStrategy(newStrategy).getSellFee(1e4);\n    assertEq(newBuyFee, buyFee - maxFeeUpdate);\n    assertEq(newSellFee, sellFee - maxFeeUpdate);\n  }\n\n  function testUpdateGsmBuySellFeesTimelock() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee + 1, sellFee + 1);\n    IGhoGsmSteward.GsmDebounce memory timelocks = GHO_GSM_STEWARD.getGsmTimelocks(address(GHO_GSM));\n    assertEq(timelocks.gsmFeeStrategyLastUpdated, block.timestamp);\n  }\n\n  function testUpdateGsmBuySellFeesAfterTimelock() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee + 1, sellFee + 1);\n    skip(GHO_GSM_STEWARD.MINIMUM_DELAY() + 1);\n    uint256 newBuyFee = buyFee + 2;\n    uint256 newSellFee = sellFee + 2;\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), newBuyFee, newSellFee);\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    uint256 currentBuyFee = IGsmFeeStrategy(newStrategy).getBuyFee(1e4);\n    uint256 currentSellFee = IGsmFeeStrategy(newStrategy).getSellFee(1e4);\n    assertEq(currentBuyFee, newBuyFee);\n    assertEq(currentSellFee, newSellFee);\n  }\n\n  function testUpdateGsmBuySellFeesNewStrategy() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee + 1, sellFee + 1);\n    address[] memory cachedStrategies = FIXED_FEE_STRATEGY_FACTORY.getFixedFeeStrategies();\n    assertEq(cachedStrategies.length, 1);\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    assertEq(newStrategy, cachedStrategies[0]);\n  }\n\n  function testUpdateGsmBuySellFeesIfZeroFees() public {\n    address currentFeeStrategy = GHO_GSM.getFeeStrategy();\n    vm.mockCall(\n      currentFeeStrategy,\n      abi.encodeWithSelector(GHO_GSM_FIXED_FEE_STRATEGY.getBuyFee.selector),\n      abi.encode(0)\n    );\n    vm.mockCall(\n      currentFeeStrategy,\n      abi.encodeWithSelector(GHO_GSM_FIXED_FEE_STRATEGY.getSellFee.selector),\n      abi.encode(0)\n    );\n    uint256 buyFee = IGsmFeeStrategy(currentFeeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(currentFeeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee + 1, sellFee);\n    address[] memory cachedStrategies = FIXED_FEE_STRATEGY_FACTORY.getFixedFeeStrategies();\n    assertEq(cachedStrategies.length, 1);\n    address newStrategy = GHO_GSM.getFeeStrategy();\n    assertEq(newStrategy, cachedStrategies[0]);\n  }\n\n  function testRevertUpdateGsmBuySellFeesIfZeroFeeStrategyAddress() public {\n    vm.mockCall(\n      address(GHO_GSM),\n      abi.encodeWithSelector(GHO_GSM.getFeeStrategy.selector),\n      abi.encode(address(0))\n    );\n    vm.expectRevert('FIXED_FEE_STRATEGY_NOT_FOUND');\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), 0.01e4, 0.01e4);\n  }\n\n  function testRevertUpdateGsmBuySellFeesIfUnauthorized() public {\n    vm.prank(ALICE);\n    vm.expectRevert('INVALID_CALLER');\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), 0.01e4, 0.01e4);\n  }\n\n  function testRevertUpdateGsmBuySellFeesIfTooSoon() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee + 1, sellFee + 1);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('DEBOUNCE_NOT_RESPECTED');\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee + 2, sellFee + 2);\n  }\n\n  function testRevertUpdateGsmBuySellFeesNoChange() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('NO_CHANGE_IN_FEES');\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee, sellFee);\n  }\n\n  function testRevertUpdateGsmBuySellFeesIfBuyFeeMoreThanMax() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 maxFeeUpdate = GHO_GSM_STEWARD.GSM_FEE_RATE_CHANGE_MAX();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_BUY_FEE_UPDATE');\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee + maxFeeUpdate + 1, sellFee);\n  }\n\n  function testRevertUpdateGsmBuySellFeesIfBuyFeeLessThanMin() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 maxFeeUpdate = GHO_GSM_STEWARD.GSM_FEE_RATE_CHANGE_MAX();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_BUY_FEE_UPDATE');\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee - maxFeeUpdate - 1, sellFee);\n  }\n\n  function testRevertUpdateGsmBuySellFeesIfSellFeeMoreThanMax() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 maxFeeUpdate = GHO_GSM_STEWARD.GSM_FEE_RATE_CHANGE_MAX();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_SELL_FEE_UPDATE');\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee, sellFee + maxFeeUpdate + 1);\n  }\n\n  function testRevertUpdateGsmBuySellFeesIfSellFeeLessThanMin() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 maxFeeUpdate = GHO_GSM_STEWARD.GSM_FEE_RATE_CHANGE_MAX();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_SELL_FEE_UPDATE');\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee, sellFee - maxFeeUpdate - 1);\n  }\n\n  function testRevertUpdateGsmBuySellFeesIfBothMoreThanMax() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 maxFeeUpdate = GHO_GSM_STEWARD.GSM_FEE_RATE_CHANGE_MAX();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_BUY_FEE_UPDATE');\n    GHO_GSM_STEWARD.updateGsmBuySellFees(\n      address(GHO_GSM),\n      buyFee + maxFeeUpdate + 1,\n      sellFee + maxFeeUpdate + 1\n    );\n  }\n\n  function testRevertUpdateGsmBuySellFeesIfBothLessThanMin() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 maxFeeUpdate = GHO_GSM_STEWARD.GSM_FEE_RATE_CHANGE_MAX();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    vm.expectRevert('INVALID_BUY_FEE_UPDATE');\n    GHO_GSM_STEWARD.updateGsmBuySellFees(\n      address(GHO_GSM),\n      buyFee - maxFeeUpdate - 1,\n      sellFee - maxFeeUpdate - 1\n    );\n  }\n\n  function testRevertUpdateGsmBuySellFeesIfStewardLostConfiguratorRole() public {\n    address feeStrategy = GHO_GSM.getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    GHO_GSM.revokeRole(GSM_CONFIGURATOR_ROLE, address(GHO_GSM_STEWARD));\n    vm.expectRevert(\n      AccessControlErrorsLib.MISSING_ROLE(GSM_CONFIGURATOR_ROLE, address(GHO_GSM_STEWARD))\n    );\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(address(GHO_GSM), buyFee + 1, sellFee + 1);\n  }\n}\n"
    },
    "src/test/TestGhoInterestRateStrategy.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGhoInterestRateStrategy is TestGhoBase {\n  function testFuzzVariableRateSetOnly(\n    address addressesProvider,\n    uint256 variableBorrowRate,\n    DataTypes.CalculateInterestRatesParams memory params\n  ) public {\n    GhoInterestRateStrategy ghoInterest = new GhoInterestRateStrategy(\n      addressesProvider,\n      variableBorrowRate\n    );\n    assertEq(address(ghoInterest.ADDRESSES_PROVIDER()), addressesProvider);\n    assertEq(ghoInterest.getBaseVariableBorrowRate(), variableBorrowRate);\n    assertEq(ghoInterest.getMaxVariableBorrowRate(), variableBorrowRate);\n    (uint256 x, uint256 y, uint256 z) = ghoInterest.calculateInterestRates(params);\n    assertEq(x, 0, 'Unexpected first return value in interest rate');\n    assertEq(y, 0, 'Unexpected second return value in interest rate');\n    assertEq(z, variableBorrowRate, 'Unexpected variable borrow rate');\n  }\n}\n"
    },
    "src/test/TestGhoOracle.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGhoOracle is TestGhoBase {\n  function testLatestAnswer() public {\n    int256 latest = GHO_ORACLE.latestAnswer();\n    assertEq(latest, DEFAULT_GHO_PRICE, 'Wrong GHO price from oracle');\n  }\n\n  function testDecimals() public {\n    uint8 decimals = GHO_ORACLE.decimals();\n    assertEq(decimals, DEFAULT_ORACLE_DECIMALS, 'Wrong decimals from oracle');\n  }\n}\n"
    },
    "src/test/TestGhoStableDebtToken.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGhoStableDebtToken is TestGhoBase {\n  function testConstructor() public {\n    GhoStableDebtToken debtToken = new GhoStableDebtToken(IPool(address(POOL)));\n    assertEq(debtToken.name(), 'GHO_STABLE_DEBT_TOKEN_IMPL', 'Wrong default ERC20 name');\n    assertEq(debtToken.symbol(), 'GHO_STABLE_DEBT_TOKEN_IMPL', 'Wrong default ERC20 symbol');\n    assertEq(debtToken.decimals(), 0, 'Wrong default ERC20 decimals');\n  }\n\n  function testInitialize() public {\n    GhoStableDebtToken debtToken = new GhoStableDebtToken(IPool(address(POOL)));\n    string memory tokenName = 'Aave Stable Debt GHO';\n    string memory tokenSymbol = 'stableDebtGHO';\n    bytes memory empty;\n    debtToken.initialize(\n      IPool(address(POOL)),\n      address(GHO_TOKEN),\n      IAaveIncentivesController(address(0)),\n      18,\n      tokenName,\n      tokenSymbol,\n      empty\n    );\n\n    assertEq(debtToken.name(), tokenName, 'Wrong initialized name');\n    assertEq(debtToken.symbol(), tokenSymbol, 'Wrong initialized symbol');\n    assertEq(debtToken.decimals(), 18, 'Wrong ERC20 decimals');\n  }\n\n  function testInitializePoolRevert() public {\n    string memory tokenName = 'Aave Stable Debt GHO';\n    string memory tokenSymbol = 'stableDebtGHO';\n    bytes memory empty;\n\n    GhoStableDebtToken debtToken = new GhoStableDebtToken(IPool(address(POOL)));\n    vm.expectRevert(bytes(Errors.POOL_ADDRESSES_DO_NOT_MATCH));\n    debtToken.initialize(\n      IPool(address(0)),\n      address(GHO_TOKEN),\n      IAaveIncentivesController(address(0)),\n      18,\n      tokenName,\n      tokenSymbol,\n      empty\n    );\n  }\n\n  function testReInitRevert() public {\n    string memory tokenName = 'Aave Stable Debt GHO';\n    string memory tokenSymbol = 'stableDebtGHO';\n    bytes memory empty;\n\n    vm.expectRevert(bytes('Contract instance has already been initialized'));\n    GHO_STABLE_DEBT_TOKEN.initialize(\n      IPool(address(POOL)),\n      address(GHO_TOKEN),\n      IAaveIncentivesController(address(0)),\n      18,\n      tokenName,\n      tokenSymbol,\n      empty\n    );\n  }\n\n  function testUnderlying() public {\n    assertEq(\n      GHO_STABLE_DEBT_TOKEN.UNDERLYING_ASSET_ADDRESS(),\n      address(GHO_TOKEN),\n      'Underlying should match token'\n    );\n  }\n\n  function testTransferRevert() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    GHO_STABLE_DEBT_TOKEN.transfer(CHARLES, 1);\n  }\n\n  function testTransferFromRevert() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    GHO_STABLE_DEBT_TOKEN.transferFrom(ALICE, CHARLES, 1);\n  }\n\n  function testApproveRevert() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    GHO_STABLE_DEBT_TOKEN.approve(CHARLES, 1);\n  }\n\n  function testIncreaseAllowanceRevert() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    GHO_STABLE_DEBT_TOKEN.increaseAllowance(CHARLES, 1);\n  }\n\n  function testDecreaseAllowanceRevert() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    GHO_STABLE_DEBT_TOKEN.decreaseAllowance(CHARLES, 1);\n  }\n\n  function testAllowanceRevert() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    GHO_STABLE_DEBT_TOKEN.allowance(CHARLES, ALICE);\n  }\n\n  function testPrincipalBalanceOfZero() public {\n    assertEq(GHO_STABLE_DEBT_TOKEN.principalBalanceOf(ALICE), 0, 'Unexpected principal balance');\n    assertEq(GHO_STABLE_DEBT_TOKEN.principalBalanceOf(BOB), 0, 'Unexpected principal balance');\n    assertEq(GHO_STABLE_DEBT_TOKEN.principalBalanceOf(CHARLES), 0, 'Unexpected principal balance');\n  }\n\n  function testMintRevert() public {\n    vm.prank(address(POOL));\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    GHO_STABLE_DEBT_TOKEN.mint(ALICE, ALICE, 0, 0);\n  }\n\n  function testUnauthorizedMint() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.CALLER_MUST_BE_POOL));\n    GHO_STABLE_DEBT_TOKEN.mint(ALICE, ALICE, 0, 0);\n  }\n\n  function testBurnRevert() public {\n    vm.prank(address(POOL));\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    GHO_STABLE_DEBT_TOKEN.burn(ALICE, 0);\n  }\n\n  function testUnauthorizedBurn() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.CALLER_MUST_BE_POOL));\n    GHO_STABLE_DEBT_TOKEN.burn(ALICE, 0);\n  }\n\n  function testGetAverageStableRateZero() public {\n    uint256 result = GHO_STABLE_DEBT_TOKEN.getAverageStableRate();\n    assertEq(result, 0, 'Unexpected stable rate');\n  }\n\n  function testGetUserLastUpdatedZero() public {\n    assertEq(GHO_STABLE_DEBT_TOKEN.getUserLastUpdated(ALICE), 0, 'Unexpected stable rate');\n    assertEq(GHO_STABLE_DEBT_TOKEN.getUserLastUpdated(BOB), 0, 'Unexpected stable rate');\n    assertEq(GHO_STABLE_DEBT_TOKEN.getUserLastUpdated(CHARLES), 0, 'Unexpected stable rate');\n  }\n\n  function testGetUserStableRateZero() public {\n    assertEq(GHO_STABLE_DEBT_TOKEN.getUserStableRate(ALICE), 0, 'Unexpected stable rate');\n    assertEq(GHO_STABLE_DEBT_TOKEN.getUserStableRate(BOB), 0, 'Unexpected stable rate');\n    assertEq(GHO_STABLE_DEBT_TOKEN.getUserStableRate(CHARLES), 0, 'Unexpected stable rate');\n  }\n\n  function testGetUserBalanceZero() public {\n    assertEq(GHO_STABLE_DEBT_TOKEN.balanceOf(ALICE), 0, 'Unexpected stable rate');\n    assertEq(GHO_STABLE_DEBT_TOKEN.balanceOf(BOB), 0, 'Unexpected stable rate');\n    assertEq(GHO_STABLE_DEBT_TOKEN.balanceOf(CHARLES), 0, 'Unexpected stable rate');\n  }\n\n  function testGetSupplyDataZero() public {\n    (\n      uint256 totalSupply,\n      uint256 calcTotalSupply,\n      uint256 avgRate,\n      uint40 timestamp\n    ) = GHO_STABLE_DEBT_TOKEN.getSupplyData();\n    assertEq(totalSupply, 0, 'Unexpected total supply');\n    assertEq(calcTotalSupply, 0, 'Unexpected total supply');\n    assertEq(avgRate, 0, 'Unexpected average rate');\n    assertEq(timestamp, 0, 'Unexpected timestamp');\n  }\n\n  function testGetTotalSupplyAvgRateZero() public {\n    (uint256 calcTotalSupply, uint256 avgRate) = GHO_STABLE_DEBT_TOKEN.getTotalSupplyAndAvgRate();\n    assertEq(calcTotalSupply, 0, 'Unexpected total supply');\n    assertEq(avgRate, 0, 'Unexpected average rate');\n  }\n\n  function testTotalSupplyZero() public {\n    uint256 result = GHO_STABLE_DEBT_TOKEN.totalSupply();\n    assertEq(result, 0, 'Unexpected total supply');\n  }\n\n  function testTotalSupplyLastUpdatedZero() public {\n    uint40 result = GHO_STABLE_DEBT_TOKEN.getTotalSupplyLastUpdated();\n    assertEq(result, 0, 'Unexpected timestamp');\n  }\n}\n"
    },
    "src/test/TestGhoStewardsForkEthereum.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport 'forge-std/Test.sol';\nimport {IAccessControl} from '@openzeppelin/contracts/access/IAccessControl.sol';\nimport {IACLManager} from '@aave/core-v3/contracts/interfaces/IACLManager.sol';\nimport {AaveV3Ethereum, AaveV3EthereumAssets} from 'aave-address-book/AaveV3Ethereum.sol';\nimport {MiscEthereum} from 'aave-address-book/MiscEthereum.sol';\nimport {IPoolAddressesProvider, IPoolDataProvider, IPool} from 'aave-address-book/AaveV3.sol';\nimport {DataTypes} from 'aave-v3-core/contracts/protocol/libraries/types/DataTypes.sol';\nimport {ReserveConfiguration} from 'aave-v3-core/contracts/protocol/libraries/configuration/ReserveConfiguration.sol';\nimport {FixedFeeStrategyFactory} from '../contracts/facilitators/gsm/feeStrategy/FixedFeeStrategyFactory.sol';\nimport {IGsmFeeStrategy} from '../contracts/facilitators/gsm/feeStrategy/interfaces/IGsmFeeStrategy.sol';\nimport {Gsm} from '../contracts/facilitators/gsm/Gsm.sol';\nimport {GhoToken} from '../contracts/gho/GhoToken.sol';\nimport {IGhoAaveSteward} from '../contracts/misc/interfaces/IGhoAaveSteward.sol';\nimport {GhoAaveSteward} from '../contracts/misc/GhoAaveSteward.sol';\nimport {GhoBucketSteward} from '../contracts/misc/GhoBucketSteward.sol';\nimport {GhoCcipSteward} from '../contracts/misc/GhoCcipSteward.sol';\nimport {GhoGsmSteward} from '../contracts/misc/GhoGsmSteward.sol';\nimport {RateLimiter, IUpgradeableLockReleaseTokenPool} from '../contracts/misc/dependencies/Ccip.sol';\nimport {IDefaultInterestRateStrategyV2} from '../contracts/misc/dependencies/AaveV3-1.sol';\nimport {MockPool} from './mocks/MockPool.sol';\nimport {MockUpgradeableLockReleaseTokenPool} from './mocks/MockUpgradeableLockReleaseTokenPool.sol';\n\ncontract TestGhoStewardsForkEthereum is Test {\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n  address public OWNER = makeAddr('OWNER');\n  address public RISK_COUNCIL = makeAddr('RISK_COUNCIL');\n  IPoolDataProvider public POOL_DATA_PROVIDER = AaveV3Ethereum.AAVE_PROTOCOL_DATA_PROVIDER;\n  IPoolAddressesProvider public POOL_ADDRESSES_PROVIDER = AaveV3Ethereum.POOL_ADDRESSES_PROVIDER;\n  address public GHO_TOKEN = AaveV3EthereumAssets.GHO_UNDERLYING;\n  address public GHO_ATOKEN = AaveV3EthereumAssets.GHO_A_TOKEN;\n  IPool public POOL = AaveV3Ethereum.POOL;\n  address public ACL_ADMIN = AaveV3Ethereum.ACL_ADMIN;\n  address public GHO_TOKEN_POOL = MiscEthereum.GHO_CCIP_TOKEN_POOL;\n  address public GHO_GSM_USDC = MiscEthereum.GSM_USDC;\n  address public GHO_GSM_USDT = MiscEthereum.GSM_USDT;\n  address public ACL_MANAGER;\n\n  GhoAaveSteward public GHO_AAVE_STEWARD;\n  GhoBucketSteward public GHO_BUCKET_STEWARD;\n  GhoCcipSteward public GHO_CCIP_STEWARD;\n  GhoGsmSteward public GHO_GSM_STEWARD;\n\n  uint64 public remoteChainSelector = 4949039107694359620;\n\n  event ChainConfigured(\n    uint64 remoteChainSelector,\n    RateLimiter.Config outboundRateLimiterConfig,\n    RateLimiter.Config inboundRateLimiterConfig\n  );\n\n  function setUp() public {\n    vm.createSelectFork(vm.rpcUrl('mainnet'), 20580302);\n    vm.startPrank(ACL_ADMIN);\n    ACL_MANAGER = POOL_ADDRESSES_PROVIDER.getACLManager();\n\n    IGhoAaveSteward.BorrowRateConfig memory defaultBorrowRateConfig = IGhoAaveSteward\n      .BorrowRateConfig({\n        optimalUsageRatioMaxChange: 5_00,\n        baseVariableBorrowRateMaxChange: 5_00,\n        variableRateSlope1MaxChange: 5_00,\n        variableRateSlope2MaxChange: 5_00\n      });\n\n    GHO_AAVE_STEWARD = new GhoAaveSteward(\n      OWNER,\n      address(POOL_ADDRESSES_PROVIDER),\n      address(POOL_DATA_PROVIDER),\n      GHO_TOKEN,\n      RISK_COUNCIL,\n      defaultBorrowRateConfig\n    );\n    IAccessControl(ACL_MANAGER).grantRole(\n      IACLManager(ACL_MANAGER).RISK_ADMIN_ROLE(),\n      address(GHO_AAVE_STEWARD)\n    );\n\n    GHO_BUCKET_STEWARD = new GhoBucketSteward(OWNER, GHO_TOKEN, RISK_COUNCIL);\n    GhoToken(GHO_TOKEN).grantRole(\n      GhoToken(GHO_TOKEN).BUCKET_MANAGER_ROLE(),\n      address(GHO_BUCKET_STEWARD)\n    );\n\n    GHO_CCIP_STEWARD = new GhoCcipSteward(GHO_TOKEN, GHO_TOKEN_POOL, RISK_COUNCIL, true);\n    IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL).setRateLimitAdmin(address(GHO_CCIP_STEWARD));\n    IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL).setBridgeLimitAdmin(address(GHO_CCIP_STEWARD));\n\n    FixedFeeStrategyFactory strategyFactory = new FixedFeeStrategyFactory();\n    GHO_GSM_STEWARD = new GhoGsmSteward(address(strategyFactory), RISK_COUNCIL);\n    Gsm(GHO_GSM_USDC).grantRole(Gsm(GHO_GSM_USDC).CONFIGURATOR_ROLE(), address(GHO_GSM_STEWARD));\n    Gsm(GHO_GSM_USDT).grantRole(Gsm(GHO_GSM_USDT).CONFIGURATOR_ROLE(), address(GHO_GSM_STEWARD));\n\n    address[] memory controlledFacilitators = new address[](3);\n    controlledFacilitators[0] = address(GHO_ATOKEN);\n    controlledFacilitators[1] = address(GHO_GSM_USDC);\n    controlledFacilitators[2] = address(GHO_GSM_USDT);\n    changePrank(OWNER);\n    GHO_BUCKET_STEWARD.setControlledFacilitator(controlledFacilitators, true);\n\n    vm.stopPrank();\n  }\n\n  function testStewardsPermissions() public {\n    assertEq(\n      IAccessControl(ACL_MANAGER).hasRole(\n        IACLManager(ACL_MANAGER).RISK_ADMIN_ROLE(),\n        address(GHO_AAVE_STEWARD)\n      ),\n      true\n    );\n\n    assertEq(\n      IAccessControl(GHO_TOKEN).hasRole(\n        GhoToken(GHO_TOKEN).BUCKET_MANAGER_ROLE(),\n        address(GHO_BUCKET_STEWARD)\n      ),\n      true\n    );\n\n    assertEq(\n      IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL).getRateLimitAdmin(),\n      address(GHO_CCIP_STEWARD)\n    );\n    assertEq(\n      IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL).getBridgeLimitAdmin(),\n      address(GHO_CCIP_STEWARD)\n    );\n\n    assertEq(\n      Gsm(GHO_GSM_USDC).hasRole(Gsm(GHO_GSM_USDC).CONFIGURATOR_ROLE(), address(GHO_GSM_STEWARD)),\n      true\n    );\n    assertEq(\n      Gsm(GHO_GSM_USDT).hasRole(Gsm(GHO_GSM_USDT).CONFIGURATOR_ROLE(), address(GHO_GSM_STEWARD)),\n      true\n    );\n  }\n\n  function testGhoAaveStewardUpdateGhoBorrowCap() public {\n    uint256 currentBorrowCap = _getGhoBorrowCap();\n    uint256 newBorrowCap = currentBorrowCap + 1;\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowCap(newBorrowCap);\n    assertEq(_getGhoBorrowCap(), newBorrowCap);\n  }\n\n  function testGhoAaveStewardUpdateGhoSupplyCap() public {\n    uint256 currentSupplyCap = _getGhoSupplyCap();\n    assertEq(currentSupplyCap, 0);\n    uint256 newSupplyCap = currentSupplyCap + 1;\n    // Can't update supply cap even by 1 since it's 0, and 100% of 0 is 0\n    vm.expectRevert('INVALID_SUPPLY_CAP_UPDATE');\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoSupplyCap(newSupplyCap);\n  }\n\n  function testGhoAaveStewardUpdateGhoBorrowRate() public {\n    IDefaultInterestRateStrategyV2.InterestRateData memory currentRates = _getGhoBorrowRates();\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      currentRates.optimalUsageRatio - 1,\n      currentRates.baseVariableBorrowRate + 1,\n      currentRates.variableRateSlope1 + 1,\n      currentRates.variableRateSlope2 + 1\n    );\n    assertEq(_getOptimalUsageRatio(), currentRates.optimalUsageRatio - 1);\n    assertEq(_getBaseVariableBorrowRate(), currentRates.baseVariableBorrowRate + 1);\n    assertEq(_getVariableRateSlope1(), currentRates.variableRateSlope1 + 1);\n    assertEq(_getVariableRateSlope2(), currentRates.variableRateSlope2 + 1);\n  }\n\n  function testGhoBucketStewardUpdateFacilitatorBucketCapacity() public {\n    (uint256 currentBucketCapacity, ) = GhoToken(GHO_TOKEN).getFacilitatorBucket(\n      address(GHO_ATOKEN)\n    );\n    vm.prank(RISK_COUNCIL);\n    uint128 newBucketCapacity = uint128(currentBucketCapacity) + 1;\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(address(GHO_ATOKEN), newBucketCapacity);\n    (uint256 capacity, ) = GhoToken(GHO_TOKEN).getFacilitatorBucket(address(GHO_ATOKEN));\n    assertEq(newBucketCapacity, capacity);\n  }\n\n  function testGhoBucketStewardSetControlledFacilitator() public {\n    address[] memory newGsmList = new address[](1);\n    address gho_gsm_4626 = makeAddr('gho_gsm_4626');\n    newGsmList[0] = gho_gsm_4626;\n    vm.prank(OWNER);\n    GHO_BUCKET_STEWARD.setControlledFacilitator(newGsmList, true);\n    assertTrue(GHO_BUCKET_STEWARD.isControlledFacilitator(gho_gsm_4626));\n    vm.prank(OWNER);\n    GHO_BUCKET_STEWARD.setControlledFacilitator(newGsmList, false);\n    assertFalse(GHO_BUCKET_STEWARD.isControlledFacilitator(gho_gsm_4626));\n  }\n\n  function testGhoCcipStewardUpdateBridgeLimit() public {\n    uint256 oldBridgeLimit = IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL).getBridgeLimit();\n    uint256 newBridgeLimit = oldBridgeLimit + 1;\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateBridgeLimit(newBridgeLimit);\n    uint256 currentBridgeLimit = IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL).getBridgeLimit();\n    assertEq(currentBridgeLimit, newBridgeLimit);\n  }\n\n  function testGhoCcipStewardUpdateRateLimit() public {\n    RateLimiter.TokenBucket memory outboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentOutboundRateLimiterState(remoteChainSelector);\n    RateLimiter.TokenBucket memory inboundConfig = MockUpgradeableLockReleaseTokenPool(\n      GHO_TOKEN_POOL\n    ).getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    RateLimiter.Config memory newOutboundConfig = RateLimiter.Config({\n      isEnabled: outboundConfig.isEnabled,\n      capacity: outboundConfig.capacity + 1,\n      rate: outboundConfig.rate\n    });\n\n    RateLimiter.Config memory newInboundConfig = RateLimiter.Config({\n      isEnabled: outboundConfig.isEnabled,\n      capacity: inboundConfig.capacity,\n      rate: inboundConfig.rate\n    });\n\n    // Currently rate limit set to 0, so can't even change by 1 because 100% of 0 is 0\n    vm.expectRevert('INVALID_RATE_LIMIT_UPDATE');\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      newOutboundConfig.isEnabled,\n      newOutboundConfig.capacity,\n      newOutboundConfig.rate,\n      newInboundConfig.isEnabled,\n      newInboundConfig.capacity,\n      newInboundConfig.rate\n    );\n  }\n\n  function testGhoGsmStewardUpdateExposureCap() public {\n    uint128 oldExposureCap = Gsm(GHO_GSM_USDC).getExposureCap();\n    uint128 newExposureCap = oldExposureCap + 1;\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmExposureCap(GHO_GSM_USDC, newExposureCap);\n    uint128 currentExposureCap = Gsm(GHO_GSM_USDC).getExposureCap();\n    assertEq(currentExposureCap, newExposureCap);\n  }\n\n  function testGhoGsmStewardUpdateGsmBuySellFees() public {\n    address feeStrategy = Gsm(GHO_GSM_USDC).getFeeStrategy();\n    uint256 buyFee = IGsmFeeStrategy(feeStrategy).getBuyFee(1e4);\n    uint256 sellFee = IGsmFeeStrategy(feeStrategy).getSellFee(1e4);\n    vm.prank(RISK_COUNCIL);\n    GHO_GSM_STEWARD.updateGsmBuySellFees(GHO_GSM_USDC, buyFee + 1, sellFee);\n    address newStrategy = Gsm(GHO_GSM_USDC).getFeeStrategy();\n    uint256 newBuyFee = IGsmFeeStrategy(newStrategy).getBuyFee(1e4);\n    assertEq(newBuyFee, buyFee + 1);\n  }\n\n  function _getGhoBorrowCap() internal view returns (uint256) {\n    DataTypes.ReserveConfigurationMap memory configuration = POOL.getConfiguration(GHO_TOKEN);\n    return configuration.getBorrowCap();\n  }\n\n  function _getGhoSupplyCap() internal view returns (uint256) {\n    DataTypes.ReserveConfigurationMap memory configuration = POOL.getConfiguration(\n      address(GHO_TOKEN)\n    );\n    return configuration.getSupplyCap();\n  }\n\n  function _getOptimalUsageRatio() internal view returns (uint16) {\n    IDefaultInterestRateStrategyV2.InterestRateData memory currentRates = _getGhoBorrowRates();\n    return currentRates.optimalUsageRatio;\n  }\n\n  function _getBaseVariableBorrowRate() internal view returns (uint32) {\n    IDefaultInterestRateStrategyV2.InterestRateData memory currentRates = _getGhoBorrowRates();\n    return currentRates.baseVariableBorrowRate;\n  }\n\n  function _getVariableRateSlope1() internal view returns (uint32) {\n    IDefaultInterestRateStrategyV2.InterestRateData memory currentRates = _getGhoBorrowRates();\n    return currentRates.variableRateSlope1;\n  }\n\n  function _getVariableRateSlope2() internal view returns (uint32) {\n    IDefaultInterestRateStrategyV2.InterestRateData memory currentRates = _getGhoBorrowRates();\n    return currentRates.variableRateSlope2;\n  }\n\n  function _getGhoBorrowRates()\n    internal\n    view\n    returns (IDefaultInterestRateStrategyV2.InterestRateData memory)\n  {\n    address rateStrategyAddress = POOL_DATA_PROVIDER.getInterestRateStrategyAddress(GHO_TOKEN);\n    return IDefaultInterestRateStrategyV2(rateStrategyAddress).getInterestRateDataBps(GHO_TOKEN);\n  }\n}\n"
    },
    "src/test/TestGhoStewardsForkRemote.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport 'forge-std/Test.sol';\nimport {IAccessControl} from '@openzeppelin/contracts/access/IAccessControl.sol';\nimport {IACLManager} from '@aave/core-v3/contracts/interfaces/IACLManager.sol';\nimport {TransparentUpgradeableProxy} from 'solidity-utils/contracts/transparent-proxy/TransparentUpgradeableProxy.sol';\nimport {AaveV3Arbitrum} from 'aave-address-book/AaveV3Arbitrum.sol';\nimport {MiscArbitrum} from 'aave-address-book/MiscArbitrum.sol';\nimport {IPoolAddressesProvider, IPoolDataProvider} from 'aave-address-book/AaveV3.sol';\nimport {GhoToken} from '../contracts/gho/GhoToken.sol';\nimport {IGhoAaveSteward} from '../contracts/misc/interfaces/IGhoAaveSteward.sol';\nimport {GhoAaveSteward} from '../contracts/misc/GhoAaveSteward.sol';\nimport {GhoBucketSteward} from '../contracts/misc/GhoBucketSteward.sol';\nimport {GhoCcipSteward} from '../contracts/misc/GhoCcipSteward.sol';\nimport {RateLimiter, IUpgradeableLockReleaseTokenPool} from '../contracts/misc/dependencies/Ccip.sol';\nimport {IDefaultInterestRateStrategyV2} from '../contracts/misc/dependencies/AaveV3-1.sol';\nimport {MockUpgradeableBurnMintTokenPool} from './mocks/MockUpgradeableBurnMintTokenPool.sol';\n\ncontract TestGhoStewardsForkRemote is Test {\n  address public OWNER = makeAddr('OWNER');\n  address public RISK_COUNCIL = makeAddr('RISK_COUNCIL');\n  IPoolDataProvider public POOL_DATA_PROVIDER = AaveV3Arbitrum.AAVE_PROTOCOL_DATA_PROVIDER;\n  IPoolAddressesProvider public POOL_ADDRESSES_PROVIDER = AaveV3Arbitrum.POOL_ADDRESSES_PROVIDER;\n  address public GHO_TOKEN = 0x7dfF72693f6A4149b17e7C6314655f6A9F7c8B33;\n  address public ARM_PROXY = 0xC311a21e6fEf769344EB1515588B9d535662a145;\n  address public ACL_ADMIN = AaveV3Arbitrum.ACL_ADMIN;\n  address public GHO_TOKEN_POOL = MiscArbitrum.GHO_CCIP_TOKEN_POOL;\n  address public PROXY_ADMIN = MiscArbitrum.PROXY_ADMIN;\n  address public ACL_MANAGER;\n\n  GhoAaveSteward public GHO_AAVE_STEWARD;\n  GhoBucketSteward public GHO_BUCKET_STEWARD;\n  GhoCcipSteward public GHO_CCIP_STEWARD;\n\n  uint64 public remoteChainSelector = 5009297550715157269;\n\n  event ChainConfigured(\n    uint64 remoteChainSelector,\n    RateLimiter.Config outboundRateLimiterConfig,\n    RateLimiter.Config inboundRateLimiterConfig\n  );\n\n  function setUp() public {\n    vm.createSelectFork(vm.rpcUrl('arbitrum'), 247477524);\n    vm.startPrank(ACL_ADMIN);\n    ACL_MANAGER = POOL_ADDRESSES_PROVIDER.getACLManager();\n\n    IGhoAaveSteward.BorrowRateConfig memory defaultBorrowRateConfig = IGhoAaveSteward\n      .BorrowRateConfig({\n        optimalUsageRatioMaxChange: 5_00,\n        baseVariableBorrowRateMaxChange: 5_00,\n        variableRateSlope1MaxChange: 5_00,\n        variableRateSlope2MaxChange: 5_00\n      });\n\n    GHO_AAVE_STEWARD = new GhoAaveSteward(\n      OWNER,\n      address(POOL_ADDRESSES_PROVIDER),\n      address(POOL_DATA_PROVIDER),\n      GHO_TOKEN,\n      RISK_COUNCIL,\n      defaultBorrowRateConfig\n    );\n    IAccessControl(ACL_MANAGER).grantRole(\n      IACLManager(ACL_MANAGER).RISK_ADMIN_ROLE(),\n      address(GHO_AAVE_STEWARD)\n    );\n\n    GHO_BUCKET_STEWARD = new GhoBucketSteward(OWNER, GHO_TOKEN, RISK_COUNCIL);\n    GhoToken(GHO_TOKEN).grantRole(\n      GhoToken(GHO_TOKEN).BUCKET_MANAGER_ROLE(),\n      address(GHO_BUCKET_STEWARD)\n    );\n\n    GHO_CCIP_STEWARD = new GhoCcipSteward(GHO_TOKEN, GHO_TOKEN_POOL, RISK_COUNCIL, true);\n\n    address[] memory controlledFacilitators = new address[](1);\n    controlledFacilitators[0] = address(GHO_TOKEN_POOL);\n    changePrank(OWNER);\n    GHO_BUCKET_STEWARD.setControlledFacilitator(controlledFacilitators, true);\n\n    vm.stopPrank();\n  }\n\n  function testStewardsPermissions() public {\n    assertEq(\n      IAccessControl(ACL_MANAGER).hasRole(\n        IACLManager(ACL_MANAGER).RISK_ADMIN_ROLE(),\n        address(GHO_AAVE_STEWARD)\n      ),\n      true\n    );\n\n    assertEq(\n      IAccessControl(GHO_TOKEN).hasRole(\n        GhoToken(GHO_TOKEN).BUCKET_MANAGER_ROLE(),\n        address(GHO_BUCKET_STEWARD)\n      ),\n      true\n    );\n  }\n\n  function testGhoAaveStewardUpdateGhoBorrowRate() public {\n    address rateStrategyAddress = POOL_DATA_PROVIDER.getInterestRateStrategyAddress(GHO_TOKEN);\n\n    IDefaultInterestRateStrategyV2.InterestRateData\n      memory mockResponse = IDefaultInterestRateStrategyV2.InterestRateData({\n        optimalUsageRatio: 100,\n        baseVariableBorrowRate: 100,\n        variableRateSlope1: 100,\n        variableRateSlope2: 100\n      });\n    vm.mockCall(\n      rateStrategyAddress,\n      abi.encodeWithSelector(\n        IDefaultInterestRateStrategyV2(rateStrategyAddress).getInterestRateDataBps.selector,\n        GHO_TOKEN\n      ),\n      abi.encode(mockResponse)\n    );\n\n    IDefaultInterestRateStrategyV2.InterestRateData memory currentRates = _getGhoBorrowRates();\n    uint16 newOptimalUsageRatio = currentRates.optimalUsageRatio + 1;\n    uint32 newBaseVariableBorrowRate = currentRates.baseVariableBorrowRate + 1;\n    uint32 newVariableRateSlope1 = currentRates.variableRateSlope1 - 1;\n    uint32 newVariableRateSlope2 = currentRates.variableRateSlope2 - 1;\n\n    vm.prank(RISK_COUNCIL);\n    GHO_AAVE_STEWARD.updateGhoBorrowRate(\n      newOptimalUsageRatio,\n      newBaseVariableBorrowRate,\n      newVariableRateSlope1,\n      newVariableRateSlope2\n    );\n\n    vm.clearMockedCalls();\n\n    assertEq(_getOptimalUsageRatio(), newOptimalUsageRatio);\n    assertEq(_getBaseVariableBorrowRate(), newBaseVariableBorrowRate);\n    assertEq(_getVariableRateSlope1(), newVariableRateSlope1);\n    assertEq(_getVariableRateSlope2(), newVariableRateSlope2);\n  }\n\n  function testGhoBucketStewardUpdateFacilitatorBucketCapacity() public {\n    (uint256 currentBucketCapacity, ) = GhoToken(GHO_TOKEN).getFacilitatorBucket(\n      address(GHO_TOKEN_POOL)\n    );\n    vm.prank(RISK_COUNCIL);\n    uint128 newBucketCapacity = uint128(currentBucketCapacity) + 1;\n    GHO_BUCKET_STEWARD.updateFacilitatorBucketCapacity(address(GHO_TOKEN_POOL), newBucketCapacity);\n    (uint256 bucketCapacity, ) = GhoToken(GHO_TOKEN).getFacilitatorBucket(address(GHO_TOKEN_POOL));\n    assertEq(bucketCapacity, newBucketCapacity);\n  }\n\n  function testGhoBucketStewardSetControlledFacilitator() public {\n    address[] memory newGsmList = new address[](1);\n    address gho_gsm_4626 = makeAddr('gho_gsm_4626');\n    newGsmList[0] = gho_gsm_4626;\n    vm.prank(OWNER);\n    GHO_BUCKET_STEWARD.setControlledFacilitator(newGsmList, true);\n    assertTrue(GHO_BUCKET_STEWARD.isControlledFacilitator(gho_gsm_4626));\n    vm.prank(OWNER);\n    GHO_BUCKET_STEWARD.setControlledFacilitator(newGsmList, false);\n    assertFalse(GHO_BUCKET_STEWARD.isControlledFacilitator(gho_gsm_4626));\n  }\n\n  function testGhoCcipStewardUpdateRateLimit() public {\n    RateLimiter.TokenBucket memory outboundConfig = IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL)\n      .getCurrentOutboundRateLimiterState(remoteChainSelector);\n    RateLimiter.TokenBucket memory inboundConfig = IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL)\n      .getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    RateLimiter.Config memory newOutboundConfig = RateLimiter.Config({\n      isEnabled: outboundConfig.isEnabled,\n      capacity: outboundConfig.capacity + 1,\n      rate: outboundConfig.rate\n    });\n\n    RateLimiter.Config memory newInboundConfig = RateLimiter.Config({\n      isEnabled: outboundConfig.isEnabled,\n      capacity: inboundConfig.capacity,\n      rate: inboundConfig.rate\n    });\n\n    // Currently rate limit set to 0, so can't even change by 1 because 100% of 0 is 0\n    vm.expectRevert('INVALID_RATE_LIMIT_UPDATE');\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      newOutboundConfig.isEnabled,\n      newOutboundConfig.capacity,\n      newOutboundConfig.rate,\n      newInboundConfig.isEnabled,\n      newInboundConfig.capacity,\n      newInboundConfig.rate\n    );\n  }\n\n  function testGhoCcipStewardRevertUpdateRateLimitUnauthorizedBeforeUpgrade() public {\n    RateLimiter.TokenBucket memory mockConfig = RateLimiter.TokenBucket({\n      rate: 50,\n      capacity: 50,\n      tokens: 1,\n      lastUpdated: 1,\n      isEnabled: true\n    });\n    // Mocking response due to rate limit currently being 0\n    vm.mockCall(\n      GHO_TOKEN_POOL,\n      abi.encodeWithSelector(\n        IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL)\n          .getCurrentOutboundRateLimiterState\n          .selector,\n        remoteChainSelector\n      ),\n      abi.encode(mockConfig)\n    );\n\n    RateLimiter.TokenBucket memory outboundConfig = IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL)\n      .getCurrentOutboundRateLimiterState(remoteChainSelector);\n    RateLimiter.TokenBucket memory inboundConfig = IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL)\n      .getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    RateLimiter.Config memory newOutboundConfig = RateLimiter.Config({\n      isEnabled: outboundConfig.isEnabled,\n      capacity: outboundConfig.capacity,\n      rate: outboundConfig.rate + 1\n    });\n\n    RateLimiter.Config memory newInboundConfig = RateLimiter.Config({\n      isEnabled: outboundConfig.isEnabled,\n      capacity: inboundConfig.capacity,\n      rate: inboundConfig.rate\n    });\n\n    vm.expectRevert('Only callable by owner');\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      newOutboundConfig.isEnabled,\n      newOutboundConfig.capacity,\n      newOutboundConfig.rate,\n      newInboundConfig.isEnabled,\n      newInboundConfig.capacity,\n      newInboundConfig.rate\n    );\n  }\n\n  function testGhoCcipStewardUpdateRateLimitAfterPoolUpgrade() public {\n    MockUpgradeableBurnMintTokenPool tokenPoolImpl = new MockUpgradeableBurnMintTokenPool(\n      address(GHO_TOKEN),\n      address(ARM_PROXY),\n      false,\n      false\n    );\n\n    vm.prank(PROXY_ADMIN);\n    TransparentUpgradeableProxy(payable(address(GHO_TOKEN_POOL))).upgradeTo(address(tokenPoolImpl));\n\n    vm.prank(ACL_ADMIN);\n    IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL).setRateLimitAdmin(address(GHO_CCIP_STEWARD));\n\n    RateLimiter.TokenBucket memory mockConfig = RateLimiter.TokenBucket({\n      rate: 50,\n      capacity: 50,\n      tokens: 1,\n      lastUpdated: 1,\n      isEnabled: true\n    });\n\n    // Mocking response due to rate limit currently being 0\n    vm.mockCall(\n      GHO_TOKEN_POOL,\n      abi.encodeWithSelector(\n        IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL)\n          .getCurrentOutboundRateLimiterState\n          .selector,\n        remoteChainSelector\n      ),\n      abi.encode(mockConfig)\n    );\n    vm.mockCall(\n      GHO_TOKEN_POOL,\n      abi.encodeWithSelector(\n        IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL).getCurrentInboundRateLimiterState.selector,\n        remoteChainSelector\n      ),\n      abi.encode(mockConfig)\n    );\n\n    RateLimiter.TokenBucket memory outboundConfig = IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL)\n      .getCurrentOutboundRateLimiterState(remoteChainSelector);\n    RateLimiter.TokenBucket memory inboundConfig = IUpgradeableLockReleaseTokenPool(GHO_TOKEN_POOL)\n      .getCurrentInboundRateLimiterState(remoteChainSelector);\n\n    RateLimiter.Config memory newOutboundConfig = RateLimiter.Config({\n      isEnabled: outboundConfig.isEnabled,\n      capacity: outboundConfig.capacity + 1,\n      rate: outboundConfig.rate\n    });\n\n    RateLimiter.Config memory newInboundConfig = RateLimiter.Config({\n      isEnabled: outboundConfig.isEnabled,\n      capacity: inboundConfig.capacity + 1,\n      rate: inboundConfig.rate\n    });\n\n    vm.expectEmit(false, false, false, true);\n    emit ChainConfigured(remoteChainSelector, newOutboundConfig, newInboundConfig);\n    vm.prank(RISK_COUNCIL);\n    GHO_CCIP_STEWARD.updateRateLimit(\n      remoteChainSelector,\n      newOutboundConfig.isEnabled,\n      newOutboundConfig.capacity,\n      newOutboundConfig.rate,\n      newInboundConfig.isEnabled,\n      newInboundConfig.capacity,\n      newInboundConfig.rate\n    );\n  }\n\n  function _getOptimalUsageRatio() internal view returns (uint16) {\n    IDefaultInterestRateStrategyV2.InterestRateData memory currentRates = _getGhoBorrowRates();\n    return currentRates.optimalUsageRatio;\n  }\n\n  function _getBaseVariableBorrowRate() internal view returns (uint32) {\n    IDefaultInterestRateStrategyV2.InterestRateData memory currentRates = _getGhoBorrowRates();\n    return currentRates.baseVariableBorrowRate;\n  }\n\n  function _getVariableRateSlope1() internal view returns (uint32) {\n    IDefaultInterestRateStrategyV2.InterestRateData memory currentRates = _getGhoBorrowRates();\n    return currentRates.variableRateSlope1;\n  }\n\n  function _getVariableRateSlope2() internal view returns (uint32) {\n    IDefaultInterestRateStrategyV2.InterestRateData memory currentRates = _getGhoBorrowRates();\n    return currentRates.variableRateSlope2;\n  }\n\n  function _getGhoBorrowRates()\n    internal\n    view\n    returns (IDefaultInterestRateStrategyV2.InterestRateData memory)\n  {\n    address rateStrategyAddress = POOL_DATA_PROVIDER.getInterestRateStrategyAddress(GHO_TOKEN);\n    return IDefaultInterestRateStrategyV2(rateStrategyAddress).getInterestRateDataBps(GHO_TOKEN);\n  }\n}\n"
    },
    "src/test/TestGhoToken.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGhoToken is TestGhoBase {\n  function testConstructor() public {\n    GhoToken ghoToken = new GhoToken(address(this));\n    vm.expectEmit(true, true, true, true, address(GHO_TOKEN));\n    emit RoleGranted(DEFAULT_ADMIN_ROLE, msg.sender, address(this));\n    GHO_TOKEN.grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    assertEq(ghoToken.name(), 'Gho Token', 'Wrong default ERC20 name');\n    assertEq(ghoToken.symbol(), 'GHO', 'Wrong default ERC20 symbol');\n    assertEq(ghoToken.decimals(), 18, 'Wrong default ERC20 decimals');\n    assertEq(ghoToken.getFacilitatorsList().length, 0, 'Facilitator list not empty');\n  }\n\n  function testGetFacilitatorData() public {\n    IGhoToken.Facilitator memory data = GHO_TOKEN.getFacilitator(address(GHO_ATOKEN));\n    assertEq(data.label, 'Aave V3 Pool', 'Unexpected facilitator label');\n    assertEq(data.bucketCapacity, DEFAULT_CAPACITY, 'Unexpected bucket capacity');\n    assertEq(data.bucketLevel, 0, 'Unexpected bucket level');\n  }\n\n  function testGetNonFacilitatorData() public {\n    IGhoToken.Facilitator memory data = GHO_TOKEN.getFacilitator(ALICE);\n    assertEq(data.label, '', 'Unexpected facilitator label');\n    assertEq(data.bucketCapacity, 0, 'Unexpected bucket capacity');\n    assertEq(data.bucketLevel, 0, 'Unexpected bucket level');\n  }\n\n  function testGetFacilitatorBucket() public {\n    (uint256 capacity, uint256 level) = GHO_TOKEN.getFacilitatorBucket(address(GHO_ATOKEN));\n    assertEq(capacity, DEFAULT_CAPACITY, 'Unexpected bucket capacity');\n    assertEq(level, 0, 'Unexpected bucket level');\n  }\n\n  function testGetNonFacilitatorBucket() public {\n    (uint256 capacity, uint256 level) = GHO_TOKEN.getFacilitatorBucket(ALICE);\n    assertEq(capacity, 0, 'Unexpected bucket capacity');\n    assertEq(level, 0, 'Unexpected bucket level');\n  }\n\n  function testGetPopulatedFacilitatorsList() public {\n    address[] memory facilitatorList = GHO_TOKEN.getFacilitatorsList();\n    assertEq(facilitatorList.length, 6, 'Unexpected number of facilitators');\n    assertEq(facilitatorList[0], address(GHO_ATOKEN), 'Unexpected address for mock facilitator 1');\n    assertEq(\n      facilitatorList[1],\n      address(GHO_FLASH_MINTER),\n      'Unexpected address for mock facilitator 2'\n    );\n    assertEq(\n      facilitatorList[2],\n      address(FLASH_BORROWER),\n      'Unexpected address for mock facilitator 3'\n    );\n    assertEq(facilitatorList[3], address(GHO_GSM), 'Unexpected address for mock facilitator 4');\n    assertEq(\n      facilitatorList[4],\n      address(GHO_GSM_4626),\n      'Unexpected address for mock facilitator 4'\n    );\n    assertEq(facilitatorList[5], FAUCET, 'Unexpected address for mock facilitator 5');\n  }\n\n  function testAddFacilitator() public {\n    vm.expectEmit(true, true, false, true, address(GHO_TOKEN));\n    emit FacilitatorAdded(ALICE, keccak256(abi.encodePacked('Alice')), DEFAULT_CAPACITY);\n    GHO_TOKEN.addFacilitator(ALICE, 'Alice', DEFAULT_CAPACITY);\n  }\n\n  function testAddFacilitatorWithRole() public {\n    vm.expectEmit(true, true, true, true, address(GHO_TOKEN));\n    emit RoleGranted(GHO_TOKEN_FACILITATOR_MANAGER_ROLE, ALICE, address(this));\n    GHO_TOKEN.grantRole(GHO_TOKEN_FACILITATOR_MANAGER_ROLE, ALICE);\n    vm.prank(ALICE);\n    vm.expectEmit(true, true, false, true, address(GHO_TOKEN));\n    emit FacilitatorAdded(ALICE, keccak256(abi.encodePacked('Alice')), DEFAULT_CAPACITY);\n    GHO_TOKEN.addFacilitator(ALICE, 'Alice', DEFAULT_CAPACITY);\n  }\n\n  function testRevertAddExistingFacilitator() public {\n    vm.expectRevert('FACILITATOR_ALREADY_EXISTS');\n    GHO_TOKEN.addFacilitator(address(GHO_ATOKEN), 'Aave V3 Pool', DEFAULT_CAPACITY);\n  }\n\n  function testRevertAddFacilitatorNoLabel() public {\n    vm.expectRevert('INVALID_LABEL');\n    GHO_TOKEN.addFacilitator(ALICE, '', DEFAULT_CAPACITY);\n  }\n\n  function testRevertAddFacilitatorNoRole() public {\n    vm.expectRevert(\n      AccessControlErrorsLib.MISSING_ROLE(GHO_TOKEN_FACILITATOR_MANAGER_ROLE, address(ALICE))\n    );\n    vm.prank(ALICE);\n    GHO_TOKEN.addFacilitator(ALICE, 'Alice', DEFAULT_CAPACITY);\n  }\n\n  function testRevertSetBucketCapacityNonFacilitator() public {\n    vm.expectRevert('FACILITATOR_DOES_NOT_EXIST');\n    GHO_TOKEN.setFacilitatorBucketCapacity(ALICE, DEFAULT_CAPACITY);\n  }\n\n  function testSetNewBucketCapacity() public {\n    vm.expectEmit(true, false, false, true, address(GHO_TOKEN));\n    emit FacilitatorBucketCapacityUpdated(address(GHO_ATOKEN), DEFAULT_CAPACITY, 0);\n    GHO_TOKEN.setFacilitatorBucketCapacity(address(GHO_ATOKEN), 0);\n  }\n\n  function testSetNewBucketCapacityAsManager() public {\n    vm.expectEmit(true, true, true, true, address(GHO_TOKEN));\n    emit RoleGranted(GHO_TOKEN_BUCKET_MANAGER_ROLE, ALICE, address(this));\n    GHO_TOKEN.grantRole(GHO_TOKEN_BUCKET_MANAGER_ROLE, ALICE);\n    vm.prank(ALICE);\n    vm.expectEmit(true, false, false, true, address(GHO_TOKEN));\n    emit FacilitatorBucketCapacityUpdated(address(GHO_ATOKEN), DEFAULT_CAPACITY, 0);\n    GHO_TOKEN.setFacilitatorBucketCapacity(address(GHO_ATOKEN), 0);\n  }\n\n  function testRevertSetNewBucketCapacityNoRole() public {\n    vm.expectRevert(\n      AccessControlErrorsLib.MISSING_ROLE(GHO_TOKEN_BUCKET_MANAGER_ROLE, address(ALICE))\n    );\n    vm.prank(ALICE);\n    GHO_TOKEN.setFacilitatorBucketCapacity(address(GHO_ATOKEN), 0);\n  }\n\n  function testRevertRemoveNonFacilitator() public {\n    vm.expectRevert('FACILITATOR_DOES_NOT_EXIST');\n    GHO_TOKEN.removeFacilitator(ALICE);\n  }\n\n  function testRevertRemoveFacilitatorNonZeroBucket() public {\n    ghoFaucet(ALICE, 1);\n    vm.expectRevert('FACILITATOR_BUCKET_LEVEL_NOT_ZERO');\n    GHO_TOKEN.removeFacilitator(FAUCET);\n  }\n\n  function testRemoveFacilitator() public {\n    vm.expectEmit(true, false, false, true, address(GHO_TOKEN));\n    emit FacilitatorRemoved(address(GHO_ATOKEN));\n    GHO_TOKEN.removeFacilitator(address(GHO_ATOKEN));\n  }\n\n  function testRemoveFacilitatorWithRole() public {\n    vm.expectEmit(true, true, true, true, address(GHO_TOKEN));\n    emit RoleGranted(GHO_TOKEN_FACILITATOR_MANAGER_ROLE, ALICE, address(this));\n    GHO_TOKEN.grantRole(GHO_TOKEN_FACILITATOR_MANAGER_ROLE, ALICE);\n    vm.prank(ALICE);\n    vm.expectEmit(true, false, false, true, address(GHO_TOKEN));\n    emit FacilitatorRemoved(address(GHO_ATOKEN));\n    GHO_TOKEN.removeFacilitator(address(GHO_ATOKEN));\n  }\n\n  function testRevertRemoveFacilitatorNoRole() public {\n    vm.expectRevert(\n      AccessControlErrorsLib.MISSING_ROLE(GHO_TOKEN_FACILITATOR_MANAGER_ROLE, address(ALICE))\n    );\n    vm.prank(ALICE);\n    GHO_TOKEN.removeFacilitator(address(GHO_ATOKEN));\n  }\n\n  function testRevertMintBadFacilitator() public {\n    vm.prank(ALICE);\n    vm.expectRevert('FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    GHO_TOKEN.mint(ALICE, DEFAULT_BORROW_AMOUNT);\n  }\n\n  function testRevertMintExceedCapacity() public {\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectRevert('FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    GHO_TOKEN.mint(ALICE, DEFAULT_CAPACITY + 1);\n  }\n\n  function testMint() public {\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectEmit(true, true, false, true, address(GHO_TOKEN));\n    emit Transfer(address(0), ALICE, DEFAULT_CAPACITY);\n    vm.expectEmit(true, false, false, true, address(GHO_TOKEN));\n    emit FacilitatorBucketLevelUpdated(address(GHO_ATOKEN), 0, DEFAULT_CAPACITY);\n    GHO_TOKEN.mint(ALICE, DEFAULT_CAPACITY);\n  }\n\n  function testRevertZeroMint() public {\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectRevert('INVALID_MINT_AMOUNT');\n    GHO_TOKEN.mint(ALICE, 0);\n  }\n\n  function testRevertZeroBurn() public {\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectRevert('INVALID_BURN_AMOUNT');\n    GHO_TOKEN.burn(0);\n  }\n\n  function testRevertBurnMoreThanMinted() public {\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectEmit(true, false, false, true, address(GHO_TOKEN));\n    emit FacilitatorBucketLevelUpdated(address(GHO_ATOKEN), 0, DEFAULT_CAPACITY);\n    GHO_TOKEN.mint(address(GHO_ATOKEN), DEFAULT_CAPACITY);\n\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectRevert(stdError.arithmeticError);\n    GHO_TOKEN.burn(DEFAULT_CAPACITY + 1);\n  }\n\n  function testRevertBurnOthersTokens() public {\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectEmit(true, true, false, true, address(GHO_TOKEN));\n    emit Transfer(address(0), ALICE, DEFAULT_CAPACITY);\n    vm.expectEmit(true, false, false, true, address(GHO_TOKEN));\n    emit FacilitatorBucketLevelUpdated(address(GHO_ATOKEN), 0, DEFAULT_CAPACITY);\n    GHO_TOKEN.mint(ALICE, DEFAULT_CAPACITY);\n\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectRevert(stdError.arithmeticError);\n    GHO_TOKEN.burn(DEFAULT_CAPACITY);\n  }\n\n  function testBurn() public {\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectEmit(true, true, false, true, address(GHO_TOKEN));\n    emit Transfer(address(0), address(GHO_ATOKEN), DEFAULT_CAPACITY);\n    vm.expectEmit(true, false, false, true, address(GHO_TOKEN));\n    emit FacilitatorBucketLevelUpdated(address(GHO_ATOKEN), 0, DEFAULT_CAPACITY);\n    GHO_TOKEN.mint(address(GHO_ATOKEN), DEFAULT_CAPACITY);\n\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectEmit(true, false, false, true, address(GHO_TOKEN));\n    emit FacilitatorBucketLevelUpdated(\n      address(GHO_ATOKEN),\n      DEFAULT_CAPACITY,\n      DEFAULT_CAPACITY - DEFAULT_BORROW_AMOUNT\n    );\n    GHO_TOKEN.burn(DEFAULT_BORROW_AMOUNT);\n  }\n\n  function testOffboardFacilitator() public {\n    // Onboard facilitator\n    vm.expectEmit(true, true, false, true, address(GHO_TOKEN));\n    emit FacilitatorAdded(ALICE, keccak256(abi.encodePacked('Alice')), DEFAULT_CAPACITY);\n    GHO_TOKEN.addFacilitator(ALICE, 'Alice', DEFAULT_CAPACITY);\n\n    // Facilitator mints half of its capacity\n    vm.prank(ALICE);\n    GHO_TOKEN.mint(ALICE, DEFAULT_CAPACITY / 2);\n    (uint256 bucketCapacity, uint256 bucketLevel) = GHO_TOKEN.getFacilitatorBucket(ALICE);\n    assertEq(bucketCapacity, DEFAULT_CAPACITY, 'Unexpected bucket capacity of facilitator');\n    assertEq(bucketLevel, DEFAULT_CAPACITY / 2, 'Unexpected bucket level of facilitator');\n\n    // Facilitator cannot be removed\n    vm.expectRevert('FACILITATOR_BUCKET_LEVEL_NOT_ZERO');\n    GHO_TOKEN.removeFacilitator(ALICE);\n\n    // Facilitator Bucket Capacity set to 0\n    GHO_TOKEN.setFacilitatorBucketCapacity(ALICE, 0);\n\n    // Facilitator cannot mint more and is expected to burn remaining level\n    vm.prank(ALICE);\n    vm.expectRevert('FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    GHO_TOKEN.mint(ALICE, 1);\n\n    vm.prank(ALICE);\n    GHO_TOKEN.burn(bucketLevel);\n\n    // Facilitator can be removed with 0 bucket level\n    vm.expectEmit(true, false, false, true, address(GHO_TOKEN));\n    emit FacilitatorRemoved(address(ALICE));\n    GHO_TOKEN.removeFacilitator(address(ALICE));\n  }\n\n  function testDomainSeparator() public {\n    bytes32 EIP712_DOMAIN = keccak256(\n      'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n    );\n    bytes memory EIP712_REVISION = bytes('1');\n    bytes32 expected = keccak256(\n      abi.encode(\n        EIP712_DOMAIN,\n        keccak256(bytes(GHO_TOKEN.name())),\n        keccak256(EIP712_REVISION),\n        block.chainid,\n        address(GHO_TOKEN)\n      )\n    );\n    bytes32 result = GHO_TOKEN.DOMAIN_SEPARATOR();\n    assertEq(result, expected, 'Unexpected domain separator');\n  }\n\n  function testDomainSeparatorNewChain() public {\n    vm.chainId(31338);\n    bytes32 EIP712_DOMAIN = keccak256(\n      'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n    );\n    bytes memory EIP712_REVISION = bytes('1');\n    bytes32 expected = keccak256(\n      abi.encode(\n        EIP712_DOMAIN,\n        keccak256(bytes(GHO_TOKEN.name())),\n        keccak256(EIP712_REVISION),\n        block.chainid,\n        address(GHO_TOKEN)\n      )\n    );\n    bytes32 result = GHO_TOKEN.DOMAIN_SEPARATOR();\n    assertEq(result, expected, 'Unexpected domain separator');\n  }\n\n  function testPermitAndVerifyNonce() public {\n    (address david, uint256 davidKey) = makeAddrAndKey('david');\n    ghoFaucet(david, 1e18);\n    bytes32 PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    bytes32 innerHash = keccak256(abi.encode(PERMIT_TYPEHASH, david, BOB, 1e18, 0, 1 hours));\n    bytes32 outerHash = keccak256(\n      abi.encodePacked('\\x19\\x01', GHO_TOKEN.DOMAIN_SEPARATOR(), innerHash)\n    );\n    (uint8 v, bytes32 r, bytes32 s) = vm.sign(davidKey, outerHash);\n    GHO_TOKEN.permit(david, BOB, 1e18, 1 hours, v, r, s);\n\n    assertEq(GHO_TOKEN.allowance(david, BOB), 1e18, 'Unexpected allowance');\n    assertEq(GHO_TOKEN.nonces(david), 1, 'Unexpected nonce');\n  }\n\n  function testRevertPermitInvalidSignature() public {\n    (, uint256 davidKey) = makeAddrAndKey('david');\n    bytes32 PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    bytes32 innerHash = keccak256(abi.encode(PERMIT_TYPEHASH, ALICE, BOB, 1e18, 0, 1 hours));\n    bytes32 outerHash = keccak256(\n      abi.encodePacked('\\x19\\x01', GHO_TOKEN.DOMAIN_SEPARATOR(), innerHash)\n    );\n    (uint8 v, bytes32 r, bytes32 s) = vm.sign(davidKey, outerHash);\n    vm.expectRevert(bytes('INVALID_SIGNER'));\n    GHO_TOKEN.permit(ALICE, BOB, 1e18, 1 hours, v, r, s);\n  }\n\n  function testRevertPermitInvalidDeadline() public {\n    vm.expectRevert(bytes('PERMIT_DEADLINE_EXPIRED'));\n    GHO_TOKEN.permit(ALICE, BOB, 1e18, block.timestamp - 1, 0, 0, 0);\n  }\n}\n"
    },
    "src/test/TestGhoVariableDebtToken.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGhoVariableDebtToken is TestGhoBase {\n  function setUp() public {\n    mintAndStakeDiscountToken(BOB, 10_000e18);\n  }\n\n  function testConstructor() public {\n    GhoVariableDebtToken debtToken = new GhoVariableDebtToken(IPool(address(POOL)));\n    assertEq(debtToken.name(), 'GHO_VARIABLE_DEBT_TOKEN_IMPL', 'Wrong default ERC20 name');\n    assertEq(debtToken.symbol(), 'GHO_VARIABLE_DEBT_TOKEN_IMPL', 'Wrong default ERC20 symbol');\n    assertEq(debtToken.decimals(), 0, 'Wrong default ERC20 decimals');\n  }\n\n  function testInitialize() public {\n    GhoVariableDebtToken debtToken = new GhoVariableDebtToken(IPool(address(POOL)));\n    string memory tokenName = 'Aave Variable Debt GHO';\n    string memory tokenSymbol = 'variableDebtGHO';\n    bytes memory empty;\n    debtToken.initialize(\n      IPool(address(POOL)),\n      address(GHO_TOKEN),\n      IAaveIncentivesController(address(0)),\n      18,\n      tokenName,\n      tokenSymbol,\n      empty\n    );\n\n    assertEq(debtToken.name(), tokenName, 'Wrong initialized name');\n    assertEq(debtToken.symbol(), tokenSymbol, 'Wrong initialized symbol');\n    assertEq(debtToken.decimals(), 18, 'Wrong ERC20 decimals');\n  }\n\n  function testInitializePoolRevert() public {\n    string memory tokenName = 'Aave Variable Debt GHO';\n    string memory tokenSymbol = 'variableDebtGHO';\n    bytes memory empty;\n\n    GhoVariableDebtToken debtToken = new GhoVariableDebtToken(IPool(address(POOL)));\n    vm.expectRevert(bytes(Errors.POOL_ADDRESSES_DO_NOT_MATCH));\n    debtToken.initialize(\n      IPool(address(0)),\n      address(GHO_TOKEN),\n      IAaveIncentivesController(address(0)),\n      18,\n      tokenName,\n      tokenSymbol,\n      empty\n    );\n  }\n\n  function testReInitRevert() public {\n    string memory tokenName = 'Aave Variable Debt GHO';\n    string memory tokenSymbol = 'variableDebtGHO';\n    bytes memory empty;\n\n    vm.expectRevert(bytes('Contract instance has already been initialized'));\n    GHO_DEBT_TOKEN.initialize(\n      IPool(address(POOL)),\n      address(GHO_TOKEN),\n      IAaveIncentivesController(address(0)),\n      18,\n      tokenName,\n      tokenSymbol,\n      empty\n    );\n  }\n\n  function testBorrowFixed() public {\n    borrowAction(ALICE, DEFAULT_BORROW_AMOUNT);\n  }\n\n  function testBorrowOnBehalf() public {\n    vm.prank(BOB);\n    GHO_DEBT_TOKEN.approveDelegation(ALICE, DEFAULT_BORROW_AMOUNT);\n\n    borrowActionOnBehalf(ALICE, BOB, DEFAULT_BORROW_AMOUNT);\n  }\n\n  function testBorrowFuzz(uint256 fuzzAmount) public {\n    vm.assume(fuzzAmount < 100000000000000000000000001);\n    vm.assume(fuzzAmount > 0);\n    borrowAction(ALICE, fuzzAmount);\n    assertEq(\n      GHO_DEBT_TOKEN.getBalanceFromInterest(ALICE),\n      0,\n      'Accumulated interest should be zero'\n    );\n  }\n\n  function testBorrowFixedWithDiscount() public {\n    borrowAction(BOB, DEFAULT_BORROW_AMOUNT);\n  }\n\n  function testMultipleBorrowFixedWithDiscount() public {\n    borrowAction(BOB, DEFAULT_BORROW_AMOUNT);\n    vm.warp(block.timestamp + 100000000);\n    borrowAction(BOB, 1e16);\n  }\n\n  function testBorrowMultiple() public {\n    for (uint x; x < 100; ++x) {\n      borrowAction(ALICE, DEFAULT_BORROW_AMOUNT);\n      vm.warp(block.timestamp + 2628000);\n    }\n  }\n\n  function testBorrowMultipleWithDiscount() public {\n    for (uint x; x < 100; ++x) {\n      borrowAction(BOB, DEFAULT_BORROW_AMOUNT);\n      vm.warp(block.timestamp + 2628000);\n    }\n  }\n\n  function testBorrowMultipleFuzz(uint256 fuzzAmount) public {\n    vm.assume(fuzzAmount < 1000000000000000000000000);\n    vm.assume(fuzzAmount > 0);\n\n    for (uint x; x < 10; ++x) {\n      borrowAction(ALICE, fuzzAmount);\n      vm.warp(block.timestamp + 2628000);\n    }\n  }\n\n  function testPartialMinorRepay() public {\n    uint256 partialRepayAmount = 1e7;\n\n    // Perform borrow\n    borrowAction(ALICE, DEFAULT_BORROW_AMOUNT);\n\n    vm.warp(block.timestamp + 2628000);\n\n    // Perform repayment\n    repayAction(ALICE, partialRepayAmount);\n  }\n\n  function testPartialRepay() public {\n    uint256 partialRepayAmount = 50e18;\n\n    // Perform borrow\n    borrowAction(ALICE, DEFAULT_BORROW_AMOUNT);\n\n    vm.warp(block.timestamp + 2628000);\n\n    // Perform repayment\n    repayAction(ALICE, partialRepayAmount);\n  }\n\n  function testPartialRepayDiscount() public {\n    uint256 partialRepayAmount = 50e18;\n\n    // Perform borrow\n    borrowAction(ALICE, DEFAULT_BORROW_AMOUNT);\n\n    vm.warp(block.timestamp + 2628000);\n\n    repayAction(ALICE, partialRepayAmount);\n\n    mintAndStakeDiscountToken(ALICE, 10_000e18);\n    vm.warp(block.timestamp + 2628000);\n\n    repayAction(ALICE, partialRepayAmount);\n  }\n\n  function testFullRepay() public {\n    vm.prank(ALICE);\n\n    // Perform borrow\n    borrowAction(ALICE, DEFAULT_BORROW_AMOUNT);\n\n    vm.warp(block.timestamp + 2628000);\n\n    uint256 allDebt = GHO_DEBT_TOKEN.balanceOf(ALICE);\n\n    ghoFaucet(ALICE, 1e18);\n\n    repayAction(ALICE, allDebt);\n  }\n\n  function testMultipleMinorRepay() public {\n    uint256 partialRepayAmount = 1e7;\n\n    // Perform borrow\n    borrowAction(ALICE, DEFAULT_BORROW_AMOUNT);\n\n    vm.warp(block.timestamp + 2628000);\n\n    for (uint x; x < 100; ++x) {\n      repayAction(ALICE, partialRepayAmount);\n      vm.warp(block.timestamp + 2628000);\n    }\n  }\n\n  function testMultipleRepay() public {\n    uint256 partialRepayAmount = 50e18;\n\n    // Perform borrow\n    borrowAction(ALICE, DEFAULT_BORROW_AMOUNT);\n\n    vm.warp(block.timestamp + 2628000);\n\n    for (uint x; x < 4; ++x) {\n      repayAction(ALICE, partialRepayAmount);\n      vm.warp(block.timestamp + 2628000);\n    }\n  }\n\n  function testDiscountRebalance() public {\n    mintAndStakeDiscountToken(ALICE, 10e18);\n    borrowAction(ALICE, 1000e18);\n    vm.warp(block.timestamp + 10000000000);\n\n    rebalanceDiscountAction(ALICE);\n  }\n\n  function testUnderlying() public {\n    assertEq(\n      GHO_DEBT_TOKEN.UNDERLYING_ASSET_ADDRESS(),\n      address(GHO_TOKEN),\n      'Underlying should match token'\n    );\n  }\n\n  function testGetAToken() public {\n    assertEq(\n      GHO_DEBT_TOKEN.getAToken(),\n      address(GHO_ATOKEN),\n      'AToken getter should match Gho AToken'\n    );\n  }\n\n  function testBalanceOfSameIndex() public {\n    borrowAction(ALICE, DEFAULT_BORROW_AMOUNT);\n    uint256 balanceOne = GHO_DEBT_TOKEN.balanceOf(ALICE);\n    uint256 balanceTwo = GHO_DEBT_TOKEN.balanceOf(ALICE);\n    assertEq(balanceOne, balanceTwo, 'Balance should be equal if index does not increase');\n  }\n\n  function testTransferRevert() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    GHO_DEBT_TOKEN.transfer(CHARLES, 1);\n  }\n\n  function testTransferFromRevert() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    GHO_DEBT_TOKEN.transferFrom(ALICE, CHARLES, 1);\n  }\n\n  function testApproveRevert() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    GHO_DEBT_TOKEN.approve(CHARLES, 1);\n  }\n\n  function testIncreaseAllowanceRevert() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    GHO_DEBT_TOKEN.increaseAllowance(CHARLES, 1);\n  }\n\n  function testDecreaseAllowanceRevert() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    GHO_DEBT_TOKEN.decreaseAllowance(CHARLES, 1);\n  }\n\n  function testAllowanceRevert() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.OPERATION_NOT_SUPPORTED));\n    GHO_DEBT_TOKEN.allowance(CHARLES, ALICE);\n  }\n\n  function testUnauthorizedUpdateDiscount() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes('CALLER_NOT_DISCOUNT_TOKEN'));\n    GHO_DEBT_TOKEN.updateDiscountDistribution(ALICE, ALICE, 0, 0, 0);\n  }\n\n  function testUpdateDiscount() public {\n    borrowAction(ALICE, DEFAULT_BORROW_AMOUNT);\n    borrowAction(BOB, DEFAULT_BORROW_AMOUNT);\n    vm.warp(block.timestamp + 1000);\n\n    vm.prank(address(STK_TOKEN));\n    GHO_DEBT_TOKEN.updateDiscountDistribution(ALICE, BOB, 0, 0, 0);\n  }\n\n  function testUpdateDiscountSkipComputation() public {\n    vm.record();\n    vm.prank(address(STK_TOKEN));\n    GHO_DEBT_TOKEN.updateDiscountDistribution(ALICE, BOB, 0, 0, 0);\n    (bytes32[] memory reads, ) = vm.accesses(address(GHO_DEBT_TOKEN.POOL()));\n    assertEq(reads.length, 0, 'Unexpected read of index from Pool');\n  }\n\n  function testUpdateDiscountSelfTransfer() public {\n    // Top up Alice with discount tokens\n    mintAndStakeDiscountToken(ALICE, 1e18);\n\n    // Alice mints some GHO\n    borrowAction(ALICE, DEFAULT_BORROW_AMOUNT);\n    uint256 discountPercentBefore = GHO_DEBT_TOKEN.getDiscountPercent(ALICE);\n    address discountRateStrategyBefore = GHO_DEBT_TOKEN.getDiscountRateStrategy();\n    assertTrue(discountPercentBefore > 0);\n    assertTrue(discountPercentBefore < GHO_DISCOUNT_STRATEGY.DISCOUNT_RATE());\n\n    // Alice self-transfers discount tokens\n    vm.record();\n    vm.prank(ALICE);\n    IERC20(address(STK_TOKEN)).transfer(ALICE, 1e18);\n    (, bytes32[] memory writes) = vm.accesses(address(GHO_DEBT_TOKEN));\n    assertEq(writes.length, 0);\n\n    assertEq(discountPercentBefore, GHO_DEBT_TOKEN.getDiscountPercent(ALICE));\n    assertEq(discountRateStrategyBefore, GHO_DEBT_TOKEN.getDiscountRateStrategy());\n  }\n\n  function testUpdateDiscountSelfTransferZeroAmount() public {\n    // Top up Alice with discount tokens\n    mintAndStakeDiscountToken(ALICE, 1e18);\n\n    // Alice mints some GHO\n    borrowAction(ALICE, DEFAULT_BORROW_AMOUNT);\n    uint256 discountPercentBefore = GHO_DEBT_TOKEN.getDiscountPercent(ALICE);\n    address discountRateStrategyBefore = GHO_DEBT_TOKEN.getDiscountRateStrategy();\n    assertTrue(discountPercentBefore > 0);\n    assertTrue(discountPercentBefore < GHO_DISCOUNT_STRATEGY.DISCOUNT_RATE());\n\n    // Alice self-transfers 0 discount tokens\n    vm.record();\n    vm.prank(ALICE);\n    IERC20(address(STK_TOKEN)).transfer(ALICE, 0);\n    (, bytes32[] memory writes) = vm.accesses(address(GHO_DEBT_TOKEN));\n    assertEq(writes.length, 0);\n\n    assertEq(discountPercentBefore, GHO_DEBT_TOKEN.getDiscountPercent(ALICE));\n    assertEq(discountRateStrategyBefore, GHO_DEBT_TOKEN.getDiscountRateStrategy());\n  }\n\n  function testUpdateDiscountTransferZeroAmount() public {\n    // Top up Alice with discount tokens\n    mintAndStakeDiscountToken(ALICE, 1e18);\n\n    // Alice mints some GHO\n    borrowAction(ALICE, DEFAULT_BORROW_AMOUNT);\n    uint256 discountPercentBefore = GHO_DEBT_TOKEN.getDiscountPercent(ALICE);\n    address discountRateStrategyBefore = GHO_DEBT_TOKEN.getDiscountRateStrategy();\n    assertTrue(discountPercentBefore > 0);\n    assertTrue(discountPercentBefore < GHO_DISCOUNT_STRATEGY.DISCOUNT_RATE());\n\n    // Alice transfers 0 discount tokens to BOB\n    vm.prank(ALICE);\n    IERC20(address(STK_TOKEN)).transfer(BOB, 0);\n\n    assertEq(discountPercentBefore, GHO_DEBT_TOKEN.getDiscountPercent(ALICE));\n    assertEq(discountRateStrategyBefore, GHO_DEBT_TOKEN.getDiscountRateStrategy());\n  }\n\n  function testUpdateDiscountSelfTransferFuzz(\n    uint256 debtBalance,\n    uint256 discountTokenBalance,\n    uint256 amount\n  ) public {\n    discountTokenBalance = bound(discountTokenBalance, 0, type(uint128).max);\n    debtBalance = bound(debtBalance, 1, DEFAULT_CAPACITY);\n    vm.assume(amount < discountTokenBalance);\n    // Top up Alice with discount tokens\n    mintAndStakeDiscountToken(ALICE, discountTokenBalance);\n\n    // Alice mints some GHO\n    borrowAction(ALICE, debtBalance);\n    uint256 discountPercentBefore = GHO_DEBT_TOKEN.getDiscountPercent(ALICE);\n    address discountRateStrategyBefore = GHO_DEBT_TOKEN.getDiscountRateStrategy();\n    assertTrue(discountPercentBefore <= GHO_DISCOUNT_STRATEGY.DISCOUNT_RATE());\n\n    // Alice self-transfers discount tokens\n    vm.record();\n    vm.prank(ALICE);\n    IERC20(address(STK_TOKEN)).transfer(ALICE, discountTokenBalance);\n    (, bytes32[] memory writes) = vm.accesses(address(GHO_DEBT_TOKEN));\n    assertEq(writes.length, 0);\n\n    assertEq(discountPercentBefore, GHO_DEBT_TOKEN.getDiscountPercent(ALICE));\n    assertEq(\n      discountPercentBefore,\n      GHO_DISCOUNT_STRATEGY.calculateDiscountRate(debtBalance, discountTokenBalance)\n    );\n    assertEq(discountRateStrategyBefore, GHO_DEBT_TOKEN.getDiscountRateStrategy());\n    assertTrue(GHO_DEBT_TOKEN.getDiscountPercent(ALICE) <= GHO_DISCOUNT_STRATEGY.DISCOUNT_RATE());\n  }\n\n  function testUpdateDiscountTransferBackAndForthFuzz(\n    uint256 aliceDebtBalance,\n    uint256 charlesDebtBalance,\n    uint256 aliceDiscountTokenBalance,\n    uint256 charlesDiscountTokenBalance,\n    uint256 transferAmount\n  ) public {\n    aliceDebtBalance = bound(aliceDebtBalance, 0, DEFAULT_CAPACITY);\n    charlesDebtBalance = bound(charlesDebtBalance, 0, DEFAULT_CAPACITY - aliceDebtBalance);\n    aliceDiscountTokenBalance = bound(aliceDiscountTokenBalance, 0, type(uint128).max);\n    charlesDiscountTokenBalance = bound(\n      charlesDiscountTokenBalance,\n      0,\n      type(uint128).max - aliceDiscountTokenBalance\n    );\n    vm.assume(transferAmount < aliceDiscountTokenBalance);\n\n    // Top up with discount tokens\n    if (aliceDiscountTokenBalance > 0) {\n      mintAndStakeDiscountToken(ALICE, aliceDiscountTokenBalance);\n    }\n    if (charlesDiscountTokenBalance > 0) {\n      mintAndStakeDiscountToken(CHARLES, charlesDiscountTokenBalance);\n    }\n\n    // Users borrow GHO\n    if (aliceDebtBalance > 0) {\n      borrowAction(ALICE, aliceDebtBalance);\n    }\n    if (charlesDebtBalance > 0) {\n      borrowAction(CHARLES, charlesDebtBalance);\n    }\n    uint256 aliceDiscountPercentBefore = GHO_DEBT_TOKEN.getDiscountPercent(ALICE);\n    uint256 charlesDiscountPercentBefore = GHO_DEBT_TOKEN.getDiscountPercent(CHARLES);\n    console2.log(\n      'balance',\n      GHO_DEBT_TOKEN.balanceOf(CHARLES),\n      IERC20(address(STK_TOKEN)).balanceOf(CHARLES),\n      GHO_DISCOUNT_STRATEGY.calculateDiscountRate(\n        GHO_DEBT_TOKEN.balanceOf(CHARLES),\n        IERC20(address(STK_TOKEN)).balanceOf(CHARLES)\n      )\n    );\n    assertTrue(aliceDiscountPercentBefore <= GHO_DISCOUNT_STRATEGY.DISCOUNT_RATE());\n    assertTrue(charlesDiscountPercentBefore <= GHO_DISCOUNT_STRATEGY.DISCOUNT_RATE());\n\n    // Transfer from Alice to Charles\n    vm.prank(ALICE);\n    IERC20(address(STK_TOKEN)).transfer(CHARLES, transferAmount);\n\n    assertEq(\n      GHO_DEBT_TOKEN.getDiscountPercent(ALICE),\n      GHO_DISCOUNT_STRATEGY.calculateDiscountRate(\n        aliceDebtBalance,\n        aliceDiscountTokenBalance - transferAmount\n      )\n    );\n    assertEq(\n      GHO_DEBT_TOKEN.getDiscountPercent(CHARLES),\n      GHO_DISCOUNT_STRATEGY.calculateDiscountRate(\n        charlesDebtBalance,\n        charlesDiscountTokenBalance + transferAmount\n      )\n    );\n\n    // Transfer from Charles to Alice\n    vm.prank(CHARLES);\n    IERC20(address(STK_TOKEN)).transfer(ALICE, transferAmount);\n\n    assertEq(\n      GHO_DEBT_TOKEN.getDiscountPercent(ALICE),\n      GHO_DISCOUNT_STRATEGY.calculateDiscountRate(aliceDebtBalance, aliceDiscountTokenBalance)\n    );\n    assertEq(\n      GHO_DEBT_TOKEN.getDiscountPercent(CHARLES),\n      GHO_DISCOUNT_STRATEGY.calculateDiscountRate(charlesDebtBalance, charlesDiscountTokenBalance)\n    );\n    assertEq(GHO_DEBT_TOKEN.getDiscountPercent(ALICE), aliceDiscountPercentBefore);\n    assertEq(GHO_DEBT_TOKEN.getDiscountPercent(CHARLES), charlesDiscountPercentBefore);\n  }\n\n  function testUnauthorizedDecreaseBalance() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes('CALLER_NOT_A_TOKEN'));\n    GHO_DEBT_TOKEN.decreaseBalanceFromInterest(ALICE, 1);\n  }\n\n  function testUnauthorizedMint() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes(Errors.CALLER_MUST_BE_POOL));\n    GHO_DEBT_TOKEN.mint(ALICE, ALICE, 0, 0);\n  }\n\n  function testUnauthorizedBurn() public {\n    vm.startPrank(ALICE);\n\n    vm.expectRevert(bytes(Errors.CALLER_MUST_BE_POOL));\n    GHO_DEBT_TOKEN.burn(ALICE, 0, 0);\n  }\n\n  function testRevertMintZero() public {\n    vm.prank(address(POOL));\n    vm.expectRevert(bytes(Errors.INVALID_MINT_AMOUNT));\n    GHO_DEBT_TOKEN.mint(ALICE, ALICE, 0, 1);\n  }\n\n  function testRevertBurnZero() public {\n    vm.prank(address(POOL));\n    vm.expectRevert(bytes(Errors.INVALID_BURN_AMOUNT));\n    GHO_DEBT_TOKEN.burn(ALICE, 0, 1);\n  }\n\n  function testUnauthorizedSetAToken() public {\n    GhoVariableDebtToken debtToken = new GhoVariableDebtToken(IPool(address(POOL)));\n\n    vm.startPrank(ALICE);\n    ACL_MANAGER.setState(false);\n\n    vm.expectRevert(bytes(Errors.CALLER_NOT_POOL_ADMIN));\n    debtToken.setAToken(ALICE);\n  }\n\n  function testSetAToken() public {\n    GhoVariableDebtToken debtToken = new GhoVariableDebtToken(IPool(address(POOL)));\n\n    vm.expectEmit(true, true, true, true, address(debtToken));\n    emit ATokenSet(address(GHO_ATOKEN));\n\n    debtToken.setAToken(address(GHO_ATOKEN));\n  }\n\n  function testUpdateAToken() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes('ATOKEN_ALREADY_SET'));\n    GHO_DEBT_TOKEN.setAToken(ALICE);\n  }\n\n  function testZeroAToken() public {\n    GhoVariableDebtToken debtToken = new GhoVariableDebtToken(IPool(address(POOL)));\n\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes('ZERO_ADDRESS_NOT_VALID'));\n    debtToken.setAToken(address(0));\n  }\n\n  function testUnauthorizedUpdateDiscountRateStrategy() public {\n    vm.startPrank(ALICE);\n    ACL_MANAGER.setState(false);\n\n    vm.expectRevert(bytes(Errors.CALLER_NOT_POOL_ADMIN));\n    GHO_DEBT_TOKEN.updateDiscountRateStrategy(ALICE);\n  }\n\n  function testUnauthorizedUpdateDiscountToken() public {\n    vm.startPrank(ALICE);\n    ACL_MANAGER.setState(false);\n\n    vm.expectRevert(bytes(Errors.CALLER_NOT_POOL_ADMIN));\n    GHO_DEBT_TOKEN.updateDiscountToken(ALICE);\n  }\n\n  function testUpdateDiscountTokenToZero() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(bytes('ZERO_ADDRESS_NOT_VALID'));\n    GHO_DEBT_TOKEN.updateDiscountToken(address(0));\n  }\n\n  function testUpdateDiscountStrategy() public {\n    vm.startPrank(ALICE);\n    GHO_DEBT_TOKEN.updateDiscountRateStrategy(CHARLES);\n    assertEq(\n      GHO_DEBT_TOKEN.getDiscountRateStrategy(),\n      CHARLES,\n      'Discount Rate Strategy should be updated'\n    );\n  }\n\n  function testRevertUpdateDiscountStrategyZero() public {\n    vm.startPrank(address(POOL));\n    vm.expectRevert(bytes('ZERO_ADDRESS_NOT_VALID'));\n    GHO_DEBT_TOKEN.updateDiscountRateStrategy(address(0));\n  }\n\n  function testUpdateDiscountToken() public {\n    vm.startPrank(ALICE);\n    GHO_DEBT_TOKEN.updateDiscountToken(CHARLES);\n    assertEq(GHO_DEBT_TOKEN.getDiscountToken(), CHARLES, 'Discount token should be updated');\n  }\n\n  function testUpdateDiscountTokenWithBorrow() public {\n    borrowAction(BOB, DEFAULT_BORROW_AMOUNT);\n    vm.warp(block.timestamp + 10000);\n\n    vm.startPrank(ALICE);\n    GHO_DEBT_TOKEN.updateDiscountToken(BOB);\n    assertEq(GHO_DEBT_TOKEN.getDiscountToken(), BOB, 'Discount token should be updated');\n  }\n\n  function testScaledUserBalanceAndSupply() public {\n    borrowAction(ALICE, DEFAULT_BORROW_AMOUNT);\n    borrowAction(BOB, DEFAULT_BORROW_AMOUNT);\n    (uint256 userScaledBalance, uint256 totalScaledSupply) = GHO_DEBT_TOKEN\n      .getScaledUserBalanceAndSupply(ALICE);\n    assertEq(userScaledBalance, DEFAULT_BORROW_AMOUNT, 'Unexpected user balance');\n    assertEq(totalScaledSupply, DEFAULT_BORROW_AMOUNT * 2, 'Unexpected total supply');\n  }\n}\n"
    },
    "src/test/TestGhoVariableDebtTokenForked.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {InitializableImmutableAdminUpgradeabilityProxy} from '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol';\nimport './TestGhoBase.t.sol';\n\ncontract TestGhoVariableDebtTokenForked is TestGhoBase {\n  IGhoToken gho = IGhoToken(0x40D16FC0246aD3160Ccc09B8D0D3A2cD28aE6C2f);\n  address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n  address aave = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\n  address stkAave = 0x4da27a545c0c5B758a6BA100e3a049001de870f5;\n  InitializableImmutableAdminUpgradeabilityProxy debtToken =\n    InitializableImmutableAdminUpgradeabilityProxy(\n      payable(0x786dBff3f1292ae8F92ea68Cf93c30b34B1ed04B)\n    );\n  IPool pool = IPool(0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2);\n  address admin = 0x64b761D848206f447Fe2dd461b0c635Ec39EbB27;\n\n  uint256 usdcSupplyAmount = 100_000e6;\n  uint256 ghoBorrowAmount = 71_000e18;\n  uint256 stkAaveAmount = 100_000e18;\n\n  function setUp() public {\n    vm.createSelectFork(vm.envString('ETH_RPC_URL'), 17987863);\n  }\n\n  function testBorrowAndRepayFullUnexpectedScaledBalance() public {\n    uint256 timeSkip = 86545113;\n\n    // Stake AAVE\n    deal(aave, ALICE, stkAaveAmount);\n    vm.startPrank(ALICE);\n    IERC20(aave).approve(stkAave, stkAaveAmount);\n    IStakedAaveV3(stkAave).stake(ALICE, stkAaveAmount);\n    vm.stopPrank();\n\n    // Supply USDC, borrow GHO\n    deal(usdc, ALICE, usdcSupplyAmount);\n    vm.startPrank(ALICE);\n    IERC20(usdc).approve(address(pool), usdcSupplyAmount);\n    pool.supply(usdc, usdcSupplyAmount, ALICE, 0);\n    pool.borrow(address(gho), ghoBorrowAmount, 2, 0, ALICE);\n    vm.stopPrank();\n\n    vm.warp(block.timestamp + timeSkip);\n\n    // Ensure Alice has the correct GHO balance\n    uint256 allDebt = IERC20(address(debtToken)).balanceOf(ALICE);\n    deal(address(gho), ALICE, allDebt);\n\n    // Repay in full\n    vm.startPrank(ALICE);\n    gho.approve(address(pool), type(uint256).max);\n    pool.repay(address(gho), type(uint256).max, 2, ALICE);\n    vm.stopPrank();\n\n    DataTypes.UserConfigurationMap memory userConfig = pool.getUserConfiguration(ALICE);\n    bool isBorrowing = ((userConfig.data >> (20 << 1)) & 1 != 0);\n\n    // Verify isBorrowing is false, but there is a non-zero scaledBalance\n    assertEq(isBorrowing, false, 'Unexpected borrow state');\n    assertEq(GhoAToken(address(debtToken)).scaledBalanceOf(ALICE), 1, 'Unexpected scaled balance');\n  }\n\n  function testBorrowAndRepayFullAmountUpgradeVerifyNoDust(uint256 timeSkip) public {\n    timeSkip = bound(timeSkip, 1, 31_560_000);\n    address newDebtToken = address(new GhoVariableDebtToken(pool));\n\n    // Stake AAVE\n    deal(aave, ALICE, stkAaveAmount);\n    vm.startPrank(ALICE);\n    IERC20(aave).approve(stkAave, stkAaveAmount);\n    IStakedAaveV3(stkAave).stake(ALICE, stkAaveAmount);\n    vm.stopPrank();\n\n    // Supply USDC, borrow GHO\n    deal(usdc, ALICE, usdcSupplyAmount);\n    vm.startPrank(ALICE);\n    IERC20(usdc).approve(address(pool), usdcSupplyAmount);\n    pool.supply(usdc, usdcSupplyAmount, ALICE, 0);\n    pool.borrow(address(gho), ghoBorrowAmount, 2, 0, ALICE);\n    vm.stopPrank();\n\n    // Upgrade GhoVariableDebtToken\n    vm.prank(admin);\n    debtToken.upgradeTo(newDebtToken);\n\n    vm.warp(block.timestamp + timeSkip);\n\n    // Ensure Alice has the correct GHO balance\n    uint256 allDebt = IERC20(address(debtToken)).balanceOf(ALICE);\n    deal(address(gho), ALICE, allDebt);\n\n    // Repay in full\n    vm.startPrank(ALICE);\n    gho.approve(address(pool), type(uint256).max);\n    pool.repay(address(gho), type(uint256).max, 2, ALICE);\n    vm.stopPrank();\n\n    DataTypes.UserConfigurationMap memory userConfig = pool.getUserConfiguration(ALICE);\n    bool isBorrowing = ((userConfig.data >> (20 << 1)) & 1 != 0);\n\n    // Ensure isBorrowing is false and the scaledBalance never exceeds zero\n    assertEq(isBorrowing, false, 'Unexpected borrow state');\n    assertEq(GhoAToken(address(debtToken)).scaledBalanceOf(ALICE), 0, 'Unexpected scaled balance');\n  }\n}\n"
    },
    "src/test/TestGsm.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGsm is TestGhoBase {\n  using PercentageMath for uint256;\n  using PercentageMath for uint128;\n\n  address internal gsmSignerAddr;\n  uint256 internal gsmSignerKey;\n\n  function setUp() public {\n    (gsmSignerAddr, gsmSignerKey) = makeAddrAndKey('gsmSigner');\n  }\n\n  function testConstructor() public {\n    Gsm gsm = new Gsm(\n      address(GHO_TOKEN),\n      address(USDC_TOKEN),\n      address(GHO_GSM_FIXED_PRICE_STRATEGY)\n    );\n    assertEq(gsm.GHO_TOKEN(), address(GHO_TOKEN), 'Unexpected GHO token address');\n    assertEq(gsm.UNDERLYING_ASSET(), address(USDC_TOKEN), 'Unexpected underlying asset address');\n    assertEq(\n      gsm.PRICE_STRATEGY(),\n      address(GHO_GSM_FIXED_PRICE_STRATEGY),\n      'Unexpected price strategy'\n    );\n    assertEq(gsm.getExposureCap(), 0, 'Unexpected exposure capacity');\n  }\n\n  function testRevertConstructorInvalidPriceStrategy() public {\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(1e18, address(GHO_TOKEN), 18);\n    vm.expectRevert('INVALID_PRICE_STRATEGY');\n    new Gsm(address(GHO_TOKEN), address(USDC_TOKEN), address(newPriceStrategy));\n  }\n\n  function testRevertConstructorZeroAddressParams() public {\n    vm.expectRevert('ZERO_ADDRESS_NOT_VALID');\n    new Gsm(address(0), address(USDC_TOKEN), address(GHO_GSM_FIXED_PRICE_STRATEGY));\n\n    vm.expectRevert('ZERO_ADDRESS_NOT_VALID');\n    new Gsm(address(GHO_TOKEN), address(0), address(GHO_GSM_FIXED_PRICE_STRATEGY));\n  }\n\n  function testInitialize() public {\n    Gsm gsm = new Gsm(\n      address(GHO_TOKEN),\n      address(USDC_TOKEN),\n      address(GHO_GSM_FIXED_PRICE_STRATEGY)\n    );\n    vm.expectEmit(true, true, true, true);\n    emit RoleGranted(DEFAULT_ADMIN_ROLE, address(this), address(this));\n    vm.expectEmit(true, true, false, true);\n    emit GhoTreasuryUpdated(address(0), address(TREASURY));\n    vm.expectEmit(true, true, false, true);\n    emit ExposureCapUpdated(0, DEFAULT_GSM_USDC_EXPOSURE);\n    gsm.initialize(address(this), TREASURY, DEFAULT_GSM_USDC_EXPOSURE);\n    assertEq(gsm.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure capacity');\n  }\n\n  function testRevertInitializeZeroAdmin() public {\n    Gsm gsm = new Gsm(\n      address(GHO_TOKEN),\n      address(USDC_TOKEN),\n      address(GHO_GSM_FIXED_PRICE_STRATEGY)\n    );\n    vm.expectRevert('ZERO_ADDRESS_NOT_VALID');\n    gsm.initialize(address(0), TREASURY, DEFAULT_GSM_USDC_EXPOSURE);\n  }\n\n  function testRevertInitializeTwice() public {\n    Gsm gsm = new Gsm(\n      address(GHO_TOKEN),\n      address(USDC_TOKEN),\n      address(GHO_GSM_FIXED_PRICE_STRATEGY)\n    );\n    gsm.initialize(address(this), TREASURY, DEFAULT_GSM_USDC_EXPOSURE);\n    vm.expectRevert('Contract instance has already been initialized');\n    gsm.initialize(address(this), TREASURY, DEFAULT_GSM_USDC_EXPOSURE);\n  }\n\n  function testSellAssetZeroFee() public {\n    vm.expectEmit(true, true, false, true, address(GHO_GSM));\n    emit FeeStrategyUpdated(address(GHO_GSM_FIXED_FEE_STRATEGY), address(0));\n    GHO_GSM.updateFeeStrategy(address(0));\n\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, 0);\n    (uint256 assetAmount, uint256 ghoBought) = GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    assertEq(ghoBought, DEFAULT_GSM_GHO_AMOUNT, 'Unexpected GHO amount bought');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected asset amount sold');\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), DEFAULT_GSM_GHO_AMOUNT, 'Unexpected final GHO balance');\n    assertEq(GHO_GSM.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure capacity');\n  }\n\n  function testSellAsset() public {\n    uint256 fee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 ghoOut = DEFAULT_GSM_GHO_AMOUNT - fee;\n\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, fee);\n    (uint256 assetAmount, uint256 ghoBought) = GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    assertEq(ghoBought, DEFAULT_GSM_GHO_AMOUNT - fee, 'Unexpected GHO amount bought');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected asset amount sold');\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), fee, 'Unexpected GSM GHO balance');\n    assertEq(\n      GHO_GSM.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(\n      GHO_GSM.getAvailableLiquidity(),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available liquidity'\n    );\n    assertEq(GHO_GSM.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure capacity');\n  }\n\n  function testSellAssetSendToOther() public {\n    uint256 fee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 ghoOut = DEFAULT_GSM_GHO_AMOUNT - fee;\n\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(ALICE, BOB, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, fee);\n    (uint256 assetAmount, uint256 ghoBought) = GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n    vm.stopPrank();\n\n    assertEq(ghoBought, DEFAULT_GSM_GHO_AMOUNT - fee, 'Unexpected GHO amount bought');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected asset amount sold');\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), 0, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(BOB), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), fee, 'Unexpected GSM GHO balance');\n    assertEq(GHO_GSM.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure capacity');\n  }\n\n  function testSellAssetWithSig() public {\n    uint256 deadline = block.timestamp + 1 hours;\n    uint256 fee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 ghoOut = DEFAULT_GSM_GHO_AMOUNT - fee;\n\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(gsmSignerAddr, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.prank(gsmSignerAddr);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n\n    assertEq(GHO_GSM.nonces(gsmSignerAddr), 0, 'Unexpected before gsmSignerAddr nonce');\n\n    bytes32 digest = keccak256(\n      abi.encode(\n        '\\x19\\x01',\n        GHO_GSM.DOMAIN_SEPARATOR(),\n        GSM_SELL_ASSET_WITH_SIG_TYPEHASH,\n        abi.encode(\n          gsmSignerAddr,\n          DEFAULT_GSM_USDC_AMOUNT,\n          gsmSignerAddr,\n          GHO_GSM.nonces(gsmSignerAddr),\n          deadline\n        )\n      )\n    );\n    (uint8 v, bytes32 r, bytes32 s) = vm.sign(gsmSignerKey, digest);\n    bytes memory signature = abi.encodePacked(r, s, v);\n\n    assertTrue(gsmSignerAddr != ALICE, 'Signer is the same as Alice');\n\n    // Send the signature via another user\n    vm.prank(ALICE);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(\n      gsmSignerAddr,\n      gsmSignerAddr,\n      DEFAULT_GSM_USDC_AMOUNT,\n      DEFAULT_GSM_GHO_AMOUNT,\n      fee\n    );\n    GHO_GSM.sellAssetWithSig(\n      gsmSignerAddr,\n      DEFAULT_GSM_USDC_AMOUNT,\n      gsmSignerAddr,\n      deadline,\n      signature\n    );\n\n    assertEq(GHO_GSM.nonces(gsmSignerAddr), 1, 'Unexpected final gsmSignerAddr nonce');\n    assertEq(USDC_TOKEN.balanceOf(gsmSignerAddr), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(gsmSignerAddr), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), fee, 'Unexpected GSM GHO balance');\n    assertEq(GHO_GSM.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure capacity');\n  }\n\n  function testSellAssetWithSigExactDeadline() public {\n    // EIP-2612 states the execution must be allowed in case deadline is equal to block.timestamp\n    uint256 deadline = block.timestamp;\n    uint256 fee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 ghoOut = DEFAULT_GSM_GHO_AMOUNT - fee;\n\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(gsmSignerAddr, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.prank(gsmSignerAddr);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n\n    assertEq(GHO_GSM.nonces(gsmSignerAddr), 0, 'Unexpected before gsmSignerAddr nonce');\n\n    bytes32 digest = keccak256(\n      abi.encode(\n        '\\x19\\x01',\n        GHO_GSM.DOMAIN_SEPARATOR(),\n        GSM_SELL_ASSET_WITH_SIG_TYPEHASH,\n        abi.encode(\n          gsmSignerAddr,\n          DEFAULT_GSM_USDC_AMOUNT,\n          gsmSignerAddr,\n          GHO_GSM.nonces(gsmSignerAddr),\n          deadline\n        )\n      )\n    );\n    (uint8 v, bytes32 r, bytes32 s) = vm.sign(gsmSignerKey, digest);\n    bytes memory signature = abi.encodePacked(r, s, v);\n\n    assertTrue(gsmSignerAddr != ALICE, 'Signer is the same as Alice');\n\n    // Send the signature via another user\n    vm.prank(ALICE);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(\n      gsmSignerAddr,\n      gsmSignerAddr,\n      DEFAULT_GSM_USDC_AMOUNT,\n      DEFAULT_GSM_GHO_AMOUNT,\n      fee\n    );\n    GHO_GSM.sellAssetWithSig(\n      gsmSignerAddr,\n      DEFAULT_GSM_USDC_AMOUNT,\n      gsmSignerAddr,\n      deadline,\n      signature\n    );\n\n    assertEq(GHO_GSM.nonces(gsmSignerAddr), 1, 'Unexpected final gsmSignerAddr nonce');\n    assertEq(USDC_TOKEN.balanceOf(gsmSignerAddr), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(gsmSignerAddr), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), fee, 'Unexpected GSM GHO balance');\n    assertEq(GHO_GSM.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure capacity');\n  }\n\n  function testRevertSellAssetWithSigExpiredSignature() public {\n    uint256 deadline = block.timestamp - 1;\n\n    bytes32 digest = keccak256(\n      abi.encode(\n        '\\x19\\x01',\n        GHO_GSM.DOMAIN_SEPARATOR(),\n        GSM_SELL_ASSET_WITH_SIG_TYPEHASH,\n        abi.encode(\n          gsmSignerAddr,\n          DEFAULT_GSM_USDC_AMOUNT,\n          gsmSignerAddr,\n          GHO_GSM.nonces(gsmSignerAddr),\n          deadline\n        )\n      )\n    );\n    (uint8 v, bytes32 r, bytes32 s) = vm.sign(gsmSignerKey, digest);\n    bytes memory signature = abi.encodePacked(r, s, v);\n\n    assertTrue(gsmSignerAddr != ALICE, 'Signer is the same as Alice');\n\n    // Send the signature via another user\n    vm.prank(ALICE);\n    vm.expectRevert('SIGNATURE_DEADLINE_EXPIRED');\n    GHO_GSM.sellAssetWithSig(\n      gsmSignerAddr,\n      DEFAULT_GSM_USDC_AMOUNT,\n      gsmSignerAddr,\n      deadline,\n      signature\n    );\n  }\n\n  function testRevertSellAssetWithSigInvalidSignature() public {\n    uint256 deadline = block.timestamp + 1 hours;\n\n    bytes32 digest = keccak256(\n      abi.encode(\n        '\\x19\\x01',\n        GHO_GSM.DOMAIN_SEPARATOR(),\n        GSM_SELL_ASSET_WITH_SIG_TYPEHASH,\n        abi.encode(\n          gsmSignerAddr,\n          DEFAULT_GSM_USDC_AMOUNT,\n          gsmSignerAddr,\n          GHO_GSM.nonces(gsmSignerAddr),\n          deadline\n        )\n      )\n    );\n    (uint8 v, bytes32 r, bytes32 s) = vm.sign(gsmSignerKey, digest);\n    bytes memory signature = abi.encodePacked(r, s, v);\n\n    assertTrue(gsmSignerAddr != ALICE, 'Signer is the same as Alice');\n\n    // Send the signature via another user\n    vm.prank(ALICE);\n    vm.expectRevert('SIGNATURE_INVALID');\n    GHO_GSM.sellAssetWithSig(ALICE, DEFAULT_GSM_USDC_AMOUNT, ALICE, deadline, signature);\n  }\n\n  function testRevertSellAssetZeroAmount() public {\n    vm.prank(ALICE);\n    vm.expectRevert('INVALID_AMOUNT');\n    GHO_GSM.sellAsset(0, ALICE);\n  }\n\n  function testRevertSellAssetNoAsset() public {\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectRevert('ERC20: transfer amount exceeds balance');\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n  }\n\n  function testRevertSellAssetNoAllowance() public {\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.prank(ALICE);\n    vm.expectRevert('ERC20: transfer amount exceeds allowance');\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n  }\n\n  function testRevertSellAssetNoBucketCap() public {\n    Gsm gsm = new Gsm(\n      address(GHO_TOKEN),\n      address(USDC_TOKEN),\n      address(GHO_GSM_FIXED_PRICE_STRATEGY)\n    );\n    gsm.initialize(address(this), TREASURY, DEFAULT_GSM_USDC_EXPOSURE);\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM Modified Bucket Cap', DEFAULT_CAPACITY - 1);\n    uint256 defaultCapInUsdc = DEFAULT_CAPACITY / (10 ** (18 - USDC_TOKEN.decimals()));\n\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, defaultCapInUsdc);\n\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(gsm), defaultCapInUsdc);\n    vm.expectRevert('FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    gsm.sellAsset(defaultCapInUsdc, ALICE);\n    vm.stopPrank();\n  }\n\n  function testRevertSellAssetTooMuchUnderlyingExposure() public {\n    Gsm gsm = new Gsm(\n      address(GHO_TOKEN),\n      address(USDC_TOKEN),\n      address(GHO_GSM_FIXED_PRICE_STRATEGY)\n    );\n    gsm.initialize(address(this), TREASURY, DEFAULT_GSM_USDC_EXPOSURE - 1);\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM Modified Exposure Cap', DEFAULT_CAPACITY);\n\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_EXPOSURE);\n\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(gsm), DEFAULT_GSM_USDC_EXPOSURE);\n    vm.expectRevert('EXOGENOUS_ASSET_EXPOSURE_TOO_HIGH');\n    gsm.sellAsset(DEFAULT_GSM_USDC_EXPOSURE, ALICE);\n    vm.stopPrank();\n  }\n\n  function testGetGhoAmountForSellAsset() public {\n    (uint256 exactAssetAmount, uint256 ghoBought, uint256 grossAmount, uint256 fee) = GHO_GSM\n      .getGhoAmountForSellAsset(DEFAULT_GSM_USDC_AMOUNT);\n\n    _sellAsset(GHO_GSM, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    assertEq(\n      DEFAULT_GSM_USDC_AMOUNT - USDC_TOKEN.balanceOf(ALICE),\n      exactAssetAmount,\n      'Unexpected asset amount sold'\n    );\n    assertEq(ghoBought + fee, grossAmount, 'Unexpected GHO gross amount');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoBought, 'Unexpected GHO bought amount');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), fee, 'Unexpected GHO fee amount');\n\n    (uint256 assetAmount, uint256 exactGhoBought, uint256 grossAmount2, uint256 fee2) = GHO_GSM\n      .getAssetAmountForSellAsset(ghoBought);\n    assertEq(GHO_TOKEN.balanceOf(ALICE), exactGhoBought, 'Unexpected GHO bought amount');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected estimation of sold assets');\n    assertEq(grossAmount, grossAmount2, 'Unexpected GHO gross amount');\n    assertEq(fee, fee2, 'Unexpected GHO fee amount');\n  }\n\n  function testGetGhoAmountForSellAssetWithZeroFee() public {\n    GHO_GSM.updateFeeStrategy(address(0));\n\n    (uint256 exactAssetAmount, uint256 ghoBought, uint256 grossAmount, uint256 fee) = GHO_GSM\n      .getGhoAmountForSellAsset(DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(fee, 0, 'Unexpected GHO fee amount');\n\n    _sellAsset(GHO_GSM, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    assertEq(\n      DEFAULT_GSM_USDC_AMOUNT - USDC_TOKEN.balanceOf(ALICE),\n      exactAssetAmount,\n      'Unexpected asset amount sold'\n    );\n    assertEq(ghoBought, grossAmount, 'Unexpected GHO gross amount');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoBought, 'Unexpected GHO bought amount');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), 0, 'Unexpected GHO fee amount');\n\n    (uint256 assetAmount, uint256 exactGhoBought, uint256 grossAmount2, uint256 fee2) = GHO_GSM\n      .getAssetAmountForSellAsset(ghoBought);\n    assertEq(GHO_TOKEN.balanceOf(ALICE), exactGhoBought, 'Unexpected GHO bought amount');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected estimation of sold assets');\n    assertEq(grossAmount, grossAmount2, 'Unexpected GHO gross amount');\n    assertEq(fee, fee2, 'Unexpected GHO fee amount');\n  }\n\n  function testGetGhoAmountForSellAssetWithZeroAmount() public {\n    (uint256 exactAssetAmount, uint256 ghoBought, uint256 grossAmount, uint256 fee) = GHO_GSM\n      .getGhoAmountForSellAsset(0);\n    assertEq(exactAssetAmount, 0, 'Unexpected exact asset amount');\n    assertEq(ghoBought, 0, 'Unexpected GHO bought amount');\n    assertEq(grossAmount, 0, 'Unexpected GHO gross amount');\n    assertEq(fee, 0, 'Unexpected GHO fee amount');\n\n    (uint256 assetAmount, uint256 exactGhoBought, uint256 grossAmount2, uint256 fee2) = GHO_GSM\n      .getAssetAmountForSellAsset(ghoBought);\n    assertEq(exactGhoBought, 0, 'Unexpected exact gho bought');\n    assertEq(assetAmount, 0, 'Unexpected estimation of sold assets');\n    assertEq(grossAmount, grossAmount2, 'Unexpected GHO gross amount');\n    assertEq(fee, fee2, 'Unexpected GHO fee amount');\n  }\n\n  function testBuyAssetZeroFee() public {\n    vm.expectEmit(true, true, false, true, address(GHO_GSM));\n    emit FeeStrategyUpdated(address(GHO_GSM_FIXED_FEE_STRATEGY), address(0));\n    GHO_GSM.updateFeeStrategy(address(0));\n\n    // Supply assets to the GSM first\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, 0);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    // Buy assets as another user\n    ghoFaucet(BOB, DEFAULT_GSM_GHO_AMOUNT);\n    vm.startPrank(BOB);\n    GHO_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_GHO_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit BuyAsset(BOB, BOB, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, 0);\n    (uint256 assetAmount, uint256 ghoSold) = GHO_GSM.buyAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n    vm.stopPrank();\n\n    assertEq(ghoSold, DEFAULT_GSM_GHO_AMOUNT, 'Unexpected GHO amount sold');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected asset amount bought');\n    assertEq(USDC_TOKEN.balanceOf(BOB), DEFAULT_GSM_USDC_AMOUNT, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), DEFAULT_GSM_GHO_AMOUNT, 'Unexpected final GHO balance');\n    assertEq(GHO_GSM.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure capacity');\n  }\n\n  function testBuyAsset() public {\n    uint256 sellFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 buyFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_BUY_FEE);\n    uint256 ghoOut = DEFAULT_GSM_GHO_AMOUNT - sellFee;\n\n    // Supply assets to the GSM first\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, sellFee);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    // Buy assets as another user\n    ghoFaucet(BOB, DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.startPrank(BOB);\n    GHO_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit BuyAsset(BOB, BOB, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT + buyFee, buyFee);\n    (uint256 assetAmount, uint256 ghoSold) = GHO_GSM.buyAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n    vm.stopPrank();\n\n    assertEq(ghoSold, DEFAULT_GSM_GHO_AMOUNT + buyFee, 'Unexpected GHO amount sold');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected asset amount bought');\n    assertEq(USDC_TOKEN.balanceOf(BOB), DEFAULT_GSM_USDC_AMOUNT, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), sellFee + buyFee, 'Unexpected GSM GHO balance');\n    assertEq(\n      GHO_GSM.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(GHO_GSM.getAvailableLiquidity(), 0, 'Unexpected available liquidity');\n    assertEq(GHO_GSM.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure capacity');\n  }\n\n  function testBuyAssetSendToOther() public {\n    uint256 sellFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 buyFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_BUY_FEE);\n    uint256 ghoOut = DEFAULT_GSM_GHO_AMOUNT - sellFee;\n\n    // Supply assets to the GSM first\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, sellFee);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    // Buy assets as another user\n    ghoFaucet(BOB, DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.startPrank(BOB);\n    GHO_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit BuyAsset(BOB, CHARLES, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT + buyFee, buyFee);\n    (uint256 assetAmount, uint256 ghoSold) = GHO_GSM.buyAsset(DEFAULT_GSM_USDC_AMOUNT, CHARLES);\n    vm.stopPrank();\n\n    assertEq(ghoSold, DEFAULT_GSM_GHO_AMOUNT + buyFee, 'Unexpected GHO amount sold');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected asset amount bought');\n    assertEq(USDC_TOKEN.balanceOf(BOB), 0, 'Unexpected final USDC balance');\n    assertEq(\n      USDC_TOKEN.balanceOf(CHARLES),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected final USDC balance'\n    );\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), sellFee + buyFee, 'Unexpected GSM GHO balance');\n    assertEq(GHO_GSM.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure capacity');\n  }\n\n  function testBuyAssetWithSig() public {\n    uint256 deadline = block.timestamp + 1 hours;\n    uint256 sellFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 buyFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_BUY_FEE);\n    uint256 ghoOut = DEFAULT_GSM_GHO_AMOUNT - sellFee;\n\n    // Supply assets to the GSM first\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, sellFee);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    assertTrue(gsmSignerAddr != ALICE, 'Signer is the same as Alice');\n\n    // Buy assets as another user\n    ghoFaucet(gsmSignerAddr, DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.prank(gsmSignerAddr);\n    GHO_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_GHO_AMOUNT + buyFee);\n\n    assertEq(GHO_GSM.nonces(gsmSignerAddr), 0, 'Unexpected before gsmSignerAddr nonce');\n\n    bytes32 digest = keccak256(\n      abi.encode(\n        '\\x19\\x01',\n        GHO_GSM.DOMAIN_SEPARATOR(),\n        GSM_BUY_ASSET_WITH_SIG_TYPEHASH,\n        abi.encode(\n          gsmSignerAddr,\n          DEFAULT_GSM_USDC_AMOUNT,\n          gsmSignerAddr,\n          GHO_GSM.nonces(gsmSignerAddr),\n          deadline\n        )\n      )\n    );\n    (uint8 v, bytes32 r, bytes32 s) = vm.sign(gsmSignerKey, digest);\n    bytes memory signature = abi.encodePacked(r, s, v);\n\n    assertTrue(gsmSignerAddr != BOB, 'Signer is the same as Bob');\n\n    vm.prank(BOB);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit BuyAsset(\n      gsmSignerAddr,\n      gsmSignerAddr,\n      DEFAULT_GSM_USDC_AMOUNT,\n      DEFAULT_GSM_GHO_AMOUNT + buyFee,\n      buyFee\n    );\n    GHO_GSM.buyAssetWithSig(\n      gsmSignerAddr,\n      DEFAULT_GSM_USDC_AMOUNT,\n      gsmSignerAddr,\n      deadline,\n      signature\n    );\n\n    assertEq(GHO_GSM.nonces(gsmSignerAddr), 1, 'Unexpected final gsmSignerAddr nonce');\n    assertEq(\n      USDC_TOKEN.balanceOf(gsmSignerAddr),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected final USDC balance'\n    );\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), sellFee + buyFee, 'Unexpected GSM GHO balance');\n    assertEq(GHO_GSM.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure capacity');\n  }\n\n  function testBuyAssetWithSigExactDeadline() public {\n    // EIP-2612 states the execution must be allowed in case deadline is equal to block.timestamp\n    uint256 deadline = block.timestamp;\n    uint256 sellFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 buyFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_BUY_FEE);\n    uint256 ghoOut = DEFAULT_GSM_GHO_AMOUNT - sellFee;\n\n    // Supply assets to the GSM first\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, sellFee);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    assertTrue(gsmSignerAddr != ALICE, 'Signer is the same as Alice');\n\n    // Buy assets as another user\n    ghoFaucet(gsmSignerAddr, DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.prank(gsmSignerAddr);\n    GHO_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_GHO_AMOUNT + buyFee);\n\n    assertEq(GHO_GSM.nonces(gsmSignerAddr), 0, 'Unexpected before gsmSignerAddr nonce');\n\n    bytes32 digest = keccak256(\n      abi.encode(\n        '\\x19\\x01',\n        GHO_GSM.DOMAIN_SEPARATOR(),\n        GSM_BUY_ASSET_WITH_SIG_TYPEHASH,\n        abi.encode(\n          gsmSignerAddr,\n          DEFAULT_GSM_USDC_AMOUNT,\n          gsmSignerAddr,\n          GHO_GSM.nonces(gsmSignerAddr),\n          deadline\n        )\n      )\n    );\n    (uint8 v, bytes32 r, bytes32 s) = vm.sign(gsmSignerKey, digest);\n    bytes memory signature = abi.encodePacked(r, s, v);\n\n    assertTrue(gsmSignerAddr != BOB, 'Signer is the same as Bob');\n\n    vm.prank(BOB);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit BuyAsset(\n      gsmSignerAddr,\n      gsmSignerAddr,\n      DEFAULT_GSM_USDC_AMOUNT,\n      DEFAULT_GSM_GHO_AMOUNT + buyFee,\n      buyFee\n    );\n    GHO_GSM.buyAssetWithSig(\n      gsmSignerAddr,\n      DEFAULT_GSM_USDC_AMOUNT,\n      gsmSignerAddr,\n      deadline,\n      signature\n    );\n\n    assertEq(GHO_GSM.nonces(gsmSignerAddr), 1, 'Unexpected final gsmSignerAddr nonce');\n    assertEq(\n      USDC_TOKEN.balanceOf(gsmSignerAddr),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected final USDC balance'\n    );\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), sellFee + buyFee, 'Unexpected GSM GHO balance');\n    assertEq(GHO_GSM.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure capacity');\n  }\n\n  function testBuyThenSellAtMaximumBucketCapacity() public {\n    // Use zero fees to simplify amount calculations\n    vm.expectEmit(true, true, false, true, address(GHO_GSM));\n    emit FeeStrategyUpdated(address(GHO_GSM_FIXED_FEE_STRATEGY), address(0));\n    GHO_GSM.updateFeeStrategy(address(0));\n\n    // Supply assets to the GSM first\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_EXPOSURE);\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_EXPOSURE);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_EXPOSURE, DEFAULT_CAPACITY, 0);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_EXPOSURE, ALICE);\n\n    (uint256 ghoCapacity, uint256 ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM));\n    assertEq(ghoLevel, ghoCapacity, 'Unexpected GHO bucket level after initial sell');\n    assertEq(\n      GHO_TOKEN.balanceOf(ALICE),\n      DEFAULT_CAPACITY,\n      'Unexpected Alice GHO balance after sell'\n    );\n\n    // Buy 1 of the underlying\n    GHO_TOKEN.approve(address(GHO_GSM), 1e18);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit BuyAsset(ALICE, ALICE, 1e6, 1e18, 0);\n    GHO_GSM.buyAsset(1e6, ALICE);\n\n    (, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM));\n    assertEq(ghoLevel, DEFAULT_CAPACITY - 1e18, 'Unexpected GHO bucket level after buy');\n    assertEq(\n      GHO_TOKEN.balanceOf(ALICE),\n      DEFAULT_CAPACITY - 1e18,\n      'Unexpected Alice GHO balance after buy'\n    );\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 1e6, 'Unexpected Alice USDC balance after buy');\n\n    // Sell 1 of the underlying\n    USDC_TOKEN.approve(address(GHO_GSM), 1e6);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(ALICE, ALICE, 1e6, 1e18, 0);\n    GHO_GSM.sellAsset(1e6, ALICE);\n    vm.stopPrank();\n\n    (ghoCapacity, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM));\n    assertEq(ghoLevel, ghoCapacity, 'Unexpected GHO bucket level after second sell');\n    assertEq(\n      GHO_TOKEN.balanceOf(ALICE),\n      DEFAULT_CAPACITY,\n      'Unexpected Alice GHO balance after second sell'\n    );\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 0, 'Unexpected Alice USDC balance after second sell');\n    assertEq(GHO_GSM.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure capacity');\n  }\n\n  function testRevertBuyAssetWithSigExpiredSignature() public {\n    uint256 deadline = block.timestamp - 1;\n\n    bytes32 digest = keccak256(\n      abi.encode(\n        '\\x19\\x01',\n        GHO_GSM.DOMAIN_SEPARATOR(),\n        GSM_BUY_ASSET_WITH_SIG_TYPEHASH,\n        abi.encode(\n          gsmSignerAddr,\n          DEFAULT_GSM_USDC_AMOUNT,\n          gsmSignerAddr,\n          GHO_GSM.nonces(gsmSignerAddr),\n          deadline\n        )\n      )\n    );\n    (uint8 v, bytes32 r, bytes32 s) = vm.sign(gsmSignerKey, digest);\n    bytes memory signature = abi.encodePacked(r, s, v);\n\n    assertTrue(gsmSignerAddr != BOB, 'Signer is the same as Bob');\n\n    vm.prank(BOB);\n    vm.expectRevert('SIGNATURE_DEADLINE_EXPIRED');\n    GHO_GSM.buyAssetWithSig(\n      gsmSignerAddr,\n      DEFAULT_GSM_USDC_AMOUNT,\n      gsmSignerAddr,\n      deadline,\n      signature\n    );\n  }\n\n  function testRevertBuyAssetWithSigInvalidSignature() public {\n    uint256 deadline = block.timestamp + 1 hours;\n\n    bytes32 digest = keccak256(\n      abi.encode(\n        '\\x19\\x01',\n        GHO_GSM.DOMAIN_SEPARATOR(),\n        GSM_BUY_ASSET_WITH_SIG_TYPEHASH,\n        abi.encode(\n          gsmSignerAddr,\n          DEFAULT_GSM_USDC_AMOUNT,\n          gsmSignerAddr,\n          GHO_GSM.nonces(gsmSignerAddr),\n          deadline\n        )\n      )\n    );\n    (uint8 v, bytes32 r, bytes32 s) = vm.sign(gsmSignerKey, digest);\n    bytes memory signature = abi.encodePacked(r, s, v);\n\n    assertTrue(gsmSignerAddr != BOB, 'Signer is the same as Bob');\n\n    vm.prank(BOB);\n    vm.expectRevert('SIGNATURE_INVALID');\n    GHO_GSM.buyAssetWithSig(BOB, DEFAULT_GSM_USDC_AMOUNT, gsmSignerAddr, deadline, signature);\n  }\n\n  function testRevertBuyAssetZeroAmount() public {\n    vm.prank(ALICE);\n    vm.expectRevert('INVALID_AMOUNT');\n    GHO_GSM.buyAsset(0, ALICE);\n  }\n\n  function testRevertBuyAssetNoGHO() public {\n    uint256 sellFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 buyFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_BUY_FEE);\n\n    // Supply assets to the GSM first\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, sellFee);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    vm.startPrank(BOB);\n    GHO_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.expectRevert(stdError.arithmeticError);\n    GHO_GSM.buyAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n    vm.stopPrank();\n  }\n\n  function testRevertBuyAssetNoAllowance() public {\n    uint256 sellFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 buyFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_BUY_FEE);\n\n    // Supply assets to the GSM first\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, sellFee);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    ghoFaucet(BOB, DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.startPrank(BOB);\n    vm.expectRevert(stdError.arithmeticError);\n    GHO_GSM.buyAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n    vm.stopPrank();\n  }\n\n  function testGetGhoAmountForBuyAsset() public {\n    (uint256 exactAssetAmount, uint256 ghoSold, uint256 grossAmount, uint256 fee) = GHO_GSM\n      .getGhoAmountForBuyAsset(DEFAULT_GSM_USDC_AMOUNT);\n\n    uint256 topUpAmount = 1_000_000e18;\n    ghoFaucet(ALICE, topUpAmount);\n\n    _sellAsset(GHO_GSM, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    uint256 ghoBalanceBefore = GHO_TOKEN.balanceOf(ALICE);\n    uint256 ghoFeesBefore = GHO_TOKEN.balanceOf(address(GHO_GSM));\n\n    vm.startPrank(ALICE);\n    GHO_TOKEN.approve(address(GHO_GSM), type(uint256).max);\n    GHO_GSM.buyAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    assertEq(DEFAULT_GSM_USDC_AMOUNT, exactAssetAmount, 'Unexpected asset amount bought');\n    assertEq(ghoSold - fee, grossAmount, 'Unexpected GHO gross sold amount');\n    assertEq(ghoBalanceBefore - GHO_TOKEN.balanceOf(ALICE), ghoSold, 'Unexpected GHO sold amount');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM)) - ghoFeesBefore,\n      fee,\n      'Unexpected GHO fee amount'\n    );\n\n    (uint256 assetAmount, uint256 exactGhoSold, uint256 grossAmount2, uint256 fee2) = GHO_GSM\n      .getAssetAmountForBuyAsset(ghoSold);\n    assertEq(\n      ghoBalanceBefore - GHO_TOKEN.balanceOf(ALICE),\n      exactGhoSold,\n      'Unexpected GHO sold exact amount'\n    );\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected estimation of bought assets');\n    assertEq(grossAmount, grossAmount2, 'Unexpected GHO gross amount');\n    assertEq(fee, fee2, 'Unexpected GHO fee amount');\n  }\n\n  function testGetGhoAmountForBuyAssetWithZeroFee() public {\n    GHO_GSM.updateFeeStrategy(address(0));\n\n    (uint256 exactAssetAmount, uint256 ghoSold, uint256 grossAmount, uint256 fee) = GHO_GSM\n      .getGhoAmountForBuyAsset(DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(fee, 0, 'Unexpected GHO fee amount');\n\n    uint256 topUpAmount = 1_000_000e18;\n    ghoFaucet(ALICE, topUpAmount);\n\n    _sellAsset(GHO_GSM, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    uint256 ghoBalanceBefore = GHO_TOKEN.balanceOf(ALICE);\n    uint256 ghoFeesBefore = GHO_TOKEN.balanceOf(address(GHO_GSM));\n\n    vm.startPrank(ALICE);\n    GHO_TOKEN.approve(address(GHO_GSM), type(uint256).max);\n    GHO_GSM.buyAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    assertEq(DEFAULT_GSM_USDC_AMOUNT, exactAssetAmount, 'Unexpected asset amount bought');\n    assertEq(ghoSold, grossAmount, 'Unexpected GHO gross sold amount');\n    assertEq(ghoBalanceBefore - GHO_TOKEN.balanceOf(ALICE), ghoSold, 'Unexpected GHO sold amount');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), ghoFeesBefore, 'Unexpected GHO fee amount');\n\n    (uint256 assetAmount, uint256 exactGhoSold, uint256 grossAmount2, uint256 fee2) = GHO_GSM\n      .getAssetAmountForBuyAsset(ghoSold);\n    assertEq(\n      ghoBalanceBefore - GHO_TOKEN.balanceOf(ALICE),\n      exactGhoSold,\n      'Unexpected GHO sold exact amount'\n    );\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected estimation of bought assets');\n    assertEq(grossAmount, grossAmount2, 'Unexpected GHO gross amount');\n    assertEq(fee, fee2, 'Unexpected GHO fee amount');\n  }\n\n  function testGetGhoAmountForBuyAssetWithZeroAmount() public {\n    (uint256 exactAssetAmount, uint256 ghoSold, uint256 grossAmount, uint256 fee) = GHO_GSM\n      .getGhoAmountForBuyAsset(0);\n    assertEq(exactAssetAmount, 0, 'Unexpected exact asset amount');\n    assertEq(ghoSold, 0, 'Unexpected GHO sold amount');\n    assertEq(grossAmount, 0, 'Unexpected GHO gross amount');\n    assertEq(fee, 0, 'Unexpected GHO fee amount');\n\n    (uint256 assetAmount, uint256 exactGhoSold, uint256 grossAmount2, uint256 fee2) = GHO_GSM\n      .getAssetAmountForBuyAsset(ghoSold);\n    assertEq(exactGhoSold, 0, 'Unexpected exact gho bought');\n    assertEq(assetAmount, 0, 'Unexpected estimation of bought assets');\n    assertEq(grossAmount, grossAmount2, 'Unexpected GHO gross amount');\n    assertEq(fee, fee2, 'Unexpected GHO fee amount');\n  }\n\n  function testSwapFreeze() public {\n    assertEq(GHO_GSM.getIsFrozen(), false, 'Unexpected freeze status before');\n    vm.prank(address(GHO_GSM_SWAP_FREEZER));\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit SwapFreeze(address(GHO_GSM_SWAP_FREEZER), true);\n    GHO_GSM.setSwapFreeze(true);\n    assertEq(GHO_GSM.getIsFrozen(), true, 'Unexpected freeze status after');\n  }\n\n  function testRevertFreezeNotAuthorized() public {\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_SWAP_FREEZER_ROLE, ALICE));\n    vm.prank(ALICE);\n    GHO_GSM.setSwapFreeze(true);\n  }\n\n  function testRevertSwapFreezeAlreadyFrozen() public {\n    vm.startPrank(address(GHO_GSM_SWAP_FREEZER));\n    GHO_GSM.setSwapFreeze(true);\n    vm.expectRevert('GSM_ALREADY_FROZEN');\n    GHO_GSM.setSwapFreeze(true);\n    vm.stopPrank();\n  }\n\n  function testSwapUnfreeze() public {\n    vm.startPrank(address(GHO_GSM_SWAP_FREEZER));\n    GHO_GSM.setSwapFreeze(true);\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit SwapFreeze(address(GHO_GSM_SWAP_FREEZER), false);\n    GHO_GSM.setSwapFreeze(false);\n    vm.stopPrank();\n  }\n\n  function testRevertUnfreezeNotAuthorized() public {\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_SWAP_FREEZER_ROLE, ALICE));\n    vm.prank(ALICE);\n    GHO_GSM.setSwapFreeze(false);\n  }\n\n  function testRevertUnfreezeNotFrozen() public {\n    vm.prank(address(GHO_GSM_SWAP_FREEZER));\n    vm.expectRevert('GSM_ALREADY_UNFROZEN');\n    GHO_GSM.setSwapFreeze(false);\n  }\n\n  function testRevertBuyAndSellWhenSwapFrozen() public {\n    vm.prank(address(GHO_GSM_SWAP_FREEZER));\n    GHO_GSM.setSwapFreeze(true);\n    vm.expectRevert('GSM_FROZEN');\n    GHO_GSM.buyAsset(0, ALICE);\n    vm.expectRevert('GSM_FROZEN');\n    GHO_GSM.sellAsset(0, ALICE);\n  }\n\n  function testUpdateConfigurator() public {\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit RoleGranted(GSM_CONFIGURATOR_ROLE, ALICE, address(this));\n    GHO_GSM.grantRole(GSM_CONFIGURATOR_ROLE, ALICE);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit RoleRevoked(GSM_CONFIGURATOR_ROLE, address(this), address(this));\n    GHO_GSM.revokeRole(GSM_CONFIGURATOR_ROLE, address(this));\n  }\n\n  function testRevertUpdateConfiguratorNotAuthorized() public {\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(DEFAULT_ADMIN_ROLE, ALICE));\n    vm.prank(ALICE);\n    GHO_GSM.grantRole(GSM_CONFIGURATOR_ROLE, ALICE);\n  }\n\n  function testConfiguratorUpdateMethods() public {\n    // Alice as configurator\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit RoleGranted(GSM_CONFIGURATOR_ROLE, ALICE, address(this));\n    GHO_GSM.grantRole(GSM_CONFIGURATOR_ROLE, ALICE);\n\n    vm.startPrank(address(ALICE));\n\n    assertEq(\n      GHO_GSM.getFeeStrategy(),\n      address(GHO_GSM_FIXED_FEE_STRATEGY),\n      'Unexpected fee strategy'\n    );\n    FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(\n      DEFAULT_GSM_BUY_FEE,\n      DEFAULT_GSM_SELL_FEE\n    );\n\n    vm.expectEmit(true, true, false, true, address(GHO_GSM));\n    emit FeeStrategyUpdated(address(GHO_GSM_FIXED_FEE_STRATEGY), address(newFeeStrategy));\n    GHO_GSM.updateFeeStrategy(address(newFeeStrategy));\n    assertEq(GHO_GSM.getFeeStrategy(), address(newFeeStrategy), 'Unexpected fee strategy');\n\n    address newGhoTreasury = address(GHO_GSM);\n    vm.expectEmit(true, true, true, true, address(newGhoTreasury));\n    emit GhoTreasuryUpdated(TREASURY, newGhoTreasury);\n    GHO_GSM.updateGhoTreasury(newGhoTreasury);\n    assertEq(GHO_GSM.getGhoTreasury(), newGhoTreasury);\n\n    vm.expectEmit(true, true, false, true, address(GHO_GSM));\n    emit ExposureCapUpdated(DEFAULT_GSM_USDC_EXPOSURE, 0);\n    GHO_GSM.updateExposureCap(0);\n    assertEq(GHO_GSM.getExposureCap(), 0, 'Unexpected exposure capacity');\n\n    vm.expectEmit(true, true, false, true, address(GHO_GSM));\n    emit ExposureCapUpdated(0, 1000);\n    GHO_GSM.updateExposureCap(1000);\n    assertEq(GHO_GSM.getExposureCap(), 1000, 'Unexpected exposure capacity');\n\n    vm.stopPrank();\n  }\n\n  function testRevertConfiguratorUpdateMethodsNotAuthorized() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(DEFAULT_ADMIN_ROLE, ALICE));\n    GHO_GSM.grantRole(GSM_LIQUIDATOR_ROLE, ALICE);\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(DEFAULT_ADMIN_ROLE, ALICE));\n    GHO_GSM.grantRole(GSM_SWAP_FREEZER_ROLE, ALICE);\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_CONFIGURATOR_ROLE, ALICE));\n    GHO_GSM.updateExposureCap(0);\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_CONFIGURATOR_ROLE, ALICE));\n    GHO_GSM.updateGhoTreasury(ALICE);\n    vm.stopPrank();\n  }\n\n  function testRevertInitializeTreasuryZeroAddress() public {\n    Gsm gsm = new Gsm(\n      address(GHO_TOKEN),\n      address(USDC_TOKEN),\n      address(GHO_GSM_FIXED_PRICE_STRATEGY)\n    );\n    vm.expectRevert(bytes('ZERO_ADDRESS_NOT_VALID'));\n    gsm.initialize(address(this), address(0), DEFAULT_GSM_USDC_EXPOSURE);\n  }\n\n  function testUpdateGhoTreasuryRevertIfZero() public {\n    vm.expectRevert(bytes('ZERO_ADDRESS_NOT_VALID'));\n    GHO_GSM.updateGhoTreasury(address(0));\n  }\n\n  function testUpdateGhoTreasury() public {\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit GhoTreasuryUpdated(TREASURY, ALICE);\n    GHO_GSM.updateGhoTreasury(ALICE);\n\n    assertEq(GHO_GSM.getGhoTreasury(), ALICE);\n  }\n\n  function testUnauthorizedUpdateGhoTreasuryRevert() public {\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_CONFIGURATOR_ROLE, ALICE));\n    vm.prank(ALICE);\n    GHO_GSM.updateGhoTreasury(ALICE);\n  }\n\n  function testRescueTokens() public {\n    GHO_GSM.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n\n    vm.prank(FAUCET);\n    WETH.mint(address(GHO_GSM), 100e18);\n    assertEq(WETH.balanceOf(address(GHO_GSM)), 100e18, 'Unexpected GSM WETH before balance');\n    assertEq(WETH.balanceOf(ALICE), 0, 'Unexpected target WETH before balance');\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit TokensRescued(address(WETH), ALICE, 100e18);\n    GHO_GSM.rescueTokens(address(WETH), ALICE, 100e18);\n    assertEq(WETH.balanceOf(address(GHO_GSM)), 0, 'Unexpected GSM WETH after balance');\n    assertEq(WETH.balanceOf(ALICE), 100e18, 'Unexpected target WETH after balance');\n  }\n\n  function testRevertRescueTokensZeroAmount() public {\n    GHO_GSM.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n    vm.expectRevert('INVALID_AMOUNT');\n    GHO_GSM.rescueTokens(address(WETH), ALICE, 0);\n  }\n\n  function testRescueGhoTokens() public {\n    GHO_GSM.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n\n    ghoFaucet(address(GHO_GSM), 100e18);\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), 100e18, 'Unexpected GSM GHO before balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), 0, 'Unexpected target GHO before balance');\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit TokensRescued(address(GHO_TOKEN), ALICE, 100e18);\n    GHO_GSM.rescueTokens(address(GHO_TOKEN), ALICE, 100e18);\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), 0, 'Unexpected GSM GHO after balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), 100e18, 'Unexpected target GHO after balance');\n  }\n\n  function testRescueGhoTokensWithAccruedFees() public {\n    GHO_GSM.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n\n    uint256 fee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    assertGt(fee, 0, 'Fee not greater than zero');\n\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, fee);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), fee, 'Unexpected GSM GHO balance');\n\n    ghoFaucet(address(GHO_GSM), 1);\n    assertEq(GHO_TOKEN.balanceOf(BOB), 0, 'Unexpected target GHO balance before');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), fee + 1, 'Unexpected GSM GHO balance before');\n\n    vm.expectRevert('INSUFFICIENT_GHO_TO_RESCUE');\n    GHO_GSM.rescueTokens(address(GHO_TOKEN), BOB, fee);\n\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit TokensRescued(address(GHO_TOKEN), BOB, 1);\n    GHO_GSM.rescueTokens(address(GHO_TOKEN), BOB, 1);\n\n    assertEq(GHO_TOKEN.balanceOf(BOB), 1, 'Unexpected target GHO balance after');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), fee, 'Unexpected GSM GHO balance after');\n  }\n\n  function testRevertRescueGhoTokens() public {\n    GHO_GSM.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n\n    vm.expectRevert('INSUFFICIENT_GHO_TO_RESCUE');\n    GHO_GSM.rescueTokens(address(GHO_TOKEN), ALICE, 1);\n  }\n\n  function testRescueUnderlyingTokens() public {\n    GHO_GSM.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 0, 'Unexpected USDC balance before');\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit TokensRescued(address(USDC_TOKEN), ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM.rescueTokens(address(USDC_TOKEN), ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(USDC_TOKEN.balanceOf(ALICE), DEFAULT_GSM_USDC_AMOUNT, 'Unexpected USDC balance after');\n  }\n\n  function testRescueUnderlyingTokensWithAccruedFees() public {\n    GHO_GSM.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    uint256 currentGSMBalance = DEFAULT_GSM_USDC_AMOUNT;\n    assertEq(\n      USDC_TOKEN.balanceOf(address(GHO_GSM)),\n      currentGSMBalance,\n      'Unexpected GSM USDC balance before'\n    );\n\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(\n      USDC_TOKEN.balanceOf(address(GHO_GSM)),\n      currentGSMBalance + DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected GSM USDC balance before, post-mint'\n    );\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 0, 'Unexpected target USDC balance before');\n\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit TokensRescued(address(USDC_TOKEN), ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM.rescueTokens(address(USDC_TOKEN), ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(\n      USDC_TOKEN.balanceOf(address(GHO_GSM)),\n      currentGSMBalance,\n      'Unexpected GSM USDC balance after'\n    );\n    assertEq(\n      USDC_TOKEN.balanceOf(ALICE),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected target USDC balance after'\n    );\n  }\n\n  function testRevertRescueUnderlyingTokens() public {\n    GHO_GSM.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n\n    vm.expectRevert('INSUFFICIENT_EXOGENOUS_ASSET_TO_RESCUE');\n    GHO_GSM.rescueTokens(address(USDC_TOKEN), ALICE, 1);\n  }\n\n  function testSeize() public {\n    assertEq(GHO_GSM.getIsSeized(), false, 'Unexpected seize status before');\n\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    assertEq(USDC_TOKEN.balanceOf(TREASURY), 0, 'Unexpected USDC before token balance');\n    vm.prank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit Seized(\n      address(GHO_GSM_LAST_RESORT_LIQUIDATOR),\n      BOB,\n      DEFAULT_GSM_USDC_AMOUNT,\n      DEFAULT_GSM_GHO_AMOUNT\n    );\n    uint256 seizedAmount = GHO_GSM.seize();\n\n    assertEq(GHO_GSM.getIsSeized(), true, 'Unexpected seize status after');\n    assertEq(seizedAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected seized amount');\n    assertEq(\n      USDC_TOKEN.balanceOf(TREASURY),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected USDC after token balance'\n    );\n    assertEq(GHO_GSM.getAvailableLiquidity(), 0, 'Unexpected available liquidity');\n    assertEq(\n      GHO_GSM.getAvailableUnderlyingExposure(),\n      0,\n      'Unexpected underlying exposure available'\n    );\n    assertEq(GHO_GSM.getExposureCap(), 0, 'Unexpected exposure capacity');\n  }\n\n  function testRevertSeizeWithoutAuthorization() public {\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_LIQUIDATOR_ROLE, address(this)));\n    GHO_GSM.seize();\n  }\n\n  function testRevertMethodsAfterSeizure() public {\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    vm.prank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    uint256 seizedAmount = GHO_GSM.seize();\n    assertEq(seizedAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected seized amount');\n\n    vm.expectRevert('GSM_SEIZED');\n    GHO_GSM.buyAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.expectRevert('GSM_SEIZED');\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.expectRevert('GSM_SEIZED');\n    GHO_GSM.seize();\n  }\n\n  function testBurnAfterSeize() public {\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    vm.prank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    uint256 seizedAmount = GHO_GSM.seize();\n    assertEq(seizedAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected seized amount');\n\n    vm.expectRevert('FACILITATOR_BUCKET_LEVEL_NOT_ZERO');\n    GHO_TOKEN.removeFacilitator(address(GHO_GSM));\n\n    ghoFaucet(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), DEFAULT_GSM_GHO_AMOUNT);\n    vm.startPrank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    GHO_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_GHO_AMOUNT);\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit BurnAfterSeize(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), DEFAULT_GSM_GHO_AMOUNT, 0);\n    uint256 burnedAmount = GHO_GSM.burnAfterSeize(DEFAULT_GSM_GHO_AMOUNT);\n    vm.stopPrank();\n    assertEq(burnedAmount, DEFAULT_GSM_GHO_AMOUNT, 'Unexpected burned amount of GHO');\n\n    vm.expectEmit(true, false, false, true, address(GHO_TOKEN));\n    emit FacilitatorRemoved(address(GHO_GSM));\n    GHO_TOKEN.removeFacilitator(address(GHO_GSM));\n  }\n\n  function testBurnAfterSeizeGreaterAmount() public {\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    vm.prank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    uint256 seizedAmount = GHO_GSM.seize();\n    assertEq(seizedAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected seized amount');\n\n    ghoFaucet(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), DEFAULT_GSM_GHO_AMOUNT + 1);\n    vm.startPrank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    GHO_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_GHO_AMOUNT + 1);\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit BurnAfterSeize(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), DEFAULT_GSM_GHO_AMOUNT, 0);\n    uint256 burnedAmount = GHO_GSM.burnAfterSeize(DEFAULT_GSM_GHO_AMOUNT + 1);\n    vm.stopPrank();\n    assertEq(burnedAmount, DEFAULT_GSM_GHO_AMOUNT, 'Unexpected burned amount of GHO');\n  }\n\n  function testRevertBurnAfterSeizeNotSeized() public {\n    vm.expectRevert('GSM_NOT_SEIZED');\n    vm.prank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    GHO_GSM.burnAfterSeize(1);\n  }\n\n  function testRevertBurnAfterInvalidAmount() public {\n    vm.startPrank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    GHO_GSM_4626.seize();\n    vm.expectRevert('INVALID_AMOUNT');\n    GHO_GSM_4626.burnAfterSeize(0);\n    vm.stopPrank();\n  }\n\n  function testRevertBurnAfterSeizeUnauthorized() public {\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_LIQUIDATOR_ROLE, address(this)));\n    GHO_GSM.burnAfterSeize(1);\n  }\n\n  function testDistributeFeesToTreasury() public {\n    uint256 fee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, fee);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), fee, 'Unexpected GSM GHO balance');\n    assertEq(GHO_GSM.getAccruedFees(), fee, 'Unexpected GSM accrued fees');\n\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit FeesDistributedToTreasury(\n      TREASURY,\n      address(GHO_TOKEN),\n      GHO_TOKEN.balanceOf(address(GHO_GSM))\n    );\n    GHO_GSM.distributeFeesToTreasury();\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM)),\n      0,\n      'Unexpected GSM GHO balance post-distribution'\n    );\n    assertEq(GHO_TOKEN.balanceOf(TREASURY), fee, 'Unexpected GHO balance in treasury');\n    assertEq(GHO_GSM.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n  }\n\n  function testDistributeYieldToTreasuryDoNothing() public {\n    uint256 gsmBalanceBefore = GHO_TOKEN.balanceOf(address(GHO_GSM));\n    uint256 treasuryBalanceBefore = GHO_TOKEN.balanceOf(address(TREASURY));\n    assertEq(GHO_GSM.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n\n    vm.record();\n    GHO_GSM.distributeFeesToTreasury();\n    (, bytes32[] memory writes) = vm.accesses(address(GHO_GSM));\n    assertEq(writes.length, 0, 'Unexpected update of accrued fees');\n\n    assertEq(GHO_GSM.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM)),\n      gsmBalanceBefore,\n      'Unexpected GSM GHO balance post-distribution'\n    );\n    assertEq(\n      GHO_TOKEN.balanceOf(TREASURY),\n      treasuryBalanceBefore,\n      'Unexpected GHO balance in treasury'\n    );\n  }\n\n  function testGetAccruedFees() public {\n    assertEq(GHO_GSM.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n\n    uint256 sellFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 buyFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_BUY_FEE);\n\n    _sellAsset(GHO_GSM, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), sellFee, 'Unexpected GSM GHO balance');\n    assertEq(GHO_GSM.getAccruedFees(), sellFee, 'Unexpected GSM accrued fees');\n\n    ghoFaucet(BOB, DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.startPrank(BOB);\n    GHO_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM));\n    emit BuyAsset(BOB, BOB, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT + buyFee, buyFee);\n    GHO_GSM.buyAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n    vm.stopPrank();\n\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM)), sellFee + buyFee, 'Unexpected GSM GHO balance');\n    assertEq(GHO_GSM.getAccruedFees(), sellFee + buyFee, 'Unexpected GSM accrued fees');\n  }\n\n  function testGetAccruedFeesWithZeroFee() public {\n    vm.expectEmit(true, true, false, true, address(GHO_GSM));\n    emit FeeStrategyUpdated(address(GHO_GSM_FIXED_FEE_STRATEGY), address(0));\n    GHO_GSM.updateFeeStrategy(address(0));\n\n    assertEq(GHO_GSM.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n\n    for (uint256 i = 0; i < 10; i++) {\n      _sellAsset(GHO_GSM, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n      assertEq(GHO_GSM.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n\n      ghoFaucet(BOB, DEFAULT_GSM_GHO_AMOUNT);\n      vm.startPrank(BOB);\n      GHO_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_GHO_AMOUNT);\n      GHO_GSM.buyAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n      vm.stopPrank();\n\n      assertEq(GHO_GSM.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n    }\n  }\n\n  function testCanSwap() public {\n    assertEq(GHO_GSM.canSwap(), true, 'Unexpected initial swap state');\n\n    // Freeze the GSM\n    vm.startPrank(address(GHO_GSM_SWAP_FREEZER));\n    GHO_GSM.setSwapFreeze(true);\n    assertEq(GHO_GSM.canSwap(), false, 'Unexpected swap state post-freeze');\n\n    // Unfreeze the GSM\n    GHO_GSM.setSwapFreeze(false);\n    assertEq(GHO_GSM.canSwap(), true, 'Unexpected swap state post-unfreeze');\n    vm.stopPrank();\n\n    // Seize the GSM\n    vm.prank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    GHO_GSM.seize();\n    assertEq(GHO_GSM.canSwap(), false, 'Unexpected swap state post-seize');\n  }\n\n  function testUpdateExposureCapBelowCurrentExposure() public {\n    assertEq(GHO_GSM.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure cap');\n\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, 2 * DEFAULT_GSM_USDC_AMOUNT);\n\n    // Alice as configurator\n    GHO_GSM.grantRole(GSM_CONFIGURATOR_ROLE, ALICE);\n    vm.startPrank(address(ALICE));\n\n    GHO_GSM.updateFeeStrategy(address(0));\n\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n\n    assertEq(\n      GHO_GSM.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(GHO_GSM.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure cap');\n\n    // Update exposure cap to smaller value than current exposure\n    uint256 currentExposure = GHO_GSM.getAvailableLiquidity();\n    uint256 newExposureCap = currentExposure - 1;\n    GHO_GSM.updateExposureCap(uint128(newExposureCap));\n    assertEq(GHO_GSM.getExposureCap(), newExposureCap, 'Unexpected exposure cap');\n    assertEq(GHO_GSM.getAvailableLiquidity(), currentExposure, 'Unexpected current exposure');\n\n    // Reducing exposure to 0\n    GHO_GSM.updateExposureCap(0);\n\n    // Sell cannot be executed\n    vm.expectRevert('EXOGENOUS_ASSET_EXPOSURE_TOO_HIGH');\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n\n    // Buy some asset to reduce current exposure\n    vm.stopPrank();\n    ghoFaucet(BOB, DEFAULT_GSM_GHO_AMOUNT / 2);\n    vm.startPrank(BOB);\n    GHO_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_GHO_AMOUNT / 2);\n    GHO_GSM.buyAsset(DEFAULT_GSM_USDC_AMOUNT / 2, BOB);\n\n    assertEq(GHO_GSM.getExposureCap(), 0, 'Unexpected exposure capacity');\n  }\n}\n"
    },
    "src/test/TestGsm4626.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGsm4626 is TestGhoBase {\n  using PercentageMath for uint256;\n  using PercentageMath for uint128;\n\n  function testConstructor() public {\n    Gsm4626 gsm = new Gsm4626(\n      address(GHO_TOKEN),\n      address(USDC_4626_TOKEN),\n      address(GHO_GSM_4626_FIXED_PRICE_STRATEGY)\n    );\n    assertEq(gsm.GHO_TOKEN(), address(GHO_TOKEN), 'Unexpected GHO token address');\n    assertEq(\n      gsm.UNDERLYING_ASSET(),\n      address(USDC_4626_TOKEN),\n      'Unexpected underlying asset address'\n    );\n    assertEq(\n      gsm.PRICE_STRATEGY(),\n      address(GHO_GSM_4626_FIXED_PRICE_STRATEGY),\n      'Unexpected price strategy'\n    );\n  }\n\n  function testRevertConstructorInvalidPriceStrategy() public {\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(1e18, address(GHO_TOKEN), 18);\n    vm.expectRevert('INVALID_PRICE_STRATEGY');\n    new Gsm4626(address(GHO_TOKEN), address(USDC_4626_TOKEN), address(newPriceStrategy));\n  }\n\n  function testRevertConstructorZeroAddressParams() public {\n    vm.expectRevert('ZERO_ADDRESS_NOT_VALID');\n    new Gsm4626(address(0), address(USDC_4626_TOKEN), address(GHO_GSM_4626_FIXED_PRICE_STRATEGY));\n\n    vm.expectRevert('ZERO_ADDRESS_NOT_VALID');\n    new Gsm4626(address(GHO_TOKEN), address(0), address(GHO_GSM_4626_FIXED_PRICE_STRATEGY));\n  }\n\n  function testInitialize() public {\n    Gsm4626 gsm = new Gsm4626(\n      address(GHO_TOKEN),\n      address(USDC_4626_TOKEN),\n      address(GHO_GSM_4626_FIXED_PRICE_STRATEGY)\n    );\n    vm.expectEmit(true, true, true, true);\n    emit RoleGranted(DEFAULT_ADMIN_ROLE, address(this), address(this));\n    vm.expectEmit(true, true, false, true);\n    emit ExposureCapUpdated(0, DEFAULT_GSM_USDC_EXPOSURE);\n    gsm.initialize(address(this), TREASURY, DEFAULT_GSM_USDC_EXPOSURE);\n    assertEq(gsm.getExposureCap(), DEFAULT_GSM_USDC_EXPOSURE, 'Unexpected exposure capacity');\n  }\n\n  function testRevertInitializeTwice() public {\n    Gsm4626 gsm = new Gsm4626(\n      address(GHO_TOKEN),\n      address(USDC_4626_TOKEN),\n      address(GHO_GSM_4626_FIXED_PRICE_STRATEGY)\n    );\n    gsm.initialize(address(this), TREASURY, DEFAULT_GSM_USDC_EXPOSURE);\n    vm.expectRevert('Contract instance has already been initialized');\n    gsm.initialize(address(this), TREASURY, DEFAULT_GSM_USDC_EXPOSURE);\n  }\n\n  function testSellAssetZeroFee() public {\n    vm.expectEmit(true, true, false, true, address(GHO_GSM_4626));\n    emit FeeStrategyUpdated(address(GHO_GSM_FIXED_FEE_STRATEGY), address(0));\n    GHO_GSM_4626.updateFeeStrategy(address(0));\n\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, 0);\n    (uint256 assetAmount, uint256 ghoBought) = GHO_GSM_4626.sellAsset(\n      DEFAULT_GSM_USDC_AMOUNT,\n      ALICE\n    );\n    vm.stopPrank();\n\n    assertEq(ghoBought, DEFAULT_GSM_GHO_AMOUNT, 'Unexpected GHO amount bought');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected asset amount sold');\n    assertEq(USDC_4626_TOKEN.balanceOf(ALICE), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), DEFAULT_GSM_GHO_AMOUNT, 'Unexpected final GHO balance');\n    assertEq(\n      GHO_GSM_4626.getExposureCap(),\n      DEFAULT_GSM_USDC_EXPOSURE,\n      'Unexpected exposure capacity'\n    );\n  }\n\n  function testSellAsset() public {\n    uint256 fee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 ghoOut = DEFAULT_GSM_GHO_AMOUNT - fee;\n\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(\n      USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(ALICE)),\n      DEFAULT_GSM_USDC_AMOUNT\n    );\n\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, fee);\n    (uint256 assetAmount, uint256 ghoBought) = GHO_GSM_4626.sellAsset(\n      DEFAULT_GSM_USDC_AMOUNT,\n      ALICE\n    );\n    vm.stopPrank();\n\n    assertEq(ghoBought, DEFAULT_GSM_GHO_AMOUNT - fee, 'Unexpected GHO amount bought');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected asset amount sold');\n    assertEq(USDC_4626_TOKEN.balanceOf(ALICE), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), fee, 'Unexpected GSM GHO balance');\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available liquidity'\n    );\n    assertEq(\n      GHO_GSM_4626.getExposureCap(),\n      DEFAULT_GSM_USDC_EXPOSURE,\n      'Unexpected exposure capacity'\n    );\n  }\n\n  function testSellAssetSendToOther() public {\n    uint256 fee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 ghoOut = DEFAULT_GSM_GHO_AMOUNT - fee;\n\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, BOB, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, fee);\n    (uint256 assetAmount, uint256 ghoBought) = GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n    vm.stopPrank();\n\n    assertEq(ghoBought, DEFAULT_GSM_GHO_AMOUNT - fee, 'Unexpected GHO amount bought');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected asset amount sold');\n    assertEq(USDC_4626_TOKEN.balanceOf(ALICE), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), 0, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(BOB), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), fee, 'Unexpected GSM GHO balance');\n    assertEq(\n      GHO_GSM_4626.getExposureCap(),\n      DEFAULT_GSM_USDC_EXPOSURE,\n      'Unexpected exposure capacity'\n    );\n  }\n\n  function testRevertSellAssetTooMuchUnderlyingExposure() public {\n    Gsm4626 gsm = new Gsm4626(\n      address(GHO_TOKEN),\n      address(USDC_4626_TOKEN),\n      address(GHO_GSM_4626_FIXED_PRICE_STRATEGY)\n    );\n    gsm.initialize(address(this), TREASURY, DEFAULT_GSM_USDC_EXPOSURE - 1);\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM Modified Exposure Cap', DEFAULT_CAPACITY);\n\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_EXPOSURE);\n\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(gsm), DEFAULT_GSM_USDC_EXPOSURE);\n    vm.expectRevert('EXOGENOUS_ASSET_EXPOSURE_TOO_HIGH');\n    gsm.sellAsset(DEFAULT_GSM_USDC_EXPOSURE, ALICE);\n    vm.stopPrank();\n  }\n\n  function testGetGhoAmountForSellAsset() public {\n    (uint256 exactAssetAmount, uint256 ghoBought, uint256 grossAmount, uint256 fee) = GHO_GSM_4626\n      .getGhoAmountForSellAsset(DEFAULT_GSM_USDC_AMOUNT);\n\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    assertEq(\n      DEFAULT_GSM_USDC_AMOUNT - USDC_4626_TOKEN.balanceOf(ALICE),\n      exactAssetAmount,\n      'Unexpected asset amount sold'\n    );\n\n    assertEq(ghoBought + fee, grossAmount, 'Unexpected GHO gross amount');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoBought, 'Unexpected GHO bought amount');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), fee, 'Unexpected GHO fee amount');\n\n    (uint256 assetAmount, uint256 exactGhoBought, uint256 grossAmount2, uint256 fee2) = GHO_GSM_4626\n      .getAssetAmountForSellAsset(ghoBought);\n    assertEq(GHO_TOKEN.balanceOf(ALICE), exactGhoBought, 'Unexpected GHO bought amount');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected estimation of sold assets');\n    assertEq(grossAmount, grossAmount2, 'Unexpected GHO gross amount');\n    assertEq(fee, fee2, 'Unexpected GHO fee amount');\n  }\n\n  function testGetGhoAmountForSellAssetWithZeroFee() public {\n    GHO_GSM_4626.updateFeeStrategy(address(0));\n\n    (uint256 exactAssetAmount, uint256 ghoBought, uint256 grossAmount, uint256 fee) = GHO_GSM_4626\n      .getGhoAmountForSellAsset(DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(fee, 0, 'Unexpected GHO fee amount');\n\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(\n      DEFAULT_GSM_USDC_AMOUNT - USDC_4626_TOKEN.balanceOf(ALICE),\n      exactAssetAmount,\n      'Unexpected asset amount sold'\n    );\n    assertEq(ghoBought, grossAmount, 'Unexpected GHO gross amount');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoBought, 'Unexpected GHO bought amount');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), 0, 'Unexpected GHO fee amount');\n\n    (uint256 assetAmount, uint256 exactGhoBought, uint256 grossAmount2, uint256 fee2) = GHO_GSM_4626\n      .getAssetAmountForSellAsset(ghoBought);\n    assertEq(GHO_TOKEN.balanceOf(ALICE), exactGhoBought, 'Unexpected GHO bought amount');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected estimation of sold assets');\n    assertEq(grossAmount, grossAmount2, 'Unexpected GHO gross amount');\n    assertEq(fee, fee2, 'Unexpected GHO fee amount');\n  }\n\n  function testGetGhoAmountForSellAssetWithZeroAmount() public {\n    (uint256 exactAssetAmount, uint256 ghoBought, uint256 grossAmount, uint256 fee) = GHO_GSM_4626\n      .getGhoAmountForSellAsset(0);\n    assertEq(exactAssetAmount, 0, 'Unexpected exact asset amount');\n    assertEq(ghoBought, 0, 'Unexpected GHO bought amount');\n    assertEq(grossAmount, 0, 'Unexpected GHO gross amount');\n    assertEq(fee, 0, 'Unexpected GHO fee amount');\n\n    (uint256 assetAmount, uint256 exactGhoBought, uint256 grossAmount2, uint256 fee2) = GHO_GSM_4626\n      .getAssetAmountForSellAsset(ghoBought);\n    assertEq(exactGhoBought, 0, 'Unexpected exact gho bought');\n    assertEq(assetAmount, 0, 'Unexpected estimation of sold assets');\n    assertEq(grossAmount, grossAmount2, 'Unexpected GHO gross amount');\n    assertEq(fee, fee2, 'Unexpected GHO fee amount');\n  }\n\n  function testBuyAssetZeroFee() public {\n    vm.expectEmit(true, true, false, true, address(GHO_GSM_4626));\n    emit FeeStrategyUpdated(address(GHO_GSM_FIXED_FEE_STRATEGY), address(0));\n    GHO_GSM_4626.updateFeeStrategy(address(0));\n\n    // Supply assets to the GSM first\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, 0);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    // Buy assets as another user\n    ghoFaucet(BOB, DEFAULT_GSM_GHO_AMOUNT);\n    vm.startPrank(BOB);\n    GHO_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_GHO_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit BuyAsset(BOB, BOB, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, 0);\n    (uint256 assetAmount, uint256 ghoSold) = GHO_GSM_4626.buyAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n    vm.stopPrank();\n\n    assertEq(ghoSold, DEFAULT_GSM_GHO_AMOUNT, 'Unexpected GHO amount sold');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected asset amount bought');\n    assertEq(\n      USDC_4626_TOKEN.balanceOf(BOB),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected final USDC balance'\n    );\n    assertEq(GHO_TOKEN.balanceOf(ALICE), DEFAULT_GSM_GHO_AMOUNT, 'Unexpected final GHO balance');\n    assertEq(\n      GHO_GSM_4626.getExposureCap(),\n      DEFAULT_GSM_USDC_EXPOSURE,\n      'Unexpected exposure capacity'\n    );\n  }\n\n  function testBuyAsset() public {\n    uint256 sellFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 buyFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_BUY_FEE);\n    uint256 ghoOut = DEFAULT_GSM_GHO_AMOUNT - sellFee;\n\n    // Supply assets to the GSM first\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, sellFee);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    // Buy assets as another user\n    ghoFaucet(BOB, DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.startPrank(BOB);\n    GHO_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit BuyAsset(BOB, BOB, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT + buyFee, buyFee);\n    (uint256 assetAmount, uint256 ghoSold) = GHO_GSM_4626.buyAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n    vm.stopPrank();\n\n    assertEq(ghoSold, DEFAULT_GSM_GHO_AMOUNT + buyFee, 'Unexpected GHO amount sold');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected asset amount bought');\n    assertEq(\n      USDC_4626_TOKEN.balanceOf(BOB),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected final USDC balance'\n    );\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      sellFee + buyFee,\n      'Unexpected GSM GHO balance'\n    );\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(GHO_GSM_4626.getAvailableLiquidity(), 0, 'Unexpected available liquidity');\n    assertEq(\n      GHO_GSM_4626.getExposureCap(),\n      DEFAULT_GSM_USDC_EXPOSURE,\n      'Unexpected exposure capacity'\n    );\n  }\n\n  function testBuyAssetSendToOther() public {\n    uint256 sellFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 buyFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_BUY_FEE);\n    uint256 ghoOut = DEFAULT_GSM_GHO_AMOUNT - sellFee;\n\n    // Supply assets to the GSM first\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, sellFee);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    // Buy assets as another user\n    ghoFaucet(BOB, DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.startPrank(BOB);\n    GHO_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit BuyAsset(BOB, CHARLES, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT + buyFee, buyFee);\n    (uint256 assetAmount, uint256 ghoSold) = GHO_GSM_4626.buyAsset(\n      DEFAULT_GSM_USDC_AMOUNT,\n      CHARLES\n    );\n    vm.stopPrank();\n\n    assertEq(ghoSold, DEFAULT_GSM_GHO_AMOUNT + buyFee, 'Unexpected GHO amount sold');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected asset amount bought');\n    assertEq(USDC_4626_TOKEN.balanceOf(BOB), 0, 'Unexpected final USDC balance');\n    assertEq(\n      USDC_4626_TOKEN.balanceOf(CHARLES),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected final USDC balance'\n    );\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      sellFee + buyFee,\n      'Unexpected GSM GHO balance'\n    );\n    assertEq(\n      GHO_GSM_4626.getExposureCap(),\n      DEFAULT_GSM_USDC_EXPOSURE,\n      'Unexpected exposure capacity'\n    );\n  }\n\n  function testBuyThenSellAtMaximumBucketCapacity() public {\n    // Use zero fees to simplify amount calculations\n    vm.expectEmit(true, true, false, true, address(GHO_GSM_4626));\n    emit FeeStrategyUpdated(address(GHO_GSM_FIXED_FEE_STRATEGY), address(0));\n    GHO_GSM_4626.updateFeeStrategy(address(0));\n\n    // Supply assets to the GSM first\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_EXPOSURE);\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_EXPOSURE);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_EXPOSURE, DEFAULT_CAPACITY, 0);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_EXPOSURE, ALICE);\n\n    (uint256 ghoCapacity, uint256 ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(ghoLevel, ghoCapacity, 'Unexpected GHO bucket level after initial sell');\n    assertEq(\n      GHO_TOKEN.balanceOf(ALICE),\n      DEFAULT_CAPACITY,\n      'Unexpected Alice GHO balance after sell'\n    );\n\n    // Buy 1 of the underlying\n    GHO_TOKEN.approve(address(GHO_GSM_4626), 1e18);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit BuyAsset(ALICE, ALICE, 1e6, 1e18, 0);\n    GHO_GSM_4626.buyAsset(1e6, ALICE);\n\n    (, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(ghoLevel, DEFAULT_CAPACITY - 1e18, 'Unexpected GHO bucket level after buy');\n    assertEq(\n      GHO_TOKEN.balanceOf(ALICE),\n      DEFAULT_CAPACITY - 1e18,\n      'Unexpected Alice GHO balance after buy'\n    );\n    assertEq(USDC_4626_TOKEN.balanceOf(ALICE), 1e6, 'Unexpected Alice USDC balance after buy');\n\n    // Sell 1 of the underlying\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), 1e6);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, ALICE, 1e6, 1e18, 0);\n    GHO_GSM_4626.sellAsset(1e6, ALICE);\n    vm.stopPrank();\n\n    (ghoCapacity, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(ghoLevel, ghoCapacity, 'Unexpected GHO bucket level after second sell');\n    assertEq(\n      GHO_TOKEN.balanceOf(ALICE),\n      DEFAULT_CAPACITY,\n      'Unexpected Alice GHO balance after second sell'\n    );\n    assertEq(\n      USDC_4626_TOKEN.balanceOf(ALICE),\n      0,\n      'Unexpected Alice USDC balance after second sell'\n    );\n    assertEq(\n      GHO_GSM_4626.getExposureCap(),\n      DEFAULT_GSM_USDC_EXPOSURE,\n      'Unexpected exposure capacity'\n    );\n  }\n\n  function testRevertBuyAssetZeroAmount() public {\n    vm.prank(ALICE);\n    vm.expectRevert('INVALID_AMOUNT');\n    GHO_GSM_4626.buyAsset(0, ALICE);\n  }\n\n  function testRevertBuyAssetNoGHO() public {\n    uint256 sellFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 buyFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_BUY_FEE);\n\n    // Supply assets to the GSM first\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, sellFee);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    vm.startPrank(BOB);\n    GHO_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.expectRevert(stdError.arithmeticError);\n    GHO_GSM_4626.buyAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n    vm.stopPrank();\n  }\n\n  function testRevertBuyAssetNoAllowance() public {\n    uint256 sellFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 buyFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_BUY_FEE);\n\n    // Supply assets to the GSM first\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, sellFee);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    ghoFaucet(BOB, DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.startPrank(BOB);\n    vm.expectRevert(stdError.arithmeticError);\n    GHO_GSM_4626.buyAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n    vm.stopPrank();\n  }\n\n  function testGetGhoAmountForBuyAsset() public {\n    (uint256 exactAssetAmount, uint256 ghoSold, uint256 grossAmount, uint256 fee) = GHO_GSM_4626\n      .getGhoAmountForBuyAsset(DEFAULT_GSM_USDC_AMOUNT);\n\n    uint256 topUpAmount = 1_000_000e18;\n    ghoFaucet(ALICE, topUpAmount);\n\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    uint256 ghoBalanceBefore = GHO_TOKEN.balanceOf(ALICE);\n    uint256 ghoFeesBefore = GHO_TOKEN.balanceOf(address(GHO_GSM_4626));\n\n    vm.startPrank(ALICE);\n    GHO_TOKEN.approve(address(GHO_GSM_4626), type(uint256).max);\n    GHO_GSM_4626.buyAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    assertEq(DEFAULT_GSM_USDC_AMOUNT, exactAssetAmount, 'Unexpected asset amount bought');\n    assertEq(ghoSold - fee, grossAmount, 'Unexpected GHO gross sold amount');\n    assertEq(ghoBalanceBefore - GHO_TOKEN.balanceOf(ALICE), ghoSold, 'Unexpected GHO sold amount');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)) - ghoFeesBefore,\n      fee,\n      'Unexpected GHO fee amount'\n    );\n\n    (uint256 assetAmount, uint256 exactGhoSold, uint256 grossAmount2, uint256 fee2) = GHO_GSM_4626\n      .getAssetAmountForBuyAsset(ghoSold);\n    assertEq(\n      ghoBalanceBefore - GHO_TOKEN.balanceOf(ALICE),\n      exactGhoSold,\n      'Unexpected GHO sold exact amount'\n    );\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected estimation of bought assets');\n    assertEq(grossAmount, grossAmount2, 'Unexpected GHO gross amount');\n    assertEq(fee, fee2, 'Unexpected GHO fee amount');\n  }\n\n  function testGetGhoAmountForBuyAssetWithZeroFee() public {\n    GHO_GSM_4626.updateFeeStrategy(address(0));\n\n    (uint256 exactAssetAmount, uint256 ghoSold, uint256 grossAmount, uint256 fee) = GHO_GSM_4626\n      .getGhoAmountForBuyAsset(DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(fee, 0, 'Unexpected GHO fee amount');\n\n    uint256 topUpAmount = 1_000_000e18;\n    ghoFaucet(ALICE, topUpAmount);\n\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    uint256 ghoBalanceBefore = GHO_TOKEN.balanceOf(ALICE);\n    uint256 ghoFeesBefore = GHO_TOKEN.balanceOf(address(GHO_GSM_4626));\n\n    vm.startPrank(ALICE);\n    GHO_TOKEN.approve(address(GHO_GSM_4626), type(uint256).max);\n    GHO_GSM_4626.buyAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    assertEq(DEFAULT_GSM_USDC_AMOUNT, exactAssetAmount, 'Unexpected asset amount bought');\n    assertEq(ghoSold, grossAmount, 'Unexpected GHO gross sold amount');\n    assertEq(ghoBalanceBefore - GHO_TOKEN.balanceOf(ALICE), ghoSold, 'Unexpected GHO sold amount');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      ghoFeesBefore,\n      'Unexpected GHO fee amount'\n    );\n\n    (uint256 assetAmount, uint256 exactGhoSold, uint256 grossAmount2, uint256 fee2) = GHO_GSM_4626\n      .getAssetAmountForBuyAsset(ghoSold);\n    assertEq(\n      ghoBalanceBefore - GHO_TOKEN.balanceOf(ALICE),\n      exactGhoSold,\n      'Unexpected GHO sold exact amount'\n    );\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected estimation of bought assets');\n    assertEq(grossAmount, grossAmount2, 'Unexpected GHO gross amount');\n    assertEq(fee, fee2, 'Unexpected GHO fee amount');\n  }\n\n  function testGetGhoAmountForBuyAssetWithZeroAmount() public {\n    (uint256 exactAssetAmount, uint256 ghoSold, uint256 grossAmount, uint256 fee) = GHO_GSM_4626\n      .getGhoAmountForBuyAsset(0);\n    assertEq(exactAssetAmount, 0, 'Unexpected exact asset amount');\n    assertEq(ghoSold, 0, 'Unexpected GHO sold amount');\n    assertEq(grossAmount, 0, 'Unexpected GHO gross amount');\n    assertEq(fee, 0, 'Unexpected GHO fee amount');\n\n    (uint256 assetAmount, uint256 exactGhoSold, uint256 grossAmount2, uint256 fee2) = GHO_GSM_4626\n      .getAssetAmountForBuyAsset(ghoSold);\n    assertEq(exactGhoSold, 0, 'Unexpected exact gho bought');\n    assertEq(assetAmount, 0, 'Unexpected estimation of bought assets');\n    assertEq(grossAmount, grossAmount2, 'Unexpected GHO gross amount');\n    assertEq(fee, fee2, 'Unexpected GHO fee amount');\n  }\n\n  function testSwapFreeze() public {\n    assertEq(GHO_GSM_4626.getIsFrozen(), false, 'Unexpected freeze status before');\n    vm.prank(address(GHO_GSM_SWAP_FREEZER));\n    vm.expectEmit(true, false, false, true, address(GHO_GSM_4626));\n    emit SwapFreeze(address(GHO_GSM_SWAP_FREEZER), true);\n    GHO_GSM_4626.setSwapFreeze(true);\n    assertEq(GHO_GSM_4626.getIsFrozen(), true, 'Unexpected freeze status after');\n  }\n\n  function testRevertFreezeNotAuthorized() public {\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_SWAP_FREEZER_ROLE, ALICE));\n    vm.prank(ALICE);\n    GHO_GSM_4626.setSwapFreeze(true);\n  }\n\n  function testRevertSwapFreezeAlreadyFrozen() public {\n    vm.startPrank(address(GHO_GSM_SWAP_FREEZER));\n    GHO_GSM_4626.setSwapFreeze(true);\n    vm.expectRevert('GSM_ALREADY_FROZEN');\n    GHO_GSM_4626.setSwapFreeze(true);\n    vm.stopPrank();\n  }\n\n  function testSwapUnfreeze() public {\n    vm.startPrank(address(GHO_GSM_SWAP_FREEZER));\n    GHO_GSM_4626.setSwapFreeze(true);\n    vm.expectEmit(true, false, false, true, address(GHO_GSM_4626));\n    emit SwapFreeze(address(GHO_GSM_SWAP_FREEZER), false);\n    GHO_GSM_4626.setSwapFreeze(false);\n    vm.stopPrank();\n  }\n\n  function testRevertUnfreezeNotAuthorized() public {\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_SWAP_FREEZER_ROLE, ALICE));\n    vm.prank(ALICE);\n    GHO_GSM_4626.setSwapFreeze(false);\n  }\n\n  function testRevertUnfreezeNotFrozen() public {\n    vm.prank(address(GHO_GSM_SWAP_FREEZER));\n    vm.expectRevert('GSM_ALREADY_UNFROZEN');\n    GHO_GSM_4626.setSwapFreeze(false);\n  }\n\n  function testRevertBuyAndSellWhenSwapFrozen() public {\n    vm.prank(address(GHO_GSM_SWAP_FREEZER));\n    GHO_GSM_4626.setSwapFreeze(true);\n    vm.expectRevert('GSM_FROZEN');\n    GHO_GSM_4626.buyAsset(0, ALICE);\n    vm.expectRevert('GSM_FROZEN');\n    GHO_GSM_4626.sellAsset(0, ALICE);\n  }\n\n  function testUpdateConfigurator() public {\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit RoleGranted(GSM_CONFIGURATOR_ROLE, ALICE, address(this));\n    GHO_GSM_4626.grantRole(GSM_CONFIGURATOR_ROLE, ALICE);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit RoleRevoked(GSM_CONFIGURATOR_ROLE, address(this), address(this));\n    GHO_GSM_4626.revokeRole(GSM_CONFIGURATOR_ROLE, address(this));\n  }\n\n  function testRevertUpdateConfiguratorNotAuthorized() public {\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(DEFAULT_ADMIN_ROLE, ALICE));\n    vm.prank(ALICE);\n    GHO_GSM_4626.grantRole(GSM_CONFIGURATOR_ROLE, ALICE);\n  }\n\n  function testConfiguratorUpdateMethods() public {\n    // Alice as configurator\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit RoleGranted(GSM_CONFIGURATOR_ROLE, ALICE, address(this));\n    GHO_GSM_4626.grantRole(GSM_CONFIGURATOR_ROLE, ALICE);\n\n    vm.startPrank(address(ALICE));\n\n    assertEq(\n      GHO_GSM_4626.getFeeStrategy(),\n      address(GHO_GSM_FIXED_FEE_STRATEGY),\n      'Unexpected fee strategy'\n    );\n    FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(\n      DEFAULT_GSM_BUY_FEE,\n      DEFAULT_GSM_SELL_FEE\n    );\n    vm.expectEmit(true, true, false, true, address(GHO_GSM_4626));\n    emit FeeStrategyUpdated(address(GHO_GSM_FIXED_FEE_STRATEGY), address(newFeeStrategy));\n    GHO_GSM_4626.updateFeeStrategy(address(newFeeStrategy));\n    assertEq(GHO_GSM_4626.getFeeStrategy(), address(newFeeStrategy), 'Unexpected fee strategy');\n\n    vm.expectEmit(true, true, false, true, address(GHO_GSM_4626));\n    emit ExposureCapUpdated(DEFAULT_GSM_USDC_EXPOSURE, 0);\n    GHO_GSM_4626.updateExposureCap(0);\n    assertEq(GHO_GSM_4626.getExposureCap(), 0, 'Unexpected exposure capacity');\n\n    vm.expectEmit(true, true, false, true, address(GHO_GSM_4626));\n    emit ExposureCapUpdated(0, 1000);\n    GHO_GSM_4626.updateExposureCap(1000);\n    assertEq(GHO_GSM_4626.getExposureCap(), 1000, 'Unexpected exposure capacity');\n\n    vm.stopPrank();\n  }\n\n  function testRevertConfiguratorUpdateMethodsNotAuthorized() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(DEFAULT_ADMIN_ROLE, ALICE));\n    GHO_GSM_4626.grantRole(GSM_LIQUIDATOR_ROLE, ALICE);\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(DEFAULT_ADMIN_ROLE, ALICE));\n    GHO_GSM_4626.grantRole(GSM_SWAP_FREEZER_ROLE, ALICE);\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_CONFIGURATOR_ROLE, ALICE));\n    GHO_GSM_4626.updateExposureCap(0);\n    vm.stopPrank();\n  }\n\n  function testUpdateGhoTreasuryRevertIfZero() public {\n    vm.expectRevert(bytes('ZERO_ADDRESS_NOT_VALID'));\n    GHO_GSM_4626.updateGhoTreasury(address(0));\n  }\n\n  function testUpdateGhoTreasury() public {\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit GhoTreasuryUpdated(TREASURY, ALICE);\n    GHO_GSM_4626.updateGhoTreasury(ALICE);\n\n    assertEq(GHO_GSM_4626.getGhoTreasury(), ALICE);\n  }\n\n  function testUnauthorizedUpdateGhoTreasuryRevert() public {\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_CONFIGURATOR_ROLE, ALICE));\n    vm.prank(ALICE);\n    GHO_GSM_4626.updateGhoTreasury(ALICE);\n  }\n\n  function testRescueTokens() public {\n    GHO_GSM_4626.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n\n    vm.prank(FAUCET);\n    WETH.mint(address(GHO_GSM_4626), 100e18);\n    assertEq(WETH.balanceOf(address(GHO_GSM_4626)), 100e18, 'Unexpected GSM WETH before balance');\n    assertEq(WETH.balanceOf(ALICE), 0, 'Unexpected target WETH before balance');\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit TokensRescued(address(WETH), ALICE, 100e18);\n    GHO_GSM_4626.rescueTokens(address(WETH), ALICE, 100e18);\n    assertEq(WETH.balanceOf(address(GHO_GSM_4626)), 0, 'Unexpected GSM WETH after balance');\n    assertEq(WETH.balanceOf(ALICE), 100e18, 'Unexpected target WETH after balance');\n  }\n\n  function testRescueGhoTokens() public {\n    GHO_GSM_4626.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n\n    ghoFaucet(address(GHO_GSM_4626), 100e18);\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      100e18,\n      'Unexpected GSM GHO before balance'\n    );\n    assertEq(GHO_TOKEN.balanceOf(ALICE), 0, 'Unexpected target GHO before balance');\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit TokensRescued(address(GHO_TOKEN), ALICE, 100e18);\n    GHO_GSM_4626.rescueTokens(address(GHO_TOKEN), ALICE, 100e18);\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), 0, 'Unexpected GSM GHO after balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), 100e18, 'Unexpected target GHO after balance');\n  }\n\n  function testRescueGhoTokensWithAccruedFees() public {\n    GHO_GSM_4626.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n\n    uint256 fee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    assertGt(fee, 0, 'Fee not greater than zero');\n\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, fee);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), fee, 'Unexpected GSM GHO balance');\n\n    ghoFaucet(address(GHO_GSM_4626), 1);\n    assertEq(GHO_TOKEN.balanceOf(BOB), 0, 'Unexpected target GHO balance before');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      fee + 1,\n      'Unexpected GSM GHO balance before'\n    );\n\n    vm.expectRevert('INSUFFICIENT_GHO_TO_RESCUE');\n    GHO_GSM_4626.rescueTokens(address(GHO_TOKEN), BOB, fee);\n\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit TokensRescued(address(GHO_TOKEN), BOB, 1);\n    GHO_GSM_4626.rescueTokens(address(GHO_TOKEN), BOB, 1);\n\n    assertEq(GHO_TOKEN.balanceOf(BOB), 1, 'Unexpected target GHO balance after');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), fee, 'Unexpected GSM GHO balance after');\n  }\n\n  function testRevertRescueGhoTokens() public {\n    GHO_GSM_4626.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n\n    vm.expectRevert('INSUFFICIENT_GHO_TO_RESCUE');\n    GHO_GSM_4626.rescueTokens(address(GHO_TOKEN), ALICE, 1);\n  }\n\n  function testRescueUnderlyingTokens() public {\n    GHO_GSM_4626.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n\n    assertEq(USDC_4626_TOKEN.balanceOf(ALICE), 0, 'Unexpected USDC balance before');\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit TokensRescued(address(USDC_4626_TOKEN), ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM_4626.rescueTokens(address(USDC_4626_TOKEN), ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(\n      USDC_4626_TOKEN.balanceOf(ALICE),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected USDC balance after'\n    );\n  }\n\n  function testRescueUnderlyingTokensWithAccruedFees() public {\n    GHO_GSM_4626.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    uint256 currentGSMBalance = DEFAULT_GSM_USDC_AMOUNT;\n    assertEq(\n      USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      currentGSMBalance,\n      'Unexpected GSM USDC balance before'\n    );\n\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n\n    assertEq(\n      USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      currentGSMBalance + DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected GSM USDC balance before, post-mint'\n    );\n    assertEq(USDC_4626_TOKEN.balanceOf(ALICE), 0, 'Unexpected target USDC balance before');\n\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit TokensRescued(address(USDC_4626_TOKEN), ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM_4626.rescueTokens(address(USDC_4626_TOKEN), ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(\n      USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      currentGSMBalance,\n      'Unexpected GSM USDC balance after'\n    );\n    assertEq(\n      USDC_4626_TOKEN.balanceOf(ALICE),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected target USDC balance after'\n    );\n  }\n\n  function testRevertRescueUnderlyingTokens() public {\n    GHO_GSM_4626.grantRole(GSM_TOKEN_RESCUER_ROLE, address(this));\n\n    vm.expectRevert('INSUFFICIENT_EXOGENOUS_ASSET_TO_RESCUE');\n    GHO_GSM_4626.rescueTokens(address(USDC_4626_TOKEN), ALICE, 1);\n  }\n\n  function testSeize() public {\n    assertEq(GHO_GSM_4626.getIsSeized(), false, 'Unexpected seize status before');\n\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    assertEq(USDC_4626_TOKEN.balanceOf(TREASURY), 0, 'Unexpected USDC before token balance');\n    vm.prank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    vm.expectEmit(true, false, false, true, address(GHO_GSM_4626));\n    emit Seized(\n      address(GHO_GSM_LAST_RESORT_LIQUIDATOR),\n      BOB,\n      DEFAULT_GSM_USDC_AMOUNT,\n      DEFAULT_GSM_GHO_AMOUNT\n    );\n    uint256 seizedAmount = GHO_GSM_4626.seize();\n    assertEq(seizedAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected seized amount');\n\n    assertEq(GHO_GSM_4626.getIsSeized(), true, 'Unexpected seize status after');\n    assertEq(\n      USDC_4626_TOKEN.balanceOf(TREASURY),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected USDC after token balance'\n    );\n    assertEq(GHO_GSM_4626.getExposureCap(), 0, 'Unexpected exposure capacity');\n  }\n\n  function testRevertSeizeWithoutAuthorization() public {\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_LIQUIDATOR_ROLE, address(this)));\n    GHO_GSM_4626.seize();\n  }\n\n  function testRevertMethodsAfterSeizure() public {\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    vm.prank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    uint256 seizedAmount = GHO_GSM_4626.seize();\n    assertEq(seizedAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected seized amount');\n\n    vm.expectRevert('GSM_SEIZED');\n    GHO_GSM_4626.buyAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.expectRevert('GSM_SEIZED');\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.expectRevert('GSM_SEIZED');\n    GHO_GSM_4626.seize();\n\n    GHO_GSM_4626.grantRole(GSM_CONFIGURATOR_ROLE, BOB);\n    vm.startPrank(BOB);\n    vm.expectRevert('GSM_SEIZED');\n    GHO_GSM_4626.backWithGho(1);\n    vm.expectRevert('GSM_SEIZED');\n    GHO_GSM_4626.backWithUnderlying(1);\n    vm.stopPrank();\n  }\n\n  function testBurnAfterSeize() public {\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    vm.prank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    uint256 seizedAmount = GHO_GSM_4626.seize();\n    assertEq(seizedAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected seized amount');\n\n    vm.expectRevert('FACILITATOR_BUCKET_LEVEL_NOT_ZERO');\n    GHO_TOKEN.removeFacilitator(address(GHO_GSM_4626));\n\n    ghoFaucet(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), DEFAULT_GSM_GHO_AMOUNT);\n    vm.startPrank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    GHO_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_GHO_AMOUNT);\n    vm.expectEmit(true, false, false, true, address(GHO_GSM_4626));\n    emit BurnAfterSeize(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), DEFAULT_GSM_GHO_AMOUNT, 0);\n    uint256 burnedAmount = GHO_GSM_4626.burnAfterSeize(DEFAULT_GSM_GHO_AMOUNT);\n    vm.stopPrank();\n    assertEq(burnedAmount, DEFAULT_GSM_GHO_AMOUNT, 'Unexpected burned amount of GHO');\n\n    vm.expectEmit(true, false, false, true, address(GHO_TOKEN));\n    emit FacilitatorRemoved(address(GHO_GSM_4626));\n    GHO_TOKEN.removeFacilitator(address(GHO_GSM_4626));\n  }\n\n  function testBurnAfterSeizeGreaterAmount() public {\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    vm.prank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    uint256 seizedAmount = GHO_GSM_4626.seize();\n    assertEq(seizedAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected seized amount');\n\n    ghoFaucet(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), DEFAULT_GSM_GHO_AMOUNT + 1);\n    vm.startPrank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    GHO_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_GHO_AMOUNT + 1);\n    vm.expectEmit(true, false, false, true, address(GHO_GSM_4626));\n    emit BurnAfterSeize(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), DEFAULT_GSM_GHO_AMOUNT, 0);\n    uint256 burnedAmount = GHO_GSM_4626.burnAfterSeize(DEFAULT_GSM_GHO_AMOUNT + 1);\n    vm.stopPrank();\n    assertEq(burnedAmount, DEFAULT_GSM_GHO_AMOUNT, 'Unexpected burned amount of GHO');\n  }\n\n  function testRevertBurnAfterInvalidAmount() public {\n    vm.startPrank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    GHO_GSM_4626.seize();\n    vm.expectRevert('INVALID_AMOUNT');\n    GHO_GSM_4626.burnAfterSeize(0);\n    vm.stopPrank();\n  }\n\n  function testRevertBurnAfterSeizeNotSeized() public {\n    vm.expectRevert('GSM_NOT_SEIZED');\n    vm.prank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    GHO_GSM_4626.burnAfterSeize(1);\n  }\n\n  function testRevertBurnAfterSeizeUnauthorized() public {\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_LIQUIDATOR_ROLE, address(this)));\n    GHO_GSM_4626.burnAfterSeize(1);\n  }\n\n  function testInjectGho() public {\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    (uint256 excess, uint256 deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, 0, 'Unexpected excess value of GHO');\n    assertEq(deficit, 0, 'Unexpected deficit of GHO');\n\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_AMOUNT / 2, false);\n\n    GHO_GSM_4626.grantRole(GSM_CONFIGURATOR_ROLE, BOB);\n\n    (excess, deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, 0, 'Unexpected excess value of GHO');\n    assertEq(deficit, DEFAULT_GSM_GHO_AMOUNT / 2, 'Unexpected deficit of GHO');\n\n    ghoFaucet(BOB, DEFAULT_GSM_GHO_AMOUNT / 2);\n    vm.startPrank(BOB);\n    GHO_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_GHO_AMOUNT / 2);\n    vm.expectEmit(true, true, false, true, address(GHO_GSM_4626));\n    emit BackingProvided(\n      BOB,\n      address(GHO_TOKEN),\n      DEFAULT_GSM_GHO_AMOUNT / 2,\n      DEFAULT_GSM_GHO_AMOUNT / 2,\n      0\n    );\n    uint256 ghoUsedForBacking = GHO_GSM_4626.backWithGho(DEFAULT_GSM_GHO_AMOUNT / 2);\n    assertEq(DEFAULT_GSM_GHO_AMOUNT / 2, ghoUsedForBacking);\n    vm.stopPrank();\n\n    (excess, deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, 0, 'Unexpected excess value of GHO');\n    assertEq(deficit, 0, 'Unexpected deficit of GHO');\n  }\n\n  function testInjectGhoMoreThanNeeded() public {\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    (uint256 excess, uint256 deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, 0, 'Unexpected excess value of GHO');\n    assertEq(deficit, 0, 'Unexpected deficit of GHO');\n\n    GHO_GSM_4626.grantRole(GSM_CONFIGURATOR_ROLE, ALICE);\n\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_AMOUNT / 2, false);\n\n    ghoFaucet(address(this), (DEFAULT_GSM_GHO_AMOUNT / 2) + 1);\n    GHO_TOKEN.approve(address(GHO_GSM_4626), type(uint256).max);\n\n    uint256 balanceBefore = GHO_TOKEN.balanceOf(address(this));\n    (, uint256 ghoLevelBefore) = IGhoToken(GHO_TOKEN).getFacilitatorBucket(address(GHO_GSM_4626));\n\n    uint256 ghoUsedForBacking = GHO_GSM_4626.backWithGho((DEFAULT_GSM_GHO_AMOUNT / 2) + 1);\n\n    uint256 balanceAfter = GHO_TOKEN.balanceOf(address(this));\n    (, uint256 ghoLevelAfter) = IGhoToken(GHO_TOKEN).getFacilitatorBucket(address(GHO_GSM_4626));\n\n    assertEq(DEFAULT_GSM_GHO_AMOUNT / 2, ghoUsedForBacking);\n    assertEq(balanceBefore - balanceAfter, ghoUsedForBacking);\n    assertEq(ghoLevelBefore - ghoLevelAfter, ghoUsedForBacking);\n\n    (excess, deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, 0, 'Unexpected excess value of GHO');\n    assertEq(deficit, 0, 'Unexpected deficit of GHO');\n  }\n\n  function testInjectUnderlying() public {\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    (uint256 excess, uint256 deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, 0, 'Unexpected excess value of GHO');\n    assertEq(deficit, 0, 'Unexpected deficit of GHO');\n\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_AMOUNT / 2, false);\n\n    (excess, deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, 0, 'Unexpected excess value of GHO');\n    assertEq(deficit, DEFAULT_GSM_GHO_AMOUNT / 2, 'Unexpected deficit of GHO');\n\n    GHO_GSM_4626.grantRole(GSM_CONFIGURATOR_ROLE, BOB);\n\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, BOB, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(BOB);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, false, true, address(GHO_GSM_4626));\n    emit BackingProvided(\n      BOB,\n      address(USDC_4626_TOKEN),\n      DEFAULT_GSM_USDC_AMOUNT,\n      DEFAULT_GSM_GHO_AMOUNT / 2,\n      0\n    );\n    uint256 usdcUsedForBacking = GHO_GSM_4626.backWithUnderlying(DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(DEFAULT_GSM_USDC_AMOUNT, usdcUsedForBacking);\n    vm.stopPrank();\n\n    (excess, deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, 0, 'Unexpected excess value of GHO');\n    assertEq(deficit, 0, 'Unexpected deficit of GHO');\n  }\n\n  function testInjectUnderlyingMoreThanNeeded() public {\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    (uint256 excess, uint256 deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, 0, 'Unexpected excess value of GHO');\n    assertEq(deficit, 0, 'Unexpected deficit of GHO');\n\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_AMOUNT / 2, false);\n\n    (excess, deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, 0, 'Unexpected excess value of GHO');\n    assertEq(deficit, DEFAULT_GSM_GHO_AMOUNT / 2, 'Unexpected deficit of GHO');\n\n    GHO_GSM_4626.grantRole(GSM_CONFIGURATOR_ROLE, BOB);\n\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, BOB, DEFAULT_GSM_USDC_AMOUNT + 1);\n\n    vm.startPrank(BOB);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT + 1);\n    vm.expectEmit(true, true, false, true, address(GHO_GSM_4626));\n    emit BackingProvided(\n      BOB,\n      address(USDC_4626_TOKEN),\n      DEFAULT_GSM_USDC_AMOUNT,\n      DEFAULT_GSM_GHO_AMOUNT / 2,\n      0\n    );\n    uint256 usdcUsedForBacking = GHO_GSM_4626.backWithUnderlying(DEFAULT_GSM_USDC_AMOUNT + 1);\n    assertEq(DEFAULT_GSM_USDC_AMOUNT, usdcUsedForBacking);\n    vm.stopPrank();\n\n    (excess, deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, 0, 'Unexpected excess value of GHO');\n    assertEq(deficit, 0, 'Unexpected deficit of GHO');\n  }\n\n  function testRevertBackWithNotAuthorized() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_CONFIGURATOR_ROLE, ALICE));\n    GHO_GSM_4626.backWithGho(0);\n    vm.expectRevert(AccessControlErrorsLib.MISSING_ROLE(GSM_CONFIGURATOR_ROLE, ALICE));\n    GHO_GSM_4626.backWithUnderlying(0);\n    vm.stopPrank();\n  }\n\n  function testRevertBackWithZeroAmount() public {\n    vm.expectRevert('INVALID_AMOUNT');\n    GHO_GSM_4626.backWithGho(0);\n    vm.expectRevert('INVALID_AMOUNT');\n    GHO_GSM_4626.backWithUnderlying(0);\n  }\n\n  function testRevertBackWithNoDeficit() public {\n    (uint256 excess, uint256 deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, 0, 'Unexpected excess value of GHO');\n    assertEq(deficit, 0, 'Unexpected deficit of GHO');\n    vm.expectRevert('NO_CURRENT_DEFICIT_BACKING');\n    GHO_GSM_4626.backWithGho(1);\n    vm.expectRevert('NO_CURRENT_DEFICIT_BACKING');\n    GHO_GSM_4626.backWithUnderlying(1);\n  }\n\n  function testDistributeFeesToTreasury() public {\n    uint256 fee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT, fee);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), fee, 'Unexpected GSM GHO balance');\n    assertEq(GHO_GSM_4626.getAccruedFees(), fee, 'Unexpected GSM accrued fees');\n\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit FeesDistributedToTreasury(\n      TREASURY,\n      address(GHO_TOKEN),\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626))\n    );\n\n    GHO_GSM_4626.distributeFeesToTreasury();\n\n    assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      0,\n      'Unexpected GSM GHO balance post-distribution'\n    );\n    assertEq(GHO_TOKEN.balanceOf(TREASURY), fee, 'Unexpected GHO balance in treasury');\n  }\n\n  function testDistributeYieldToTreasuryDoNothing() public {\n    uint256 gsmBalanceBefore = GHO_TOKEN.balanceOf(address(GHO_GSM_4626));\n    uint256 treasuryBalanceBefore = GHO_TOKEN.balanceOf(address(TREASURY));\n    assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n\n    vm.record();\n    GHO_GSM_4626.distributeFeesToTreasury();\n    (, bytes32[] memory writes) = vm.accesses(address(GHO_GSM_4626));\n    assertEq(writes.length, 0, 'Unexpected update of accrued fees');\n\n    assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      gsmBalanceBefore,\n      'Unexpected GSM GHO balance post-distribution'\n    );\n    assertEq(\n      GHO_TOKEN.balanceOf(TREASURY),\n      treasuryBalanceBefore,\n      'Unexpected GHO balance in treasury'\n    );\n  }\n\n  function testGetAccruedFees() public {\n    assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n\n    uint256 sellFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 buyFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_BUY_FEE);\n\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), sellFee, 'Unexpected GSM GHO balance');\n    assertEq(GHO_GSM_4626.getAccruedFees(), sellFee, 'Unexpected GSM accrued fees');\n\n    ghoFaucet(BOB, DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.startPrank(BOB);\n    GHO_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_GHO_AMOUNT + buyFee);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit BuyAsset(BOB, BOB, DEFAULT_GSM_USDC_AMOUNT, DEFAULT_GSM_GHO_AMOUNT + buyFee, buyFee);\n    GHO_GSM_4626.buyAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n    vm.stopPrank();\n\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      sellFee + buyFee,\n      'Unexpected GSM GHO balance'\n    );\n    assertEq(GHO_GSM_4626.getAccruedFees(), sellFee + buyFee, 'Unexpected GSM accrued fees');\n  }\n\n  function testGetAccruedFeesWithZeroFee() public {\n    vm.expectEmit(true, true, false, true, address(GHO_GSM_4626));\n    emit FeeStrategyUpdated(address(GHO_GSM_FIXED_FEE_STRATEGY), address(0));\n    GHO_GSM_4626.updateFeeStrategy(address(0));\n\n    assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n\n    for (uint256 i = 0; i < 10; i++) {\n      _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n      assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n\n      ghoFaucet(BOB, DEFAULT_GSM_GHO_AMOUNT);\n      vm.startPrank(BOB);\n      GHO_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_GHO_AMOUNT);\n      GHO_GSM_4626.buyAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n      vm.stopPrank();\n\n      assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n    }\n  }\n}\n"
    },
    "src/test/TestGsm4626Edge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGsm4626Edge is TestGhoBase {\n  using PercentageMath for uint256;\n  using PercentageMath for uint128;\n\n  function testOngoingExposureSellAsset() public {\n    (, uint256 ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(ghoLevel, 0);\n    assertEq(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)), 0);\n    assertEq(USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))), 0);\n    assertEq(GHO_GSM_4626.getAvailableUnderlyingExposure(), DEFAULT_GSM_USDC_EXPOSURE);\n    assertEq(GHO_GSM_4626.getAvailableLiquidity(), 0);\n\n    uint128 sellAssetAmount = DEFAULT_GSM_USDC_AMOUNT;\n    uint256 sellFee = DEFAULT_GSM_GHO_AMOUNT.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 calcGhoMinted = DEFAULT_GSM_GHO_AMOUNT;\n    uint256 calcExposure = DEFAULT_GSM_USDC_AMOUNT;\n    uint256 ghoBought = _sellAsset(\n      GHO_GSM_4626,\n      USDC_4626_TOKEN,\n      USDC_TOKEN,\n      ALICE,\n      sellAssetAmount\n    );\n    assertEq(ghoBought, calcGhoMinted - sellFee, 'Unexpected GHO amount bought');\n\n    (, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(ghoLevel, calcGhoMinted);\n    assertEq(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)), sellAssetAmount);\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - calcExposure\n    );\n    assertEq(GHO_GSM_4626.getAvailableLiquidity(), calcExposure);\n    assertEq(\n      USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))),\n      sellAssetAmount\n    );\n\n    // Inflate exchange rate\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, sellAssetAmount, true);\n\n    // same exposure\n    assertEq(ghoLevel, calcGhoMinted);\n    assertEq(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)), calcExposure);\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - calcExposure\n    );\n    assertEq(GHO_GSM_4626.getAvailableLiquidity(), calcExposure);\n    assertEq(\n      USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))),\n      sellAssetAmount * 2\n    );\n\n    // more GHO minted with same amount sold\n    uint256 ghoAmountBefore = GHO_TOKEN.balanceOf(ALICE);\n    uint256 ghoReceived = ghoAmountBefore;\n\n    sellFee = (DEFAULT_GSM_GHO_AMOUNT * 2).percentMul(DEFAULT_GSM_SELL_FEE);\n    calcGhoMinted += DEFAULT_GSM_GHO_AMOUNT * 2;\n    calcExposure += DEFAULT_GSM_USDC_AMOUNT;\n    ghoBought = _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, sellAssetAmount);\n    assertEq(ghoBought, (DEFAULT_GSM_GHO_AMOUNT * 2) - sellFee, 'Unexpected GHO amount bought');\n\n    uint256 ghoAmountAfter = GHO_TOKEN.balanceOf(ALICE) - ghoAmountBefore;\n    assertEq(ghoAmountAfter, ghoReceived * 2);\n\n    (, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(ghoLevel, calcGhoMinted);\n    assertEq(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)), calcExposure);\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - calcExposure\n    );\n    assertEq(GHO_GSM_4626.getAvailableLiquidity(), calcExposure);\n    assertEq(\n      USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))),\n      sellAssetAmount * 2 * 2\n    );\n\n    // Deflate exchange rate\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, sellAssetAmount * 3, false);\n\n    // same exposure\n    assertEq(ghoLevel, calcGhoMinted);\n    assertEq(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)), calcExposure);\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - calcExposure\n    );\n    assertEq(GHO_GSM_4626.getAvailableLiquidity(), calcExposure);\n    assertEq(\n      USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))),\n      sellAssetAmount\n    );\n\n    // less GHO minted with same amount sold\n    ghoAmountBefore = GHO_TOKEN.balanceOf(ALICE);\n\n    sellFee = (DEFAULT_GSM_GHO_AMOUNT / 2).percentMul(DEFAULT_GSM_SELL_FEE);\n    calcGhoMinted += DEFAULT_GSM_GHO_AMOUNT / 2;\n    calcExposure += DEFAULT_GSM_USDC_AMOUNT;\n    ghoBought = _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, sellAssetAmount);\n    assertEq(ghoBought, (DEFAULT_GSM_GHO_AMOUNT / 2) - sellFee, 'Unexpected GHO amount bought');\n\n    ghoAmountAfter = GHO_TOKEN.balanceOf(ALICE) - ghoAmountBefore;\n    assertEq(ghoAmountAfter, ghoReceived / 2);\n  }\n\n  function testSellAssetWithHighExchangeRate() public {\n    uint256 resultingAssets = DEFAULT_GSM_USDC_AMOUNT * 2;\n    uint256 grossAmount = DEFAULT_GSM_GHO_AMOUNT * 2;\n    uint256 fee = grossAmount.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 ghoOut = grossAmount - fee;\n\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    // Inflate exchange rate\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_AMOUNT, true);\n    assertEq(USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(ALICE)), resultingAssets);\n\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, grossAmount, fee);\n    (uint256 assetAmount, uint256 ghoBought) = GHO_GSM_4626.sellAsset(\n      DEFAULT_GSM_USDC_AMOUNT,\n      ALICE\n    );\n    vm.stopPrank();\n\n    assertEq(ghoBought, ghoOut, 'Unexpected GHO amount bought');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected asset amount sold');\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), fee, 'Unexpected GSM GHO balance');\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available liquidity'\n    );\n  }\n\n  function testSellAssetWithLowExchangeRate() public {\n    uint256 resultingAssets = DEFAULT_GSM_USDC_AMOUNT / 2;\n    uint256 grossAmount = DEFAULT_GSM_GHO_AMOUNT / 2;\n    uint256 fee = grossAmount.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 ghoOut = grossAmount - fee;\n\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n\n    // Deflate exchange rate\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_AMOUNT / 2, false);\n    assertEq(USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(ALICE)), resultingAssets);\n\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_AMOUNT);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_AMOUNT, grossAmount, fee);\n    (uint256 assetAmount, uint256 ghoBought) = GHO_GSM_4626.sellAsset(\n      DEFAULT_GSM_USDC_AMOUNT,\n      ALICE\n    );\n    vm.stopPrank();\n\n    assertEq(ghoBought, ghoOut, 'Unexpected GHO amount bought');\n    assertEq(assetAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected asset amount sold');\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), fee, 'Unexpected GSM GHO balance');\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available liquidity'\n    );\n  }\n\n  function testExposureLimitWithSharpExchangeRate() public {\n    Gsm4626 gsm = new Gsm4626(\n      address(GHO_TOKEN),\n      address(USDC_4626_TOKEN),\n      address(GHO_GSM_4626_FIXED_PRICE_STRATEGY)\n    );\n    gsm.initialize(address(this), TREASURY, DEFAULT_GSM_USDC_EXPOSURE - 1);\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM Modified Exposure Cap', DEFAULT_CAPACITY);\n\n    uint128 depositAmount = DEFAULT_GSM_USDC_EXPOSURE / 2;\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, depositAmount);\n\n    // Inflate exchange rate\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, depositAmount, true);\n    assertEq(\n      USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(ALICE)),\n      DEFAULT_GSM_USDC_EXPOSURE\n    );\n\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(gsm), depositAmount);\n    gsm.sellAsset(depositAmount, ALICE);\n    assertEq(gsm.getAvailableLiquidity(), depositAmount);\n    assertEq(gsm.getAvailableUnderlyingExposure(), DEFAULT_GSM_USDC_EXPOSURE - 1 - depositAmount);\n    vm.stopPrank();\n  }\n\n  function testRevertExposureWithSharpExchangeRate() public {\n    Gsm4626 gsm = new Gsm4626(\n      address(GHO_TOKEN),\n      address(USDC_4626_TOKEN),\n      address(GHO_GSM_4626_FIXED_PRICE_STRATEGY)\n    );\n    gsm.initialize(address(this), TREASURY, DEFAULT_GSM_USDC_EXPOSURE - 1);\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM Modified Exposure Cap', DEFAULT_CAPACITY);\n\n    uint128 depositAmount = DEFAULT_GSM_USDC_EXPOSURE * 2;\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, depositAmount);\n\n    // Deflate exchange rate\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_EXPOSURE, false);\n    assertEq(\n      USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(ALICE)),\n      DEFAULT_GSM_USDC_EXPOSURE\n    );\n\n    vm.prank(ALICE);\n    vm.expectRevert('EXOGENOUS_ASSET_EXPOSURE_TOO_HIGH');\n    gsm.sellAsset(depositAmount, ALICE);\n  }\n\n  function testDistributeYieldToTreasury() public {\n    /**\n     * 1. Alice sellAsset with 1:1 exchangeRate\n     * 2. ExchangeRate increases, so there is an excess of backing\n     * 3. Distribute GHO fees to treasury, which redirect excess yield in form of GHO too\n     */\n\n    uint256 grossAmount = DEFAULT_GSM_GHO_AMOUNT;\n    uint256 fee = grossAmount.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 ghoOut = grossAmount - fee;\n\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(GHO_GSM_4626.getAccruedFees(), fee, 'Unexpected GSM accrued fees');\n\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), fee, 'Unexpected GSM GHO balance');\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available liquidity'\n    );\n\n    uint256 backingBefore = USDC_4626_TOKEN.previewRedeem(\n      USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))\n    );\n\n    // Inflate exchange rate\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_AMOUNT, true);\n    // Accrued dees does not change\n    assertEq(GHO_GSM_4626.getAccruedFees(), fee, 'Unexpected GSM accrued fees');\n\n    // Same underlying exposure\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available liquidity'\n    );\n\n    // More backing than before\n    uint256 backingAfter = USDC_4626_TOKEN.previewRedeem(\n      USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))\n    );\n    assertEq(backingAfter, backingBefore * 2);\n\n    // Distribute fees and yield in form of GHO to the treasury\n    uint256 totalBackedGho = GHO_GSM_4626_FIXED_PRICE_STRATEGY.getAssetPriceInGho(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      true\n    );\n    (, uint256 totalMintedGho) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(totalBackedGho, totalMintedGho + DEFAULT_GSM_GHO_AMOUNT);\n\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit FeesDistributedToTreasury(\n      TREASURY,\n      address(GHO_TOKEN),\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)) + DEFAULT_GSM_GHO_AMOUNT\n    );\n\n    // Accrued fees does not change, only upon swap action or distribution of fees\n    assertEq(GHO_GSM_4626.getAccruedFees(), fee, 'Unexpected GSM accrued fees');\n\n    GHO_GSM_4626.distributeFeesToTreasury();\n\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      0,\n      'Unexpected GSM GHO balance post-distribution'\n    );\n    assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n    assertEq(\n      GHO_TOKEN.balanceOf(TREASURY),\n      fee + DEFAULT_GSM_GHO_AMOUNT,\n      'Unexpected GHO balance in treasury'\n    );\n\n    (, totalMintedGho) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(\n      totalBackedGho,\n      GHO_GSM_4626_FIXED_PRICE_STRATEGY.getAssetPriceInGho(\n        GHO_GSM_4626.getAvailableLiquidity(),\n        false\n      )\n    );\n    assertEq(totalBackedGho, totalMintedGho);\n  }\n\n  function testDistributeYieldToTreasuryDoNothing() public {\n    uint256 gsmBalanceBefore = GHO_TOKEN.balanceOf(address(GHO_GSM_4626));\n    uint256 treasuryBalanceBefore = GHO_TOKEN.balanceOf(address(TREASURY));\n    assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n\n    GHO_GSM_4626.distributeFeesToTreasury();\n\n    assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      gsmBalanceBefore,\n      'Unexpected GSM GHO balance post-distribution'\n    );\n    assertEq(\n      GHO_TOKEN.balanceOf(TREASURY),\n      treasuryBalanceBefore,\n      'Unexpected GHO balance in treasury'\n    );\n  }\n\n  function testDistributeYieldToTreasuryWithNoExcess() public {\n    /**\n     * 1. Alice sellAsset with 1:1 exchangeRate\n     * 2. Distribute GHO fees to treasury, but there is no yield from excess backing\n     */\n\n    uint256 grossAmount = DEFAULT_GSM_GHO_AMOUNT;\n    uint256 fee = grossAmount.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 ghoOut = grossAmount - fee;\n\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(GHO_GSM_4626.getAccruedFees(), fee, 'Unexpected GSM accrued fees');\n\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), fee, 'Unexpected GSM GHO balance');\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available liquidity'\n    );\n\n    // Distribute fees, with no yield in GHO to redirect\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit FeesDistributedToTreasury(\n      TREASURY,\n      address(GHO_TOKEN),\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626))\n    );\n    uint256 totalBackedGho = GHO_GSM_4626_FIXED_PRICE_STRATEGY.getAssetPriceInGho(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      false\n    );\n    (, uint256 totalMintedGho) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(totalBackedGho, totalMintedGho);\n\n    GHO_GSM_4626.distributeFeesToTreasury();\n\n    assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      0,\n      'Unexpected GSM GHO balance post-distribution'\n    );\n    assertEq(GHO_TOKEN.balanceOf(TREASURY), fee, 'Unexpected GHO balance in treasury');\n\n    (, totalMintedGho) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(totalBackedGho, totalMintedGho);\n  }\n\n  function testDistributeYieldToTreasuryWithLosses() public {\n    /**\n     * 1. Alice sellAsset with 1:1 exchangeRate\n     * 2. ExchangeRate decreases, so there is a loss\n     * 3. Distribute of GHO fees only\n     * 4. Portion of minted GHO unbacked\n     */\n\n    uint256 grossAmount = DEFAULT_GSM_GHO_AMOUNT;\n    uint256 fee = grossAmount.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 ghoOut = grossAmount - fee;\n\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    assertEq(GHO_GSM_4626.getAccruedFees(), fee, 'Unexpected GSM accrued fees');\n\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), fee, 'Unexpected GSM GHO balance');\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available liquidity'\n    );\n\n    uint256 backingBefore = USDC_4626_TOKEN.previewRedeem(\n      USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))\n    );\n\n    // Deflate exchange rate\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_AMOUNT / 2, false);\n    assertEq(\n      USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))),\n      DEFAULT_GSM_USDC_AMOUNT / 2\n    );\n    // Accrued fees does not change\n    assertEq(GHO_GSM_4626.getAccruedFees(), fee, 'Unexpected GSM accrued fees');\n\n    // Same underlying exposure\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available liquidity'\n    );\n\n    // Less backing than before\n    uint256 backingAfter = USDC_4626_TOKEN.previewRedeem(\n      USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))\n    );\n    assertEq(backingAfter, backingBefore / 2);\n\n    // Distribute fees\n    uint256 totalBackedGho = GHO_GSM_4626_FIXED_PRICE_STRATEGY.getAssetPriceInGho(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      false\n    );\n    (, uint256 totalMintedGho) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(totalBackedGho, totalMintedGho / 2);\n\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit FeesDistributedToTreasury(\n      TREASURY,\n      address(GHO_TOKEN),\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626))\n    );\n\n    GHO_GSM_4626.distributeFeesToTreasury();\n\n    assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      0,\n      'Unexpected GSM GHO balance post-distribution'\n    );\n    assertEq(GHO_TOKEN.balanceOf(TREASURY), fee, 'Unexpected GHO balance in treasury');\n    assertEq(totalBackedGho, totalMintedGho / 2);\n  }\n\n  function testDistributeYieldToTreasuryWithExcessExceedingCapacity() public {\n    /**\n     * 1. Alice sellAsset with 1:1 exchangeRate\n     * 2. Facilitator capacity set to an amount less than the accrued fees\n     * 3. ExchangeRate increases, so there is an excess of backing\n     * 4. The distribution fees should mint up to the remaining capacity\n     */\n    uint256 ongoingAccruedFees = 0;\n\n    uint256 grossAmount = DEFAULT_GSM_GHO_AMOUNT;\n    uint256 fee = grossAmount.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 ghoOut = grossAmount - fee;\n\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    ongoingAccruedFees += fee;\n\n    assertEq(GHO_GSM_4626.getAccruedFees(), ongoingAccruedFees, 'Unexpected GSM accrued fees');\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), fee, 'Unexpected GSM GHO balance');\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available liquidity'\n    );\n\n    // set the capacity to be less than the amount of fees accrued\n    uint128 feePercentToMint = 0.3e4; // 30%\n    uint128 margin = uint128(fee.percentMul(feePercentToMint));\n    uint128 capacity = DEFAULT_GSM_GHO_AMOUNT + margin;\n    GHO_TOKEN.setFacilitatorBucketCapacity(address(GHO_GSM_4626), capacity);\n\n    // Inflate exchange rate\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_AMOUNT, true);\n    (uint256 excessBeforeDistribution, uint256 deficitBeforeDistribution) = GHO_GSM_4626\n      .getCurrentBacking();\n    assertEq(excessBeforeDistribution, (DEFAULT_GSM_USDC_AMOUNT) * 1e12, 'Unexpected excess');\n    assertEq(deficitBeforeDistribution, 0, 'Unexpected non-zero deficit');\n\n    (uint256 ghoCapacity, uint256 ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    uint256 ghoAvailableToMint = ghoCapacity - ghoLevel;\n\n    assertEq(ghoAvailableToMint, margin, 'Unexpected GHO amount available to mint');\n\n    // Fee distribution\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit FeesDistributedToTreasury(TREASURY, address(GHO_TOKEN), ongoingAccruedFees + margin);\n    GHO_GSM_4626.distributeFeesToTreasury();\n\n    (ghoCapacity, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    ghoAvailableToMint = ghoCapacity - ghoLevel;\n    assertEq(ghoAvailableToMint, 0);\n\n    assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), 0, 'Unexpected GSM GHO balance');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(TREASURY)),\n      ongoingAccruedFees + margin,\n      'Unexpected Treasury GHO balance'\n    );\n\n    (uint256 excessAfterDistribution, uint256 deficitAfterDistribution) = GHO_GSM_4626\n      .getCurrentBacking();\n    assertEq(\n      excessAfterDistribution,\n      excessBeforeDistribution - fee.percentMul(feePercentToMint),\n      'Unexpected excess'\n    );\n    assertEq(deficitAfterDistribution, 0, 'Unexpected non-zero deficit');\n  }\n\n  function testGetAccruedFeesWithHighExchangeRate() public {\n    /**\n     * 1. Alice sellAsset with 1:1 exchangeRate\n     * 2. ExchangeRate increases, so there is an excess of backing\n     * 3. Accrued fees does not factor in new yield in form of GHO\n     * 4. A new sellAsset does not accrue fees from yield (only the swap fee)\n     * 5. A new buyAsset accrues fees from the swap fee and yield\n     * 6. The distribution of fees does not add new fees\n     */\n    uint256 ongoingAccruedFees = 0;\n\n    uint256 grossAmount = DEFAULT_GSM_GHO_AMOUNT;\n    uint256 sellFee = grossAmount.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 ghoOut = grossAmount - sellFee;\n\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    ongoingAccruedFees += sellFee;\n    assertEq(GHO_GSM_4626.getAccruedFees(), ongoingAccruedFees, 'Unexpected GSM accrued fees');\n\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      ongoingAccruedFees,\n      'Unexpected GSM GHO balance'\n    );\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available liquidity'\n    );\n\n    // Inflate exchange rate\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_AMOUNT, true);\n    // Accrued dees does not change\n    assertEq(GHO_GSM_4626.getAccruedFees(), ongoingAccruedFees, 'Unexpected GSM accrued fees');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      ongoingAccruedFees,\n      'Unexpected GSM GHO balance'\n    );\n\n    // Yield in form of GHO, not accrued yet\n    uint256 totalBackedGho = GHO_GSM_4626_FIXED_PRICE_STRATEGY.getAssetPriceInGho(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      false\n    );\n    (, uint256 totalMintedGho) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    uint256 yieldInGho = totalBackedGho - totalMintedGho;\n    assertEq(yieldInGho, DEFAULT_GSM_GHO_AMOUNT);\n\n    // Sell asset accrues only the swap fee\n    grossAmount = DEFAULT_GSM_GHO_AMOUNT * 2; // taking exchange rate into account\n    sellFee = grossAmount.percentMul(DEFAULT_GSM_SELL_FEE);\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    ongoingAccruedFees += sellFee;\n    assertEq(GHO_GSM_4626.getAccruedFees(), ongoingAccruedFees, 'Unexpected GSM accrued fees');\n\n    // Buy asset accrues only the swap fee\n    grossAmount = DEFAULT_GSM_GHO_AMOUNT * 2; // taking exchange rate into account\n    uint256 buyFee = grossAmount.percentMul(DEFAULT_GSM_BUY_FEE);\n    ghoFaucet(BOB, grossAmount + buyFee);\n    vm.startPrank(BOB);\n    GHO_TOKEN.approve(address(GHO_GSM_4626), grossAmount + buyFee);\n    GHO_GSM_4626.buyAsset(DEFAULT_GSM_USDC_AMOUNT, BOB);\n    vm.stopPrank();\n\n    ongoingAccruedFees += buyFee + yieldInGho;\n    assertEq(GHO_GSM_4626.getAccruedFees(), ongoingAccruedFees, 'Unexpected GSM accrued fees');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      ongoingAccruedFees,\n      'Unexpected GSM GHO balance'\n    );\n\n    // Fee distribution\n    uint256 treasuryBalanceBefore = GHO_TOKEN.balanceOf(address(TREASURY));\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit FeesDistributedToTreasury(TREASURY, address(GHO_TOKEN), ongoingAccruedFees);\n    GHO_GSM_4626.distributeFeesToTreasury();\n\n    assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), 0, 'Unexpected GSM GHO balance');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(TREASURY)) - treasuryBalanceBefore,\n      ongoingAccruedFees,\n      'Unexpected Treasury GHO balance'\n    );\n  }\n\n  function testGetAccruedFeesWithHighExchangeRateAndMaxedOutCapacity() public {\n    /**\n     * 1. Alice sellAsset with 1:1 exchangeRate\n     * 2. ExchangeRate increases, so there is an excess of backing\n     * 3. Accrued fees does not factor in new yield in form of GHO\n     * 4. A new sellAsset does not accrue fees from yield (only the swap fee)\n     * 5. Bucket capacity is set to 0, so yield in form of GHO cannot be minted\n     * 6. The distribution of fees does not accrue fees from yield in form of GHO\n     */\n    uint256 ongoingAccruedFees = 0;\n\n    uint256 grossAmount = DEFAULT_GSM_GHO_AMOUNT;\n    uint256 sellFee = grossAmount.percentMul(DEFAULT_GSM_SELL_FEE);\n    uint256 ghoOut = grossAmount - sellFee;\n\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    ongoingAccruedFees += sellFee;\n    assertEq(GHO_GSM_4626.getAccruedFees(), ongoingAccruedFees, 'Unexpected GSM accrued fees');\n\n    assertEq(USDC_TOKEN.balanceOf(ALICE), 0, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), ghoOut, 'Unexpected final GHO balance');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      ongoingAccruedFees,\n      'Unexpected GSM GHO balance'\n    );\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available underlying exposure'\n    );\n    assertEq(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      DEFAULT_GSM_USDC_AMOUNT,\n      'Unexpected available liquidity'\n    );\n\n    // Inflate exchange rate\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_AMOUNT, true);\n    // Accrued dees does not change\n    assertEq(GHO_GSM_4626.getAccruedFees(), ongoingAccruedFees, 'Unexpected GSM accrued fees');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(GHO_GSM_4626)),\n      ongoingAccruedFees,\n      'Unexpected GSM GHO balance'\n    );\n\n    // Yield in form of GHO, not accrued yet\n    uint256 totalBackedGho = GHO_GSM_4626_FIXED_PRICE_STRATEGY.getAssetPriceInGho(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      false\n    );\n    (, uint256 totalMintedGho) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    uint256 yieldInGho = totalBackedGho - totalMintedGho;\n    assertEq(yieldInGho, DEFAULT_GSM_GHO_AMOUNT);\n\n    // Sell asset accrues only the swap fee\n    grossAmount = DEFAULT_GSM_GHO_AMOUNT * 2; // taking exchange rate into account\n    sellFee = grossAmount.percentMul(DEFAULT_GSM_SELL_FEE);\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    ongoingAccruedFees += sellFee;\n    assertEq(GHO_GSM_4626.getAccruedFees(), ongoingAccruedFees, 'Unexpected GSM accrued fees');\n\n    // Bucket capacity of GSM set to 0 so no more GHO can be minted (including yield in form of GHO)\n    GHO_TOKEN.setFacilitatorBucketCapacity(address(GHO_GSM_4626), 0);\n\n    // Fee distribution\n    uint256 treasuryBalanceBefore = GHO_TOKEN.balanceOf(address(TREASURY));\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit FeesDistributedToTreasury(TREASURY, address(GHO_TOKEN), ongoingAccruedFees);\n    GHO_GSM_4626.distributeFeesToTreasury();\n\n    assertEq(GHO_GSM_4626.getAccruedFees(), 0, 'Unexpected GSM accrued fees');\n    assertEq(GHO_TOKEN.balanceOf(address(GHO_GSM_4626)), 0, 'Unexpected GSM GHO balance');\n    assertEq(\n      GHO_TOKEN.balanceOf(address(TREASURY)) - treasuryBalanceBefore,\n      ongoingAccruedFees,\n      'Unexpected Treasury GHO balance'\n    );\n  }\n\n  function testBuyAssetAfterHighExchangeRate() public {\n    /**\n     * 1. Alice sellAsset with 1:1 exchangeRate\n     * 2. Exchange rate increases, there is an excess of underlying backing GHO\n     * 3. Alice buyAsset of the current exposure. There is a mint of GHO before the action so the level is updated.\n     */\n\n    (, uint256 ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(ghoLevel, 0);\n    assertEq(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)), 0);\n    assertEq(USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))), 0);\n    assertEq(GHO_GSM_4626.getAvailableUnderlyingExposure(), DEFAULT_GSM_USDC_EXPOSURE);\n    assertEq(GHO_GSM_4626.getAvailableLiquidity(), 0);\n\n    uint128 sellAssetAmount = DEFAULT_GSM_USDC_AMOUNT;\n    uint256 calcGhoMinted = DEFAULT_GSM_GHO_AMOUNT;\n    uint256 calcExposure = DEFAULT_GSM_USDC_AMOUNT;\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, sellAssetAmount);\n\n    (, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(ghoLevel, calcGhoMinted);\n    assertEq(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)), sellAssetAmount);\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - calcExposure\n    );\n    assertEq(GHO_GSM_4626.getAvailableLiquidity(), calcExposure);\n    assertEq(\n      USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))),\n      sellAssetAmount\n    );\n\n    // Inflate exchange rate\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, sellAssetAmount, true);\n\n    assertEq(ghoLevel, calcGhoMinted);\n    assertEq(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)), calcExposure);\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - calcExposure\n    );\n    assertEq(GHO_GSM_4626.getAvailableLiquidity(), calcExposure);\n    assertEq(\n      USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))),\n      sellAssetAmount * 2\n    );\n\n    // Top up Alice with GHO\n    ghoFaucet(ALICE, 1_000_000e18);\n\n    // Alice buy all assets and there is a mint of GHO backed by excess of underlying before the action\n    vm.startPrank(ALICE);\n    GHO_TOKEN.approve(address(GHO_GSM_4626), type(uint256).max);\n\n    uint256 totalBackedGho = GHO_GSM_4626_FIXED_PRICE_STRATEGY.getAssetPriceInGho(\n      GHO_GSM_4626.getAvailableLiquidity(),\n      false\n    );\n    (, uint256 totalMintedGho) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(totalBackedGho, totalMintedGho + DEFAULT_GSM_GHO_AMOUNT);\n\n    calcGhoMinted = 0;\n    calcExposure = 0;\n    GHO_GSM_4626.buyAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    (, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(ghoLevel, calcGhoMinted);\n    assertEq(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)), calcExposure);\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - calcExposure\n    );\n    assertEq(GHO_GSM_4626.getAvailableLiquidity(), calcExposure);\n    assertEq(USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))), 0);\n  }\n\n  function testBuyAssetAfterLowExchangeRate() public {\n    /**\n     * 1. Alice sellAsset with 1:1 exchangeRate\n     * 2. Exchange rate decreases, there is a portion of GHO unbacked\n     * 3. Alice buyAsset of the current exposure\n     * 4. Exposure is 0 but level is not 0, so there is unbacked GHO\n     */\n\n    (, uint256 ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(ghoLevel, 0);\n    assertEq(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)), 0);\n    assertEq(USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))), 0);\n    assertEq(GHO_GSM_4626.getAvailableUnderlyingExposure(), DEFAULT_GSM_USDC_EXPOSURE);\n    assertEq(GHO_GSM_4626.getAvailableLiquidity(), 0);\n\n    uint128 sellAssetAmount = DEFAULT_GSM_USDC_AMOUNT;\n    uint256 calcGhoMinted = DEFAULT_GSM_GHO_AMOUNT;\n    uint256 calcExposure = DEFAULT_GSM_USDC_AMOUNT;\n    _sellAsset(GHO_GSM_4626, USDC_4626_TOKEN, USDC_TOKEN, ALICE, sellAssetAmount);\n\n    (, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(ghoLevel, calcGhoMinted);\n    assertEq(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)), sellAssetAmount);\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - calcExposure\n    );\n    assertEq(GHO_GSM_4626.getAvailableLiquidity(), calcExposure);\n    assertEq(\n      USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))),\n      sellAssetAmount\n    );\n\n    // Deflate exchange rate\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_AMOUNT / 2, false);\n\n    assertEq(ghoLevel, calcGhoMinted);\n    assertEq(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)), calcExposure);\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - calcExposure\n    );\n    assertEq(GHO_GSM_4626.getAvailableLiquidity(), calcExposure);\n    assertEq(\n      USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))),\n      sellAssetAmount / 2\n    );\n\n    // Top up Alice with GHO\n    ghoFaucet(ALICE, 1_000_000e18);\n\n    // Buy all assets\n    vm.startPrank(ALICE);\n    calcGhoMinted = DEFAULT_GSM_GHO_AMOUNT / 2;\n    calcExposure = 0;\n    GHO_TOKEN.approve(address(GHO_GSM_4626), type(uint256).max);\n    GHO_GSM_4626.buyAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    // 0 exposure, but non-zero level\n    (, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertTrue(ghoLevel != 0);\n    assertEq(ghoLevel, calcGhoMinted);\n    assertEq(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626)), calcExposure);\n    assertEq(\n      GHO_GSM_4626.getAvailableUnderlyingExposure(),\n      DEFAULT_GSM_USDC_EXPOSURE - calcExposure\n    );\n    assertEq(GHO_GSM_4626.getAvailableLiquidity(), calcExposure);\n    assertEq(USDC_4626_TOKEN.previewRedeem(USDC_4626_TOKEN.balanceOf(address(GHO_GSM_4626))), 0);\n  }\n\n  function testBuyAssetAtCapacityWithGain() public {\n    /**\n     * 1. Alice sellAsset with 1:1 exchangeRate, up to the maximum exposure\n     * 2. Exchange rate increases,  there is an excess of underlying backing GHO\n     * 3. Alice buyAsset of the maximum exposure, but excess is not minted due to maximum exposure maxed out\n     * 4. Excess is minted once a buyAsset occurs and the maximum is not maxed out\n     */\n    // Use zero fees for easier calculations\n    vm.expectEmit(true, true, false, true, address(GHO_GSM_4626));\n    emit FeeStrategyUpdated(address(GHO_GSM_FIXED_FEE_STRATEGY), address(0));\n    GHO_GSM_4626.updateFeeStrategy(address(0));\n\n    // Supply assets to the GSM first\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_EXPOSURE);\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_GSM_USDC_EXPOSURE);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit SellAsset(ALICE, ALICE, DEFAULT_GSM_USDC_EXPOSURE, DEFAULT_CAPACITY, 0);\n    GHO_GSM_4626.sellAsset(DEFAULT_GSM_USDC_EXPOSURE, ALICE);\n    vm.stopPrank();\n\n    (uint256 ghoCapacity, uint256 ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(ghoLevel, ghoCapacity, 'Unexpected GHO bucket level after initial sell');\n\n    // Simulate a gain\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_EXPOSURE / 4, true);\n    (uint256 excess, uint256 deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, (DEFAULT_GSM_USDC_EXPOSURE / 4) * 1e12, 'Unexpected excess');\n    assertEq(deficit, 0, 'Unexpected non-zero deficit');\n    uint128 buyAmount = DEFAULT_CAPACITY / (((5 * DEFAULT_GSM_USDC_EXPOSURE) / 4) / 100);\n\n    vm.startPrank(ALICE);\n    GHO_TOKEN.approve(address(GHO_GSM_4626), DEFAULT_CAPACITY);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit BuyAsset(ALICE, ALICE, buyAmount, DEFAULT_CAPACITY, 0);\n    GHO_GSM_4626.buyAsset(buyAmount, ALICE);\n    vm.stopPrank();\n\n    assertEq(USDC_4626_TOKEN.balanceOf(ALICE), buyAmount, 'Unexpected final USDC balance');\n    assertEq(GHO_TOKEN.balanceOf(ALICE), 0, 'Unexpected final GHO balance');\n\n    // Ensure GHO level is at 0, but that excess is unchanged\n    (, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    (ghoCapacity, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(ghoLevel, 0, 'Unexpected GHO bucket level after initial sell');\n    (excess, deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, (DEFAULT_GSM_USDC_EXPOSURE / 4) * 1e12, 'Unexpected excess');\n    assertEq(deficit, 0, 'Unexpected non-zero deficit');\n\n    // Sell a bit of asset so its possible to buy\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), 2);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    // Expected amount is a result of a 25% gain on 2 of the underlying getting rounded down\n    emit SellAsset(ALICE, ALICE, 2, 2e12, 0);\n    GHO_GSM_4626.sellAsset(2, ALICE);\n    vm.stopPrank();\n\n    // Ensure GHO level is at 2e12, but that excess is unchanged\n    (, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(ghoLevel, 2e12, 'Unexpected GHO bucket level after initial sell');\n    (excess, deficit) = GHO_GSM_4626.getCurrentBacking();\n    assertEq(excess, (DEFAULT_GSM_USDC_EXPOSURE / 4) * 1e12, 'Unexpected excess');\n    assertEq(deficit, 0, 'Unexpected non-zero deficit');\n\n    // Buy a bit of asset so the excess is minted\n    vm.startPrank(ALICE);\n    GHO_TOKEN.approve(address(GHO_GSM_4626), 2e12);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit BuyAsset(ALICE, ALICE, 1, 2e12, 0);\n    GHO_GSM_4626.buyAsset(1, ALICE);\n    vm.stopPrank();\n\n    // Ensure GHO level is at the previous amount of excess, and excess is now 1e12\n    (, ghoLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM_4626));\n    assertEq(\n      ghoLevel,\n      (DEFAULT_GSM_USDC_EXPOSURE / 4) * 1e12,\n      'Unexpected GHO bucket level after final buy'\n    );\n    (excess, deficit) = GHO_GSM_4626.getCurrentBacking();\n    // Excess of 1e12 due to the last purchase (rounding is causing excess on every sell-buy)\n    assertEq(excess, 1e12, 'Unexpected excess');\n    assertEq(deficit, 0, 'Unexpected non-zero deficit');\n  }\n\n  function testExcessBuildUpDueToUnbalanced4626() public {\n    /**\n     * 1. Vault gets unbalanced, 1 share equals 1.25 assets\n     * 2. Alice sells 2 assets for 2e12 GHO\n     * 3. Alice buys 1 asset for 2e12 GHO\n     * 4. GSM gets 1 asset due to the imprecision error caused by math and unbalance vault\n     */\n    // Use zero fees for easier calculations\n    vm.expectEmit(true, true, false, true, address(GHO_GSM_4626));\n    emit FeeStrategyUpdated(address(GHO_GSM_FIXED_FEE_STRATEGY), address(0));\n    GHO_GSM_4626.updateFeeStrategy(address(0));\n\n    // Mint some vault shares first\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, DEFAULT_GSM_USDC_EXPOSURE);\n\n    // Simulate imbalance in vault (e.g. gift made to the vault, yield accumulation)\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, DEFAULT_GSM_USDC_EXPOSURE / 4, true);\n\n    // Sell 2 assets for 2e12 GHO\n    vm.startPrank(ALICE);\n    USDC_4626_TOKEN.approve(address(GHO_GSM_4626), 2);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    // Expected amount is a result of a 25% gain on 2 of the underlying getting rounded down\n    emit SellAsset(ALICE, ALICE, 2, 2e12, 0);\n    GHO_GSM_4626.sellAsset(2, ALICE);\n    vm.stopPrank();\n\n    // Buy 1 asset for 2e12 GHO\n    vm.startPrank(ALICE);\n    GHO_TOKEN.approve(address(GHO_GSM_4626), 2e12);\n    vm.expectEmit(true, true, true, true, address(GHO_GSM_4626));\n    emit BuyAsset(ALICE, ALICE, 1, 2e12, 0);\n    GHO_GSM_4626.buyAsset(1, ALICE);\n    vm.stopPrank();\n\n    (uint256 excess, uint256 deficit) = GHO_GSM_4626.getCurrentBacking();\n    // Excess of 1e12 due to the last purchase (rounding is causing excess on every sell-buy)\n    assertEq(excess, 1e12, 'Unexpected excess');\n    assertEq(deficit, 0, 'Unexpected non-zero deficit');\n  }\n}\n"
    },
    "src/test/TestGsmFixedFeeStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGsmFixedFeeStrategy is TestGhoBase {\n  function testRevertAboveMaximumFee() public {\n    vm.expectRevert('INVALID_BUY_FEE');\n    FixedFeeStrategy feeStrategy = new FixedFeeStrategy(5000, DEFAULT_GSM_SELL_FEE);\n\n    vm.expectRevert('INVALID_SELL_FEE');\n    feeStrategy = new FixedFeeStrategy(DEFAULT_GSM_BUY_FEE, 5000);\n  }\n\n  function testZeroBuyFee() public {\n    FixedFeeStrategy feeStrategy = new FixedFeeStrategy(0, DEFAULT_GSM_SELL_FEE);\n    uint256 fee = feeStrategy.getBuyFee(DEFAULT_GSM_GHO_AMOUNT);\n    assertEq(fee, 0, 'Unexpected non-zero fee');\n    assertEq(\n      feeStrategy.getGrossAmountFromTotalBought(DEFAULT_GSM_GHO_AMOUNT + fee),\n      DEFAULT_GSM_GHO_AMOUNT\n    );\n  }\n\n  function testZeroSellFee() public {\n    FixedFeeStrategy feeStrategy = new FixedFeeStrategy(DEFAULT_GSM_BUY_FEE, 0);\n    uint256 fee = feeStrategy.getSellFee(DEFAULT_GSM_GHO_AMOUNT);\n    assertEq(fee, 0, 'Unexpected non-zero fee');\n    assertEq(\n      feeStrategy.getGrossAmountFromTotalSold(DEFAULT_GSM_GHO_AMOUNT + fee),\n      DEFAULT_GSM_GHO_AMOUNT\n    );\n  }\n\n  function testRevertBothFeesZero() public {\n    vm.expectRevert('MUST_HAVE_ONE_NONZERO_FEE');\n    new FixedFeeStrategy(0, 0);\n  }\n}\n"
    },
    "src/test/TestGsmFixedPriceStrategy.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGsmFixedPriceStrategy is TestGhoBase {\n  function testConstructor(uint256 ratio, address underlying, uint8 decimals) public {\n    vm.assume(ratio > 0);\n    decimals = uint8(bound(decimals, 0, 40));\n\n    FixedPriceStrategy strategy = new FixedPriceStrategy(ratio, underlying, decimals);\n    assertEq(strategy.GHO_DECIMALS(), 18, 'Unexpected GHO decimals');\n    assertEq(strategy.PRICE_RATIO(), ratio, 'Unexpected price ratio');\n    assertEq(strategy.UNDERLYING_ASSET(), underlying, 'Unexpected underlying asset');\n    assertEq(\n      strategy.UNDERLYING_ASSET_DECIMALS(),\n      decimals,\n      'Unexpected underlying asset decimals'\n    );\n  }\n\n  function testOneToOnePriceRatio() public {\n    FixedPriceStrategy strategy = new FixedPriceStrategy(1e18, address(USDC_TOKEN), 6);\n    uint256 usdcIn = 100e6;\n    uint256 ghoOut = 100e18;\n    assertEq(strategy.getAssetPriceInGho(usdcIn, true), ghoOut, 'Unexpected asset price in GHO');\n    assertEq(strategy.getGhoPriceInAsset(ghoOut, false), usdcIn, 'Unexpected gho price in asset');\n  }\n\n  function testOneToTwoPriceRatio() public {\n    FixedPriceStrategy strategy = new FixedPriceStrategy(2e18, address(USDC_TOKEN), 6);\n    uint256 usdcIn = 100e6;\n    uint256 ghoOut = 200e18;\n    assertEq(strategy.getAssetPriceInGho(usdcIn, true), ghoOut, 'Unexpected asset price in GHO');\n    assertEq(strategy.getGhoPriceInAsset(ghoOut, false), usdcIn, 'Unexpected gho price in asset');\n  }\n\n  function testTwoToOnePriceRatio() public {\n    FixedPriceStrategy strategy = new FixedPriceStrategy(0.5e18, address(USDC_TOKEN), 6);\n    uint256 usdcIn = 100e6;\n    uint256 ghoOut = 50e18;\n    assertEq(strategy.getAssetPriceInGho(usdcIn, true), ghoOut, 'Unexpected asset price in GHO');\n    assertEq(strategy.getGhoPriceInAsset(ghoOut, false), usdcIn, 'Unexpected gho price in asset');\n  }\n\n  function testRevertZeroPriceRatio() public {\n    vm.expectRevert('INVALID_PRICE_RATIO');\n    new FixedPriceStrategy(0, address(USDC_TOKEN), 6);\n  }\n\n  function testFuzzingExchangeRate(\n    uint256 ratio,\n    address underlying,\n    uint8 decimals,\n    uint256 amount\n  ) public {\n    decimals = uint8(bound(decimals, 1, 40));\n    ratio = bound(ratio, 1, type(uint128).max - 1);\n    amount = bound(amount, 0, type(uint128).max - 1);\n\n    FixedPriceStrategy strategy = new FixedPriceStrategy(ratio, underlying, decimals);\n    uint256 amountInGho = (amount * ratio) / (10 ** decimals);\n    assertEq(\n      strategy.getAssetPriceInGho(amount, false),\n      amountInGho,\n      'Unexpected asset price in GHO'\n    );\n  }\n}\n"
    },
    "src/test/TestGsmFixedPriceStrategy4626.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGsmFixedPriceStrategy4626 is TestGhoBase {\n  function testConstructor(uint256 ratio, address underlying, uint8 decimals) public {\n    vm.assume(ratio > 0);\n    decimals = uint8(bound(decimals, 0, 40));\n\n    FixedPriceStrategy4626 strategy = new FixedPriceStrategy4626(ratio, underlying, decimals);\n    assertEq(strategy.GHO_DECIMALS(), 18, 'Unexpected GHO decimals');\n    assertEq(strategy.PRICE_RATIO(), ratio, 'Unexpected price ratio');\n    assertEq(strategy.UNDERLYING_ASSET(), underlying, 'Unexpected underlying asset');\n    assertEq(\n      strategy.UNDERLYING_ASSET_DECIMALS(),\n      decimals,\n      'Unexpected underlying asset decimals'\n    );\n  }\n\n  function testOneToOnePriceRatio() public {\n    FixedPriceStrategy4626 strategy = new FixedPriceStrategy4626(1e18, address(USDC_4626_TOKEN), 6);\n    uint256 usdcIn = 100e6;\n    uint256 ghoOut = 100e18;\n    assertEq(strategy.getAssetPriceInGho(usdcIn, true), ghoOut, 'Unexpected asset price in GHO');\n    assertEq(strategy.getGhoPriceInAsset(ghoOut, false), usdcIn, 'Unexpected gho price in asset');\n  }\n\n  function testOneToTwoPriceRatio() public {\n    FixedPriceStrategy4626 strategy = new FixedPriceStrategy4626(2e18, address(USDC_4626_TOKEN), 6);\n    uint256 usdcIn = 100e6;\n    uint256 ghoOut = 200e18;\n    assertEq(strategy.getAssetPriceInGho(usdcIn, true), ghoOut, 'Unexpected asset price in GHO');\n    assertEq(strategy.getGhoPriceInAsset(ghoOut, false), usdcIn, 'Unexpected gho price in asset');\n  }\n\n  function testTwoToOnePriceRatio() public {\n    FixedPriceStrategy4626 strategy = new FixedPriceStrategy4626(\n      0.5e18,\n      address(USDC_4626_TOKEN),\n      6\n    );\n    uint256 usdcIn = 100e6;\n    uint256 ghoOut = 50e18;\n    assertEq(strategy.getAssetPriceInGho(usdcIn, true), ghoOut, 'Unexpected asset price in GHO');\n    assertEq(strategy.getGhoPriceInAsset(ghoOut, false), usdcIn, 'Unexpected gho price in asset');\n  }\n\n  function testRevertZeroPriceRatio() public {\n    vm.expectRevert('INVALID_PRICE_RATIO');\n    new FixedPriceStrategy4626(0, address(USDC_4626_TOKEN), 6);\n  }\n\n  function testPriceFeedHighExchangeRate() public {\n    FixedPriceStrategy4626 strategy = new FixedPriceStrategy4626(1e18, address(USDC_4626_TOKEN), 6);\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, 100e6);\n\n    // Inflate exchange rate to 2\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, 100e6, true);\n\n    assertEq(strategy.getAssetPriceInGho(50e6, true), 100e18);\n    assertEq(strategy.getGhoPriceInAsset(100e18, true), 50e6);\n  }\n\n  function testPriceFeedLowExchangeRate() public {\n    FixedPriceStrategy4626 strategy = new FixedPriceStrategy4626(1e18, address(USDC_4626_TOKEN), 6);\n    _mintVaultAssets(USDC_4626_TOKEN, USDC_TOKEN, ALICE, 100e6);\n\n    // Deflate exchange rate to 1/2\n    _changeExchangeRate(USDC_4626_TOKEN, USDC_TOKEN, 50e6, false);\n\n    assertEq(strategy.getAssetPriceInGho(200e6, true), 100e18);\n    assertEq(strategy.getGhoPriceInAsset(100e18, true), 200e6);\n  }\n\n  function testFuzzingExchangeRate(uint256 ratio, uint8 decimals, uint256 amount) public {\n    decimals = uint8(bound(decimals, 1, 40));\n    ratio = bound(ratio, 1, type(uint128).max - 1);\n    amount = bound(amount, 0, type(uint128).max - 1);\n\n    FixedPriceStrategy4626 strategy = new FixedPriceStrategy4626(\n      ratio,\n      address(USDC_4626_TOKEN),\n      decimals\n    );\n    uint256 amountInGho = (amount * ratio) / (10 ** decimals);\n    assertEq(\n      strategy.getAssetPriceInGho(amount, false),\n      amountInGho,\n      'Unexpected asset price in GHO'\n    );\n  }\n}\n"
    },
    "src/test/TestGsmOracleSwapFreezer.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\nimport {OracleSwapFreezer} from '../contracts/facilitators/gsm/swapFreezer/OracleSwapFreezer.sol';\n\ncontract TestGsmOracleSwapFreezer is TestGhoBase {\n  OracleSwapFreezer swapFreezer;\n  uint128 constant DEFAULT_FREEZE_LOWER_BOUND = 0.97e8;\n  uint128 constant DEFAULT_FREEZE_UPPER_BOUND = 1.03e8;\n  uint128 constant DEFAULT_UNFREEZE_LOWER_BOUND = 0.99e8;\n  uint128 constant DEFAULT_UNFREEZE_UPPER_BOUND = 1.01e8;\n\n  function setUp() public {\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), 1e8);\n    swapFreezer = new OracleSwapFreezer(\n      GHO_GSM,\n      address(USDC_TOKEN),\n      IPoolAddressesProvider(address(PROVIDER)),\n      DEFAULT_FREEZE_LOWER_BOUND,\n      DEFAULT_FREEZE_UPPER_BOUND,\n      DEFAULT_UNFREEZE_LOWER_BOUND,\n      DEFAULT_UNFREEZE_UPPER_BOUND,\n      true\n    );\n    GHO_GSM.grantRole(GSM_SWAP_FREEZER_ROLE, address(swapFreezer));\n  }\n\n  function testRevertConstructorInvalidZeroAddress() public {\n    vm.expectRevert('ZERO_ADDRESS_NOT_VALID');\n    new OracleSwapFreezer(\n      GHO_GSM,\n      address(0),\n      IPoolAddressesProvider(address(PROVIDER)),\n      DEFAULT_FREEZE_LOWER_BOUND,\n      DEFAULT_FREEZE_UPPER_BOUND,\n      DEFAULT_UNFREEZE_LOWER_BOUND,\n      DEFAULT_UNFREEZE_UPPER_BOUND,\n      true\n    );\n  }\n\n  function testConstructorInvalidUnfreezeWhileFreezeNotAllowed() public {\n    uint128 unfreezeLowerBound = 1;\n    uint128 unfreezeUpperBound = type(uint128).max;\n\n    // Ensure bound check fails if allowing unfreezing, as expected\n    vm.expectRevert('BOUNDS_NOT_VALID');\n    new OracleSwapFreezer(\n      GHO_GSM,\n      address(USDC_TOKEN),\n      IPoolAddressesProvider(address(PROVIDER)),\n      DEFAULT_FREEZE_LOWER_BOUND,\n      DEFAULT_FREEZE_UPPER_BOUND,\n      unfreezeLowerBound,\n      unfreezeUpperBound,\n      true\n    );\n\n    // Revert expected when non-zero unfreeze lower bound\n    unfreezeUpperBound = 0;\n    vm.expectRevert('BOUNDS_NOT_VALID');\n    new OracleSwapFreezer(\n      GHO_GSM,\n      address(USDC_TOKEN),\n      IPoolAddressesProvider(address(PROVIDER)),\n      DEFAULT_FREEZE_LOWER_BOUND,\n      DEFAULT_FREEZE_UPPER_BOUND,\n      unfreezeLowerBound,\n      unfreezeUpperBound,\n      false\n    );\n\n    // Revert expected when non-zero unfreeze upper bound\n    unfreezeLowerBound = 0;\n    unfreezeUpperBound = type(uint128).max;\n    vm.expectRevert('BOUNDS_NOT_VALID');\n    new OracleSwapFreezer(\n      GHO_GSM,\n      address(USDC_TOKEN),\n      IPoolAddressesProvider(address(PROVIDER)),\n      DEFAULT_FREEZE_LOWER_BOUND,\n      DEFAULT_FREEZE_UPPER_BOUND,\n      unfreezeLowerBound,\n      unfreezeUpperBound,\n      false\n    );\n\n    // No revert expected with 0 unfreeze lower/upper bound\n    unfreezeLowerBound = 0;\n    unfreezeUpperBound = 0;\n    new OracleSwapFreezer(\n      GHO_GSM,\n      address(USDC_TOKEN),\n      IPoolAddressesProvider(address(PROVIDER)),\n      DEFAULT_FREEZE_LOWER_BOUND,\n      DEFAULT_FREEZE_UPPER_BOUND,\n      unfreezeLowerBound,\n      unfreezeUpperBound,\n      false\n    );\n  }\n\n  function testRevertConstructorInvalidBounds() public {\n    // Case 1: Freeze upper bound less than or equal to lower bound\n    uint128 freezeLowerBound = DEFAULT_FREEZE_LOWER_BOUND;\n    uint128 freezeUpperBound = DEFAULT_FREEZE_LOWER_BOUND;\n    vm.expectRevert('BOUNDS_NOT_VALID');\n    new OracleSwapFreezer(\n      GHO_GSM,\n      address(USDC_TOKEN),\n      IPoolAddressesProvider(address(PROVIDER)),\n      freezeLowerBound,\n      freezeUpperBound,\n      DEFAULT_UNFREEZE_LOWER_BOUND,\n      DEFAULT_UNFREEZE_UPPER_BOUND,\n      true\n    );\n\n    // Case 2: Unfreeze upper bound less than or equal to lower bound\n    uint128 unfreezeLowerBound = DEFAULT_UNFREEZE_UPPER_BOUND;\n    uint128 unfreezeUpperBound = DEFAULT_UNFREEZE_UPPER_BOUND;\n    vm.expectRevert('BOUNDS_NOT_VALID');\n    new OracleSwapFreezer(\n      GHO_GSM,\n      address(USDC_TOKEN),\n      IPoolAddressesProvider(address(PROVIDER)),\n      DEFAULT_FREEZE_LOWER_BOUND,\n      DEFAULT_FREEZE_UPPER_BOUND,\n      unfreezeLowerBound,\n      unfreezeUpperBound,\n      true\n    );\n\n    // Case 3: Freeze lower bound is greater than or equal to unfreeze lower bound\n    freezeLowerBound = DEFAULT_UNFREEZE_LOWER_BOUND;\n    freezeUpperBound = DEFAULT_FREEZE_UPPER_BOUND;\n    vm.expectRevert('BOUNDS_NOT_VALID');\n    new OracleSwapFreezer(\n      GHO_GSM,\n      address(USDC_TOKEN),\n      IPoolAddressesProvider(address(PROVIDER)),\n      freezeLowerBound,\n      freezeUpperBound,\n      DEFAULT_UNFREEZE_LOWER_BOUND,\n      DEFAULT_UNFREEZE_UPPER_BOUND,\n      true\n    );\n\n    // Case 4: Unfreeze upper bound is greater than or equal to freeze upper bound\n    unfreezeLowerBound = DEFAULT_UNFREEZE_LOWER_BOUND;\n    unfreezeUpperBound = DEFAULT_FREEZE_UPPER_BOUND;\n    vm.expectRevert('BOUNDS_NOT_VALID');\n    new OracleSwapFreezer(\n      GHO_GSM,\n      address(USDC_TOKEN),\n      IPoolAddressesProvider(address(PROVIDER)),\n      DEFAULT_FREEZE_LOWER_BOUND,\n      DEFAULT_FREEZE_UPPER_BOUND,\n      unfreezeLowerBound,\n      unfreezeUpperBound,\n      true\n    );\n  }\n\n  function testCheckUpkeepCanFreeze() public {\n    (bool canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, false, 'Unexpected initial upkeep state');\n\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), DEFAULT_FREEZE_LOWER_BOUND);\n    (canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, true, 'Unexpected upkeep state after price == freeze lower bound');\n\n    assertLt(1, DEFAULT_FREEZE_LOWER_BOUND, '1 not less than freeze lower bound');\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), 1);\n    (canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, true, 'Unexpected upkeep state after price < freeze lower bound');\n\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), DEFAULT_FREEZE_UPPER_BOUND);\n    (canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, true, 'Unexpected upkeep state after price == freeze upper bound');\n\n    assertGt(\n      type(uint128).max,\n      DEFAULT_FREEZE_UPPER_BOUND,\n      'uint128.max not greater than freeze upper bound'\n    );\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), type(uint128).max);\n    (canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, true, 'Unexpected upkeep state after price > freeze upper bound');\n  }\n\n  function testCheckUpkeepCannotFreezeWhenOracleZero() public {\n    (bool canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, false, 'Unexpected initial upkeep state');\n\n    assertLt(0, DEFAULT_FREEZE_LOWER_BOUND, '0 not less than freeze lower bound');\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), 0);\n    (canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, false, 'Unexpected upkeep state when oracle price is zero');\n  }\n\n  function testCheckUpkeepCanUnfreeze() public {\n    // Freeze the GSM and set the asset price to 1 wei\n    vm.prank(address(GHO_GSM_SWAP_FREEZER));\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit SwapFreeze(address(GHO_GSM_SWAP_FREEZER), true);\n    GHO_GSM.setSwapFreeze(true);\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), 1);\n\n    (bool canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, false, 'Unexpected initial upkeep state');\n\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), DEFAULT_UNFREEZE_LOWER_BOUND);\n    (canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, true, 'Unexpected upkeep state after price >= unfreeze lower bound');\n\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), DEFAULT_UNFREEZE_UPPER_BOUND);\n    (canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, true, 'Unexpected upkeep state after price <= unfreeze upper bound');\n\n    PRICE_ORACLE.setAssetPrice(\n      address(USDC_TOKEN),\n      (DEFAULT_UNFREEZE_LOWER_BOUND + DEFAULT_UNFREEZE_UPPER_BOUND) / 2\n    );\n    (canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, true, 'Unexpected upkeep state after price in unfreeze bound range');\n  }\n\n  function testCheckUpkeepCannotUnfreeze() public {\n    OracleSwapFreezer swapFreezerWithoutUnfreeze = new OracleSwapFreezer(\n      GHO_GSM,\n      address(USDC_TOKEN),\n      IPoolAddressesProvider(address(PROVIDER)),\n      DEFAULT_FREEZE_LOWER_BOUND,\n      DEFAULT_FREEZE_UPPER_BOUND,\n      0,\n      0,\n      false\n    );\n\n    // Freeze the GSM\n    vm.prank(address(GHO_GSM_SWAP_FREEZER));\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit SwapFreeze(address(GHO_GSM_SWAP_FREEZER), true);\n    GHO_GSM.setSwapFreeze(true);\n\n    (bool canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, true, 'Unexpected upkeep state for default freezer');\n\n    (canPerformUpkeep, ) = swapFreezerWithoutUnfreeze.checkUpkeep('');\n    assertEq(canPerformUpkeep, false, 'Unexpected upkeep state for no-unfreeze freezer');\n  }\n\n  function testCheckUpkeepCannotUnfreezeWhenSeized() public {\n    // Set oracle price to a value allowing a freeze\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), DEFAULT_FREEZE_LOWER_BOUND);\n    (bool canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, true, 'Unexpected initial upkeep state for default freezer');\n\n    // Seize the GSM\n    vm.prank(address(GHO_GSM_LAST_RESORT_LIQUIDATOR));\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit Seized(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), TREASURY, 0, 0);\n    GHO_GSM.seize();\n\n    (canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, false, 'Unexpected upkeep state post-seize');\n  }\n\n  function testPerformUpkeepCanFreeze() public {\n    (bool canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, false, 'Unexpected initial upkeep state');\n    assertEq(GHO_GSM.getIsFrozen(), false, 'Unexpected initial freeze state for GSM');\n\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), DEFAULT_FREEZE_LOWER_BOUND);\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit SwapFreeze(address(swapFreezer), true);\n    swapFreezer.performUpkeep('');\n\n    assertEq(GHO_GSM.getIsFrozen(), true, 'Unexpected final freeze state for GSM');\n  }\n\n  function testPerformUpkeepCanUnfreeze() public {\n    // Freeze the GSM and set price to 1 wei\n    vm.prank(address(GHO_GSM_SWAP_FREEZER));\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit SwapFreeze(address(GHO_GSM_SWAP_FREEZER), true);\n    GHO_GSM.setSwapFreeze(true);\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), 1);\n\n    (bool canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, false, 'Unexpected initial upkeep state');\n    assertEq(GHO_GSM.getIsFrozen(), true, 'Unexpected initial freeze state for GSM');\n\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), DEFAULT_UNFREEZE_LOWER_BOUND);\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit SwapFreeze(address(swapFreezer), false);\n    swapFreezer.performUpkeep('');\n\n    assertEq(GHO_GSM.getIsFrozen(), false, 'Unexpected final freeze state for GSM');\n  }\n\n  function testCheckUpkeepNoSwapFreezeRole() public {\n    // Move price outside freeze range\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), DEFAULT_FREEZE_LOWER_BOUND - 1);\n    (bool canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, true, 'Unexpected initial upkeep state');\n\n    // Revoke SwapFreezer role\n    GHO_GSM.revokeRole(GSM_SWAP_FREEZER_ROLE, address(swapFreezer));\n\n    // Upkeep shouldn't be possible\n    (canPerformUpkeep, ) = swapFreezer.checkUpkeep('');\n    assertEq(canPerformUpkeep, false, 'Unexpected upkeep state');\n    // Do not revert, it's a no-op execution\n    swapFreezer.performUpkeep('');\n  }\n\n  function testGetCanUnfreeze() public {\n    assertEq(swapFreezer.getCanUnfreeze(), true, 'Unexpected initial unfreeze state');\n    swapFreezer = new OracleSwapFreezer(\n      GHO_GSM,\n      address(USDC_TOKEN),\n      IPoolAddressesProvider(address(PROVIDER)),\n      DEFAULT_FREEZE_LOWER_BOUND,\n      DEFAULT_FREEZE_UPPER_BOUND,\n      0,\n      0,\n      false\n    );\n    assertEq(swapFreezer.getCanUnfreeze(), false, 'Unexpected final unfreeze state');\n  }\n\n  function testFuzzUpkeepConsistency(uint256 assetPrice, bool grantRole) public {\n    PRICE_ORACLE.setAssetPrice(address(USDC_TOKEN), assetPrice);\n    OracleSwapFreezer agent = new OracleSwapFreezer(\n      GHO_GSM,\n      address(USDC_TOKEN),\n      IPoolAddressesProvider(address(PROVIDER)),\n      DEFAULT_FREEZE_LOWER_BOUND,\n      DEFAULT_FREEZE_UPPER_BOUND,\n      DEFAULT_UNFREEZE_LOWER_BOUND,\n      DEFAULT_UNFREEZE_UPPER_BOUND,\n      true\n    );\n    if (grantRole) {\n      GHO_GSM.grantRole(GSM_SWAP_FREEZER_ROLE, address(agent));\n    }\n\n    // If canPerformUpkeep, there must be a state change\n    bool freezeState = GHO_GSM.getIsFrozen();\n    (bool canPerformUpkeep, ) = agent.checkUpkeep('');\n\n    agent.performUpkeep('');\n    if (canPerformUpkeep) {\n      // state change\n      assertEq(freezeState, !GHO_GSM.getIsFrozen(), 'no state change after performUpkeep');\n    } else {\n      // no state change\n      assertEq(freezeState, GHO_GSM.getIsFrozen(), 'state change after performUpkeep');\n    }\n  }\n}\n"
    },
    "src/test/TestGsmRegistry.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGsmRegistry is TestGhoBase {\n  function testConstructor(address newOwner) public {\n    vm.assume(newOwner != address(this) && newOwner != address(0));\n\n    vm.expectEmit(true, true, false, true);\n    emit OwnershipTransferred(address(0), address(this));\n    vm.expectEmit(true, true, false, true);\n    emit OwnershipTransferred(address(this), newOwner);\n\n    GsmRegistry registry = new GsmRegistry(newOwner);\n    assertEq(registry.owner(), newOwner, 'Unexpected contract owner');\n    assertEq(registry.getGsmList().length, 0, 'Unexpected gsm list length');\n    assertEq(registry.getGsmListLength(), 0, 'Unexpected gsm list length');\n  }\n\n  function testRevertConstructorZeroAddress() public {\n    vm.expectRevert('ZERO_ADDRESS_NOT_VALID');\n    new GsmRegistry(address(0));\n  }\n\n  function testAddGsm(address newGsm) public {\n    vm.assume(newGsm != address(0));\n\n    vm.expectEmit(true, false, false, true);\n    emit GsmAdded(newGsm);\n    GHO_GSM_REGISTRY.addGsm(newGsm);\n\n    assertEq(GHO_GSM_REGISTRY.getGsmListLength(), 1, 'Unexpected gsm list length');\n    assertEq(GHO_GSM_REGISTRY.getGsmAtIndex(0), newGsm, 'Unexpected gsm registered');\n  }\n\n  function testAddGsmMultiple(uint256 size) public {\n    size = bound(size, 0, 20);\n\n    for (uint256 i = 0; i < size; i++) {\n      address newGsm = address(uint160(i + 123));\n      vm.expectEmit(true, false, false, true);\n      emit GsmAdded(newGsm);\n      GHO_GSM_REGISTRY.addGsm(newGsm);\n      assertEq(GHO_GSM_REGISTRY.getGsmAtIndex(i), newGsm, 'Unexpected gsm registered');\n    }\n\n    assertEq(GHO_GSM_REGISTRY.getGsmListLength(), size, 'Unexpected gsm list length');\n  }\n\n  function testRevertAddGsmUnauthorized(address caller) public {\n    vm.assume(caller != GHO_GSM_REGISTRY.owner());\n\n    vm.expectRevert(OwnableErrorsLib.CALLER_NOT_OWNER());\n    vm.prank(caller);\n    GHO_GSM_REGISTRY.addGsm(address(123));\n  }\n\n  function testRevertAddGsmInvalidAddress() public {\n    vm.expectRevert('ZERO_ADDRESS_NOT_VALID');\n    GHO_GSM_REGISTRY.addGsm(address(0));\n\n    assertEq(GHO_GSM_REGISTRY.getGsmListLength(), 0, 'Unexpected gsm list length');\n  }\n\n  function testRevertAddSameGsmTwice(address newGsm) public {\n    vm.assume(newGsm != address(0));\n    vm.expectEmit(true, false, false, true);\n    emit GsmAdded(newGsm);\n    GHO_GSM_REGISTRY.addGsm(newGsm);\n\n    assertEq(GHO_GSM_REGISTRY.getGsmListLength(), 1, 'Unexpected gsm list length');\n    assertEq(GHO_GSM_REGISTRY.getGsmAtIndex(0), newGsm, 'Unexpected gsm registered');\n\n    vm.expectRevert('GSM_ALREADY_ADDED');\n    GHO_GSM_REGISTRY.addGsm(newGsm);\n\n    assertEq(GHO_GSM_REGISTRY.getGsmListLength(), 1, 'Unexpected gsm list length');\n    assertEq(GHO_GSM_REGISTRY.getGsmAtIndex(0), newGsm, 'Unexpected gsm registered');\n  }\n\n  function testRemoveGsm(address gsmToRemove) public {\n    vm.assume(gsmToRemove != address(0));\n\n    uint256 sizeBefore = GHO_GSM_REGISTRY.getGsmListLength();\n\n    GHO_GSM_REGISTRY.addGsm(gsmToRemove);\n\n    vm.expectEmit(true, false, false, true);\n    emit GsmRemoved(gsmToRemove);\n    GHO_GSM_REGISTRY.removeGsm(gsmToRemove);\n\n    assertEq(GHO_GSM_REGISTRY.getGsmListLength(), sizeBefore, 'Unexpected gsm list length');\n  }\n\n  function testRemoveGsmMultiple(uint256 size) public {\n    size = bound(size, 0, 20);\n\n    for (uint256 i = 0; i < size; i++) {\n      address newGsm = address(uint160(i + 123));\n\n      GHO_GSM_REGISTRY.addGsm(newGsm);\n      assertEq(GHO_GSM_REGISTRY.getGsmAtIndex(0), newGsm, 'Unexpected gsm registered');\n\n      vm.expectEmit(true, false, false, true);\n      emit GsmRemoved(newGsm);\n      GHO_GSM_REGISTRY.removeGsm(newGsm);\n    }\n\n    assertEq(GHO_GSM_REGISTRY.getGsmListLength(), 0, 'Unexpected gsm list length');\n  }\n\n  function testRevertRemoveGsmUnauthorized(address caller) public {\n    vm.assume(caller != GHO_GSM_REGISTRY.owner());\n\n    vm.expectRevert(OwnableErrorsLib.CALLER_NOT_OWNER());\n    vm.prank(caller);\n    GHO_GSM_REGISTRY.removeGsm(address(123));\n  }\n\n  function testRevertRemoveGsmInvalidAddress() public {\n    vm.expectRevert('ZERO_ADDRESS_NOT_VALID');\n    GHO_GSM_REGISTRY.removeGsm(address(0));\n  }\n\n  function testRevertRemoveSameGsmTwice(address newGsm) public {\n    vm.assume(newGsm != address(0));\n    GHO_GSM_REGISTRY.addGsm(newGsm);\n\n    vm.expectEmit(true, false, false, true);\n    emit GsmRemoved(newGsm);\n    GHO_GSM_REGISTRY.removeGsm(newGsm);\n\n    assertEq(GHO_GSM_REGISTRY.getGsmListLength(), 0, 'Unexpected gsm list length');\n\n    vm.expectRevert('NONEXISTENT_GSM');\n    GHO_GSM_REGISTRY.removeGsm(newGsm);\n\n    assertEq(GHO_GSM_REGISTRY.getGsmListLength(), 0, 'Unexpected gsm list length');\n  }\n\n  function testGetGsmList(uint256 sizeToAdd, uint256 sizeToRemove) public {\n    sizeToAdd = bound(sizeToAdd, 1, 20);\n    sizeToRemove = bound(sizeToRemove, 0, sizeToAdd - 1);\n\n    address[] memory localGsmList = new address[](sizeToAdd);\n\n    uint256 i;\n    for (i = 0; i < sizeToAdd; i++) {\n      address newGsm = address(uint160(i + 123));\n      localGsmList[i] = newGsm;\n      GHO_GSM_REGISTRY.addGsm(newGsm);\n    }\n\n    for (i = 0; i < sizeToRemove; i++) {\n      GHO_GSM_REGISTRY.removeGsm(localGsmList[sizeToAdd - i - 1]);\n    }\n\n    uint256 leftOvers = sizeToAdd - sizeToRemove;\n    assertEq(leftOvers, GHO_GSM_REGISTRY.getGsmListLength());\n    address[] memory gsmList = GHO_GSM_REGISTRY.getGsmList();\n    for (i = 0; i < leftOvers; i++) {\n      assertEq(gsmList[i], localGsmList[i], 'unexpected GSM address');\n      assertEq(\n        GHO_GSM_REGISTRY.getGsmAtIndex(i),\n        localGsmList[i],\n        'unexpected GSM address at given index'\n      );\n    }\n  }\n\n  function testRevertGetGsmAtIndex() public {\n    assertEq(GHO_GSM_REGISTRY.getGsmListLength(), 0, 'Unexpected gsm list length');\n\n    vm.expectRevert('INVALID_INDEX');\n    GHO_GSM_REGISTRY.getGsmAtIndex(0);\n\n    address newGsm = address(0x123);\n    GHO_GSM_REGISTRY.addGsm(newGsm);\n    assertEq(GHO_GSM_REGISTRY.getGsmListLength(), 1, 'Unexpected gsm list length');\n    assertEq(GHO_GSM_REGISTRY.getGsmAtIndex(0), newGsm, 'Unexpected gsm address at index 0');\n\n    vm.expectRevert('INVALID_INDEX');\n    GHO_GSM_REGISTRY.getGsmAtIndex(1);\n  }\n}\n"
    },
    "src/test/TestGsmSampleLiquidator.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGsmSampleLiquidator is TestGhoBase {\n  function testSeize() public {\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit Seized(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), TREASURY, 0, 0);\n    GHO_GSM_LAST_RESORT_LIQUIDATOR.triggerSeize(address(GHO_GSM));\n  }\n\n  function testRevertSeizeNotAuthorized() public {\n    vm.expectRevert(OwnableErrorsLib.CALLER_NOT_OWNER());\n    vm.prank(ALICE);\n    GHO_GSM_LAST_RESORT_LIQUIDATOR.triggerSeize(address(GHO_GSM));\n  }\n\n  function testRevertSeizeAlreadySeized() public {\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit Seized(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), TREASURY, 0, 0);\n    GHO_GSM_LAST_RESORT_LIQUIDATOR.triggerSeize(address(GHO_GSM));\n\n    vm.expectRevert('GSM_SEIZED');\n    GHO_GSM_LAST_RESORT_LIQUIDATOR.triggerSeize(address(GHO_GSM));\n  }\n\n  function testBurnAfterSeize() public {\n    // Mint GHO in the GSM\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    // Seize the GSM\n    uint256 seizedAmount = GHO_GSM_LAST_RESORT_LIQUIDATOR.triggerSeize(address(GHO_GSM));\n    assertEq(seizedAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected seize amount returned');\n\n    // Mint the current bucket level\n    (, uint256 bucketLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM));\n    assertGt(bucketLevel, 0, 'Unexpected 0 minted GHO');\n    ghoFaucet(address(this), bucketLevel);\n\n    GHO_TOKEN.approve(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), bucketLevel);\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit BurnAfterSeize(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), bucketLevel, 0);\n    uint256 burnAmount = GHO_GSM_LAST_RESORT_LIQUIDATOR.triggerBurnAfterSeize(\n      address(GHO_GSM),\n      bucketLevel\n    );\n    assertEq(burnAmount, bucketLevel, 'Unexpected burn amount returned');\n  }\n\n  function testBurnMoreThanMintedAfterSeize() public {\n    // Mint GHO in the GSM\n    vm.prank(FAUCET);\n    USDC_TOKEN.mint(ALICE, DEFAULT_GSM_USDC_AMOUNT);\n    vm.startPrank(ALICE);\n    USDC_TOKEN.approve(address(GHO_GSM), DEFAULT_GSM_USDC_AMOUNT);\n    GHO_GSM.sellAsset(DEFAULT_GSM_USDC_AMOUNT, ALICE);\n    vm.stopPrank();\n\n    // Seize the GSM\n    uint256 seizedAmount = GHO_GSM_LAST_RESORT_LIQUIDATOR.triggerSeize(address(GHO_GSM));\n    assertEq(seizedAmount, DEFAULT_GSM_USDC_AMOUNT, 'Unexpected seize amount returned');\n\n    // Mint the current bucket level + 1, to have more GHO than necessary\n    (, uint256 bucketLevel) = GHO_TOKEN.getFacilitatorBucket(address(GHO_GSM));\n    assertGt(bucketLevel, 0, 'Unexpected 0 minted GHO');\n    ghoFaucet(address(this), bucketLevel + 1);\n\n    // Attempt to burn more than what was minted, leaving 1 GHO left-over and burning the bucketLevel\n    GHO_TOKEN.approve(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), bucketLevel + 1);\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit BurnAfterSeize(address(GHO_GSM_LAST_RESORT_LIQUIDATOR), bucketLevel, 0);\n    uint256 burnAmount = GHO_GSM_LAST_RESORT_LIQUIDATOR.triggerBurnAfterSeize(\n      address(GHO_GSM),\n      bucketLevel + 1\n    );\n    assertEq(burnAmount, bucketLevel, 'Unexpected burn amount returned');\n    assertEq(GHO_TOKEN.balanceOf(address(this)), 1, 'Unexpected final GHO amount');\n  }\n}\n"
    },
    "src/test/TestGsmSampleSwapFreezer.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGsmSampleSwapFreezer is TestGhoBase {\n  function testFreeze() public {\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit SwapFreeze(address(GHO_GSM_SWAP_FREEZER), true);\n    GHO_GSM_SWAP_FREEZER.triggerFreeze(address(GHO_GSM));\n  }\n\n  function testUnfreeze() public {\n    GHO_GSM_SWAP_FREEZER.triggerFreeze(address(GHO_GSM));\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit SwapFreeze(address(GHO_GSM_SWAP_FREEZER), false);\n    GHO_GSM_SWAP_FREEZER.triggerUnfreeze(address(GHO_GSM));\n  }\n\n  function testRevertNotAuthorized() public {\n    vm.startPrank(ALICE);\n    vm.expectRevert(OwnableErrorsLib.CALLER_NOT_OWNER());\n    GHO_GSM_SWAP_FREEZER.triggerFreeze(address(GHO_GSM));\n    vm.expectRevert(OwnableErrorsLib.CALLER_NOT_OWNER());\n    GHO_GSM_SWAP_FREEZER.triggerUnfreeze(address(GHO_GSM));\n    vm.stopPrank();\n  }\n\n  function testRevertFreezeAlreadyFrozen() public {\n    GHO_GSM_SWAP_FREEZER.triggerFreeze(address(GHO_GSM));\n\n    vm.expectRevert('GSM_ALREADY_FROZEN');\n    GHO_GSM_SWAP_FREEZER.triggerFreeze(address(GHO_GSM));\n  }\n\n  function testRevertUnfreezeNotFrozen() public {\n    vm.expectRevert('GSM_ALREADY_UNFROZEN');\n    GHO_GSM_SWAP_FREEZER.triggerUnfreeze(address(GHO_GSM));\n  }\n}\n"
    },
    "src/test/TestGsmSwapEdge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGsmSwapEdge is TestGhoBase {\n  using PercentageMath for uint256;\n  using PercentageMath for uint128;\n\n  /**\n   * @dev Edge case where it is not possible to burn all GHO minted due to rounding issues.\n   * e.g. With (1e16 + 1) priceRatio, a user gets 1e11 gho for selling 1 asset but gets 1 asset by selling 1e11+1 gho\n   */\n  function testCannotBuyAllUnderlying() public {\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', 5, FAUCET);\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      10000000000000001, // 1e16 + 1\n      address(newToken),\n      5\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, type(uint128).max);\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM TINY', type(uint128).max);\n\n    // Sell 2 assets for 2e11 GHO\n    vm.prank(FAUCET);\n    newToken.mint(ALICE, 2);\n\n    vm.startPrank(ALICE);\n    newToken.approve(address(gsm), 2);\n    gsm.sellAsset(2, ALICE);\n    vm.stopPrank();\n\n    // Top up with GHO\n    (, uint256 estGhoBought, , ) = gsm.getGhoAmountForBuyAsset(2);\n    ghoFaucet(ALICE, estGhoBought * 20);\n\n    vm.startPrank(ALICE);\n    GHO_TOKEN.approve(address(gsm), type(uint256).max);\n\n    // Try to buy all, which is 2 assets for 2e11+1 GHO\n    uint256 allUnderlying = gsm.getAvailableLiquidity();\n    vm.expectRevert();\n    gsm.buyAsset(allUnderlying, ALICE);\n\n    // Buy a portion\n    uint256 userGhoBefore = GHO_TOKEN.balanceOf(ALICE);\n    uint256 userAssetBefore = newToken.balanceOf(ALICE);\n\n    (uint256 exactAssetAmount, uint256 exactGhoAmount) = gsm.buyAsset(1, ALICE);\n\n    assertEq(\n      newToken.balanceOf(ALICE) - userAssetBefore,\n      exactAssetAmount,\n      'unexpected underlying balance of ALICE'\n    );\n    assertEq(\n      userGhoBefore - GHO_TOKEN.balanceOf(ALICE),\n      exactGhoAmount,\n      'unexpected GHO balance of ALICE'\n    );\n\n    assertTrue(gsm.getAvailableLiquidity() > 0, 'unexpected remaining liquidity');\n    vm.stopPrank();\n  }\n\n  /**\n   * @dev Edge case where it is not possible to sell less than the minimum amount because would lead to 0 GHO.\n   */\n  function testGetAssetAmountForSellAssetBelowMinimumAmount() public {\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', 18, FAUCET);\n    FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(4900, 4900);\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      DEFAULT_FIXED_PRICE,\n      address(newToken),\n      18\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, 100_000_000e18);\n    gsm.updateFeeStrategy(address(newFeeStrategy));\n    GHO_TOKEN.addFacilitator(address(gsm), 'Test GSM', DEFAULT_CAPACITY);\n\n    // Get asset amount required to receive 1 GHO\n    (uint256 assetAmount, uint256 ghoBought, uint256 grossAmount, uint256 fee) = gsm\n      .getAssetAmountForSellAsset(1);\n\n    assertEq(assetAmount, 2, 'Unexpected asset to sell');\n    assertEq(ghoBought, 1, 'Unexpected gho amount bought');\n    assertEq(grossAmount, 2, 'Unexpected gross amount');\n    assertEq(fee, 1, 'Unexpected fee');\n\n    // Using 1 wei less than the assetAmount will round down the asset amount to 0, so should revert\n    vm.expectRevert('INVALID_AMOUNT');\n    gsm.sellAsset(assetAmount - 1, ALICE);\n\n    _sellAsset(gsm, newToken, ALICE, assetAmount);\n    assertEq(GHO_TOKEN.balanceOf(ALICE), 1, 'Unexpected GHO balance');\n  }\n\n  /**\n   * @dev Sell asset function meets the maximum amount to be sold and does not over-charge the user.\n   * e.g. if the GSM can provide 10 GHO for 12 assets, it charges only 12 even if the user provides more than 12.\n   */\n  function testSellAssetWithMinimumAmount() public {\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', 18, FAUCET);\n    FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(3000, 3000);\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      DEFAULT_FIXED_PRICE,\n      address(newToken),\n      18\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, 100_000_000e18);\n    gsm.updateFeeStrategy(address(newFeeStrategy));\n    GHO_TOKEN.addFacilitator(address(gsm), 'Test GSM', DEFAULT_CAPACITY);\n\n    // Get asset amount required to receive 10000 GHO\n    (uint256 assetAmount, uint256 ghoBought, uint256 grossAmount, uint256 fee) = gsm\n      .getAssetAmountForSellAsset(10000);\n\n    assertEq(assetAmount, 14286, 'Unexpected asset to sell');\n    assertEq(ghoBought, 10000, 'Unexpected gho amount bought');\n    assertEq(grossAmount, 14286, 'Unexpected gross amount');\n    assertEq(fee, 4286, 'Unexpected fee');\n\n    assertEq(newToken.balanceOf(ALICE), 0, 'Unexpected asset amount before');\n\n    // Mint 1 more asset than required (14286) to receive 10000 GHO\n    vm.prank(FAUCET);\n    newToken.mint(ALICE, assetAmount + 1);\n\n    vm.startPrank(ALICE);\n    newToken.approve(address(gsm), assetAmount);\n    // Sell 1 more asset than required to receive 10000 GHO\n    gsm.sellAsset(assetAmount + 1, ALICE);\n    vm.stopPrank();\n    assertEq(GHO_TOKEN.balanceOf(ALICE), 10000, 'Unexpected GHO balance');\n    // Should have 1 \"leftover\" asset, as sellAsset prevents \"overpaying\" so only assetAmount spent\n    assertEq(newToken.balanceOf(ALICE), 1, 'Unexpected ending asset amount');\n  }\n\n  /**\n   * @dev Checks sellAsset does not charge more asset than needed\n   * in case the underlying asset has more decimals than GHO (18)\n   */\n  function testSellAssetWithHigherDecimals() public {\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', 24, FAUCET);\n    vm.prank(FAUCET);\n    newToken.mint(ALICE, 1_000_000e24);\n\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      DEFAULT_FIXED_PRICE, // 1e18\n      address(newToken),\n      24 // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(ALICE, TREASURY, 1_000_000e24);\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM TINY', DEFAULT_CAPACITY);\n\n    vm.startPrank(ALICE);\n    newToken.approve(address(gsm), type(uint256).max);\n\n    // Less than 1e6 results in 0 GHO\n    vm.expectRevert('INVALID_AMOUNT');\n    gsm.sellAsset(0.9e6, ALICE);\n\n    // Lowest amount that can be sold is 1e6\n    uint256 userGhoBefore = GHO_TOKEN.balanceOf(ALICE);\n    uint256 userAssetBefore = newToken.balanceOf(ALICE);\n\n    gsm.sellAsset(1e6, ALICE);\n\n    assertEq(GHO_TOKEN.balanceOf(ALICE) - userGhoBefore, 1, 'unexpected amount of GHO purchased');\n    assertEq(userAssetBefore - newToken.balanceOf(ALICE), 1e6, 'unexpected amount of asset sold');\n\n    // It does not overcharge in case of non-divisible amount of assets\n    userGhoBefore = GHO_TOKEN.balanceOf(ALICE);\n    userAssetBefore = newToken.balanceOf(ALICE);\n\n    (uint256 assetAmount, uint256 ghoBought) = gsm.sellAsset(1.9e6, ALICE);\n\n    assertEq(GHO_TOKEN.balanceOf(ALICE) - userGhoBefore, 1, 'unexpected amount of GHO purchased');\n    assertEq(ghoBought, 1, 'unexpected amount of returned GHO purchased');\n    assertEq(assetAmount, 1e6, 'Unexpected asset amount sold');\n    assertEq(userAssetBefore - newToken.balanceOf(ALICE), 1e6, 'unexpected amount of asset sold');\n\n    vm.stopPrank();\n  }\n\n  /**\n   * @dev Checks buyAsset does not provide more asset than the corresponding to the\n   * gho amount charged, in case the underlying asset has more decimals than GHO (18)\n   */\n  function testBuyAssetWithHigherDecimals() public {\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', 24, FAUCET);\n    vm.prank(FAUCET);\n    newToken.mint(ALICE, 1_000_000e24);\n    ghoFaucet(ALICE, DEFAULT_CAPACITY);\n\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      DEFAULT_FIXED_PRICE, // 1e18\n      address(newToken),\n      24 // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(ALICE, TREASURY, 1_000_000e24);\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM TINY', DEFAULT_CAPACITY);\n\n    vm.startPrank(ALICE);\n    // Alice sells some asset to the GSM\n    newToken.approve(address(gsm), type(uint256).max);\n    GHO_TOKEN.approve(address(gsm), type(uint256).max);\n    gsm.sellAsset(1_000_000e24, ALICE);\n\n    // The minimum amount of assets that can be bought is 1e6, and the contract recalculates\n    // the corresponding amount of assets to the exact GHO burned.\n    // User buys more asset than it should due to price conversion\n    uint256 userGhoBefore = GHO_TOKEN.balanceOf(ALICE);\n    uint256 userAssetBefore = newToken.balanceOf(ALICE);\n\n    (uint256 assetAmount, uint256 ghoSold) = gsm.buyAsset(1.9e6, ALICE); // should by just 1e6 asset in exchange of 1 GHO\n\n    assertEq(userGhoBefore - GHO_TOKEN.balanceOf(ALICE), 2, 'unexpected amount of GHO spent');\n    assertEq(ghoSold, 2, 'unexpected amount of returned GHO spent');\n    assertEq(assetAmount, 2e6, 'Unexpected asset amount bought');\n    assertEq(\n      newToken.balanceOf(ALICE) - userAssetBefore,\n      2e6,\n      'unexpected amount of assets purchased'\n    );\n\n    vm.stopPrank();\n  }\n\n  /**\n   * @dev Checks sellAsset function is aligned with getAssetAmountForSellAsset,\n   * in case the underlying asset has less decimals than GHO (18)\n   */\n  function testSellAssetByGhoAmountWithLowerDecimals() public {\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', 6, FAUCET);\n    vm.prank(FAUCET);\n    newToken.mint(ALICE, 1_000_000e6);\n\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      DEFAULT_FIXED_PRICE, // 1e18\n      address(newToken),\n      6 // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(ALICE, TREASURY, 1_000_000e6);\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM TINY', DEFAULT_CAPACITY);\n\n    // User wants to know how much asset must sell to get 1.9e12 GHO\n    vm.startPrank(ALICE);\n    uint256 ghoAmountToGet = 1.9e12; // this is the minimum that must get\n    (uint256 estSellAssetAmount, uint256 exactGhoToGet, , ) = gsm.getAssetAmountForSellAsset(\n      ghoAmountToGet\n    );\n    uint256 userGhoBefore = GHO_TOKEN.balanceOf(ALICE);\n    uint256 userAssetBefore = newToken.balanceOf(ALICE);\n\n    newToken.approve(address(gsm), type(uint256).max);\n    gsm.sellAsset(estSellAssetAmount, ALICE);\n\n    assertEq(\n      GHO_TOKEN.balanceOf(ALICE) - userGhoBefore,\n      exactGhoToGet,\n      'exact gho amount to get does not match'\n    );\n    assertGt(\n      GHO_TOKEN.balanceOf(ALICE) - userGhoBefore,\n      ghoAmountToGet,\n      'minimum gho to get not reached'\n    );\n\n    assertEq(\n      userAssetBefore - newToken.balanceOf(ALICE),\n      estSellAssetAmount,\n      'sold assets above maximum amount'\n    );\n\n    vm.stopPrank();\n  }\n\n  /**\n   * @dev Checks sellAsset function is aligned with getAssetAmountForSellAsset,\n   * in case the underlying asset has more decimals than GHO (18)\n   */\n  function testSellAssetByGhoAmountWithHigherDecimals() public {\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', 24, FAUCET);\n    vm.prank(FAUCET);\n    newToken.mint(ALICE, 1_000_000e24);\n\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      DEFAULT_FIXED_PRICE, // 1e18\n      address(newToken),\n      24 // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(ALICE, TREASURY, 1_000_000e24);\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM TINY', DEFAULT_CAPACITY);\n\n    // User wants to know how much asset must sell to get 1 GHO\n    vm.startPrank(ALICE);\n    uint256 ghoAmountToGet = 1; // this is the lowest GHO that can be purchased\n    (uint256 estSellAssetAmount, uint256 exactGhoToGet, , ) = gsm.getAssetAmountForSellAsset(\n      ghoAmountToGet\n    );\n    uint256 userGhoBefore = GHO_TOKEN.balanceOf(ALICE);\n    uint256 userAssetBefore = newToken.balanceOf(ALICE);\n\n    newToken.approve(address(gsm), type(uint256).max);\n    gsm.sellAsset(estSellAssetAmount, ALICE);\n\n    assertEq(\n      GHO_TOKEN.balanceOf(ALICE) - userGhoBefore,\n      exactGhoToGet,\n      'exact gho amount to get does not match'\n    );\n    assertEq(\n      GHO_TOKEN.balanceOf(ALICE) - userGhoBefore,\n      ghoAmountToGet,\n      'unexpected amount of GHO purchased'\n    );\n    assertEq(\n      userAssetBefore - newToken.balanceOf(ALICE),\n      estSellAssetAmount,\n      'unexpected amount of asset sold'\n    );\n\n    vm.stopPrank();\n  }\n\n  /**\n   * @dev Checks buyAsset function is aligned with getAssetAmountForBuyAsset,\n   * in case the underlying asset has less decimals than GHO (18)\n   */\n  function testBuyAssetByGhoAmountWithLowerDecimals() public {\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', 6, FAUCET);\n    vm.prank(FAUCET);\n    newToken.mint(ALICE, 1_000_000e6);\n    ghoFaucet(ALICE, DEFAULT_CAPACITY);\n\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      DEFAULT_FIXED_PRICE, // 1e18\n      address(newToken),\n      6 // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(ALICE, TREASURY, 1_000_000e6);\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM TINY', DEFAULT_CAPACITY);\n\n    vm.startPrank(ALICE);\n    // Alice sells some asset to the GSM\n    newToken.approve(address(gsm), type(uint256).max);\n    gsm.sellAsset(1_000_000e6, ALICE);\n\n    // User wants to know how much asset can buy with 1.9e12 GHO\n    uint256 ghoAmountToSpend = 1.9e12; // this is the maximum that can spend\n    (uint256 estBuyAssetAmount, uint256 exactGhoSpent, , ) = gsm.getAssetAmountForBuyAsset(\n      ghoAmountToSpend\n    );\n    uint256 userGhoBefore = GHO_TOKEN.balanceOf(ALICE);\n    uint256 userAssetBefore = newToken.balanceOf(ALICE);\n\n    GHO_TOKEN.approve(address(gsm), type(uint256).max);\n    gsm.buyAsset(estBuyAssetAmount, ALICE);\n\n    assertTrue(\n      userGhoBefore - GHO_TOKEN.balanceOf(ALICE) <= ghoAmountToSpend,\n      'gho spend above maximum amount'\n    );\n    assertEq(userGhoBefore - GHO_TOKEN.balanceOf(ALICE), exactGhoSpent, 'gho spent does not match');\n    assertEq(\n      newToken.balanceOf(ALICE) - userAssetBefore,\n      estBuyAssetAmount,\n      'bought assets and amount diff do not match'\n    );\n\n    vm.stopPrank();\n  }\n\n  /**\n   * @dev Checks buyAsset function is aligned with getAssetAmountForBuyAsset,\n   * in case the underlying asset has more decimals than GHO (18)\n   */\n  function testBuyAssetByGhoAmountWithHigherDecimals() public {\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', 24, FAUCET);\n    vm.prank(FAUCET);\n    newToken.mint(ALICE, 1_000_000e24);\n    ghoFaucet(ALICE, DEFAULT_CAPACITY);\n\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      DEFAULT_FIXED_PRICE, // 1e18\n      address(newToken),\n      24 // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(ALICE, TREASURY, 1_000_000e24);\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM TINY', DEFAULT_CAPACITY);\n\n    vm.startPrank(ALICE);\n    // Alice sells some asset to the GSM\n    newToken.approve(address(gsm), type(uint256).max);\n    gsm.sellAsset(1_000_000e24, ALICE);\n\n    // User wants to know how much asset can buy with 1 GHO\n    uint256 ghoAmountToSpend = 1; // this is the lowest amount that can spend\n    (uint256 estBuyAssetAmount, uint256 exactGhoSpent, , ) = gsm.getAssetAmountForBuyAsset(\n      ghoAmountToSpend\n    );\n    uint256 userGhoBefore = GHO_TOKEN.balanceOf(ALICE);\n    uint256 userAssetBefore = newToken.balanceOf(ALICE);\n\n    GHO_TOKEN.approve(address(gsm), type(uint256).max);\n    gsm.buyAsset(estBuyAssetAmount, ALICE);\n\n    assertEq(\n      userGhoBefore - GHO_TOKEN.balanceOf(ALICE),\n      exactGhoSpent,\n      'exact gho spent does not match'\n    );\n    assertEq(\n      userGhoBefore - GHO_TOKEN.balanceOf(ALICE),\n      ghoAmountToSpend,\n      'unexpected amount of GHO spent'\n    );\n    assertEq(\n      newToken.balanceOf(ALICE) - userAssetBefore,\n      estBuyAssetAmount,\n      'unexpected amount of assets purchased'\n    );\n\n    vm.stopPrank();\n  }\n}\n"
    },
    "src/test/TestGsmSwapFuzz.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\n/**\n * @title TestGsmSwapFuzz\n * @dev Fuzzing tests for swap functions\n * @dev Bounds for priceRatio: [0.01e18, 100e18]\n * @dev Bounds for fees: [0, 5000]\n * @dev Bounds for underlyingDecimals: [5, 27]\n */\ncontract TestGsmSwapFuzz is TestGhoBase {\n  using PercentageMath for uint256;\n  using PercentageMath for uint128;\n\n  struct TestFuzzSwapAssetVars {\n    // estimation function 1\n    uint256 estAssetAmount1;\n    uint256 estGhoAmount1;\n    uint256 estGrossAmount1;\n    uint256 estFeeAmount1;\n    // estimation function 2\n    uint256 estAssetAmount2;\n    uint256 estGhoAmount2;\n    uint256 estGrossAmount2;\n    uint256 estFeeAmount2;\n    // swap function\n    uint256 exactAssetAmount;\n    uint256 exactGhoAmount;\n  }\n\n  function _checkValidPrice(\n    FixedPriceStrategy priceStrat,\n    uint256 assetAmount,\n    uint256 ghoAmount\n  ) internal {\n    assertApproxEqAbs(\n      priceStrat.getAssetPriceInGho(assetAmount, false),\n      ghoAmount,\n      2,\n      'price between asset and gho amounts is not valid _1'\n    );\n\n    assertApproxEqAbs(\n      priceStrat.getAssetPriceInGho(assetAmount, true),\n      ghoAmount,\n      2,\n      'price between asset and gho amounts is not valid _2'\n    );\n\n    assertApproxEqAbs(\n      priceStrat.getGhoPriceInAsset(ghoAmount, false),\n      assetAmount,\n      2,\n      'price between asset and gho amounts is not valid _3'\n    );\n    assertApproxEqAbs(\n      priceStrat.getGhoPriceInAsset(ghoAmount, true),\n      assetAmount,\n      2,\n      'price between asset and gho amounts is not valid _4'\n    );\n  }\n\n  /**\n   * @dev Check there is no way of making money by sell-buy actions\n   */\n  function testFuzzSellBuyNoArb(\n    uint8 underlyingDecimals,\n    uint256 priceRatio,\n    uint256 assetAmount,\n    uint256 buyFeeBps,\n    uint256 sellFeeBps\n  ) public {\n    TestFuzzSwapAssetVars memory vars;\n\n    underlyingDecimals = uint8(bound(underlyingDecimals, 5, 27));\n    buyFeeBps = bound(buyFeeBps, 0, 5000 - 1);\n    sellFeeBps = bound(sellFeeBps, 0, 5000 - 1);\n    priceRatio = bound(priceRatio, 0.01e18, 100e18);\n    assetAmount = bound(assetAmount, 1, type(uint64).max - 1);\n\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', underlyingDecimals, FAUCET);\n\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      priceRatio,\n      address(newToken),\n      underlyingDecimals // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, type(uint128).max);\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM TINY', type(uint128).max);\n\n    if (buyFeeBps > 0 || sellFeeBps > 0) {\n      FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(buyFeeBps, sellFeeBps);\n      gsm.updateFeeStrategy(address(newFeeStrategy));\n    }\n\n    // Strat estimation\n    (, vars.estGhoAmount1, , ) = gsm.getGhoAmountForSellAsset(assetAmount);\n    (vars.estAssetAmount2, , , ) = gsm.getAssetAmountForBuyAsset(vars.estGhoAmount1);\n    assertLe(\n      vars.estAssetAmount2,\n      assetAmount,\n      'getting more assetAmount than provided in estimation'\n    );\n\n    // Init GSM with some assets\n    (, uint256 aux, , ) = gsm.getGhoAmountForSellAsset(assetAmount);\n    vm.assume(aux > 0);\n    vm.startPrank(FAUCET);\n    newToken.mint(FAUCET, assetAmount);\n    newToken.approve(address(gsm), type(uint256).max);\n    gsm.sellAsset(assetAmount, FAUCET);\n    vm.stopPrank();\n\n    // Arb Strat estimation\n    (, vars.estGhoAmount1, , ) = gsm.getGhoAmountForSellAsset(assetAmount);\n    (vars.estAssetAmount2, , , ) = gsm.getAssetAmountForBuyAsset(vars.estGhoAmount1);\n    assertLe(\n      vars.estAssetAmount2,\n      assetAmount,\n      'getting more assetAmount than provided in estimation'\n    );\n\n    // Top up Alice\n    vm.prank(FAUCET);\n    newToken.mint(ALICE, assetAmount);\n\n    // Arb Strat\n    vm.startPrank(ALICE);\n    uint256 aliceBalanceBefore = newToken.balanceOf(ALICE);\n    newToken.approve(address(gsm), type(uint256).max);\n    GHO_TOKEN.approve(address(gsm), type(uint256).max);\n\n    (, vars.exactGhoAmount) = gsm.sellAsset(assetAmount, ALICE);\n    (vars.estAssetAmount1, , , ) = gsm.getAssetAmountForBuyAsset(vars.exactGhoAmount);\n    assertLe(\n      vars.estAssetAmount1,\n      assetAmount,\n      'getting more assetAmount than provided in estimation'\n    );\n    vm.assume(vars.estAssetAmount1 > 0); // 0 value is a valid for the property to hold, but buyAsset op would fail\n    (vars.exactAssetAmount, ) = gsm.buyAsset(vars.estAssetAmount1, ALICE);\n\n    assertLe(vars.exactAssetAmount, assetAmount, 'getting more assetAmount than provided in swap');\n    assertLe(newToken.balanceOf(ALICE), aliceBalanceBefore, 'asset balance more than before');\n    vm.stopPrank();\n  }\n\n  /**\n   * @dev It is possible to use values for price ratio that creates unbalance in the GSM, so all GHO cannot be burned.\n   * e.g. With (1e16 + 1) priceRatio, a user gets 1e11 gho for selling 1 asset but gets 1 asset by selling 1e11+1 gho\n   */\n  function testFuzzPriceRatioRoundingUnbalance(\n    uint8 underlyingDecimals,\n    uint256 priceRatio,\n    uint256 amount,\n    uint256 buyFeeBps,\n    uint256 sellFeeBps\n  ) public {\n    underlyingDecimals = uint8(bound(underlyingDecimals, 5, 27));\n    buyFeeBps = bound(buyFeeBps, 0, 5000 - 1);\n    sellFeeBps = bound(sellFeeBps, 0, 5000 - 1);\n    priceRatio = bound(priceRatio, 0.01e18, 100e18);\n    amount = bound(amount, 1, type(uint128).max - 1);\n\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', underlyingDecimals, FAUCET);\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      priceRatio,\n      address(newToken),\n      underlyingDecimals // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, type(uint128).max);\n\n    // Get gho amount for selling assets\n    (uint256 assetSold, , uint256 ghoMinted, ) = gsm.getGhoAmountForSellAsset(amount);\n    (, , uint256 ghoToBurn, ) = gsm.getGhoAmountForBuyAsset(assetSold);\n\n    // 1 unit of imprecision due to rounding\n    assertTrue(ghoToBurn <= ghoMinted + 1, 'unexpected gsm unbalance');\n\n    // Get amount of assets can be purchased based on minted GHO amount\n    (, uint256 ghoAmount, , ) = gsm.getAssetAmountForBuyAsset(ghoMinted);\n    assertTrue(ghoAmount <= ghoMinted);\n  }\n\n  /**\n   * @dev Checks that passing an amount higher than 2*128-1 (`maxUint128`) to a swap function reverts\n   */\n  function testFuzzSwapAmountAbove128(\n    uint8 underlyingDecimals,\n    uint256 priceRatio,\n    uint256 amount,\n    uint256 buyFeeBps,\n    uint256 sellFeeBps\n  ) public {\n    underlyingDecimals = uint8(bound(underlyingDecimals, 5, 27));\n    buyFeeBps = bound(buyFeeBps, 0, 5000 - 1);\n    sellFeeBps = bound(sellFeeBps, 0, 5000 - 1);\n    priceRatio = bound(priceRatio, 0.01e18, 100e18);\n    amount = bound(amount, 1, type(uint128).max) + type(uint128).max; // avoiding a bug in forge-std where bound will revert\n\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', underlyingDecimals, FAUCET);\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      priceRatio,\n      address(newToken),\n      underlyingDecimals // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, type(uint128).max);\n    GHO_TOKEN.addFacilitator(address(gsm), 'Test GSM', type(uint128).max);\n\n    if (buyFeeBps > 0 || sellFeeBps > 0) {\n      FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(buyFeeBps, sellFeeBps);\n      gsm.updateFeeStrategy(address(newFeeStrategy));\n    }\n\n    (uint256 ghoBought, , , ) = gsm.getGhoAmountForSellAsset(amount);\n    vm.assume(ghoBought > type(uint128).max);\n\n    vm.startPrank(FAUCET);\n    newToken.mint(FAUCET, amount);\n    newToken.approve(address(gsm), amount);\n    vm.expectRevert();\n    gsm.sellAsset(amount, ALICE);\n    vm.stopPrank();\n  }\n\n  /**\n   * @dev Tests to ensure a revert when the GSM holds the maximum amount of asset possible and a user attempts to buy\n   * 1 more unit of the asset than is available\n   */\n  function testFuzzBuyAmountAboveMaximum(\n    uint8 underlyingDecimals,\n    uint256 priceRatio,\n    uint256 buyFeeBps,\n    uint256 sellFeeBps\n  ) public {\n    underlyingDecimals = uint8(bound(underlyingDecimals, 5, 27));\n    priceRatio = bound(priceRatio, 0.01e18, 100e18);\n    buyFeeBps = bound(buyFeeBps, 0, 5000 - 1);\n    sellFeeBps = bound(sellFeeBps, 0, 5000 - 1);\n\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', underlyingDecimals, FAUCET);\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      priceRatio,\n      address(newToken),\n      underlyingDecimals // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, type(uint128).max);\n    GHO_TOKEN.addFacilitator(address(gsm), 'Test GSM', type(uint128).max);\n\n    if (buyFeeBps > 0 || sellFeeBps > 0) {\n      FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(buyFeeBps, sellFeeBps);\n      gsm.updateFeeStrategy(address(newFeeStrategy));\n    }\n\n    uint256 amount = newPriceStrategy.getGhoPriceInAsset(type(uint128).max, false);\n    if (amount > type(uint128).max) {\n      amount = type(uint128).max;\n    }\n\n    vm.startPrank(FAUCET);\n    newToken.mint(FAUCET, amount);\n    newToken.approve(address(gsm), amount);\n    gsm.sellAsset(amount, ALICE);\n    vm.stopPrank();\n\n    ghoFaucet(BOB, type(uint128).max);\n    vm.startPrank(BOB);\n    GHO_TOKEN.approve(address(gsm), type(uint128).max);\n    vm.expectRevert();\n    gsm.buyAsset(amount + 1, BOB);\n    vm.stopPrank();\n  }\n\n  /**\n   * @dev Checks behaviour of getGhoAmountForSellAsset\n   */\n  function testFuzzGetGhoAmountForSellAsset(\n    uint8 underlyingDecimals,\n    uint256 priceRatio,\n    uint256 amount,\n    uint256 buyFeeBps,\n    uint256 sellFeeBps\n  ) public {\n    underlyingDecimals = uint8(bound(underlyingDecimals, 5, 27));\n    buyFeeBps = bound(buyFeeBps, 0, 5000 - 1);\n    sellFeeBps = bound(sellFeeBps, 0, 5000 - 1);\n    priceRatio = bound(priceRatio, 0.01e18, 100e18);\n    amount = bound(amount, 1, type(uint128).max - 1);\n\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', underlyingDecimals, FAUCET);\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      priceRatio,\n      address(newToken),\n      underlyingDecimals // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, type(uint128).max);\n\n    if (buyFeeBps > 0 || sellFeeBps > 0) {\n      FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(buyFeeBps, sellFeeBps);\n      gsm.updateFeeStrategy(address(newFeeStrategy));\n    }\n\n    (uint256 exactAssetAmount, uint256 ghoBought, uint256 grossAmount, uint256 fee) = gsm\n      .getGhoAmountForSellAsset(amount);\n    assertTrue(exactAssetAmount <= amount, 'maximum asset amount exceeded');\n    assertTrue(ghoBought <= grossAmount, 'gross amount lower than ghoBought');\n    _checkValidPrice(newPriceStrategy, exactAssetAmount, grossAmount);\n\n    // In case of 0 sellFee\n    if (sellFeeBps == 0) {\n      assertEq(grossAmount, ghoBought, 'unexpected gross amount');\n      assertEq(fee, 0, 'unexpected fee');\n    }\n  }\n\n  /**\n   * @dev Checks behaviour of getGhoAmountForBuyAsset\n   */\n  function testFuzzGetGhoAmountForBuyAsset(\n    uint8 underlyingDecimals,\n    uint256 priceRatio,\n    uint256 amount,\n    uint256 buyFeeBps,\n    uint256 sellFeeBps\n  ) public {\n    underlyingDecimals = uint8(bound(underlyingDecimals, 5, 27));\n    buyFeeBps = bound(buyFeeBps, 0, 5000 - 1);\n    sellFeeBps = bound(sellFeeBps, 0, 5000 - 1);\n    priceRatio = bound(priceRatio, 0.01e18, 100e18);\n    amount = bound(amount, 1, type(uint128).max - 1);\n\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', underlyingDecimals, FAUCET);\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      priceRatio,\n      address(newToken),\n      underlyingDecimals // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, type(uint128).max);\n\n    if (buyFeeBps > 0 || sellFeeBps > 0) {\n      FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(buyFeeBps, sellFeeBps);\n      gsm.updateFeeStrategy(address(newFeeStrategy));\n    }\n\n    (uint256 exactAssetAmount, uint256 ghoSold, uint256 grossAmount, uint256 fee) = gsm\n      .getGhoAmountForBuyAsset(amount);\n    assertTrue(exactAssetAmount >= amount, 'minimum asset amount not reached');\n    assertTrue(ghoSold >= grossAmount, 'gross amount lower than ghoSold');\n    _checkValidPrice(newPriceStrategy, exactAssetAmount, grossAmount);\n\n    // In case of 0 buyFee\n    if (buyFeeBps == 0) {\n      assertEq(grossAmount, ghoSold, 'unexpected gross amount');\n      assertEq(fee, 0, 'unexpected fee');\n    }\n  }\n\n  /**\n   * @dev Checks behaviour of getAssetAmountForSellAsset\n   */\n  function testFuzzGetAssetAmountForSellAsset(\n    uint8 underlyingDecimals,\n    uint256 priceRatio,\n    uint256 amount,\n    uint256 buyFeeBps,\n    uint256 sellFeeBps\n  ) public {\n    underlyingDecimals = uint8(bound(underlyingDecimals, 5, 27));\n    buyFeeBps = bound(buyFeeBps, 0, 5000 - 1);\n    sellFeeBps = bound(sellFeeBps, 0, 5000 - 1);\n    priceRatio = bound(priceRatio, 0.01e18, 100e18);\n    amount = bound(amount, 1, type(uint128).max - 1);\n\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', underlyingDecimals, FAUCET);\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      priceRatio,\n      address(newToken),\n      underlyingDecimals // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, type(uint128).max);\n\n    if (buyFeeBps > 0 || sellFeeBps > 0) {\n      FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(buyFeeBps, sellFeeBps);\n      gsm.updateFeeStrategy(address(newFeeStrategy));\n    }\n\n    (uint256 exactAssetAmount, uint256 ghoBought, uint256 grossAmount, uint256 fee) = gsm\n      .getAssetAmountForSellAsset(amount);\n    assertTrue(ghoBought > 0, 'unexpected 0 value for ghoBought');\n    assertTrue(ghoBought >= amount, 'minimum gho amount not reached');\n    assertTrue(ghoBought <= grossAmount, 'gross amount lower than ghoBought');\n    _checkValidPrice(newPriceStrategy, exactAssetAmount, grossAmount);\n\n    // In case of 0 sellFee\n    if (sellFeeBps == 0) {\n      assertEq(grossAmount, ghoBought, 'unexpected gross amount');\n      assertEq(fee, 0, 'unexpected fee');\n    }\n  }\n\n  /**\n   * @dev Checks behaviour of getAssetAmountForBuyAsset\n   */\n  function testFuzzGetAssetAmountForBuyAsset(\n    uint8 underlyingDecimals,\n    uint256 priceRatio,\n    uint256 amount,\n    uint256 buyFeeBps,\n    uint256 sellFeeBps\n  ) public {\n    underlyingDecimals = uint8(bound(underlyingDecimals, 5, 27));\n    buyFeeBps = bound(buyFeeBps, 0, 5000 - 1);\n    sellFeeBps = bound(sellFeeBps, 0, 5000 - 1);\n    priceRatio = bound(priceRatio, 0.01e18, 100e18);\n    amount = bound(amount, 1, type(uint128).max - 1);\n\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', underlyingDecimals, FAUCET);\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      priceRatio,\n      address(newToken),\n      underlyingDecimals // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, type(uint128).max);\n\n    if (buyFeeBps > 0 || sellFeeBps > 0) {\n      FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(buyFeeBps, sellFeeBps);\n      gsm.updateFeeStrategy(address(newFeeStrategy));\n    }\n\n    (uint256 exactAssetAmount, uint256 ghoSold, uint256 grossAmount, uint256 fee) = gsm\n      .getAssetAmountForBuyAsset(amount);\n    assertTrue(ghoSold <= amount, 'maximum gho amount exceeded');\n    assertTrue(ghoSold >= grossAmount, 'gross amount lower than ghoSold');\n    _checkValidPrice(newPriceStrategy, exactAssetAmount, grossAmount);\n\n    // In case of 0 buyFee\n    if (buyFeeBps == 0) {\n      assertEq(grossAmount, ghoSold, 'unexpected gross amount');\n      assertEq(fee, 0, 'unexpected fee');\n    }\n  }\n\n  /**\n   * @dev Checks invariant between inverse functions to query amounts for the sell action: getGhoAmountForSellAsset\n   * and getAssetAmountForSellAsset.\n   */\n  function testFuzzSellEstimation(\n    uint8 underlyingDecimals,\n    uint256 priceRatio,\n    uint256 assetAmount,\n    uint256 buyFeeBps,\n    uint256 sellFeeBps\n  ) public {\n    TestFuzzSwapAssetVars memory vars;\n\n    underlyingDecimals = uint8(bound(underlyingDecimals, 5, 27));\n    buyFeeBps = bound(buyFeeBps, 0, 5000 - 1);\n    sellFeeBps = bound(sellFeeBps, 0, 5000 - 1);\n    priceRatio = bound(priceRatio, 0.01e18, 100e18);\n    assetAmount = bound(assetAmount, 1, type(uint64).max - 1);\n\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', underlyingDecimals, FAUCET);\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      priceRatio,\n      address(newToken),\n      underlyingDecimals // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, uint128(assetAmount));\n\n    if (buyFeeBps > 0 || sellFeeBps > 0) {\n      FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(buyFeeBps, sellFeeBps);\n      gsm.updateFeeStrategy(address(newFeeStrategy));\n    }\n\n    (vars.estAssetAmount1, vars.estGhoAmount1, vars.estGrossAmount1, vars.estFeeAmount1) = gsm\n      .getGhoAmountForSellAsset(assetAmount);\n    vm.assume(vars.estGhoAmount1 > 0);\n    (vars.estAssetAmount2, vars.estGhoAmount2, vars.estGrossAmount2, vars.estFeeAmount2) = gsm\n      .getAssetAmountForSellAsset(vars.estGhoAmount1);\n\n    assertTrue(\n      assetAmount >= vars.estAssetAmount1,\n      'exact asset amount being used is higher than the amount passed'\n    );\n    assertTrue(\n      assetAmount >= vars.estAssetAmount2,\n      'exact asset amount being used is higher than the amount passed'\n    );\n    assertEq(vars.estGhoAmount1, vars.estGhoAmount2, 'bought gho amount do not match');\n    assertEq(\n      vars.estAssetAmount1,\n      vars.estAssetAmount2,\n      'given assetAmount and estimated do not match'\n    );\n    // 1 wei precision error\n    assertApproxEqAbs(\n      vars.estGrossAmount1,\n      vars.estGrossAmount2,\n      1,\n      'estimated gross amounts do not match'\n    );\n    assertApproxEqAbs(vars.estFeeAmount1, vars.estFeeAmount2, 1, 'estimated fees do not match');\n\n    // In case of 0 sellFee\n    if (sellFeeBps == 0) {\n      assertEq(vars.estGrossAmount1, vars.estGhoAmount1, 'unexpected grossAmount1 and ghoBought');\n      assertEq(vars.estGrossAmount2, vars.estGhoAmount1, 'unexpected grossAmount2 and ghoBought');\n      assertEq(vars.estFeeAmount1, 0, 'expected fee1');\n      assertEq(vars.estFeeAmount2, 0, 'expected fee2');\n    }\n  }\n\n  /**\n   * @dev Checks invariant between inverse functions to query amounts for the buy action: getGhoAmountForBuyAsset\n   * and getAssetAmountForBuyAsset.\n   */\n  function testFuzzBuyEstimation(\n    uint8 underlyingDecimals,\n    uint256 priceRatio,\n    uint256 assetAmount,\n    uint256 buyFeeBps,\n    uint256 sellFeeBps\n  ) public {\n    TestFuzzSwapAssetVars memory vars;\n\n    underlyingDecimals = uint8(bound(underlyingDecimals, 5, 27));\n    buyFeeBps = bound(buyFeeBps, 0, 5000 - 1);\n    sellFeeBps = bound(sellFeeBps, 0, 5000 - 1);\n    priceRatio = bound(priceRatio, 0.01e18, 100e18);\n    assetAmount = bound(assetAmount, 1, type(uint64).max - 1);\n\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', underlyingDecimals, FAUCET);\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      priceRatio,\n      address(newToken),\n      underlyingDecimals // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, uint128(assetAmount));\n\n    if (buyFeeBps > 0 || sellFeeBps > 0) {\n      FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(buyFeeBps, sellFeeBps);\n      gsm.updateFeeStrategy(address(newFeeStrategy));\n    }\n\n    (vars.estAssetAmount1, vars.estGhoAmount1, vars.estGrossAmount1, vars.estFeeAmount1) = gsm\n      .getGhoAmountForBuyAsset(assetAmount);\n    vm.assume(vars.estGhoAmount1 > 0);\n    (vars.estAssetAmount2, vars.estGhoAmount2, vars.estGrossAmount2, vars.estFeeAmount2) = gsm\n      .getAssetAmountForBuyAsset(vars.estGhoAmount1);\n\n    assertTrue(\n      vars.estAssetAmount1 >= assetAmount,\n      'exact asset amount being used is less than the amount passed'\n    );\n    assertTrue(\n      vars.estAssetAmount2 >= assetAmount,\n      'exact asset amount being used is less than the amount passed'\n    );\n    assertEq(vars.estGhoAmount1, vars.estGhoAmount2, 'sold gho amount do not match');\n    assertEq(\n      vars.estAssetAmount1,\n      vars.estAssetAmount2,\n      'given assetAmount and estimated do not match'\n    );\n    assertEq(vars.estGrossAmount1, vars.estGrossAmount2, 'estimated gross amounts do not match');\n    assertEq(vars.estFeeAmount1, vars.estFeeAmount2, 'estimated fees do not match');\n\n    // In case of 0 buyFee\n    if (buyFeeBps == 0) {\n      assertEq(vars.estGrossAmount1, vars.estGhoAmount1, 'unexpected grossAmount1 and ghoSold');\n      assertEq(vars.estGrossAmount2, vars.estGhoAmount1, 'unexpected grossAmount2 and ghoSold');\n      assertEq(vars.estFeeAmount1, 0, 'expected fee1');\n      assertEq(vars.estFeeAmount2, 0, 'expected fee2');\n    }\n  }\n\n  /**\n   * @dev Checks sellAsset is aligned with getAssetAmountForSellAsset and getGhoAmountForSellAsset\n   */\n  function testFuzzSellAssetWithEstimation(\n    uint8 underlyingDecimals,\n    uint256 priceRatio,\n    uint256 assetAmount,\n    uint256 buyFeeBps,\n    uint256 sellFeeBps\n  ) public {\n    TestFuzzSwapAssetVars memory vars;\n\n    underlyingDecimals = uint8(bound(underlyingDecimals, 5, 27));\n    buyFeeBps = bound(buyFeeBps, 0, 5000 - 1);\n    sellFeeBps = bound(sellFeeBps, 0, 5000 - 1);\n    priceRatio = bound(priceRatio, 0.01e18, 100e18);\n    assetAmount = bound(assetAmount, 1, type(uint64).max - 1);\n\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', underlyingDecimals, FAUCET);\n    vm.prank(FAUCET);\n    newToken.mint(ALICE, assetAmount);\n\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      priceRatio,\n      address(newToken),\n      underlyingDecimals // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, uint128(assetAmount));\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM TINY', type(uint128).max);\n\n    if (buyFeeBps > 0 || sellFeeBps > 0) {\n      FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(buyFeeBps, sellFeeBps);\n      gsm.updateFeeStrategy(address(newFeeStrategy));\n    }\n\n    vm.startPrank(ALICE);\n    newToken.approve(address(gsm), type(uint256).max);\n\n    uint256 userGhoBefore = GHO_TOKEN.balanceOf(ALICE);\n    uint256 userAssetBefore = newToken.balanceOf(ALICE);\n\n    // Calculate GHO amount to purchase with given asset amount, bail if 0\n    (, vars.estGhoAmount1, vars.estGrossAmount1, vars.estFeeAmount1) = gsm.getGhoAmountForSellAsset(\n      assetAmount\n    );\n    vm.assume(vars.estGhoAmount1 > 0);\n\n    (vars.exactAssetAmount, vars.exactGhoAmount) = gsm.sellAsset(assetAmount, ALICE);\n\n    // Calculate asset amount needed for the amount of GHO required to buy\n    (vars.estAssetAmount2, , vars.estGrossAmount2, vars.estFeeAmount2) = gsm\n      .getAssetAmountForSellAsset(vars.exactGhoAmount);\n\n    assertEq(\n      userAssetBefore - newToken.balanceOf(ALICE),\n      vars.exactAssetAmount,\n      'real assets sold are not equal to the exact amount'\n    );\n    assertTrue(\n      userAssetBefore - newToken.balanceOf(ALICE) <= assetAmount,\n      'real assets sold are more than the input'\n    );\n    assertEq(\n      GHO_TOKEN.balanceOf(ALICE) - userGhoBefore,\n      vars.exactGhoAmount,\n      'real gho bought does not match returned value'\n    );\n    assertEq(\n      GHO_TOKEN.balanceOf(ALICE) - userGhoBefore,\n      vars.estGhoAmount1,\n      'real gho bought does not match estimated value'\n    );\n    assertEq(\n      userAssetBefore - newToken.balanceOf(ALICE),\n      vars.estAssetAmount2,\n      'real assets sold does not match estimated value'\n    );\n\n    // 1 wei precision error\n    assertApproxEqAbs(\n      vars.estGrossAmount1,\n      vars.estGrossAmount2,\n      1,\n      'estimated gross amounts do not match'\n    );\n    assertApproxEqAbs(vars.estFeeAmount1, vars.estFeeAmount2, 1, 'estimated fees do not match');\n\n    // In case of 0 sellFeeBps\n    if (sellFeeBps == 0) {\n      assertEq(vars.estGrossAmount1, vars.exactGhoAmount, 'unexpected grossAmount1 and ghoBought');\n      assertEq(vars.estGrossAmount2, vars.exactGhoAmount, 'unexpected grossAmount2 and ghoBought');\n      assertEq(vars.estFeeAmount1, 0, 'expected fee1');\n      assertEq(vars.estFeeAmount2, 0, 'expected fee2');\n    }\n\n    vm.stopPrank();\n  }\n\n  /**\n   * @dev Checks buyAsset is aligned with getAssetAmountForBuyAsset and getGhoAmountForBuyAsset\n   */\n  function testFuzzBuyAssetWithEstimation(\n    uint8 underlyingDecimals,\n    uint256 priceRatio,\n    uint256 assetAmount,\n    uint256 buyFeeBps,\n    uint256 sellFeeBps\n  ) public {\n    TestFuzzSwapAssetVars memory vars;\n\n    underlyingDecimals = uint8(bound(underlyingDecimals, 5, 27));\n    buyFeeBps = bound(buyFeeBps, 0, 5000 - 1);\n    sellFeeBps = bound(sellFeeBps, 0, 5000 - 1);\n    priceRatio = bound(priceRatio, 0.01e18, 100e18);\n    assetAmount = bound(assetAmount, 1, type(uint64).max - 1);\n\n    TestnetERC20 newToken = new TestnetERC20('Test Coin', 'TEST', underlyingDecimals, FAUCET);\n\n    FixedPriceStrategy newPriceStrategy = new FixedPriceStrategy(\n      priceRatio,\n      address(newToken),\n      underlyingDecimals // decimals\n    );\n    Gsm gsm = new Gsm(address(GHO_TOKEN), address(newToken), address(newPriceStrategy));\n    gsm.initialize(address(this), TREASURY, type(uint128).max);\n    GHO_TOKEN.addFacilitator(address(gsm), 'GSM TINY', type(uint128).max);\n\n    if (buyFeeBps > 0 || sellFeeBps > 0) {\n      FixedFeeStrategy newFeeStrategy = new FixedFeeStrategy(buyFeeBps, sellFeeBps);\n      gsm.updateFeeStrategy(address(newFeeStrategy));\n    }\n\n    // Alice sells some assets to the GSM, so the purchase is doable\n    uint256 sellAssetAmount = newPriceStrategy.getGhoPriceInAsset(type(uint128).max, false);\n    if (sellAssetAmount > type(uint128).max) {\n      sellAssetAmount = type(uint128).max;\n    }\n\n    vm.prank(FAUCET);\n    newToken.mint(ALICE, sellAssetAmount);\n\n    vm.startPrank(ALICE);\n    newToken.approve(address(gsm), type(uint256).max);\n    gsm.sellAsset(sellAssetAmount, ALICE);\n    vm.stopPrank();\n\n    // rough estimation of GHO funds needed for buyAsset\n    (, uint256 estGhoBought, , ) = gsm.getGhoAmountForBuyAsset(assetAmount);\n    ghoFaucet(ALICE, estGhoBought * 20);\n\n    // Buy\n    vm.startPrank(ALICE);\n    uint256 userGhoBefore = GHO_TOKEN.balanceOf(ALICE);\n    uint256 userAssetBefore = newToken.balanceOf(ALICE);\n\n    // Calculate GHO amount to sell with given asset amount\n    (, vars.estGhoAmount1, vars.estGrossAmount1, vars.estFeeAmount1) = gsm.getGhoAmountForBuyAsset(\n      assetAmount\n    );\n\n    userGhoBefore = GHO_TOKEN.balanceOf(ALICE);\n    userAssetBefore = newToken.balanceOf(ALICE);\n\n    GHO_TOKEN.approve(address(gsm), type(uint256).max);\n    (vars.exactAssetAmount, vars.exactGhoAmount) = gsm.buyAsset(assetAmount, ALICE);\n\n    // Calculate asset amount can be bought for the amount of GHO available\n    (vars.estAssetAmount2, vars.estGhoAmount2, vars.estGrossAmount2, vars.estFeeAmount2) = gsm\n      .getAssetAmountForBuyAsset(vars.exactGhoAmount);\n\n    assertEq(\n      newToken.balanceOf(ALICE) - userAssetBefore,\n      vars.exactAssetAmount,\n      'real assets bought are not equal to the exact amount'\n    );\n    assertTrue(\n      newToken.balanceOf(ALICE) - userAssetBefore >= assetAmount,\n      'real assets bought are less than the input'\n    );\n    assertEq(\n      newToken.balanceOf(ALICE) - userAssetBefore,\n      vars.estAssetAmount2,\n      'real assets bought does not match estimated value'\n    );\n    assertEq(\n      userGhoBefore - GHO_TOKEN.balanceOf(ALICE),\n      vars.exactGhoAmount,\n      'real gho sold does not match returned value'\n    );\n    assertEq(\n      userGhoBefore - GHO_TOKEN.balanceOf(ALICE),\n      vars.estGhoAmount1,\n      'real gho sold does not match estimated value'\n    );\n\n    assertEq(vars.estGhoAmount1, vars.estGhoAmount2, 'estimated gross amounts do not match');\n    assertEq(vars.estFeeAmount1, vars.estFeeAmount2, 'estimated fees do not match');\n\n    // In case of 0 buyFeeBps\n    if (buyFeeBps == 0) {\n      assertEq(vars.estGhoAmount1, vars.exactGhoAmount, 'unexpected grossAmount1 and ghoSold');\n      assertEq(vars.estGhoAmount2, vars.exactGhoAmount, 'unexpected grossAmount2 and ghoSold');\n      assertEq(vars.estFeeAmount1, 0, 'expected fee1');\n      assertEq(vars.estFeeAmount2, 0, 'expected fee2');\n    }\n\n    vm.stopPrank();\n  }\n}\n"
    },
    "src/test/TestGsmUpgrade.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestGsmUpgrade is TestGhoBase {\n  function testUpgrade() public {\n    assertEq(GHO_GSM.GSM_REVISION(), 1, 'Unexpected pre-upgrade GSM revision');\n\n    bytes32[] memory beforeSnapshot = _getStorageSnapshot();\n\n    // Sanity check on select storage variable\n    assertEq(uint256(beforeSnapshot[1]), uint160(TREASURY), 'GHO Treasury address not set');\n\n    // Perform the mock upgrade\n    address gsmV2 = address(\n      new MockGsmV2(address(GHO_TOKEN), address(USDC_TOKEN), address(GHO_GSM_FIXED_PRICE_STRATEGY))\n    );\n    bytes memory data = abi.encodeWithSelector(MockGsmV2.initialize.selector);\n    vm.expectEmit(true, false, false, true, address(GHO_GSM));\n    emit Upgraded(gsmV2);\n    vm.prank(SHORT_EXECUTOR);\n    AdminUpgradeabilityProxy(payable(address(GHO_GSM))).upgradeToAndCall(gsmV2, data);\n\n    assertEq(GHO_GSM.GSM_REVISION(), 2, 'Unexpected post-upgrade GSM revision');\n\n    bytes32[] memory afterSnapshot = _getStorageSnapshot();\n    // First storage item should be different, the rest the same post-upgrade\n    assertTrue(afterSnapshot[0] != beforeSnapshot[0], 'Unexpected lastInitializedRevision');\n    for (uint8 i = 1; i < afterSnapshot.length; i++) {\n      assertEq(afterSnapshot[i], beforeSnapshot[i], 'Unexpected storage value updated');\n    }\n  }\n\n  function _getStorageSnapshot() internal view returns (bytes32[] memory) {\n    // Snapshot values for lastInitializedRevision (slot 1) and GSM local storage (54-58)\n    bytes32[] memory data = new bytes32[](6);\n    data[0] = vm.load(address(GHO_GSM), bytes32(uint256(1)));\n    data[1] = vm.load(address(GHO_GSM), bytes32(uint256(54)));\n    data[2] = vm.load(address(GHO_GSM), bytes32(uint256(55)));\n    data[3] = vm.load(address(GHO_GSM), bytes32(uint256(56)));\n    data[4] = vm.load(address(GHO_GSM), bytes32(uint256(57)));\n    data[5] = vm.load(address(GHO_GSM), bytes32(uint256(58)));\n    return data;\n  }\n}\n"
    },
    "src/test/TestUiGhoDataProvider.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\nimport {UiGhoDataProvider, IUiGhoDataProvider} from '../contracts/facilitators/aave/misc/UiGhoDataProvider.sol';\n\ncontract TestUiGhoDataProvider is TestGhoBase {\n  UiGhoDataProvider dataProvider;\n\n  function setUp() public {\n    dataProvider = new UiGhoDataProvider(IPool(POOL), GHO_TOKEN);\n  }\n\n  function testGhoReserveData() public {\n    DataTypes.ReserveData memory baseData = POOL.getReserveData(address(GHO_TOKEN));\n    (uint256 bucketCapacity, uint256 bucketLevel) = GHO_TOKEN.getFacilitatorBucket(\n      baseData.aTokenAddress\n    );\n    IUiGhoDataProvider.GhoReserveData memory result = dataProvider.getGhoReserveData();\n    assertEq(\n      result.ghoBaseVariableBorrowRate,\n      baseData.currentVariableBorrowRate,\n      'Unexpected variable borrow rate'\n    );\n    assertEq(\n      result.ghoDiscountedPerToken,\n      GHO_DISCOUNT_STRATEGY.GHO_DISCOUNTED_PER_DISCOUNT_TOKEN(),\n      'Unexpected discount per token'\n    );\n    assertEq(\n      result.ghoDiscountRate,\n      GHO_DISCOUNT_STRATEGY.DISCOUNT_RATE(),\n      'Unexpected discount rate'\n    );\n    assertEq(\n      result.ghoMinDiscountTokenBalanceForDiscount,\n      GHO_DISCOUNT_STRATEGY.MIN_DISCOUNT_TOKEN_BALANCE(),\n      'Unexpected minimum discount token balance'\n    );\n    assertEq(\n      result.ghoMinDebtTokenBalanceForDiscount,\n      GHO_DISCOUNT_STRATEGY.MIN_DEBT_TOKEN_BALANCE(),\n      'Unexpected minimum debt token balance'\n    );\n    assertEq(\n      result.ghoReserveLastUpdateTimestamp,\n      baseData.lastUpdateTimestamp,\n      'Unexpected last timestamp'\n    );\n    assertEq(result.ghoCurrentBorrowIndex, baseData.variableBorrowIndex, 'Unexpected borrow index');\n    assertEq(result.aaveFacilitatorBucketLevel, bucketLevel, 'Unexpected facilitator bucket level');\n    assertEq(\n      result.aaveFacilitatorBucketMaxCapacity,\n      bucketCapacity,\n      'Unexpected facilitator bucket capacity'\n    );\n  }\n\n  function testGhoUserData() public {\n    IUiGhoDataProvider.GhoUserData memory result = dataProvider.getGhoUserData(ALICE);\n    assertEq(\n      result.userGhoDiscountPercent,\n      GHO_DEBT_TOKEN.getDiscountPercent(ALICE),\n      'Unexpected discount percent'\n    );\n    assertEq(\n      result.userDiscountTokenBalance,\n      IERC20(GHO_DEBT_TOKEN.getDiscountToken()).balanceOf(ALICE),\n      'Unexpected discount token balance'\n    );\n    assertEq(\n      result.userPreviousGhoBorrowIndex,\n      GHO_DEBT_TOKEN.getPreviousIndex(ALICE),\n      'Unexpected previous index'\n    );\n    assertEq(\n      result.userGhoScaledBorrowBalance,\n      GHO_DEBT_TOKEN.scaledBalanceOf(ALICE),\n      'Unexpected scaled balance'\n    );\n  }\n}\n"
    },
    "src/test/TestUpgradeableGhoToken.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\ncontract TestUpgradeableGhoTokenSetup is TestGhoBase {\n  address internal PROXY_ADMIN = makeAddr('PROXY_ADMIN');\n\n  UpgradeableGhoToken internal ghoToken;\n\n  function setUp() public virtual {\n    UpgradeableGhoToken ghoTokenImple = new UpgradeableGhoToken();\n\n    // proxy deploy and init\n    bytes memory ghoTokenImpleParams = abi.encodeWithSignature(\n      'initialize(address)',\n      address(this)\n    );\n    TransparentUpgradeableProxy ghoTokenProxy = new TransparentUpgradeableProxy(\n      address(ghoTokenImple),\n      PROXY_ADMIN,\n      ghoTokenImpleParams\n    );\n\n    ghoToken = UpgradeableGhoToken(address(ghoTokenProxy));\n  }\n}\n\ncontract TestUpgradeableGhoToken is TestUpgradeableGhoTokenSetup {\n  function setUp() public override {\n    super.setUp();\n\n    // Grant\n    ghoToken.grantRole(GHO_TOKEN_FACILITATOR_MANAGER_ROLE, address(this));\n    ghoToken.grantRole(GHO_TOKEN_BUCKET_MANAGER_ROLE, address(this));\n\n    // Add Aave as Facilitator\n    ghoToken.addFacilitator(address(GHO_ATOKEN), 'Aave V3 Pool', DEFAULT_CAPACITY);\n    // Add Faucet ad Facilitator\n    ghoToken.addFacilitator(FAUCET, 'Faucet Facilitator', type(uint128).max);\n  }\n\n  function testInit() public {\n    UpgradeableGhoToken ghoTokenImple = new UpgradeableGhoToken();\n    // proxy deploy and init\n    bytes memory ghoTokenImpleParams = abi.encodeWithSignature(\n      'initialize(address)',\n      address(this)\n    );\n\n    vm.expectEmit(true, true, true, true);\n    emit RoleGranted(DEFAULT_ADMIN_ROLE, address(this), address(this));\n    TransparentUpgradeableProxy ghoTokenProxy = new TransparentUpgradeableProxy(\n      address(ghoTokenImple),\n      PROXY_ADMIN,\n      ghoTokenImpleParams\n    );\n\n    // Implementation asserts\n    assertEq(ghoTokenImple.decimals(), 18, 'Wrong default ERC20 decimals');\n    vm.expectRevert('Initializable: contract is already initialized');\n    ghoTokenImple.initialize(address(this));\n\n    // Proxy asserts\n    UpgradeableGhoToken token = UpgradeableGhoToken(address(ghoTokenProxy));\n\n    assertEq(token.name(), 'Gho Token', 'Wrong default ERC20 name');\n    assertEq(token.symbol(), 'GHO', 'Wrong default ERC20 symbol');\n    assertEq(token.decimals(), 18, 'Wrong default ERC20 decimals');\n    assertEq(token.getFacilitatorsList().length, 0, 'Facilitator list not empty');\n  }\n\n  function testGetFacilitatorData() public {\n    IGhoToken.Facilitator memory data = ghoToken.getFacilitator(address(GHO_ATOKEN));\n    assertEq(data.label, 'Aave V3 Pool', 'Unexpected facilitator label');\n    assertEq(data.bucketCapacity, DEFAULT_CAPACITY, 'Unexpected bucket capacity');\n    assertEq(data.bucketLevel, 0, 'Unexpected bucket level');\n  }\n\n  function testGetNonFacilitatorData() public {\n    IGhoToken.Facilitator memory data = ghoToken.getFacilitator(ALICE);\n    assertEq(data.label, '', 'Unexpected facilitator label');\n    assertEq(data.bucketCapacity, 0, 'Unexpected bucket capacity');\n    assertEq(data.bucketLevel, 0, 'Unexpected bucket level');\n  }\n\n  function testGetFacilitatorBucket() public {\n    (uint256 capacity, uint256 level) = ghoToken.getFacilitatorBucket(address(GHO_ATOKEN));\n    assertEq(capacity, DEFAULT_CAPACITY, 'Unexpected bucket capacity');\n    assertEq(level, 0, 'Unexpected bucket level');\n  }\n\n  function testGetNonFacilitatorBucket() public {\n    (uint256 capacity, uint256 level) = ghoToken.getFacilitatorBucket(ALICE);\n    assertEq(capacity, 0, 'Unexpected bucket capacity');\n    assertEq(level, 0, 'Unexpected bucket level');\n  }\n\n  function testGetPopulatedFacilitatorsList() public {\n    address[] memory facilitatorList = ghoToken.getFacilitatorsList();\n    assertEq(facilitatorList.length, 2, 'Unexpected number of facilitators');\n    assertEq(facilitatorList[0], address(GHO_ATOKEN), 'Unexpected address for mock facilitator 1');\n    assertEq(facilitatorList[1], FAUCET, 'Unexpected address for mock facilitator 5');\n  }\n\n  function testAddFacilitator() public {\n    vm.expectEmit(true, true, false, true, address(ghoToken));\n    emit FacilitatorAdded(ALICE, keccak256(abi.encodePacked('Alice')), DEFAULT_CAPACITY);\n    ghoToken.addFacilitator(ALICE, 'Alice', DEFAULT_CAPACITY);\n  }\n\n  function testAddFacilitatorWithRole() public {\n    vm.expectEmit(true, true, true, true, address(ghoToken));\n    emit RoleGranted(GHO_TOKEN_FACILITATOR_MANAGER_ROLE, ALICE, address(this));\n    ghoToken.grantRole(GHO_TOKEN_FACILITATOR_MANAGER_ROLE, ALICE);\n    vm.prank(ALICE);\n    vm.expectEmit(true, true, false, true, address(ghoToken));\n    emit FacilitatorAdded(ALICE, keccak256(abi.encodePacked('Alice')), DEFAULT_CAPACITY);\n    ghoToken.addFacilitator(ALICE, 'Alice', DEFAULT_CAPACITY);\n  }\n\n  function testRevertAddExistingFacilitator() public {\n    vm.expectRevert('FACILITATOR_ALREADY_EXISTS');\n    ghoToken.addFacilitator(address(GHO_ATOKEN), 'Aave V3 Pool', DEFAULT_CAPACITY);\n  }\n\n  function testRevertAddFacilitatorNoLabel() public {\n    vm.expectRevert('INVALID_LABEL');\n    ghoToken.addFacilitator(ALICE, '', DEFAULT_CAPACITY);\n  }\n\n  function testRevertAddFacilitatorNoRole() public {\n    vm.expectRevert(\n      AccessControlErrorsLib.MISSING_ROLE(GHO_TOKEN_FACILITATOR_MANAGER_ROLE, address(ALICE))\n    );\n    vm.prank(ALICE);\n    ghoToken.addFacilitator(ALICE, 'Alice', DEFAULT_CAPACITY);\n  }\n\n  function testRevertSetBucketCapacityNonFacilitator() public {\n    vm.expectRevert('FACILITATOR_DOES_NOT_EXIST');\n    ghoToken.setFacilitatorBucketCapacity(ALICE, DEFAULT_CAPACITY);\n  }\n\n  function testSetNewBucketCapacity() public {\n    vm.expectEmit(true, false, false, true, address(ghoToken));\n    emit FacilitatorBucketCapacityUpdated(address(GHO_ATOKEN), DEFAULT_CAPACITY, 0);\n    ghoToken.setFacilitatorBucketCapacity(address(GHO_ATOKEN), 0);\n  }\n\n  function testSetNewBucketCapacityAsManager() public {\n    vm.expectEmit(true, true, true, true, address(ghoToken));\n    emit RoleGranted(GHO_TOKEN_BUCKET_MANAGER_ROLE, ALICE, address(this));\n    ghoToken.grantRole(GHO_TOKEN_BUCKET_MANAGER_ROLE, ALICE);\n    vm.prank(ALICE);\n    vm.expectEmit(true, false, false, true, address(ghoToken));\n    emit FacilitatorBucketCapacityUpdated(address(GHO_ATOKEN), DEFAULT_CAPACITY, 0);\n    ghoToken.setFacilitatorBucketCapacity(address(GHO_ATOKEN), 0);\n  }\n\n  function testRevertSetNewBucketCapacityNoRole() public {\n    vm.expectRevert(\n      AccessControlErrorsLib.MISSING_ROLE(GHO_TOKEN_BUCKET_MANAGER_ROLE, address(ALICE))\n    );\n    vm.prank(ALICE);\n    ghoToken.setFacilitatorBucketCapacity(address(GHO_ATOKEN), 0);\n  }\n\n  function testRevertRemoveNonFacilitator() public {\n    vm.expectRevert('FACILITATOR_DOES_NOT_EXIST');\n    ghoToken.removeFacilitator(ALICE);\n  }\n\n  function testRevertRemoveFacilitatorNonZeroBucket() public {\n    vm.prank(FAUCET);\n    ghoToken.mint(ALICE, 1);\n\n    vm.expectRevert('FACILITATOR_BUCKET_LEVEL_NOT_ZERO');\n    ghoToken.removeFacilitator(FAUCET);\n  }\n\n  function testRemoveFacilitator() public {\n    vm.expectEmit(true, false, false, true, address(ghoToken));\n    emit FacilitatorRemoved(address(GHO_ATOKEN));\n    ghoToken.removeFacilitator(address(GHO_ATOKEN));\n  }\n\n  function testRemoveFacilitatorWithRole() public {\n    vm.expectEmit(true, true, true, true, address(ghoToken));\n    emit RoleGranted(GHO_TOKEN_FACILITATOR_MANAGER_ROLE, ALICE, address(this));\n    ghoToken.grantRole(GHO_TOKEN_FACILITATOR_MANAGER_ROLE, ALICE);\n    vm.prank(ALICE);\n    vm.expectEmit(true, false, false, true, address(ghoToken));\n    emit FacilitatorRemoved(address(GHO_ATOKEN));\n    ghoToken.removeFacilitator(address(GHO_ATOKEN));\n  }\n\n  function testRevertRemoveFacilitatorNoRole() public {\n    vm.expectRevert(\n      AccessControlErrorsLib.MISSING_ROLE(GHO_TOKEN_FACILITATOR_MANAGER_ROLE, address(ALICE))\n    );\n    vm.prank(ALICE);\n    ghoToken.removeFacilitator(address(GHO_ATOKEN));\n  }\n\n  function testRevertMintBadFacilitator() public {\n    vm.prank(ALICE);\n    vm.expectRevert('FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    ghoToken.mint(ALICE, DEFAULT_BORROW_AMOUNT);\n  }\n\n  function testRevertMintExceedCapacity() public {\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectRevert('FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    ghoToken.mint(ALICE, DEFAULT_CAPACITY + 1);\n  }\n\n  function testMint() public {\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectEmit(true, true, false, true, address(ghoToken));\n    emit Transfer(address(0), ALICE, DEFAULT_CAPACITY);\n    vm.expectEmit(true, false, false, true, address(ghoToken));\n    emit FacilitatorBucketLevelUpdated(address(GHO_ATOKEN), 0, DEFAULT_CAPACITY);\n    ghoToken.mint(ALICE, DEFAULT_CAPACITY);\n  }\n\n  function testRevertZeroMint() public {\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectRevert('INVALID_MINT_AMOUNT');\n    ghoToken.mint(ALICE, 0);\n  }\n\n  function testRevertZeroBurn() public {\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectRevert('INVALID_BURN_AMOUNT');\n    ghoToken.burn(0);\n  }\n\n  function testRevertBurnMoreThanMinted() public {\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectEmit(true, false, false, true, address(ghoToken));\n    emit FacilitatorBucketLevelUpdated(address(GHO_ATOKEN), 0, DEFAULT_CAPACITY);\n    ghoToken.mint(address(GHO_ATOKEN), DEFAULT_CAPACITY);\n\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectRevert(stdError.arithmeticError);\n    ghoToken.burn(DEFAULT_CAPACITY + 1);\n  }\n\n  function testRevertBurnOthersTokens() public {\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectEmit(true, true, false, true, address(ghoToken));\n    emit Transfer(address(0), ALICE, DEFAULT_CAPACITY);\n    vm.expectEmit(true, false, false, true, address(ghoToken));\n    emit FacilitatorBucketLevelUpdated(address(GHO_ATOKEN), 0, DEFAULT_CAPACITY);\n    ghoToken.mint(ALICE, DEFAULT_CAPACITY);\n\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectRevert(stdError.arithmeticError);\n    ghoToken.burn(DEFAULT_CAPACITY);\n  }\n\n  function testBurn() public {\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectEmit(true, true, false, true, address(ghoToken));\n    emit Transfer(address(0), address(GHO_ATOKEN), DEFAULT_CAPACITY);\n    vm.expectEmit(true, false, false, true, address(ghoToken));\n    emit FacilitatorBucketLevelUpdated(address(GHO_ATOKEN), 0, DEFAULT_CAPACITY);\n    ghoToken.mint(address(GHO_ATOKEN), DEFAULT_CAPACITY);\n\n    vm.prank(address(GHO_ATOKEN));\n    vm.expectEmit(true, false, false, true, address(ghoToken));\n    emit FacilitatorBucketLevelUpdated(\n      address(GHO_ATOKEN),\n      DEFAULT_CAPACITY,\n      DEFAULT_CAPACITY - DEFAULT_BORROW_AMOUNT\n    );\n    ghoToken.burn(DEFAULT_BORROW_AMOUNT);\n  }\n\n  function testOffboardFacilitator() public {\n    // Onboard facilitator\n    vm.expectEmit(true, true, false, true, address(ghoToken));\n    emit FacilitatorAdded(ALICE, keccak256(abi.encodePacked('Alice')), DEFAULT_CAPACITY);\n    ghoToken.addFacilitator(ALICE, 'Alice', DEFAULT_CAPACITY);\n\n    // Facilitator mints half of its capacity\n    vm.prank(ALICE);\n    ghoToken.mint(ALICE, DEFAULT_CAPACITY / 2);\n    (uint256 bucketCapacity, uint256 bucketLevel) = ghoToken.getFacilitatorBucket(ALICE);\n    assertEq(bucketCapacity, DEFAULT_CAPACITY, 'Unexpected bucket capacity of facilitator');\n    assertEq(bucketLevel, DEFAULT_CAPACITY / 2, 'Unexpected bucket level of facilitator');\n\n    // Facilitator cannot be removed\n    vm.expectRevert('FACILITATOR_BUCKET_LEVEL_NOT_ZERO');\n    ghoToken.removeFacilitator(ALICE);\n\n    // Facilitator Bucket Capacity set to 0\n    ghoToken.setFacilitatorBucketCapacity(ALICE, 0);\n\n    // Facilitator cannot mint more and is expected to burn remaining level\n    vm.prank(ALICE);\n    vm.expectRevert('FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    ghoToken.mint(ALICE, 1);\n\n    vm.prank(ALICE);\n    ghoToken.burn(bucketLevel);\n\n    // Facilitator can be removed with 0 bucket level\n    vm.expectEmit(true, false, false, true, address(ghoToken));\n    emit FacilitatorRemoved(address(ALICE));\n    ghoToken.removeFacilitator(address(ALICE));\n  }\n\n  function testDomainSeparator() public {\n    bytes32 EIP712_DOMAIN = keccak256(\n      'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n    );\n    bytes memory EIP712_REVISION = bytes('1');\n    bytes32 expected = keccak256(\n      abi.encode(\n        EIP712_DOMAIN,\n        keccak256(bytes(ghoToken.name())),\n        keccak256(EIP712_REVISION),\n        block.chainid,\n        address(ghoToken)\n      )\n    );\n    bytes32 result = ghoToken.DOMAIN_SEPARATOR();\n    assertEq(result, expected, 'Unexpected domain separator');\n  }\n\n  function testDomainSeparatorNewChain() public {\n    vm.chainId(31338);\n    bytes32 EIP712_DOMAIN = keccak256(\n      'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n    );\n    bytes memory EIP712_REVISION = bytes('1');\n    bytes32 expected = keccak256(\n      abi.encode(\n        EIP712_DOMAIN,\n        keccak256(bytes(ghoToken.name())),\n        keccak256(EIP712_REVISION),\n        block.chainid,\n        address(ghoToken)\n      )\n    );\n    bytes32 result = ghoToken.DOMAIN_SEPARATOR();\n    assertEq(result, expected, 'Unexpected domain separator');\n  }\n\n  function testPermitAndVerifyNonce() public {\n    (address david, uint256 davidKey) = makeAddrAndKey('david');\n    ghoFaucet(david, 1e18);\n    bytes32 PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    bytes32 innerHash = keccak256(abi.encode(PERMIT_TYPEHASH, david, BOB, 1e18, 0, 1 hours));\n    bytes32 outerHash = keccak256(\n      abi.encodePacked('\\x19\\x01', ghoToken.DOMAIN_SEPARATOR(), innerHash)\n    );\n    (uint8 v, bytes32 r, bytes32 s) = vm.sign(davidKey, outerHash);\n    ghoToken.permit(david, BOB, 1e18, 1 hours, v, r, s);\n\n    assertEq(ghoToken.allowance(david, BOB), 1e18, 'Unexpected allowance');\n    assertEq(ghoToken.nonces(david), 1, 'Unexpected nonce');\n  }\n\n  function testRevertPermitInvalidSignature() public {\n    (, uint256 davidKey) = makeAddrAndKey('david');\n    bytes32 PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    bytes32 innerHash = keccak256(abi.encode(PERMIT_TYPEHASH, ALICE, BOB, 1e18, 0, 1 hours));\n    bytes32 outerHash = keccak256(\n      abi.encodePacked('\\x19\\x01', ghoToken.DOMAIN_SEPARATOR(), innerHash)\n    );\n    (uint8 v, bytes32 r, bytes32 s) = vm.sign(davidKey, outerHash);\n    vm.expectRevert(bytes('INVALID_SIGNER'));\n    ghoToken.permit(ALICE, BOB, 1e18, 1 hours, v, r, s);\n  }\n\n  function testRevertPermitInvalidDeadline() public {\n    vm.expectRevert(bytes('PERMIT_DEADLINE_EXPIRED'));\n    ghoToken.permit(ALICE, BOB, 1e18, block.timestamp - 1, 0, 0, 0);\n  }\n}\n\ncontract TestUpgradeableGhoTokenUpgrade is TestUpgradeableGhoTokenSetup {\n  function testInitialization() public {\n    // Upgradeability\n\n    // version is 1st slot\n    uint256 version = uint8(uint256(vm.load(address(ghoToken), bytes32(uint256(0)))));\n    assertEq(version, 1);\n    vm.prank(PROXY_ADMIN);\n    (bool ok, bytes memory result) = address(ghoToken).staticcall(\n      abi.encodeWithSelector(TransparentUpgradeableProxy.admin.selector)\n    );\n    assertTrue(ok, 'proxy admin fetch failed');\n    address decodedProxyAdmin = abi.decode(result, (address));\n    assertEq(decodedProxyAdmin, PROXY_ADMIN, 'proxy admin is wrong');\n    assertEq(decodedProxyAdmin, getProxyAdminAddress(address(ghoToken)), 'proxy admin is wrong');\n\n    // Implementation\n    vm.prank(PROXY_ADMIN);\n    (ok, result) = address(ghoToken).staticcall(\n      abi.encodeWithSelector(TransparentUpgradeableProxy.implementation.selector)\n    );\n    assertTrue(ok, 'proxy implementation fetch failed');\n    address decodedImple = abi.decode(result, (address));\n    assertEq(\n      decodedImple,\n      getProxyImplementationAddress(address(ghoToken)),\n      'proxy implementation is wrong'\n    );\n\n    assertEq(UpgradeableGhoToken(decodedImple).decimals(), 18, 'Wrong default ERC20 decimals');\n    vm.expectRevert('Initializable: contract is already initialized');\n    UpgradeableGhoToken(decodedImple).initialize(address(this));\n\n    // Proxy\n    assertEq(ghoToken.name(), 'Gho Token', 'Wrong default ERC20 name');\n    assertEq(ghoToken.symbol(), 'GHO', 'Wrong default ERC20 symbol');\n    assertEq(ghoToken.decimals(), 18, 'Wrong default ERC20 decimals');\n    assertEq(ghoToken.totalSupply(), 0, 'Wrong total supply');\n    assertEq(ghoToken.getFacilitatorsList().length, 0, 'Facilitator list not empty');\n  }\n\n  function testUpgrade() public {\n    MockUpgradeable newImpl = new MockUpgradeable();\n    bytes memory mockImpleParams = abi.encodeWithSignature('initialize()');\n    vm.prank(PROXY_ADMIN);\n    TransparentUpgradeableProxy(payable(address(ghoToken))).upgradeToAndCall(\n      address(newImpl),\n      mockImpleParams\n    );\n\n    // version is 1st slot\n    uint256 version = uint8(uint256(vm.load(address(ghoToken), bytes32(uint256(0)))));\n    assertEq(version, 2);\n  }\n\n  function testRevertUpgradeUnauthorized() public {\n    vm.expectRevert();\n    TransparentUpgradeableProxy(payable(address(ghoToken))).upgradeToAndCall(address(0), bytes(''));\n\n    vm.expectRevert();\n    TransparentUpgradeableProxy(payable(address(ghoToken))).upgradeTo(address(0));\n  }\n\n  function testChangeAdmin() public {\n    assertEq(getProxyAdminAddress(address(ghoToken)), PROXY_ADMIN);\n\n    address newAdmin = makeAddr('newAdmin');\n    vm.prank(PROXY_ADMIN);\n    TransparentUpgradeableProxy(payable(address(ghoToken))).changeAdmin(newAdmin);\n\n    assertEq(getProxyAdminAddress(address(ghoToken)), newAdmin, 'Admin change failed');\n  }\n\n  function testChangeAdminUnauthorized() public {\n    assertEq(getProxyAdminAddress(address(ghoToken)), PROXY_ADMIN);\n\n    address newAdmin = makeAddr('newAdmin');\n    vm.expectRevert();\n    TransparentUpgradeableProxy(payable(address(ghoToken))).changeAdmin(newAdmin);\n\n    assertEq(getProxyAdminAddress(address(ghoToken)), PROXY_ADMIN, 'Unauthorized admin change');\n  }\n}\n"
    },
    "src/test/TestZeroDiscountRateStrategy.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './TestGhoBase.t.sol';\n\nimport {ZeroDiscountRateStrategy} from '../contracts/facilitators/aave/interestStrategy/ZeroDiscountRateStrategy.sol';\n\ncontract TestZeroDiscountRateStrategy is TestGhoBase {\n  ZeroDiscountRateStrategy emptyStrategy;\n\n  function setUp() public {\n    emptyStrategy = new ZeroDiscountRateStrategy();\n  }\n\n  function testFuzzRateAlwaysZero(uint256 debtBalance, uint256 discountTokenBalance) public {\n    uint256 result = emptyStrategy.calculateDiscountRate(debtBalance, discountTokenBalance);\n    assertEq(result, 0, 'Unexpected discount rate');\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}